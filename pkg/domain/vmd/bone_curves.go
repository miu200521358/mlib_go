package vmd

import "github.com/miu200521358/mlib_go/pkg/domain/mmath"

var InitialBoneCurves = []byte{
	20,
	20,
	0,
	0,
	20,
	20,
	20,
	20,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	0,
	20,
	20,
	20,
	20,
	20,
	20,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	0,
	0,
	20,
	20,
	20,
	20,
	20,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	107,
	0,
	0,
	0,
}

type BoneCurves struct {
	TranslateX *mmath.Curve // 移動X
	TranslateY *mmath.Curve // 移動Y
	TranslateZ *mmath.Curve // 移動Z
	Rotate     *mmath.Curve // 回転
	Values     []byte       // 補間曲線の値
}

func NewBoneCurves() *BoneCurves {
	return &BoneCurves{
		TranslateX: mmath.NewCurve(),
		TranslateY: mmath.NewCurve(),
		TranslateZ: mmath.NewCurve(),
		Rotate:     mmath.NewCurve(),
		Values: []byte{
			20,
			20,
			0,
			0,
			20,
			20,
			20,
			20,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			20,
			20,
			20,
			20,
			20,
			20,
			20,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			0,
			20,
			20,
			20,
			20,
			20,
			20,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			0,
			0,
			20,
			20,
			20,
			20,
			20,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			107,
			0,
			0,
			0,
		},
	}
}

func NewBoneCurvesByValues(values []byte) *BoneCurves {
	curves := &BoneCurves{
		TranslateX: mmath.NewCurveByValues(values[0], values[4], values[8], values[12]),
		TranslateY: mmath.NewCurveByValues(values[16], values[20], values[24], values[28]),
		TranslateZ: mmath.NewCurveByValues(values[32], values[36], values[40], values[44]),
		Rotate:     mmath.NewCurveByValues(values[48], values[52], values[56], values[60]),
		Values:     values,
	}

	return curves
}

// 補間曲線の計算 (xy, yy, zy, ry)
func (boneCurves *BoneCurves) Evaluate(prevIndex, nowIndex, nextIndex int) (float64, float64, float64, float64) {
	var xy, yy, zy, ry float64
	_, xy, _ = mmath.Evaluate(boneCurves.TranslateX, prevIndex, nowIndex, nextIndex)
	_, yy, _ = mmath.Evaluate(boneCurves.TranslateY, prevIndex, nowIndex, nextIndex)
	_, zy, _ = mmath.Evaluate(boneCurves.TranslateZ, prevIndex, nowIndex, nextIndex)
	_, ry, _ = mmath.Evaluate(boneCurves.Rotate, prevIndex, nowIndex, nextIndex)

	return xy, yy, zy, ry
}

func (boneCurves *BoneCurves) Merge() []byte {
	return []byte{
		byte(boneCurves.TranslateX.Start.X),
		boneCurves.Values[1],
		boneCurves.Values[2],
		boneCurves.Values[3],
		byte(boneCurves.TranslateX.Start.Y),
		boneCurves.Values[5],
		boneCurves.Values[6],
		boneCurves.Values[7],
		byte(boneCurves.TranslateX.End.X),
		boneCurves.Values[9],
		boneCurves.Values[10],
		boneCurves.Values[11],
		byte(boneCurves.TranslateX.End.Y),
		boneCurves.Values[13],
		boneCurves.Values[14],
		boneCurves.Values[15],
		byte(boneCurves.TranslateY.Start.X),
		boneCurves.Values[17],
		boneCurves.Values[18],
		boneCurves.Values[19],
		byte(boneCurves.TranslateY.Start.Y),
		boneCurves.Values[21],
		boneCurves.Values[22],
		boneCurves.Values[23],
		byte(boneCurves.TranslateY.End.X),
		boneCurves.Values[25],
		boneCurves.Values[26],
		boneCurves.Values[27],
		byte(boneCurves.TranslateY.End.Y),
		boneCurves.Values[29],
		boneCurves.Values[30],
		boneCurves.Values[31],
		byte(boneCurves.TranslateZ.Start.X),
		boneCurves.Values[33],
		boneCurves.Values[34],
		boneCurves.Values[35],
		byte(boneCurves.TranslateZ.Start.Y),
		boneCurves.Values[37],
		boneCurves.Values[38],
		boneCurves.Values[39],
		byte(boneCurves.TranslateZ.End.X),
		boneCurves.Values[41],
		boneCurves.Values[42],
		boneCurves.Values[43],
		byte(boneCurves.TranslateZ.End.Y),
		boneCurves.Values[45],
		boneCurves.Values[46],
		boneCurves.Values[47],
		byte(boneCurves.Rotate.Start.X),
		boneCurves.Values[49],
		boneCurves.Values[50],
		boneCurves.Values[51],
		byte(boneCurves.Rotate.Start.Y),
		boneCurves.Values[53],
		boneCurves.Values[54],
		boneCurves.Values[55],
		byte(boneCurves.Rotate.End.X),
		boneCurves.Values[57],
		boneCurves.Values[58],
		boneCurves.Values[59],
		byte(boneCurves.Rotate.End.Y),
		boneCurves.Values[61],
		boneCurves.Values[62],
		boneCurves.Values[63],
	}
}

func (boneCurves *BoneCurves) Copy() *BoneCurves {
	return &BoneCurves{
		TranslateX: boneCurves.TranslateX.Copy(),
		TranslateY: boneCurves.TranslateY.Copy(),
		TranslateZ: boneCurves.TranslateZ.Copy(),
		Rotate:     boneCurves.Rotate.Copy(),
		Values:     boneCurves.Values,
	}
}
