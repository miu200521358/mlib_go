/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

// source: C:\MMD\mlib_go\pkg\mbt\bullet.i


extern
#ifdef __cplusplus
  "C"
#endif
  void cgo_panic__mbt_c407977658d33772(const char*);
static void _swig_gopanic(const char *p) {
  cgo_panic__mbt_c407977658d33772(p);
}



#define SWIG_VERSION 0x040200
#define SWIGGO
#define SWIGMODULE mbt
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 


/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif



#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>



typedef ptrdiff_t intgo;
typedef size_t uintgo;


# if !defined(__clang__) && (defined(__i386__) || defined(__x86_64__))
#   define SWIGSTRUCTPACKED __attribute__((__packed__, __gcc_struct__))
# else
#   define SWIGSTRUCTPACKED __attribute__((__packed__))
# endif



typedef struct { char *p; intgo n; } _gostring_;
typedef struct { void* array; intgo len; intgo cap; } _goslice_;



static _gostring_ Swig_AllocateString(const char *p, size_t l) {
  _gostring_ ret;
  ret.p = (char*)malloc(l);
  memcpy(ret.p, p, l);
  ret.n = l;
  return ret;
}


#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


static void Swig_free(void* p) {
  free(p);
}

static void* Swig_malloc(int c) {
  return malloc(c);
}


    #include <cmath>
    #include <string>


#define FLT_EPSILON      1.192092896e-07F        // smallest such that 1.0+FLT_EPSILON != 1.0
#define FLT_MAX          3.402823466e+38F        // max value



/* 7.12.4 Trigonometric functions: Double in C89 */
  extern float __cdecl sinf(float _X);
  extern long double __cdecl sinl(long double);

  extern float __cdecl cosf(float _X);
  extern long double __cdecl cosl(long double);

  extern float __cdecl tanf(float _X);
  extern long double __cdecl tanl(long double);
  extern float __cdecl asinf(float _X);
  extern long double __cdecl asinl(long double);

  extern float __cdecl acosf (float);
  extern long double __cdecl acosl (long double);

  extern float __cdecl atanf (float);
  extern long double __cdecl atanl (long double);

  extern float __cdecl atan2f (float, float);
  extern long double __cdecl atan2l (long double, long double);

/* 7.12.6.1 Double in C89 */
  extern float __cdecl expf(float _X);

/* 7.12.6.7 Double in C89 */
  extern float __cdecl logf (float);

/* 7.12.7.4 The pow functions. Double in C89 */
  extern float __cdecl powf(float _X,float _Y);

/* 7.12.7.5 The sqrt functions. Double in C89. */
  extern float __cdecl sqrtf (float);

/* 7.12.7.2 The fabs functions: Double in C89 */
  extern  float __cdecl fabsf (float x);

/* 7.12.10.1 Double in C89 */
  extern float __cdecl fmodf (float, float);




/*
Copyright (c) 2003-2009 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SCALAR_H
#define BT_SCALAR_H

#ifdef BT_MANAGED_CODE
//Aligned data types not supported in managed code
#pragma unmanaged
#endif


/* SVN $Revision$ on $Date$ from http://bullet.googlecode.com*/
#define BT_BULLET_VERSION 326

inline int btGetVersion()
{
	return BT_BULLET_VERSION;
}

inline int btIsDoublePrecision()
{
  #ifdef BT_USE_DOUBLE_PRECISION
  return true;
  #else
  return false;
  #endif
}


// The following macro "BT_NOT_EMPTY_FILE" can be put into a file
// in order suppress the MS Visual C++ Linker warning 4221
//
// warning LNK4221: no public symbols found; archive member will be inaccessible
//
// This warning occurs on PC and XBOX when a file compiles out completely
// has no externally visible symbols which may be dependant on configuration
// #defines and options.
//
// see more https://stackoverflow.com/questions/1822887/what-is-the-best-way-to-eliminate-ms-visual-c-linker-warning-warning-lnk422

#if defined(_MSC_VER)
#define BT_NOT_EMPTY_FILE_CAT_II(p, res) res
#define BT_NOT_EMPTY_FILE_CAT_I(a, b) BT_NOT_EMPTY_FILE_CAT_II(~, a##b)
#define BT_NOT_EMPTY_FILE_CAT(a, b) BT_NOT_EMPTY_FILE_CAT_I(a, b)
#define BT_NOT_EMPTY_FILE                                      \
	namespace                                                  \
	{                                                          \
	char BT_NOT_EMPTY_FILE_CAT(NoEmptyFileDummy, __COUNTER__); \
	}
#else
#define BT_NOT_EMPTY_FILE
#endif

// clang and most formatting tools don't support indentation of preprocessor guards, so turn it off
// clang-format off
#if defined(DEBUG) || defined (_DEBUG)
	#define BT_DEBUG
#endif

#ifdef _WIN32
	#if  defined(__GNUC__)	// it should handle both MINGW and CYGWIN
        	#define SIMD_FORCE_INLINE        __inline__ __attribute__((always_inline))
        	#define ATTRIBUTE_ALIGNED16(a)   a __attribute__((aligned(16)))
        	#define ATTRIBUTE_ALIGNED64(a)   a __attribute__((aligned(64)))
        	#define ATTRIBUTE_ALIGNED128(a)  a __attribute__((aligned(128)))
    	#elif ( defined(_MSC_VER) && _MSC_VER < 1300 )
		#define SIMD_FORCE_INLINE inline
		#define ATTRIBUTE_ALIGNED16(a) a
		#define ATTRIBUTE_ALIGNED64(a) a
		#define ATTRIBUTE_ALIGNED128(a) a
	#elif defined(_M_ARM)
		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec() a
		#define ATTRIBUTE_ALIGNED64(a) __declspec() a
		#define ATTRIBUTE_ALIGNED128(a) __declspec () a
	#else//__MINGW32__
		//#define BT_HAS_ALIGNED_ALLOCATOR
		#pragma warning(disable : 4324) // disable padding warning
//			#pragma warning(disable:4530) // Disable the exception disable but used in MSCV Stl warning.
		#pragma warning(disable:4996) //Turn off warnings about deprecated C routines
//			#pragma warning(disable:4786) // Disable the "debug name too long" warning

		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec(align(16)) a
		#define ATTRIBUTE_ALIGNED64(a) __declspec(align(64)) a
		#define ATTRIBUTE_ALIGNED128(a) __declspec (align(128)) a
		#ifdef _XBOX
			#define BT_USE_VMX128

 			#define BT_HAVE_NATIVE_FSEL
 			#define btFsel(a,b,c) __fsel((a),(b),(c))
		#else

#if defined (_M_ARM) || defined (_M_ARM64)
            //Do not turn SSE on for ARM (may want to turn on BT_USE_NEON however)
#elif (defined (_WIN32) && (_MSC_VER) && _MSC_VER >= 1400) && (!defined (BT_USE_DOUBLE_PRECISION))

#ifdef __clang__
#define __BT_DISABLE_SSE__
#endif
#ifndef __BT_DISABLE_SSE__
			#if _MSC_VER>1400
				#define BT_USE_SIMD_VECTOR3
			#endif
			#define BT_USE_SSE
#endif//__BT_DISABLE_SSE__
			#ifdef BT_USE_SSE

#if (_MSC_FULL_VER >= 170050727)//Visual Studio 2012 can compile SSE4/FMA3 (but SSE4/FMA3 is not enabled by default)
			#define BT_ALLOW_SSE4
#endif //(_MSC_FULL_VER >= 160040219)

			//BT_USE_SSE_IN_API is disabled under Windows by default, because 
			//it makes it harder to integrate Bullet into your application under Windows 
			//(structured embedding Bullet structs/classes need to be 16-byte aligned)
			//with relatively little performance gain
			//If you are not embedded Bullet data in your classes, or make sure that you align those classes on 16-byte boundaries
			//you can manually enable this line or set it in the build system for a bit of performance gain (a few percent, dependent on usage)
			//#define BT_USE_SSE_IN_API
			#endif //BT_USE_SSE
#endif

		#endif//_XBOX

	#endif //__MINGW32__

	#ifdef BT_DEBUG
		#ifdef _MSC_VER
			#define btAssert(x) { if(!(x)){printf("Assert " __FILE__ ":%u (%s)\n", __LINE__, #x);__debugbreak();	}}
		#else//_MSC_VER
			#define btAssert assert
		#endif//_MSC_VER
	#else
		#define btAssert(x)
	#endif
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

#else//_WIN32
	
	#if defined	(__CELLOS_LV2__)
		#define SIMD_FORCE_INLINE inline __attribute__((always_inline))
		#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
		#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
		#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
		#ifndef assert
		#endif
		#ifdef BT_DEBUG
			#ifdef __SPU__
				#define printf spu_printf
				#define btAssert(x) {if(!(x)){printf("Assert " __FILE__ ":%u ("#x")\n", __LINE__);spu_hcmpeq(0,0);}}
			#else
				#define btAssert assert
			#endif
	
		#else//BT_DEBUG
				#define btAssert(x)
		#endif//BT_DEBUG
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

	#else//defined	(__CELLOS_LV2__)

		#ifdef USE_LIBSPE2

			#define SIMD_FORCE_INLINE __inline
			#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
			#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
			#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
			#ifndef assert
			#endif
	#ifdef BT_DEBUG
			#define btAssert assert
	#else
			#define btAssert(x)
	#endif
			//btFullAssert is optional, slows down a lot
			#define btFullAssert(x)


			#define btLikely(_c)   __builtin_expect((_c), 1)
			#define btUnlikely(_c) __builtin_expect((_c), 0)
		

		#else//USE_LIBSPE2
	//non-windows systems

			#if (defined (__APPLE__) && (!defined (BT_USE_DOUBLE_PRECISION)))
				#if defined (__i386__) || defined (__x86_64__)
					#define BT_USE_SIMD_VECTOR3
					#define BT_USE_SSE
					//BT_USE_SSE_IN_API is enabled on Mac OSX by default, because memory is automatically aligned on 16-byte boundaries
					//if apps run into issues, we will disable the next line
					#define BT_USE_SSE_IN_API
					#ifdef BT_USE_SSE
						// include appropriate SSE level
						#if defined (__SSE4_1__)
						#elif defined (__SSSE3__)
						#elif defined (__SSE3__)
						#else
						#endif
					#endif //BT_USE_SSE
				#elif defined( __ARM_NEON__ )
					#ifdef __clang__
						#define BT_USE_NEON 1
						#define BT_USE_SIMD_VECTOR3
		
						#if defined BT_USE_NEON && defined (__clang__)
						#endif//BT_USE_NEON
				   #endif //__clang__
				#endif//__arm__

				#define SIMD_FORCE_INLINE inline __attribute__ ((always_inline))
			///@todo: check out alignment methods for other platforms/compilers
				#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
				 #if defined (__i386__) || defined (__x86_64__)
				 #define btAssert(x)\
				{\
				if(!(x))\
				{\
					printf("Assert %s in line %d, file %s\n",#x, __LINE__, __FILE__);\
					asm volatile ("int3");\
				}\
				}
				#else//defined (__i386__) || defined (__x86_64__)
					#define btAssert assert
				#endif//defined (__i386__) || defined (__x86_64__)
				#else//defined(DEBUG) || defined (_DEBUG)
					#define btAssert(x)
				#endif//defined(DEBUG) || defined (_DEBUG)

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c

			#else//__APPLE__

				#define SIMD_FORCE_INLINE inline
				///@todo: check out alignment methods for other platforms/compilers
				///#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				///#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				///#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#define ATTRIBUTE_ALIGNED16(a) a
				#define ATTRIBUTE_ALIGNED64(a) a
				#define ATTRIBUTE_ALIGNED128(a) a
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
					#define btAssert assert
				#else
					#define btAssert(x)
				#endif

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c
			#endif //__APPLE__ 
		#endif // LIBSPE2
	#endif	//__CELLOS_LV2__
#endif//_WIN32


///The btScalar type abstracts floating point numbers, to easily switch between double and single floating point precision.
#if defined(BT_USE_DOUBLE_PRECISION)
	typedef double btScalar;
	//this number could be bigger in double precision
	#define BT_LARGE_FLOAT 1e30
#else
	typedef float btScalar;
	//keep BT_LARGE_FLOAT*BT_LARGE_FLOAT < FLT_MAX
	#define BT_LARGE_FLOAT 1e18f
#endif

#ifdef BT_USE_SSE
	typedef __m128 btSimdFloat4;
#endif  //BT_USE_SSE

#if defined(BT_USE_SSE)
	//#if defined BT_USE_SSE_IN_API && defined (BT_USE_SSE)
	#ifdef _WIN32

		#ifndef BT_NAN
			static int btNanMask = 0x7F800001;
			#define BT_NAN (*(float *)&btNanMask)
		#endif

		#ifndef BT_INFINITY
			static int btInfinityMask = 0x7F800000;
			#define BT_INFINITY (*(float *)&btInfinityMask)
			inline int btGetInfinityMask()  //suppress stupid compiler warning
			{
				return btInfinityMask;
			}
		#endif



	//use this, in case there are clashes (such as xnamath.h)
	#ifndef BT_NO_SIMD_OPERATOR_OVERLOADS
	inline __m128 operator+(const __m128 A, const __m128 B)
	{
		return _mm_add_ps(A, B);
	}

	inline __m128 operator-(const __m128 A, const __m128 B)
	{
		return _mm_sub_ps(A, B);
	}

	inline __m128 operator*(const __m128 A, const __m128 B)
	{
		return _mm_mul_ps(A, B);
	}
	#endif  //BT_NO_SIMD_OPERATOR_OVERLOADS

	#define btCastfTo128i(a) (_mm_castps_si128(a))
	#define btCastfTo128d(a) (_mm_castps_pd(a))
	#define btCastiTo128f(a) (_mm_castsi128_ps(a))
	#define btCastdTo128f(a) (_mm_castpd_ps(a))
	#define btCastdTo128i(a) (_mm_castpd_si128(a))
	#define btAssign128(r0, r1, r2, r3) _mm_setr_ps(r0, r1, r2, r3)

	#else  //_WIN32

		#define btCastfTo128i(a) ((__m128i)(a))
		#define btCastfTo128d(a) ((__m128d)(a))
		#define btCastiTo128f(a) ((__m128)(a))
		#define btCastdTo128f(a) ((__m128)(a))
		#define btCastdTo128i(a) ((__m128i)(a))
		#define btAssign128(r0, r1, r2, r3) \
			(__m128) { r0, r1, r2, r3 }
		#define BT_INFINITY INFINITY
		#define BT_NAN NAN
	#endif  //_WIN32
#else//BT_USE_SSE

	#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
	#else  //BT_USE_NEON

	#ifndef BT_INFINITY
	struct btInfMaskConverter
	{
		union {
			float mask;
			int intmask;
		};
		btInfMaskConverter(int _mask = 0x7F800000)
			: intmask(_mask)
		{
		}
	};
	static btInfMaskConverter btInfinityMask = 0x7F800000;
	#define BT_INFINITY (btInfinityMask.mask)
	inline int btGetInfinityMask()  //suppress stupid compiler warning
	{
		return btInfinityMask.intmask;
	}
	#endif
	#endif  //BT_USE_NEON

#endif  //BT_USE_SSE

#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
#endif//BT_USE_NEON

#define BT_DECLARE_ALIGNED_ALLOCATOR()                                                                     \
	SIMD_FORCE_INLINE void *operator new(size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); }   \
	SIMD_FORCE_INLINE void operator delete(void *ptr) { btAlignedFree(ptr); }                              \
	SIMD_FORCE_INLINE void *operator new(size_t, void *ptr) { return ptr; }                                \
	SIMD_FORCE_INLINE void operator delete(void *, void *) {}                                              \
	SIMD_FORCE_INLINE void *operator new[](size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); } \
	SIMD_FORCE_INLINE void operator delete[](void *ptr) { btAlignedFree(ptr); }                            \
	SIMD_FORCE_INLINE void *operator new[](size_t, void *ptr) { return ptr; }                              \
	SIMD_FORCE_INLINE void operator delete[](void *, void *) {}

#if defined(BT_USE_DOUBLE_PRECISION) || defined(BT_FORCE_DOUBLE_FUNCTIONS)

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar x)
	{
		return sqrt(x);
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabs(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cos(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sin(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tan(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return acos(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return asin(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atan(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return exp(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return log(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return pow(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmod(x, y); }

#else//BT_USE_DOUBLE_PRECISION

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar y)
	{
	#ifdef USE_APPROXIMATION
	#ifdef __LP64__
		float xhalf = 0.5f * y;
		int i = *(int *)&y;
		i = 0x5f375a86 - (i >> 1);
		y = *(float *)&i;
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = 1 / y;
		return y;
	#else
		double x, z, tempf;
		unsigned long *tfptr = ((unsigned long *)&tempf) + 1;
		tempf = y;
		*tfptr = (0xbfcdd90a - *tfptr) >> 1; /* estimate of 1/sqrt(y) */
		x = tempf;
		z = y * btScalar(0.5);
		x = (btScalar(1.5) * x) - (x * x) * (x * z); /* iteration formula     */
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		return x * y;
	#endif
	#else
		return sqrtf(y);
	#endif
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabsf(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cosf(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sinf(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tanf(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return acosf(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return asinf(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atanf(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2f(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return expf(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return logf(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return powf(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmodf(x, y); }

#endif//BT_USE_DOUBLE_PRECISION

#define SIMD_PI btScalar(3.1415926535897932384626433832795029)
#define SIMD_2_PI (btScalar(2.0) * SIMD_PI)
#define SIMD_HALF_PI (SIMD_PI * btScalar(0.5))
#define SIMD_RADS_PER_DEG (SIMD_2_PI / btScalar(360.0))
#define SIMD_DEGS_PER_RAD (btScalar(360.0) / SIMD_2_PI)
#define SIMDSQRT12 btScalar(0.7071067811865475244008443621048490)
#define btRecipSqrt(x) ((btScalar)(btScalar(1.0) / btSqrt(btScalar(x)))) /* reciprocal square root */
#define btRecip(x) (btScalar(1.0) / btScalar(x))

#ifdef BT_USE_DOUBLE_PRECISION
	#define SIMD_EPSILON DBL_EPSILON
	#define SIMD_INFINITY DBL_MAX
	#define BT_ONE 1.0
	#define BT_ZERO 0.0
	#define BT_TWO 2.0
	#define BT_HALF 0.5
#else
	#define SIMD_EPSILON FLT_EPSILON
	#define SIMD_INFINITY FLT_MAX
	#define BT_ONE 1.0f
	#define BT_ZERO 0.0f
	#define BT_TWO 2.0f
	#define BT_HALF 0.5f
#endif

// clang-format on

SIMD_FORCE_INLINE btScalar btAtan2Fast(btScalar y, btScalar x)
{
	btScalar coeff_1 = SIMD_PI / 4.0f;
	btScalar coeff_2 = 3.0f * coeff_1;
	btScalar abs_y = btFabs(y);
	btScalar angle;
	if (x >= 0.0f)
	{
		btScalar r = (x - abs_y) / (x + abs_y);
		angle = coeff_1 - coeff_1 * r;
	}
	else
	{
		btScalar r = (x + abs_y) / (abs_y - x);
		angle = coeff_2 - coeff_1 * r;
	}
	return (y < 0.0f) ? -angle : angle;
}

SIMD_FORCE_INLINE bool btFuzzyZero(btScalar x) { return btFabs(x) < SIMD_EPSILON; }

SIMD_FORCE_INLINE bool btEqual(btScalar a, btScalar eps)
{
	return (((a) <= eps) && !((a) < -eps));
}
SIMD_FORCE_INLINE bool btGreaterEqual(btScalar a, btScalar eps)
{
	return (!((a) <= eps));
}

SIMD_FORCE_INLINE int btIsNegative(btScalar x)
{
	return x < btScalar(0.0) ? 1 : 0;
}

SIMD_FORCE_INLINE btScalar btRadians(btScalar x) { return x * SIMD_RADS_PER_DEG; }
SIMD_FORCE_INLINE btScalar btDegrees(btScalar x) { return x * SIMD_DEGS_PER_RAD; }

#define BT_DECLARE_HANDLE(name) \
	typedef struct name##__     \
	{                           \
		int unused;             \
	} * name

#ifndef btFsel
SIMD_FORCE_INLINE btScalar btFsel(btScalar a, btScalar b, btScalar c)
{
	return a >= 0 ? b : c;
}
#endif
#define btFsels(a, b, c) (btScalar) btFsel(a, b, c)

SIMD_FORCE_INLINE bool btMachineIsLittleEndian()
{
	long int i = 1;
	const char *p = (const char *)&i;
	if (p[0] == 1)  // Lowest address contains the least significant byte
		return true;
	else
		return false;
}

///btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
///Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html
SIMD_FORCE_INLINE unsigned btSelect(unsigned condition, unsigned valueIfConditionNonZero, unsigned valueIfConditionZero)
{
	// Set testNz to 0xFFFFFFFF if condition is nonzero, 0x00000000 if condition is zero
	// Rely on positive value or'ed with its negative having sign bit on
	// and zero value or'ed with its negative (which is still zero) having sign bit off
	// Use arithmetic shift right, shifting the sign bit through all 32 bits
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return ((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE int btSelect(unsigned condition, int valueIfConditionNonZero, int valueIfConditionZero)
{
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return static_cast<int>((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE float btSelect(unsigned condition, float valueIfConditionNonZero, float valueIfConditionZero)
{
#ifdef BT_HAVE_NATIVE_FSEL
	return (float)btFsel((btScalar)condition - btScalar(1.0f), valueIfConditionNonZero, valueIfConditionZero);
#else
	return (condition != 0) ? valueIfConditionNonZero : valueIfConditionZero;
#endif
}

template <typename T>
SIMD_FORCE_INLINE void btSwap(T &a, T &b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

//PCK: endian swapping functions
SIMD_FORCE_INLINE unsigned btSwapEndian(unsigned val)
{
	return (((val & 0xff000000) >> 24) | ((val & 0x00ff0000) >> 8) | ((val & 0x0000ff00) << 8) | ((val & 0x000000ff) << 24));
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(unsigned short val)
{
	return static_cast<unsigned short>(((val & 0xff00) >> 8) | ((val & 0x00ff) << 8));
}

SIMD_FORCE_INLINE unsigned btSwapEndian(int val)
{
	return btSwapEndian((unsigned)val);
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(short val)
{
	return btSwapEndian((unsigned short)val);
}

///btSwapFloat uses using char pointers to swap the endianness
////btSwapFloat/btSwapDouble will NOT return a float, because the machine might 'correct' invalid floating point values
///Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754.
///When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception.
///In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you.
///so instead of returning a float/double, we return integer/long long integer
SIMD_FORCE_INLINE unsigned int btSwapEndianFloat(float d)
{
	unsigned int a = 0;
	unsigned char *dst = (unsigned char *)&a;
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];
	return a;
}

// unswap using char pointers
SIMD_FORCE_INLINE float btUnswapEndianFloat(unsigned int a)
{
	float d = 0.0f;
	unsigned char *src = (unsigned char *)&a;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];

	return d;
}

// swap using char pointers
SIMD_FORCE_INLINE void btSwapEndianDouble(double d, unsigned char *dst)
{
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];
}

// unswap using char pointers
SIMD_FORCE_INLINE double btUnswapEndianDouble(const unsigned char *src)
{
	double d = 0.0;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];

	return d;
}

template <typename T>
SIMD_FORCE_INLINE void btSetZero(T *a, int n)
{
	T *acurr = a;
	size_t ncurr = n;
	while (ncurr > 0)
	{
		*(acurr++) = 0;
		--ncurr;
	}
}

SIMD_FORCE_INLINE btScalar btLargeDot(const btScalar *a, const btScalar *b, int n)
{
	btScalar p0, q0, m0, p1, q1, m1, sum;
	sum = 0;
	n -= 2;
	while (n >= 0)
	{
		p0 = a[0];
		q0 = b[0];
		m0 = p0 * q0;
		p1 = a[1];
		q1 = b[1];
		m1 = p1 * q1;
		sum += m0;
		sum += m1;
		a += 2;
		b += 2;
		n -= 2;
	}
	n += 2;
	while (n > 0)
	{
		sum += (*a) * (*b);
		a++;
		b++;
		n--;
	}
	return sum;
}

// returns normalized value in range [-SIMD_PI, SIMD_PI]
SIMD_FORCE_INLINE btScalar btNormalizeAngle(btScalar angleInRadians)
{
	angleInRadians = btFmod(angleInRadians, SIMD_2_PI);
	if (angleInRadians < -SIMD_PI)
	{
		return angleInRadians + SIMD_2_PI;
	}
	else if (angleInRadians > SIMD_PI)
	{
		return angleInRadians - SIMD_2_PI;
	}
	else
	{
		return angleInRadians;
	}
}

///rudimentary class to provide type info
struct btTypedObject
{
	btTypedObject(int objectType)
		: m_objectType(objectType)
	{
	}
	int m_objectType;
	inline int getObjectType() const
	{
		return m_objectType;
	}
};

///align a pointer to the provided alignment, upwards
template <typename T>
T *btAlignPointer(T *unalignedPtr, size_t alignment)
{
	struct btConvertPointerSizeT
	{
		union {
			T *ptr;
			size_t integer;
		};
	};
	btConvertPointerSizeT converter;

	const size_t bit_mask = ~(alignment - 1);
	converter.ptr = unalignedPtr;
	converter.integer += alignment - 1;
	converter.integer &= bit_mask;
	return converter.ptr;
}

#endif  //BT_SCALAR_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEN_MINMAX_H
#define BT_GEN_MINMAX_H

#include "LinearMath/btScalar.h"

template <class T>
SIMD_FORCE_INLINE const T& btMin(const T& a, const T& b)
{
	return a < b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btMax(const T& a, const T& b)
{
	return a > b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btClamped(const T& a, const T& lb, const T& ub)
{
	return a < lb ? lb : (ub < a ? ub : a);
}

template <class T>
SIMD_FORCE_INLINE void btSetMin(T& a, const T& b)
{
	if (b < a)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btSetMax(T& a, const T& b)
{
	if (a < b)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btClamp(T& a, const T& lb, const T& ub)
{
	if (a < lb)
	{
		a = lb;
	}
	else if (ub < a)
	{
		a = ub;
	}
}

#endif  //BT_GEN_MINMAX_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_ALIGNED_ALLOCATOR
#define BT_ALIGNED_ALLOCATOR

///we probably replace this with our own aligned memory allocator
///so we replace _aligned_malloc and _aligned_free with our own
///that is better portable and more predictable

#include "LinearMath/btScalar.h"

///BT_DEBUG_MEMORY_ALLOCATIONS preprocessor can be set in build system
///for regression tests to detect memory leaks
///#define BT_DEBUG_MEMORY_ALLOCATIONS 1
#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

int btDumpMemoryLeaks();

#define btAlignedAlloc(a, b) \
	btAlignedAllocInternal(a, b, __LINE__, __FILE__)

#define btAlignedFree(ptr) \
	btAlignedFreeInternal(ptr, __LINE__, __FILE__)

void* btAlignedAllocInternal(size_t size, int alignment, int line, const char* filename);

void btAlignedFreeInternal(void* ptr, int line, const char* filename);

#else
void* btAlignedAllocInternal(size_t size, int alignment);
void btAlignedFreeInternal(void* ptr);

#define btAlignedAlloc(size, alignment) btAlignedAllocInternal(size, alignment)
#define btAlignedFree(ptr) btAlignedFreeInternal(ptr)

#endif
typedef int size_type;

typedef void*(btAlignedAllocFunc)(size_t size, int alignment);
typedef void(btAlignedFreeFunc)(void* memblock);
typedef void*(btAllocFunc)(size_t size);
typedef void(btFreeFunc)(void* memblock);

///The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
void btAlignedAllocSetCustom(btAllocFunc* allocFunc, btFreeFunc* freeFunc);
///If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
void btAlignedAllocSetCustomAligned(btAlignedAllocFunc* allocFunc, btAlignedFreeFunc* freeFunc);

///The btAlignedAllocator is a portable class for aligned memory allocations.
///Default implementations for unaligned and aligned allocations can be overridden by a custom allocator using btAlignedAllocSetCustom and btAlignedAllocSetCustomAligned.
template <typename T, unsigned Alignment>
class btAlignedAllocator
{
	typedef btAlignedAllocator<T, Alignment> self_type;

public:
	//just going down a list:
	btAlignedAllocator() {}
	/*
	btAlignedAllocator( const self_type & ) {}
	*/

	template <typename Other>
	btAlignedAllocator(const btAlignedAllocator<Other, Alignment>&)
	{
	}

	typedef const T* const_pointer;
	typedef const T& const_reference;
	typedef T* pointer;
	typedef T& reference;
	typedef T value_type;

	pointer address(reference ref) const { return &ref; }
	const_pointer address(const_reference ref) const { return &ref; }
	pointer allocate(size_type n, const_pointer* hint = 0)
	{
		(void)hint;
		return reinterpret_cast<pointer>(btAlignedAlloc(sizeof(value_type) * n, Alignment));
	}
	void construct(pointer ptr, const value_type& value) { new (ptr) value_type(value); }
	void deallocate(pointer ptr)
	{
		btAlignedFree(reinterpret_cast<void*>(ptr));
	}
	void destroy(pointer ptr) { ptr->~value_type(); }

	template <typename O>
	struct rebind
	{
		typedef btAlignedAllocator<O, Alignment> other;
	};
	template <typename O>
	self_type& operator=(const btAlignedAllocator<O, Alignment>&)
	{
		return *this;
	}

	friend bool operator==(const self_type&, const self_type&) { return true; }
};

#endif  //BT_ALIGNED_ALLOCATOR





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS
int gNumAlignedAllocs = 0;
int gNumAlignedFree = 0;
int gTotalBytesAlignedAllocs = 0;  //detect memory leaks
#endif                             //BT_DEBUG_MEMORY_ALLOCATIONST_DEBUG_ALLOCATIONS

static void *btAllocDefault(size_t size)
{
  char* data = (char*) malloc(size);
  memset(data,0,size);//keep msan happy
  return data;
}

static void btFreeDefault(void *ptr)
{
	free(ptr);
}

static btAllocFunc *sAllocFunc = btAllocDefault;
static btFreeFunc *sFreeFunc = btFreeDefault;

#if defined(BT_HAS_ALIGNED_ALLOCATOR)
static void *btAlignedAllocDefault(size_t size, int alignment)
{
	return _aligned_malloc(size, (size_t)alignment);
}

static void btAlignedFreeDefault(void *ptr)
{
	_aligned_free(ptr);
}
#elif defined(__CELLOS_LV2__)

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	return memalign(alignment, size);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	free(ptr);
}
#else

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	void *ret;
	char *real;
	real = (char *)sAllocFunc(size + sizeof(void *) + (alignment - 1));
	if (real)
	{
		ret = btAlignPointer(real + sizeof(void *), alignment);
		*((void **)(ret)-1) = (void *)(real);
	}
	else
	{
		ret = (void *)(real);
	}
  //keep msan happy
  memset((char*) ret, 0, size);
	return (ret);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	void *real;

	if (ptr)
	{
		real = *((void **)(ptr)-1);
		sFreeFunc(real);
	}
}
#endif

static btAlignedAllocFunc *sAlignedAllocFunc = btAlignedAllocDefault;
static btAlignedFreeFunc *sAlignedFreeFunc = btAlignedFreeDefault;

void btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc)
{
	sAlignedAllocFunc = allocFunc ? allocFunc : btAlignedAllocDefault;
	sAlignedFreeFunc = freeFunc ? freeFunc : btAlignedFreeDefault;
}

void btAlignedAllocSetCustom(btAllocFunc *allocFunc, btFreeFunc *freeFunc)
{
	sAllocFunc = allocFunc ? allocFunc : btAllocDefault;
	sFreeFunc = freeFunc ? freeFunc : btFreeDefault;
}

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

static int allocations_id[10241024];
static int allocations_bytes[10241024];
static int mynumallocs = 0;

int btDumpMemoryLeaks()
{
	int totalLeak = 0;

	for (int i = 0; i < mynumallocs; i++)
	{
		printf("Error: leaked memory of allocation #%d (%d bytes)\n", allocations_id[i], allocations_bytes[i]);
		totalLeak += allocations_bytes[i];
	}
	if (totalLeak)
	{
		printf("Error: memory leaks: %d allocations were not freed and leaked together %d bytes\n", mynumallocs, totalLeak);
	}
	return totalLeak;
}
//this generic allocator provides the total allocated number of bytes

struct btDebugPtrMagic
{
	union {
		void **vptrptr;
		void *vptr;
		int *iptr;
		char *cptr;
	};
};

void *btAlignedAllocInternal(size_t size, int alignment, int line, const char *filename)
{
	if (size == 0)
	{
		printf("Whaat? size==0");
		return 0;
	}
	static int allocId = 0;

	void *ret;
	char *real;

	// to find some particular memory leak, you could do something like this:
	//	if (allocId==172)
	//	{
	//		printf("catch me!\n");
	//	}
	//	if (size>1024*1024)
	//	{
	//		printf("big alloc!%d\n", size);
	//	}

	gTotalBytesAlignedAllocs += size;
	gNumAlignedAllocs++;

	int sz4prt = 4 * sizeof(void *);

	real = (char *)sAllocFunc(size + sz4prt + (alignment - 1));
	if (real)
	{
		ret = (void *)btAlignPointer(real + sz4prt, alignment);
		btDebugPtrMagic p;
		p.vptr = ret;
		p.cptr -= sizeof(void *);
		*p.vptrptr = (void *)real;
		p.cptr -= sizeof(void *);
		*p.iptr = size;
		p.cptr -= sizeof(void *);
		*p.iptr = allocId;

		allocations_id[mynumallocs] = allocId;
		allocations_bytes[mynumallocs] = size;
		mynumallocs++;
	}
	else
	{
		ret = (void *)(real);  //??
	}

	printf("allocation %d at address %x, from %s,line %d, size %d (total allocated = %d)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs);
	allocId++;

	int *ptr = (int *)ret;
	*ptr = 12;
	return (ret);
}

void btAlignedFreeInternal(void *ptr, int line, const char *filename)
{
	void *real;

	if (ptr)
	{
		gNumAlignedFree++;

		btDebugPtrMagic p;
		p.vptr = ptr;
		p.cptr -= sizeof(void *);
		real = *p.vptrptr;
		p.cptr -= sizeof(void *);
		int size = *p.iptr;
		p.cptr -= sizeof(void *);
		int allocId = *p.iptr;

		bool found = false;

		for (int i = 0; i < mynumallocs; i++)
		{
			if (allocations_id[i] == allocId)
			{
				allocations_id[i] = allocations_id[mynumallocs - 1];
				allocations_bytes[i] = allocations_bytes[mynumallocs - 1];
				mynumallocs--;
				found = true;
				break;
			}
		}

		gTotalBytesAlignedAllocs -= size;

		int diff = gNumAlignedAllocs - gNumAlignedFree;
		printf("free %d at address %x, from %s,line %d, size %d (total remain = %d in %d non-freed allocations)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs, diff);

		sFreeFunc(real);
	}
	else
	{
		//printf("deleting a NULL ptr, no effect\n");
	}
}

#else  //BT_DEBUG_MEMORY_ALLOCATIONS

void *btAlignedAllocInternal(size_t size, int alignment)
{
	void *ptr;
	ptr = sAlignedAllocFunc(size, alignment);
	//	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
	return ptr;
}

void btAlignedFreeInternal(void *ptr)
{
	if (!ptr)
	{
		return;
	}

	//	printf("btAlignedFreeInternal %x\n",ptr);
	sAlignedFreeFunc(ptr);
}

#endif  //BT_DEBUG_MEMORY_ALLOCATIONS





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_VECTOR3_H
#define BT_VECTOR3_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btVector3Data btVector3DoubleData
#define btVector3DataName "btVector3DoubleData"
#else
#define btVector3Data btVector3FloatData
#define btVector3DataName "btVector3FloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#if defined BT_USE_SSE

//typedef  uint32_t __m128i __attribute__ ((vector_size(16)));

#ifdef _MSC_VER
#pragma warning(disable : 4556)  // value of intrinsic immediate argument '4294967239' is out of range '0 - 255'
#endif

#define BT_SHUFFLE(x, y, z, w) (((w) << 6 | (z) << 4 | (y) << 2 | (x)) & 0xff)
//#define bt_pshufd_ps( _a, _mask ) (__m128) _mm_shuffle_epi32((__m128i)(_a), (_mask) )
#define bt_pshufd_ps(_a, _mask) _mm_shuffle_ps((_a), (_a), (_mask))
#define bt_splat3_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, 3))
#define bt_splat_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, _i))

#define btv3AbsiMask (_mm_set_epi32(0x00000000, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvAbsMask (_mm_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvFFF0Mask (_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))
#define btv3AbsfMask btCastiTo128f(btv3AbsiMask)
#define btvFFF0fMask btCastiTo128f(btvFFF0Mask)
#define btvxyzMaskf btvFFF0fMask
#define btvAbsfMask btCastiTo128f(btvAbsMask)

//there is an issue with XCode 3.2 (LCx errors)
#define btvMzeroMask (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f))
#define v1110 (_mm_set_ps(0.0f, 1.0f, 1.0f, 1.0f))
#define vHalf (_mm_set_ps(0.5f, 0.5f, 0.5f, 0.5f))
#define v1_5 (_mm_set_ps(1.5f, 1.5f, 1.5f, 1.5f))

//const __m128 ATTRIBUTE_ALIGNED16(btvMzeroMask) = {-0.0f, -0.0f, -0.0f, -0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(v1110) = {1.0f, 1.0f, 1.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vHalf) = {0.5f, 0.5f, 0.5f, 0.5f};
//const __m128 ATTRIBUTE_ALIGNED16(v1_5)  = {1.5f, 1.5f, 1.5f, 1.5f};

#endif

#ifdef BT_USE_NEON

const float32x4_t ATTRIBUTE_ALIGNED16(btvMzeroMask) = (float32x4_t){-0.0f, -0.0f, -0.0f, -0.0f};
const int32x4_t ATTRIBUTE_ALIGNED16(btvFFF0Mask) = (int32x4_t){static_cast<int32_t>(0xFFFFFFFF),
															   static_cast<int32_t>(0xFFFFFFFF), static_cast<int32_t>(0xFFFFFFFF), 0x0};
const int32x4_t ATTRIBUTE_ALIGNED16(btvAbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF};
const int32x4_t ATTRIBUTE_ALIGNED16(btv3AbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x0};

#endif

/**@brief btVector3 can be used to represent 3D points and vectors.
 * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
 * Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
 */
ATTRIBUTE_ALIGNED16(class)
btVector3
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

#if defined(__SPU__) && defined(__CELLOS_LV2__)
	btScalar m_floats[4];

public:
	SIMD_FORCE_INLINE const vec_float4& get128() const
	{
		return *((const vec_float4*)&m_floats[0]);
	}

public:
#else                                            //__CELLOS_LV2__ __SPU__
#if defined(BT_USE_SSE) || defined(BT_USE_NEON)  // _WIN32 || ARM
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif
#endif  //__CELLOS_LV2__ __SPU__

public:
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btVector3()
	{
	}

	/**@brief Constructor from scalars 
   * @param x X value
   * @param y Y value 
   * @param z Z value 
   */
	SIMD_FORCE_INLINE btVector3(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btVector3(btSimdFloat4 v)
	{
		mVec128 = v;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btVector3(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btVector3&
	operator=(const btVector3& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	/**@brief Add a vector to this one 
 * @param The vector to add to this one */
	SIMD_FORCE_INLINE btVector3& operator+=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, v.mVec128);
#else
		m_floats[0] += v.m_floats[0];
		m_floats[1] += v.m_floats[1];
		m_floats[2] += v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Subtract a vector from this one
   * @param The vector to subtract */
	SIMD_FORCE_INLINE btVector3& operator-=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, v.mVec128);
#else
		m_floats[0] -= v.m_floats[0];
		m_floats[1] -= v.m_floats[1];
		m_floats[2] -= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Scale the vector
   * @param s Scale factor */
	SIMD_FORCE_INLINE btVector3& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
#endif
		return *this;
	}

	/**@brief Inversely scale the vector 
   * @param s Scale factor to divide by */
	SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)
	{
		btFullAssert(s != btScalar(0.0));

#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
		__m128 vs = _mm_load_ss(&s);
		vs = _mm_div_ss(v1110, vs);
		vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

		mVec128 = _mm_mul_ps(mVec128, vs);
		
		return *this;
#else
		return *this *= btScalar(1.0) / s;
#endif
	}

	/**@brief Return the dot product
   * @param v The other vector in the dot product */
	SIMD_FORCE_INLINE btScalar dot(const btVector3& v) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd = _mm_mul_ps(mVec128, v.mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);
		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, v.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_low_f32(vd));
		x = vadd_f32(x, vget_high_f32(vd));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * v.m_floats[0] +
			   m_floats[1] * v.m_floats[1] +
			   m_floats[2] * v.m_floats[2];
#endif
	}

	/**@brief Return the length of the vector squared */
	SIMD_FORCE_INLINE btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the vector */
	SIMD_FORCE_INLINE btScalar length() const
	{
		return btSqrt(length2());
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar norm() const
	{
		return length();
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar safeNorm() const
	{
		btScalar d = length2();
		//workaround for some clang/gcc issue of sqrtf(tiny number) = -INF
		if (d > SIMD_EPSILON)
			return btSqrt(d);
		return btScalar(0);
	}

	/**@brief Return the distance squared between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance2(const btVector3& v) const;

	/**@brief Return the distance between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance(const btVector3& v) const;

	SIMD_FORCE_INLINE btVector3& safeNormalize()
	{
		btScalar l2 = length2();
		//triNormal.normalize();
		if (l2 >= SIMD_EPSILON * SIMD_EPSILON)
		{
			(*this) /= btSqrt(l2);
		}
		else
		{
			setValue(1, 0, 0);
		}
		return *this;
	}

	/**@brief Normalize this vector 
   * x^2 + y^2 + z^2 = 1 */
	SIMD_FORCE_INLINE btVector3& normalize()
	{
		btAssert(!fuzzyZero());

#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// dot product first
		__m128 vd = _mm_mul_ps(mVec128, mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);

#if 0
        vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(v1110, vd);
		vd = bt_splat_ps(vd, 0x80);
		mVec128 = _mm_mul_ps(mVec128, vd);
#else

		// NR step 1/sqrt(x) - vd is x, y is output
		y = _mm_rsqrt_ss(vd);  // estimate

		//  one step NR
		z = v1_5;
		vd = _mm_mul_ss(vd, vHalf);  // vd * 0.5
		//x2 = vd;
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0 * y0
		z = _mm_sub_ss(z, vd);   // 1.5 - vd * 0.5 * y0 * y0

		y = _mm_mul_ss(y, z);  // y0 * (1.5 - vd * 0.5 * y0 * y0)

		y = bt_splat_ps(y, 0x80);
		mVec128 = _mm_mul_ps(mVec128, y);

#endif

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a normalized version of this vector */
	SIMD_FORCE_INLINE btVector3 normalized() const;

	/**@brief Return a rotated version of this vector
   * @param wAxis The axis to rotate about 
   * @param angle The angle to rotate by */
	SIMD_FORCE_INLINE btVector3 rotate(const btVector3& wAxis, const btScalar angle) const;

	/**@brief Return the angle between this and another vector
   * @param v The other vector */
	SIMD_FORCE_INLINE btScalar angle(const btVector3& v) const
	{
		btScalar s = btSqrt(length2() * v.length2());
		btFullAssert(s != btScalar(0.0));
		return btAcos(dot(v) / s);
	}

	/**@brief Return a vector with the absolute values of each element */
	SIMD_FORCE_INLINE btVector3 absolute() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector3(_mm_and_ps(mVec128, btv3AbsfMask));
#elif defined(BT_USE_NEON)
		return btVector3(vabsq_f32(mVec128));
#else
		return btVector3(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]));
#endif
	}

	/**@brief Return the cross product between this and another vector 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3 cross(const btVector3& v) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 T, V;

		T = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 3));    //	(Y Z X 0)
		V = bt_pshufd_ps(v.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, mVec128);
		T = _mm_mul_ps(T, v.mVec128);
		V = _mm_sub_ps(V, T);

		V = bt_pshufd_ps(V, BT_SHUFFLE(1, 2, 0, 3));
		return btVector3(V);
#elif defined(BT_USE_NEON)
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(mVec128);
		float32x2_t Vlow = vget_low_f32(v.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v.mVec128), 1), Vlow);

		V = vmulq_f32(V, mVec128);
		T = vmulq_f32(T, v.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);
		V = (float32x4_t)vandq_s32((int32x4_t)V, btvFFF0Mask);

		return btVector3(V);
#else
		return btVector3(
			m_floats[1] * v.m_floats[2] - m_floats[2] * v.m_floats[1],
			m_floats[2] * v.m_floats[0] - m_floats[0] * v.m_floats[2],
			m_floats[0] * v.m_floats[1] - m_floats[1] * v.m_floats[0]);
#endif
	}

	SIMD_FORCE_INLINE btScalar triple(const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// cross:
		__m128 T = _mm_shuffle_ps(v1.mVec128, v1.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)
		__m128 V = _mm_shuffle_ps(v2.mVec128, v2.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, v1.mVec128);
		T = _mm_mul_ps(T, v2.mVec128);
		V = _mm_sub_ps(V, T);

		V = _mm_shuffle_ps(V, V, BT_SHUFFLE(1, 2, 0, 3));

		// dot:
		V = _mm_mul_ps(V, mVec128);
		__m128 z = _mm_movehl_ps(V, V);
		__m128 y = _mm_shuffle_ps(V, V, 0x55);
		V = _mm_add_ss(V, y);
		V = _mm_add_ss(V, z);
		return _mm_cvtss_f32(V);

#elif defined(BT_USE_NEON)
		// cross:
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(v1.mVec128);
		float32x2_t Vlow = vget_low_f32(v2.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(v1.mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v2.mVec128), 1), Vlow);

		V = vmulq_f32(V, v1.mVec128);
		T = vmulq_f32(T, v2.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);

		// dot:
		V = vmulq_f32(mVec128, V);
		float32x2_t x = vpadd_f32(vget_low_f32(V), vget_low_f32(V));
		x = vadd_f32(x, vget_high_f32(V));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * (v1.m_floats[1] * v2.m_floats[2] - v1.m_floats[2] * v2.m_floats[1]) +
			   m_floats[1] * (v1.m_floats[2] * v2.m_floats[0] - v1.m_floats[0] * v2.m_floats[2]) +
			   m_floats[2] * (v1.m_floats[0] * v2.m_floats[1] - v1.m_floats[1] * v2.m_floats[0]);
#endif
	}

	/**@brief Return the axis with the smallest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int minAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[0] < m_floats[2] ? 0 : 2) : (m_floats[1] < m_floats[2] ? 1 : 2);
	}

	/**@brief Return the axis with the largest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int maxAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[1] < m_floats[2] ? 2 : 1) : (m_floats[0] < m_floats[2] ? 2 : 0);
	}

	SIMD_FORCE_INLINE int furthestAxis() const
	{
		return absolute().minAxis();
	}

	SIMD_FORCE_INLINE int closestAxis() const
	{
		return absolute().maxAxis();
	}

	SIMD_FORCE_INLINE void setInterpolate3(const btVector3& v0, const btVector3& v1, btScalar rt)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vrt = _mm_load_ss(&rt);  //	(rt 0 0 0)
		btScalar s = btScalar(1.0) - rt;
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		__m128 r0 = _mm_mul_ps(v0.mVec128, vs);
		vrt = bt_pshufd_ps(vrt, 0x80);  //	(rt rt rt 0.0)
		__m128 r1 = _mm_mul_ps(v1.mVec128, vrt);
		__m128 tmp3 = _mm_add_ps(r0, r1);
		mVec128 = tmp3;
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v1.mVec128, v0.mVec128);
		vl = vmulq_n_f32(vl, rt);
		mVec128 = vaddq_f32(vl, v0.mVec128);
#else
		btScalar s = btScalar(1.0) - rt;
		m_floats[0] = s * v0.m_floats[0] + rt * v1.m_floats[0];
		m_floats[1] = s * v0.m_floats[1] + rt * v1.m_floats[1];
		m_floats[2] = s * v0.m_floats[2] + rt * v1.m_floats[2];
		//don't do the unused w component
		//		m_co[3] = s * v0[3] + rt * v1[3];
#endif
	}

	/**@brief Return the linear interpolation between this and another vector 
   * @param v The other vector 
   * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
	SIMD_FORCE_INLINE btVector3 lerp(const btVector3& v, const btScalar& t) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vt = _mm_load_ss(&t);  //	(t 0 0 0)
		vt = bt_pshufd_ps(vt, 0x80);  //	(rt rt rt 0.0)
		__m128 vl = _mm_sub_ps(v.mVec128, mVec128);
		vl = _mm_mul_ps(vl, vt);
		vl = _mm_add_ps(vl, mVec128);

		return btVector3(vl);
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v.mVec128, mVec128);
		vl = vmulq_n_f32(vl, t);
		vl = vaddq_f32(vl, mVec128);

		return btVector3(vl);
#else
		return btVector3(m_floats[0] + (v.m_floats[0] - m_floats[0]) * t,
						 m_floats[1] + (v.m_floats[1] - m_floats[1]) * t,
						 m_floats[2] + (v.m_floats[2] - m_floats[2]) * t);
#endif
	}

	/**@brief Elementwise multiply this vector by the other 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_mul_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_f32(mVec128, v.mVec128);
#else
		m_floats[0] *= v.m_floats[0];
		m_floats[1] *= v.m_floats[1];
		m_floats[2] *= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btVector3& other) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btVector3& other) const
	{
		return !(*this == other);
	}

	/**@brief Set each element to the max of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.w());
#endif
	}

	/**@brief Set each element to the min of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.w());
#endif
	}

	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

	void getSkewSymmetricMatrix(btVector3 * v0, btVector3 * v1, btVector3 * v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 V = _mm_and_ps(mVec128, btvFFF0fMask);
		__m128 V0 = _mm_xor_ps(btvMzeroMask, V);
		__m128 V2 = _mm_movelh_ps(V0, V);

		__m128 V1 = _mm_shuffle_ps(V, V0, 0xCE);

		V0 = _mm_shuffle_ps(V0, V, 0xDB);
		V2 = _mm_shuffle_ps(V2, V, 0xF9);

		v0->mVec128 = V0;
		v1->mVec128 = V1;
		v2->mVec128 = V2;
#else
		v0->setValue(0., -z(), y());
		v1->setValue(z(), 0., -x());
		v2->setValue(-y(), x(), 0.);
#endif
	}

	void setZero()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = (__m128)_mm_xor_ps(mVec128, mVec128);
#elif defined(BT_USE_NEON)
		int32x4_t vi = vdupq_n_s32(0);
		mVec128 = vreinterpretq_f32_s32(vi);
#else
		setValue(btScalar(0.), btScalar(0.), btScalar(0.));
#endif
	}

	SIMD_FORCE_INLINE bool isZero() const
	{
		return m_floats[0] == btScalar(0) && m_floats[1] == btScalar(0) && m_floats[2] == btScalar(0);
	}

	SIMD_FORCE_INLINE bool fuzzyZero() const
	{
		return length2() < SIMD_EPSILON * SIMD_EPSILON;
	}

	SIMD_FORCE_INLINE void serialize(struct btVector3Data & dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3DoubleData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btVector3FloatData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btVector3DoubleData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btVector3DoubleData& dataIn);

	/**@brief returns index of maximum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The maximum dot product */
	SIMD_FORCE_INLINE long maxDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/**@brief returns index of minimum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The minimum dot product */
	SIMD_FORCE_INLINE long minDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/* create a vector as  btVector3( this->dot( btVector3 v0 ), this->dot( btVector3 v1), this->dot( btVector3 v2 ))  */
	SIMD_FORCE_INLINE btVector3 dot3(const btVector3& v0, const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 a0 = _mm_mul_ps(v0.mVec128, this->mVec128);
		__m128 a1 = _mm_mul_ps(v1.mVec128, this->mVec128);
		__m128 a2 = _mm_mul_ps(v2.mVec128, this->mVec128);
		__m128 b0 = _mm_unpacklo_ps(a0, a1);
		__m128 b1 = _mm_unpackhi_ps(a0, a1);
		__m128 b2 = _mm_unpacklo_ps(a2, _mm_setzero_ps());
		__m128 r = _mm_movelh_ps(b0, b2);
		r = _mm_add_ps(r, _mm_movehl_ps(b2, b0));
		a2 = _mm_and_ps(a2, btvxyzMaskf);
		r = _mm_add_ps(r, btCastdTo128f(_mm_move_sd(btCastfTo128d(a2), btCastfTo128d(b1))));
		return btVector3(r);

#elif defined(BT_USE_NEON)
		static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
		float32x4_t a0 = vmulq_f32(v0.mVec128, this->mVec128);
		float32x4_t a1 = vmulq_f32(v1.mVec128, this->mVec128);
		float32x4_t a2 = vmulq_f32(v2.mVec128, this->mVec128);
		float32x2x2_t zLo = vtrn_f32(vget_high_f32(a0), vget_high_f32(a1));
		a2 = (float32x4_t)vandq_u32((uint32x4_t)a2, xyzMask);
		float32x2_t b0 = vadd_f32(vpadd_f32(vget_low_f32(a0), vget_low_f32(a1)), zLo.val[0]);
		float32x2_t b1 = vpadd_f32(vpadd_f32(vget_low_f32(a2), vget_high_f32(a2)), vdup_n_f32(0.0f));
		return btVector3(vcombine_f32(b0, b1));
#else
		return btVector3(dot(v0), dot(v1), dot(v2));
#endif
	}
};

/**@brief Return the sum of two vectors (Point symantics)*/
SIMD_FORCE_INLINE btVector3
operator+(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_add_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vaddq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] + v2.m_floats[0],
		v1.m_floats[1] + v2.m_floats[1],
		v1.m_floats[2] + v2.m_floats[2]);
#endif
}

/**@brief Return the elementwise product of two vectors */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_mul_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vmulq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] * v2.m_floats[0],
		v1.m_floats[1] * v2.m_floats[1],
		v1.m_floats[2] * v2.m_floats[2]);
#endif
}

/**@brief Return the difference between two vectors */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	//	without _mm_and_ps this code causes slowdown in Concave moving
	__m128 r = _mm_sub_ps(v1.mVec128, v2.mVec128);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	float32x4_t r = vsubq_f32(v1.mVec128, v2.mVec128);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(
		v1.m_floats[0] - v2.m_floats[0],
		v1.m_floats[1] - v2.m_floats[1],
		v1.m_floats[2] - v2.m_floats[2]);
#endif
}

/**@brief Return the negative of the vector */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 r = _mm_xor_ps(v.mVec128, btvMzeroMask);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((btSimdFloat4)veorq_s32((int32x4_t)v.mVec128, (int32x4_t)btvMzeroMask));
#else
	return btVector3(-v.m_floats[0], -v.m_floats[1], -v.m_floats[2]);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btScalar& s)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
	vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
	return btVector3(_mm_mul_ps(v.mVec128, vs));
#elif defined(BT_USE_NEON)
	float32x4_t r = vmulq_n_f32(v.mVec128, s);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(v.m_floats[0] * s, v.m_floats[1] * s, v.m_floats[2] * s);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btScalar& s, const btVector3& v)
{
	return v * s;
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v, const btScalar& s)
{
	btFullAssert(s != btScalar(0.0));
#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
	__m128 vs = _mm_load_ss(&s);
    vs = _mm_div_ss(v1110, vs);
	vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

	return btVector3(_mm_mul_ps(v.mVec128, vs));
#else
	return v * (btScalar(1.0) / s);
#endif
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vec = _mm_div_ps(v1.mVec128, v2.mVec128);
	vec = _mm_and_ps(vec, btvFFF0fMask);
	return btVector3(vec);
#elif defined(BT_USE_NEON)
	float32x4_t x, y, v, m;

	x = v1.mVec128;
	y = v2.mVec128;

	v = vrecpeq_f32(y);     // v ~ 1/y
	m = vrecpsq_f32(y, v);  // m = (2-v*y)
	v = vmulq_f32(v, m);    // vv = v*m ~~ 1/y
	m = vrecpsq_f32(y, v);  // mm = (2-vv*y)
	v = vmulq_f32(v, x);    // x*vv
	v = vmulq_f32(v, m);    // (x*vv)*(2-vv*y) = x*(vv(2-vv*y)) ~~~ x/y

	return btVector3(v);
#else
	return btVector3(
		v1.m_floats[0] / v2.m_floats[0],
		v1.m_floats[1] / v2.m_floats[1],
		v1.m_floats[2] / v2.m_floats[2]);
#endif
}

/**@brief Return the dot product between two vectors */
SIMD_FORCE_INLINE btScalar
btDot(const btVector3& v1, const btVector3& v2)
{
	return v1.dot(v2);
}

/**@brief Return the distance squared between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance2(const btVector3& v1, const btVector3& v2)
{
	return v1.distance2(v2);
}

/**@brief Return the distance between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance(const btVector3& v1, const btVector3& v2)
{
	return v1.distance(v2);
}

/**@brief Return the angle between two vectors */
SIMD_FORCE_INLINE btScalar
btAngle(const btVector3& v1, const btVector3& v2)
{
	return v1.angle(v2);
}

/**@brief Return the cross product of two vectors */
SIMD_FORCE_INLINE btVector3
btCross(const btVector3& v1, const btVector3& v2)
{
	return v1.cross(v2);
}

SIMD_FORCE_INLINE btScalar
btTriple(const btVector3& v1, const btVector3& v2, const btVector3& v3)
{
	return v1.triple(v2, v3);
}

/**@brief Return the linear interpolation between two vectors
 * @param v1 One vector 
 * @param v2 The other vector 
 * @param t The ration of this to v (t = 0 => return v1, t=1 => return v2) */
SIMD_FORCE_INLINE btVector3
lerp(const btVector3& v1, const btVector3& v2, const btScalar& t)
{
	return v1.lerp(v2, t);
}

SIMD_FORCE_INLINE btScalar btVector3::distance2(const btVector3& v) const
{
	return (v - *this).length2();
}

SIMD_FORCE_INLINE btScalar btVector3::distance(const btVector3& v) const
{
	return (v - *this).length();
}

SIMD_FORCE_INLINE btVector3 btVector3::normalized() const
{
	btVector3 nrm = *this;

	return nrm.normalize();
}

SIMD_FORCE_INLINE btVector3 btVector3::rotate(const btVector3& wAxis, const btScalar _angle) const
{
	// wAxis must be a unit lenght vector

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

	__m128 O = _mm_mul_ps(wAxis.mVec128, mVec128);
	btScalar ssin = btSin(_angle);
	__m128 C = wAxis.cross(mVec128).mVec128;
	O = _mm_and_ps(O, btvFFF0fMask);
	btScalar scos = btCos(_angle);

	__m128 vsin = _mm_load_ss(&ssin);  //	(S 0 0 0)
	__m128 vcos = _mm_load_ss(&scos);  //	(S 0 0 0)

	__m128 Y = bt_pshufd_ps(O, 0xC9);  //	(Y Z X 0)
	__m128 Z = bt_pshufd_ps(O, 0xD2);  //	(Z X Y 0)
	O = _mm_add_ps(O, Y);
	vsin = bt_pshufd_ps(vsin, 0x80);  //	(S S S 0)
	O = _mm_add_ps(O, Z);
	vcos = bt_pshufd_ps(vcos, 0x80);  //	(S S S 0)

	vsin = vsin * C;
	O = O * wAxis.mVec128;
	__m128 X = mVec128 - O;

	O = O + vsin;
	vcos = vcos * X;
	O = O + vcos;

	return btVector3(O);
#else
	btVector3 o = wAxis * wAxis.dot(*this);
	btVector3 _x = *this - o;
	btVector3 _y;

	_y = wAxis.cross(*this);

	return (o + _x * btCos(_angle) + _y * btSin(_angle));
#endif
}

SIMD_FORCE_INLINE long btVector3::maxDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined _WIN32 || defined(BT_USE_SSE)
	const long scalar_cutoff = 10;
	long _maxdot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_maxdot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#endif
	if (array_count < scalar_cutoff)
#endif
	{
		btScalar maxDot1 = -SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;
		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot > maxDot1)
			{
				maxDot1 = dot;
				ptIndex = i;
			}
		}

		dotOut = maxDot1;
		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _maxdot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif
}

SIMD_FORCE_INLINE long btVector3::minDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined BT_USE_SSE
	const long scalar_cutoff = 10;
	long _mindot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_mindot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#else
#error unhandled arch!
#endif

	if (array_count < scalar_cutoff)
#endif
	{
		btScalar minDot = SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;

		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot < minDot)
			{
				minDot = dot;
				ptIndex = i;
			}
		}

		dotOut = minDot;

		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _mindot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif  //BT_USE_SIMD_VECTOR3
}

class btVector4 : public btVector3
{
public:
	SIMD_FORCE_INLINE btVector4() {}

	SIMD_FORCE_INLINE btVector4(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btVector3(_x, _y, _z)
	{
		m_floats[3] = _w;
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btVector4(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	SIMD_FORCE_INLINE btVector4(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	SIMD_FORCE_INLINE btVector4&
	operator=(const btVector4& v)
	{
		mVec128 = v.mVec128;
		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	SIMD_FORCE_INLINE btVector4 absolute4() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector4(_mm_and_ps(mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
		return btVector4(vabsq_f32(mVec128));
#else
		return btVector4(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]),
			btFabs(m_floats[3]));
#endif
	}

	btScalar getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE int maxAxis4() const
	{
		int maxIndex = -1;
		btScalar maxVal = btScalar(-BT_LARGE_FLOAT);
		if (m_floats[0] > maxVal)
		{
			maxIndex = 0;
			maxVal = m_floats[0];
		}
		if (m_floats[1] > maxVal)
		{
			maxIndex = 1;
			maxVal = m_floats[1];
		}
		if (m_floats[2] > maxVal)
		{
			maxIndex = 2;
			maxVal = m_floats[2];
		}
		if (m_floats[3] > maxVal)
		{
			maxIndex = 3;
		}

		return maxIndex;
	}

	SIMD_FORCE_INLINE int minAxis4() const
	{
		int minIndex = -1;
		btScalar minVal = btScalar(BT_LARGE_FLOAT);
		if (m_floats[0] < minVal)
		{
			minIndex = 0;
			minVal = m_floats[0];
		}
		if (m_floats[1] < minVal)
		{
			minIndex = 1;
			minVal = m_floats[1];
		}
		if (m_floats[2] < minVal)
		{
			minIndex = 2;
			minVal = m_floats[2];
		}
		if (m_floats[3] < minVal)
		{
			minIndex = 3;
		}

		return minIndex;
	}

	SIMD_FORCE_INLINE int closestAxis4() const
	{
		return absolute4().maxAxis4();
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] =m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
};

///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapScalarEndian(const btScalar& sourceVal, btScalar& destVal)
{
#ifdef BT_USE_DOUBLE_PRECISION
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[7];
	dest[1] = src[6];
	dest[2] = src[5];
	dest[3] = src[4];
	dest[4] = src[3];
	dest[5] = src[2];
	dest[6] = src[1];
	dest[7] = src[0];
#else
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[3];
	dest[1] = src[2];
	dest[2] = src[1];
	dest[3] = src[0];
#endif  //BT_USE_DOUBLE_PRECISION
}
///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapVector3Endian(const btVector3& sourceVec, btVector3& destVec)
{
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(sourceVec[i], destVec[i]);
	}
}

///btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btUnSwapVector3Endian(btVector3& vector)
{
	btVector3 swappedVec;
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(vector[i], swappedVec[i]);
	}
	vector = swappedVec;
}

template <class T>
SIMD_FORCE_INLINE void btPlaneSpace1(const T& n, T& p, T& q)
{
	if (btFabs(n[2]) > SIMDSQRT12)
	{
		// choose p in y-z plane
		btScalar a = n[1] * n[1] + n[2] * n[2];
		btScalar k = btRecipSqrt(a);
		p[0] = 0;
		p[1] = -n[2] * k;
		p[2] = n[1] * k;
		// set q = n x p
		q[0] = a * k;
		q[1] = -n[0] * p[2];
		q[2] = n[0] * p[1];
	}
	else
	{
		// choose p in x-y plane
		btScalar a = n[0] * n[0] + n[1] * n[1];
		btScalar k = btRecipSqrt(a);
		p[0] = -n[1] * k;
		p[1] = n[0] * k;
		p[2] = 0;
		// set q = n x p
		q[0] = -n[2] * p[1];
		q[1] = n[2] * p[0];
		q[2] = a * k;
	}
}

struct btVector3FloatData
{
	float m_floats[4];
};

struct btVector3DoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btVector3::serializeFloat(struct btVector3FloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeFloat(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serializeDouble(struct btVector3DoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeDouble(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serialize(struct btVector3Data& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_VECTOR3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD_QUADWORD_H
#define BT_SIMD_QUADWORD_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"

#if defined(__CELLOS_LV2) && defined(__SPU__)
#endif

/**@brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.
 */
#ifndef USE_LIBSPE2
ATTRIBUTE_ALIGNED16(class)
btQuadWord
#else
class btQuadWord
#endif
{
protected:
#if defined(__SPU__) && defined(__CELLOS_LV2__)
	union {
		vec_float4 mVec128;
		btScalar m_floats[4];
	};

public:
	vec_float4 get128() const
	{
		return mVec128;
	}

protected:
#else  //__CELLOS_LV2__ __SPU__

#if defined(BT_USE_SSE) || defined(BT_USE_NEON)
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};

public:
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif  // BT_USE_SSE

#endif  //__CELLOS_LV2__ __SPU__

public:
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

	// Set Vector
	SIMD_FORCE_INLINE btQuadWord(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuadWord(const btQuadWord& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuadWord&
	operator=(const btQuadWord& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btQuadWord& other) const
	{
#ifdef BT_USE_SSE
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btQuadWord& other) const
	{
		return !(*this == other);
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = 0.f;
	}

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] = m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btQuadWord()
	//	:m_floats[0](btScalar(0.)),m_floats[1](btScalar(0.)),m_floats[2](btScalar(0.)),m_floats[3](btScalar(0.))
	{
	}

	/**@brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = 0.0f;
	}

	/**@brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = _w;
	}

	/**@brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.m_floats[3]);
#endif
	}
	/**@brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.m_floats[3]);
#endif
	}
};

#endif  //BT_SIMD_QUADWORD_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD__QUATERNION_H_
#define BT_SIMD__QUATERNION_H_

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuadWord.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btQuaternionData btQuaternionDoubleData
#define btQuaternionDataName "btQuaternionDoubleData"
#else
#define btQuaternionData btQuaternionFloatData
#define btQuaternionDataName "btQuaternionFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#ifdef BT_USE_SSE

//const __m128 ATTRIBUTE_ALIGNED16(vOnes) = {1.0f, 1.0f, 1.0f, 1.0f};
#define vOnes (_mm_set_ps(1.0f, 1.0f, 1.0f, 1.0f))

#endif

#if defined(BT_USE_SSE)

#define vQInv (_mm_set_ps(+0.0f, -0.0f, -0.0f, -0.0f))
#define vPPPM (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f))

#elif defined(BT_USE_NEON)

const btSimdFloat4 ATTRIBUTE_ALIGNED16(vQInv) = {-0.0f, -0.0f, -0.0f, +0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(vPPPM) = {+0.0f, +0.0f, +0.0f, -0.0f};

#endif

/**@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
class btQuaternion : public btQuadWord
{
public:
	/**@brief No initialization constructor */
	btQuaternion() {}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btQuaternion(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuaternion(const btQuaternion& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuaternion&
	operator=(const btQuaternion& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	//		template <typename btScalar>
	//		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
	/**@brief Constructor from scalars */
	btQuaternion(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btQuadWord(_x, _y, _z, _w)
	{
	}
	/**@brief Axis angle Constructor
   * @param axis The axis which the rotation is around
   * @param angle The magnitude of the rotation around the angle (Radians) */
	btQuaternion(const btVector3& _axis, const btScalar& _angle)
	{
		setRotation(_axis, _angle);
	}
	/**@brief Constructor from Euler angles
   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
	btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
#ifndef BT_EULER_DEFAULT_ZYX
		setEuler(yaw, pitch, roll);
#else
		setEulerZYX(yaw, pitch, roll);
#endif
	}
	/**@brief Set the rotation using axis angle notation 
   * @param axis The axis around which to rotate
   * @param angle The magnitude of the rotation in Radians */
	void setRotation(const btVector3& axis, const btScalar& _angle)
	{
		btScalar d = axis.length();
		btAssert(d != btScalar(0.0));
		btScalar s = btSin(_angle * btScalar(0.5)) / d;
		setValue(axis.x() * s, axis.y() * s, axis.z() * s,
				 btCos(_angle * btScalar(0.5)));
	}
	/**@brief Set the quaternion using Euler angles
   * @param yaw Angle around Y
   * @param pitch Angle around X
   * @param roll Angle around Z */
	void setEuler(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitch) * btScalar(0.5);
		btScalar halfRoll = btScalar(roll) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,
				 sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
	}
	/**@brief Set the quaternion using euler angles 
   * @param yaw Angle around Z
   * @param pitch Angle around Y
   * @param roll Angle around X */
	void setEulerZYX(const btScalar& yawZ, const btScalar& pitchY, const btScalar& rollX)
	{
		btScalar halfYaw = btScalar(yawZ) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitchY) * btScalar(0.5);
		btScalar halfRoll = btScalar(rollX) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,   //x
				 cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,   //y
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,   //z
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);  //formerly yzx
	}

	/**@brief Get the euler angles from this quaternion
	   * @param yaw Angle around Z
	   * @param pitch Angle around Y
	   * @param roll Angle around X */
	void getEulerZYX(btScalar& yawZ, btScalar& pitchY, btScalar& rollX) const
	{
		btScalar squ;
		btScalar sqx;
		btScalar sqy;
		btScalar sqz;
		btScalar sarg;
		sqx = m_floats[0] * m_floats[0];
		sqy = m_floats[1] * m_floats[1];
		sqz = m_floats[2] * m_floats[2];
		squ = m_floats[3] * m_floats[3];
		sarg = btScalar(-2.) * (m_floats[0] * m_floats[2] - m_floats[3] * m_floats[1]);

		// If the pitch angle is PI/2 or -PI/2, we can only compute
		// the sum roll + yaw.  However, any combination that gives
		// the right sum will produce the correct orientation, so we
		// set rollX = 0 and compute yawZ.
		if (sarg <= -btScalar(0.99999))
		{
			pitchY = btScalar(-0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(m_floats[0], -m_floats[1]);
		}
		else if (sarg >= btScalar(0.99999))
		{
			pitchY = btScalar(0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(-m_floats[0], m_floats[1]);
		}
		else
		{
			pitchY = btAsin(sarg);
			rollX = btAtan2(2 * (m_floats[1] * m_floats[2] + m_floats[3] * m_floats[0]), squ - sqx - sqy + sqz);
			yawZ = btAtan2(2 * (m_floats[0] * m_floats[1] + m_floats[3] * m_floats[2]), squ + sqx - sqy - sqz);
		}
	}

	/**@brief Add two quaternions
   * @param q The quaternion to add to this one */
	SIMD_FORCE_INLINE btQuaternion& operator+=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, q.mVec128);
#else
		m_floats[0] += q.x();
		m_floats[1] += q.y();
		m_floats[2] += q.z();
		m_floats[3] += q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Subtract out a quaternion
   * @param q The quaternion to subtract from this one */
	btQuaternion& operator-=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, q.mVec128);
#else
		m_floats[0] -= q.x();
		m_floats[1] -= q.y();
		m_floats[2] -= q.z();
		m_floats[3] -= q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Scale this quaternion
   * @param s The scalar to scale by */
	btQuaternion& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0);     //	(S S S S)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
		m_floats[3] *= s;
#endif
		return *this;
	}

	/**@brief Multiply this quaternion by q on the right
   * @param q The other quaternion 
   * Equivilant to this = this * q */
	btQuaternion& operator*=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vQ2 = q.get128();

		__m128 A1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(0, 1, 2, 0));
		__m128 B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));

		A1 = A1 * B1;

		__m128 A2 = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 1));
		__m128 B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

		A2 = A2 * B2;

		B1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(2, 0, 1, 2));
		B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

		B1 = B1 * B2;  //	A3 *= B3

		mVec128 = bt_splat_ps(mVec128, 3);  //	A0
		mVec128 = mVec128 * vQ2;            //	A0 * B0

		A1 = A1 + A2;                //	AB12
		mVec128 = mVec128 - B1;      //	AB03 = AB0 - AB3
		A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
		mVec128 = mVec128 + A1;      //	AB03 + AB12

#elif defined(BT_USE_NEON)

		float32x4_t vQ1 = mVec128;
		float32x4_t vQ2 = q.get128();
		float32x4_t A0, A1, B1, A2, B2, A3, B3;
		float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

		{
			float32x2x2_t tmp;
			tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
			vQ1zx = tmp.val[0];

			tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
			vQ2zx = tmp.val[0];
		}
		vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

		vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

		vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
		vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

		A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
		B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

		A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
		B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

		A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
		B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

		A1 = vmulq_f32(A1, B1);
		A2 = vmulq_f32(A2, B2);
		A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
		A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

		A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
		A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

		//	change the sign of the last element
		A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
		A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

		mVec128 = A0;
#else
		setValue(
			m_floats[3] * q.x() + m_floats[0] * q.m_floats[3] + m_floats[1] * q.z() - m_floats[2] * q.y(),
			m_floats[3] * q.y() + m_floats[1] * q.m_floats[3] + m_floats[2] * q.x() - m_floats[0] * q.z(),
			m_floats[3] * q.z() + m_floats[2] * q.m_floats[3] + m_floats[0] * q.y() - m_floats[1] * q.x(),
			m_floats[3] * q.m_floats[3] - m_floats[0] * q.x() - m_floats[1] * q.y() - m_floats[2] * q.z());
#endif
		return *this;
	}
	/**@brief Return the dot product between this quaternion and another
   * @param q The other quaternion */
	btScalar dot(const btQuaternion& q) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, q.mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, q.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_high_f32(vd));
		x = vpadd_f32(x, x);
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * q.x() +
			   m_floats[1] * q.y() +
			   m_floats[2] * q.z() +
			   m_floats[3] * q.m_floats[3];
#endif
	}

	/**@brief Return the length squared of the quaternion */
	btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the quaternion */
	btScalar length() const
	{
		return btSqrt(length2());
	}
	btQuaternion& safeNormalize()
	{
		btScalar l2 = length2();
		if (l2 > SIMD_EPSILON)
		{
			normalize();
		}
		return *this;
	}
	/**@brief Normalize the quaternion 
   * Such that x^2 + y^2 + z^2 +w^2 = 1 */
	btQuaternion& normalize()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(vOnes, vd);
		vd = bt_pshufd_ps(vd, 0);  // splat
		mVec128 = _mm_mul_ps(mVec128, vd);

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a scaled version of this quaternion
   * @param s The scale factor */
	SIMD_FORCE_INLINE btQuaternion
	operator*(const btScalar& s) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x00);  //	(S S S S)

		return btQuaternion(_mm_mul_ps(mVec128, vs));
#elif defined(BT_USE_NEON)
		return btQuaternion(vmulq_n_f32(mVec128, s));
#else
		return btQuaternion(x() * s, y() * s, z() * s, m_floats[3] * s);
#endif
	}

	/**@brief Return an inversely scaled versionof this quaternion
   * @param s The inverse scale factor */
	btQuaternion operator/(const btScalar& s) const
	{
		btAssert(s != btScalar(0.0));
		return *this * (btScalar(1.0) / s);
	}

	/**@brief Inversely scale this quaternion
   * @param s The scale factor */
	btQuaternion& operator/=(const btScalar& s)
	{
		btAssert(s != btScalar(0.0));
		return *this *= btScalar(1.0) / s;
	}

	/**@brief Return a normalized version of this quaternion */
	btQuaternion normalized() const
	{
		return *this / length();
	}
	/**@brief Return the ***half*** angle between this quaternion and the other
   * @param q The other quaternion */
	btScalar angle(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		return btAcos(dot(q) / s);
	}

	/**@brief Return the angle between this quaternion and the other along the shortest path
	* @param q The other quaternion */
	btScalar angleShortestPath(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		if (dot(q) < 0)  // Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			return btAcos(dot(-q) / s) * btScalar(2.0);
		else
			return btAcos(dot(q) / s) * btScalar(2.0);
	}

	/**@brief Return the angle [0, 2Pi] of rotation represented by this quaternion */
	btScalar getAngle() const
	{
		btScalar s = btScalar(2.) * btAcos(m_floats[3]);
		return s;
	}

	/**@brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path */
	btScalar getAngleShortestPath() const
	{
		btScalar s;
		if (m_floats[3] >= 0)
			s = btScalar(2.) * btAcos(m_floats[3]);
		else
			s = btScalar(2.) * btAcos(-m_floats[3]);
		return s;
	}

	/**@brief Return the axis of the rotation represented by this quaternion */
	btVector3 getAxis() const
	{
		btScalar s_squared = 1.f - m_floats[3] * m_floats[3];

		if (s_squared < btScalar(10.) * SIMD_EPSILON)  //Check for divide by zero
			return btVector3(1.0, 0.0, 0.0);           // Arbitrary
		btScalar s = 1.f / btSqrt(s_squared);
		return btVector3(m_floats[0] * s, m_floats[1] * s, m_floats[2] * s);
	}

	/**@brief Return the inverse of this quaternion */
	btQuaternion inverse() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, vQInv));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)vQInv));
#else
		return btQuaternion(-m_floats[0], -m_floats[1], -m_floats[2], m_floats[3]);
#endif
	}

	/**@brief Return the sum of this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator+(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_add_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vaddq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() + q2.x(), q1.y() + q2.y(), q1.z() + q2.z(), q1.m_floats[3] + q2.m_floats[3]);
#endif
	}

	/**@brief Return the difference between this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator-(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_sub_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vsubq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() - q2.x(), q1.y() - q2.y(), q1.z() - q2.z(), q1.m_floats[3] - q2.m_floats[3]);
#endif
	}

	/**@brief Return the negative of this quaternion 
   * This simply negates each element */
	SIMD_FORCE_INLINE btQuaternion operator-() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, btvMzeroMask));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)btvMzeroMask));
#else
		const btQuaternion& q2 = *this;
		return btQuaternion(-q2.x(), -q2.y(), -q2.z(), -q2.m_floats[3]);
#endif
	}
	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion farthest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) > sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion nearest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) < sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
   * @param q The other quaternion to interpolate with 
   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
   * Slerp interpolates assuming constant velocity.  */
	btQuaternion slerp(const btQuaternion& q, const btScalar& t) const
	{
		const btScalar magnitude = btSqrt(length2() * q.length2());
		btAssert(magnitude > btScalar(0));

		const btScalar product = dot(q) / magnitude;
		const btScalar absproduct = btFabs(product);

		if (absproduct < btScalar(1.0 - SIMD_EPSILON))
		{
			// Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			const btScalar theta = btAcos(absproduct);
			const btScalar d = btSin(theta);
			btAssert(d > btScalar(0));

			const btScalar sign = (product < 0) ? btScalar(-1) : btScalar(1);
			const btScalar s0 = btSin((btScalar(1.0) - t) * theta) / d;
			const btScalar s1 = btSin(sign * t * theta) / d;

			return btQuaternion(
				(m_floats[0] * s0 + q.x() * s1),
				(m_floats[1] * s0 + q.y() * s1),
				(m_floats[2] * s0 + q.z() * s1),
				(m_floats[3] * s0 + q.w() * s1));
		}
		else
		{
			return *this;
		}
	}

	static const btQuaternion& getIdentity()
	{
		static const btQuaternion identityQuat(btScalar(0.), btScalar(0.), btScalar(0.), btScalar(1.));
		return identityQuat;
	}

	SIMD_FORCE_INLINE const btScalar& getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE void serialize(struct btQuaternionData& dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionDoubleData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btQuaternionFloatData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btQuaternionDoubleData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btQuaternionDoubleData& dataIn);
};

/**@brief Return the product of two quaternions */
SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q1, const btQuaternion& q2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q1.get128();
	__m128 vQ2 = q2.get128();
	__m128 A0, A1, B1, A2, B2;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x     //      vtrn
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X     // vdup vext

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));  // Y Z  X Y     // vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));  // z x  Y Y     // vtrn vdup

	A2 = A2 * B2;

	B1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));  // z x Y Z      // vtrn vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));  // Y Z x z      // vext vtrn

	B1 = B1 * B2;  //	A3 *= B3

	A0 = bt_splat_ps(vQ1, 3);  //	A0
	A0 = A0 * vQ2;             //	A0 * B0

	A1 = A1 + A2;  //	AB12
	A0 = A0 - B1;  //	AB03 = AB0 - AB3

	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A0 = A0 + A1;                //	AB03 + AB12

	return btQuaternion(A0);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q1.get128();
	float32x4_t vQ2 = q2.get128();
	float32x4_t A0, A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;
		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
	A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
	A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
	A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

	return btQuaternion(A0);

#else
	return btQuaternion(
		q1.w() * q2.x() + q1.x() * q2.w() + q1.y() * q2.z() - q1.z() * q2.y(),
		q1.w() * q2.y() + q1.y() * q2.w() + q1.z() * q2.x() - q1.x() * q2.z(),
		q1.w() * q2.z() + q1.z() * q2.w() + q1.x() * q2.y() - q1.y() * q2.x(),
		q1.w() * q2.w() - q1.x() * q2.x() - q1.y() * q2.y() - q1.z() * q2.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q, const btVector3& w)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q.get128();
	__m128 vQ2 = w.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(3, 3, 3, 0));
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(0, 1, 2, 0));

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q.get128();
	float32x4_t vQ2 = w.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1wx, vQ2zx, vQ1yz, vQ2yz, vQ1zx, vQ2xz;

	vQ1wx = vext_f32(vget_high_f32(vQ1), vget_low_f32(vQ1), 1);
	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];
	}

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ1), 1), vQ1wx);  // W W  W X
	B1 = vcombine_f32(vget_low_f32(vQ2), vQ2zx);                     // X Y  z x

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		q.w() * w.x() + q.y() * w.z() - q.z() * w.y(),
		q.w() * w.y() + q.z() * w.x() - q.x() * w.z(),
		q.w() * w.z() + q.x() * w.y() - q.y() * w.x(),
		-q.x() * w.x() - q.y() * w.y() - q.z() * w.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btVector3& w, const btQuaternion& q)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = w.get128();
	__m128 vQ2 = q.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = w.get128();
	float32x4_t vQ2 = q.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		+w.x() * q.w() + w.y() * q.z() - w.z() * q.y(),
		+w.y() * q.w() + w.z() * q.x() - w.x() * q.z(),
		+w.z() * q.w() + w.x() * q.y() - w.y() * q.x(),
		-w.x() * q.x() - w.y() * q.y() - w.z() * q.z());
#endif
}

/**@brief Calculate the dot product between two quaternions */
SIMD_FORCE_INLINE btScalar
dot(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.dot(q2);
}

/**@brief Return the length of a quaternion */
SIMD_FORCE_INLINE btScalar
length(const btQuaternion& q)
{
	return q.length();
}

/**@brief Return the angle between two quaternions*/
SIMD_FORCE_INLINE btScalar
btAngle(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.angle(q2);
}

/**@brief Return the inverse of a quaternion*/
SIMD_FORCE_INLINE btQuaternion
inverse(const btQuaternion& q)
{
	return q.inverse();
}

/**@brief Return the result of spherical linear interpolation betwen two quaternions 
 * @param q1 The first quaternion
 * @param q2 The second quaternion 
 * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
 * Slerp assumes constant velocity between positions. */
SIMD_FORCE_INLINE btQuaternion
slerp(const btQuaternion& q1, const btQuaternion& q2, const btScalar& t)
{
	return q1.slerp(q2, t);
}

SIMD_FORCE_INLINE btVector3
quatRotate(const btQuaternion& rotation, const btVector3& v)
{
	btQuaternion q = rotation * v;
	q *= rotation.inverse();
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_and_ps(q.get128(), btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((float32x4_t)vandq_s32((int32x4_t)q.get128(), btvFFF0Mask));
#else
	return btVector3(q.getX(), q.getY(), q.getZ());
#endif
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuat(const btVector3& v0, const btVector3& v1)  // Game Programming Gems 2.10. make sure v0,v1 are normalized
{
	btVector3 c = v0.cross(v1);
	btScalar d = v0.dot(v1);

	if (d < -1.0 + SIMD_EPSILON)
	{
		btVector3 n, unused;
		btPlaneSpace1(v0, n, unused);
		return btQuaternion(n.x(), n.y(), n.z(), 0.0f);  // just pick any vector that is orthogonal to v0
	}

	btScalar s = btSqrt((1.0f + d) * 2.0f);
	btScalar rs = 1.0f / s;

	return btQuaternion(c.getX() * rs, c.getY() * rs, c.getZ() * rs, s * 0.5f);
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuatNormalize2(btVector3& v0, btVector3& v1)
{
	v0.normalize();
	v1.normalize();
	return shortestArcQuat(v0, v1);
}

struct btQuaternionFloatData
{
	float m_floats[4];
};

struct btQuaternionDoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btQuaternion::serializeFloat(struct btQuaternionFloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeFloat(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serializeDouble(struct btQuaternionDoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeDouble(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serialize(struct btQuaternionData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_SIMD__QUATERNION_H_





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MATRIX3x3_H
#define BT_MATRIX3x3_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuaternion.h"

#ifdef BT_USE_SSE
//const __m128 ATTRIBUTE_ALIGNED16(v2220) = {2.0f, 2.0f, 2.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vMPPP) = {-0.0f, +0.0f, +0.0f, +0.0f};
#define vMPPP (_mm_set_ps(+0.0f, +0.0f, +0.0f, -0.0f))
#endif

#if defined(BT_USE_SSE)
#define v0000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 0.0f))
#define v1000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 1.0f))
#define v0100 (_mm_set_ps(0.0f, 0.0f, 1.0f, 0.0f))
#define v0010 (_mm_set_ps(0.0f, 1.0f, 0.0f, 0.0f))
#elif defined(BT_USE_NEON)
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0000) = {0.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v1000) = {1.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0100) = {0.0f, 1.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0010) = {0.0f, 0.0f, 1.0f, 0.0f};
#endif

#ifdef BT_USE_DOUBLE_PRECISION
#define btMatrix3x3Data btMatrix3x3DoubleData
#else
#define btMatrix3x3Data btMatrix3x3FloatData
#endif  //BT_USE_DOUBLE_PRECISION

/**@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
ATTRIBUTE_ALIGNED16(class)
btMatrix3x3
{
	///Data storage for the matrix, each vector is a row of the matrix
	btVector3 m_el[3];

public:
	/** @brief No initializaion constructor */
	btMatrix3x3() {}

	//		explicit btMatrix3x3(const btScalar *m) { setFromOpenGLSubMatrix(m); }

	/**@brief Constructor from Quaternion */
	explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }
	/*
	template <typename btScalar>
	Matrix3x3(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{ 
	setEulerYPR(yaw, pitch, roll);
	}
	*/
	/** @brief Constructor with row major formatting */
	btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				const btScalar& yx, const btScalar& yy, const btScalar& yz,
				const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		setValue(xx, xy, xz,
				 yx, yy, yz,
				 zx, zy, zz);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btMatrix3x3(const btSimdFloat4 v0, const btSimdFloat4 v1, const btSimdFloat4 v2)
	{
		m_el[0].mVec128 = v0;
		m_el[1].mVec128 = v1;
		m_el[2].mVec128 = v2;
	}

	SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
	{
		m_el[0] = v0;
		m_el[1] = v1;
		m_el[2] = v2;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& rhs)
	{
		m_el[0].mVec128 = rhs.m_el[0].mVec128;
		m_el[1].mVec128 = rhs.m_el[1].mVec128;
		m_el[2].mVec128 = rhs.m_el[2].mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& m)
	{
		m_el[0].mVec128 = m.m_el[0].mVec128;
		m_el[1].mVec128 = m.m_el[1].mVec128;
		m_el[2].mVec128 = m.m_el[2].mVec128;

		return *this;
	}

#else

	/** @brief Copy constructor */
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
	}

	/** @brief Assignment Operator */
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
		return *this;
	}
    
    SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
    {
        m_el[0] = v0;
        m_el[1] = v1;
        m_el[2] = v2;
    }

#endif

	/** @brief Get a column of the matrix as a vector 
	*  @param i Column number 0 indexed */
	SIMD_FORCE_INLINE btVector3 getColumn(int i) const
	{
		return btVector3(m_el[0][i], m_el[1][i], m_el[2][i]);
	}

	/** @brief Get a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& getRow(int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a mutable reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE btVector3& operator[](int i)
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a const reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& operator[](int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Multiply by the target matrix on the right
	*  @param m Rotation matrix to be applied 
	* Equivilant to this = this * m */
	btMatrix3x3& operator*=(const btMatrix3x3& m);

	/** @brief Adds by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this + m */
	btMatrix3x3& operator+=(const btMatrix3x3& m);

	/** @brief Substractss by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this - m */
	btMatrix3x3& operator-=(const btMatrix3x3& m);

	/** @brief Set from the rotational part of a 4x4 OpenGL matrix
	*  @param m A pointer to the beginning of the array of scalars*/
	void setFromOpenGLSubMatrix(const btScalar* m)
	{
		m_el[0].setValue(m[0], m[4], m[8]);
		m_el[1].setValue(m[1], m[5], m[9]);
		m_el[2].setValue(m[2], m[6], m[10]);
	}
	/** @brief Set the values of the matrix explicitly (row major)
	*  @param xx Top left
	*  @param xy Top Middle
	*  @param xz Top Right
	*  @param yx Middle Left
	*  @param yy Middle Middle
	*  @param yz Middle Right
	*  @param zx Bottom Left
	*  @param zy Bottom Middle
	*  @param zz Bottom Right*/
	void setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				  const btScalar& yx, const btScalar& yy, const btScalar& yz,
				  const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		m_el[0].setValue(xx, xy, xz);
		m_el[1].setValue(yx, yy, yz);
		m_el[2].setValue(zx, zy, zz);
	}

	/** @brief Set the matrix from a quaternion
	*  @param q The Quaternion to match */
	void setRotation(const btQuaternion& q)
	{
		btScalar d = q.length2();
		btFullAssert(d != btScalar(0.0));
		btScalar s = btScalar(2.0) / d;

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs, Q = q.get128();
		__m128i Qi = btCastfTo128i(Q);
		__m128 Y, Z;
		__m128 V1, V2, V3;
		__m128 V11, V21, V31;
		__m128 NQ = _mm_xor_ps(Q, btvMzeroMask);
		__m128i NQi = btCastfTo128i(NQ);

		V1 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 2, 3)));  // Y X Z W
		V2 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(0, 0, 1, 3));                 // -X -X  Y  W
		V3 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(2, 1, 0, 3)));  // Z Y X W
		V1 = _mm_xor_ps(V1, vMPPP);                                         //	change the sign of the first element

		V11 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 1, 0, 3)));  // Y Y X W
		V21 = _mm_unpackhi_ps(Q, Q);                                         //  Z  Z  W  W
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(0, 2, 0, 3));                 //  X  Z -X -W

		V2 = V2 * V1;   //
		V1 = V1 * V11;  //
		V3 = V3 * V31;  //

		V11 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(2, 3, 1, 3));                //	-Z -W  Y  W
		V11 = V11 * V21;                                                    //
		V21 = _mm_xor_ps(V21, vMPPP);                                       //	change the sign of the first element
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(3, 3, 1, 3));                //	 W  W -Y -W
		V31 = _mm_xor_ps(V31, vMPPP);                                       //	change the sign of the first element
		Y = btCastiTo128f(_mm_shuffle_epi32(NQi, BT_SHUFFLE(3, 2, 0, 3)));  // -W -Z -X -W
		Z = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 1, 3)));   //  Y  X  Y  W

		vs = _mm_load_ss(&s);
		V21 = V21 * Y;
		V31 = V31 * Z;

		V1 = V1 + V11;
		V2 = V2 + V21;
		V3 = V3 + V31;

		vs = bt_splat3_ps(vs, 0);
		//	s ready
		V1 = V1 * vs;
		V2 = V2 * vs;
		V3 = V3 * vs;

		V1 = V1 + v1000;
		V2 = V2 + v0100;
		V3 = V3 + v0010;

		m_el[0] = V1;
		m_el[1] = V2;
		m_el[2] = V3;
#else
		btScalar xs = q.x() * s, ys = q.y() * s, zs = q.z() * s;
		btScalar wx = q.w() * xs, wy = q.w() * ys, wz = q.w() * zs;
		btScalar xx = q.x() * xs, xy = q.x() * ys, xz = q.x() * zs;
		btScalar yy = q.y() * ys, yz = q.y() * zs, zz = q.z() * zs;
		setValue(
			btScalar(1.0) - (yy + zz), xy - wz, xz + wy,
			xy + wz, btScalar(1.0) - (xx + zz), yz - wx,
			xz - wy, yz + wx, btScalar(1.0) - (xx + yy));
#endif
	}

	/** @brief Set the matrix from euler angles using YPR around YXZ respectively
	*  @param yaw Yaw about Y axis
	*  @param pitch Pitch about X axis
	*  @param roll Roll about Z axis 
	*/
	void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		setEulerZYX(roll, pitch, yaw);
	}

	/** @brief Set the matrix from euler angles YPR around ZYX axes
	* @param eulerX Roll about X axis
	* @param eulerY Pitch around Y axis
	* @param eulerZ Yaw about Z axis
	* 
	* These angles are used to produce a rotation matrix. The euler
	* angles are applied in ZYX order. I.e a vector is first rotated 
	* about X then Y and then Z
	**/
	void setEulerZYX(btScalar eulerX, btScalar eulerY, btScalar eulerZ)
	{
		///@todo proposed to reverse this since it's labeled zyx but takes arguments xyz and it will match all other parts of the code
		btScalar ci(btCos(eulerX));
		btScalar cj(btCos(eulerY));
		btScalar ch(btCos(eulerZ));
		btScalar si(btSin(eulerX));
		btScalar sj(btSin(eulerY));
		btScalar sh(btSin(eulerZ));
		btScalar cc = ci * ch;
		btScalar cs = ci * sh;
		btScalar sc = si * ch;
		btScalar ss = si * sh;

		setValue(cj * ch, sj * sc - cs, sj * cc + ss,
				 cj * sh, sj * ss + cc, sj * cs - sc,
				 -sj, cj * si, cj * ci);
	}

	/**@brief Set the matrix to the identity */
	void setIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		m_el[0] = v1000;
		m_el[1] = v0100;
		m_el[2] = v0010;
#else
		setValue(btScalar(1.0), btScalar(0.0), btScalar(0.0),
				 btScalar(0.0), btScalar(1.0), btScalar(0.0),
				 btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
	}
    
    /**@brief Set the matrix to the identity */
    void setZero()
    {
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
        m_el[0] = v0000;
        m_el[1] = v0000;
        m_el[2] = v0000;
#else
        setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0));
#endif
    }

	static const btMatrix3x3& getIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		static const btMatrix3x3
			identityMatrix(v1000, v0100, v0010);
#else
		static const btMatrix3x3
			identityMatrix(
				btScalar(1.0), btScalar(0.0), btScalar(0.0),
				btScalar(0.0), btScalar(1.0), btScalar(0.0),
				btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
		return identityMatrix;
	}

	/**@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
	* @param m The array to be filled */
	void getOpenGLSubMatrix(btScalar * m) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 v0 = m_el[0].mVec128;
		__m128 v1 = m_el[1].mVec128;
		__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
		__m128* vm = (__m128*)m;
		__m128 vT;

		v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

		vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
		v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

		v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
		v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
		v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#elif defined(BT_USE_NEON)
		// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
		static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
		float32x4_t* vm = (float32x4_t*)m;
		float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
		float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
		float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
		float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
		float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
		float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#else
		m[0] = btScalar(m_el[0].x());
		m[1] = btScalar(m_el[1].x());
		m[2] = btScalar(m_el[2].x());
		m[3] = btScalar(0.0);
		m[4] = btScalar(m_el[0].y());
		m[5] = btScalar(m_el[1].y());
		m[6] = btScalar(m_el[2].y());
		m[7] = btScalar(0.0);
		m[8] = btScalar(m_el[0].z());
		m[9] = btScalar(m_el[1].z());
		m[10] = btScalar(m_el[2].z());
		m[11] = btScalar(0.0);
#endif
	}

	/**@brief Get the matrix represented as a quaternion 
	* @param q The quaternion which will be set */
	void getRotation(btQuaternion & q) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
		btScalar s, x;

		union {
			btSimdFloat4 vec;
			btScalar f[4];
		} temp;

		if (trace > btScalar(0.0))
		{
			x = trace + btScalar(1.0);

			temp.f[0] = m_el[2].y() - m_el[1].z();
			temp.f[1] = m_el[0].z() - m_el[2].x();
			temp.f[2] = m_el[1].x() - m_el[0].y();
			temp.f[3] = x;
			//temp.f[3]= s * btScalar(0.5);
		}
		else
		{
			int i, j, k;
			if (m_el[0].x() < m_el[1].y())
			{
				if (m_el[1].y() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 1;
					j = 2;
					k = 0;
				}
			}
			else
			{
				if (m_el[0].x() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 0;
					j = 1;
					k = 2;
				}
			}

			x = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);

			temp.f[3] = (m_el[k][j] - m_el[j][k]);
			temp.f[j] = (m_el[j][i] + m_el[i][j]);
			temp.f[k] = (m_el[k][i] + m_el[i][k]);
			temp.f[i] = x;
			//temp.f[i] = s * btScalar(0.5);
		}

		s = btSqrt(x);
		q.set128(temp.vec);
		s = btScalar(0.5) / s;

		q *= s;
#else
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();

		btScalar temp[4];

		if (trace > btScalar(0.0))
		{
			btScalar s = btSqrt(trace + btScalar(1.0));
			temp[3] = (s * btScalar(0.5));
			s = btScalar(0.5) / s;

			temp[0] = ((m_el[2].y() - m_el[1].z()) * s);
			temp[1] = ((m_el[0].z() - m_el[2].x()) * s);
			temp[2] = ((m_el[1].x() - m_el[0].y()) * s);
		}
		else
		{
			int i = m_el[0].x() < m_el[1].y() ? (m_el[1].y() < m_el[2].z() ? 2 : 1) : (m_el[0].x() < m_el[2].z() ? 2 : 0);
			int j = (i + 1) % 3;
			int k = (i + 2) % 3;

			btScalar s = btSqrt(m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0));
			temp[i] = s * btScalar(0.5);
			s = btScalar(0.5) / s;

			temp[3] = (m_el[k][j] - m_el[j][k]) * s;
			temp[j] = (m_el[j][i] + m_el[i][j]) * s;
			temp[k] = (m_el[k][i] + m_el[i][k]) * s;
		}
		q.setValue(temp[0], temp[1], temp[2], temp[3]);
#endif
	}

	/**@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
	* @param yaw Yaw around Y axis
	* @param pitch Pitch around X axis
	* @param roll around Z axis */
	void getEulerYPR(btScalar & yaw, btScalar & pitch, btScalar & roll) const
	{
		// first use the normal calculus
		yaw = btScalar(btAtan2(m_el[1].x(), m_el[0].x()));
		pitch = btScalar(btAsin(-m_el[2].x()));
		roll = btScalar(btAtan2(m_el[2].y(), m_el[2].z()));

		// on pitch = +/-HalfPI
		if (btFabs(pitch) == SIMD_HALF_PI)
		{
			if (yaw > 0)
				yaw -= SIMD_PI;
			else
				yaw += SIMD_PI;

			if (roll > 0)
				roll -= SIMD_PI;
			else
				roll += SIMD_PI;
		}
	};

	/**@brief Get the matrix represented as euler angles around ZYX
	* @param yaw Yaw around Z axis
	* @param pitch Pitch around Y axis
	* @param roll around X axis 
	* @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
	void getEulerZYX(btScalar & yaw, btScalar & pitch, btScalar & roll, unsigned int solution_number = 1) const
	{
		struct Euler
		{
			btScalar yaw;
			btScalar pitch;
			btScalar roll;
		};

		Euler euler_out;
		Euler euler_out2;  //second solution
		//get the pointer to the raw data

		// Check that pitch is not at a singularity
		if (btFabs(m_el[2].x()) >= 1)
		{
			euler_out.yaw = 0;
			euler_out2.yaw = 0;

			// From difference of angles formula
			btScalar delta = btAtan2(m_el[0].x(), m_el[0].z());
			if (m_el[2].x() > 0)  //gimbal locked up
			{
				euler_out.pitch = SIMD_PI / btScalar(2.0);
				euler_out2.pitch = SIMD_PI / btScalar(2.0);
				euler_out.roll = euler_out.pitch + delta;
				euler_out2.roll = euler_out.pitch + delta;
			}
			else  // gimbal locked down
			{
				euler_out.pitch = -SIMD_PI / btScalar(2.0);
				euler_out2.pitch = -SIMD_PI / btScalar(2.0);
				euler_out.roll = -euler_out.pitch + delta;
				euler_out2.roll = -euler_out.pitch + delta;
			}
		}
		else
		{
			euler_out.pitch = -btAsin(m_el[2].x());
			euler_out2.pitch = SIMD_PI - euler_out.pitch;

			euler_out.roll = btAtan2(m_el[2].y() / btCos(euler_out.pitch),
									 m_el[2].z() / btCos(euler_out.pitch));
			euler_out2.roll = btAtan2(m_el[2].y() / btCos(euler_out2.pitch),
									  m_el[2].z() / btCos(euler_out2.pitch));

			euler_out.yaw = btAtan2(m_el[1].x() / btCos(euler_out.pitch),
									m_el[0].x() / btCos(euler_out.pitch));
			euler_out2.yaw = btAtan2(m_el[1].x() / btCos(euler_out2.pitch),
									 m_el[0].x() / btCos(euler_out2.pitch));
		}

		if (solution_number == 1)
		{
			yaw = euler_out.yaw;
			pitch = euler_out.pitch;
			roll = euler_out.roll;
		}
		else
		{
			yaw = euler_out2.yaw;
			pitch = euler_out2.pitch;
			roll = euler_out2.roll;
		}
	}

	/**@brief Create a scaled copy of the matrix 
	* @param s Scaling vector The elements of the vector will scale each column */

	btMatrix3x3 scaled(const btVector3& s) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		return btMatrix3x3(m_el[0] * s, m_el[1] * s, m_el[2] * s);
#else
		return btMatrix3x3(
			m_el[0].x() * s.x(), m_el[0].y() * s.y(), m_el[0].z() * s.z(),
			m_el[1].x() * s.x(), m_el[1].y() * s.y(), m_el[1].z() * s.z(),
			m_el[2].x() * s.x(), m_el[2].y() * s.y(), m_el[2].z() * s.z());
#endif
	}

	/**@brief Return the determinant of the matrix */
	btScalar determinant() const;
	/**@brief Return the adjoint of the matrix */
	btMatrix3x3 adjoint() const;
	/**@brief Return the matrix with all values non negative */
	btMatrix3x3 absolute() const;
	/**@brief Return the transpose of the matrix */
	btMatrix3x3 transpose() const;
	/**@brief Return the inverse of the matrix */
	btMatrix3x3 inverse() const;

	/// Solve A * x = b, where b is a column vector. This is more efficient
	/// than computing the inverse in one-shot cases.
	///Solve33 is from Box2d, thanks to Erin Catto,
	btVector3 solve33(const btVector3& b) const
	{
		btVector3 col1 = getColumn(0);
		btVector3 col2 = getColumn(1);
		btVector3 col3 = getColumn(2);

		btScalar det = btDot(col1, btCross(col2, col3));
		if (btFabs(det) > SIMD_EPSILON)
		{
			det = 1.0f / det;
		}
		btVector3 x;
		x[0] = det * btDot(b, btCross(col2, col3));
		x[1] = det * btDot(col1, btCross(b, col3));
		x[2] = det * btDot(col1, btCross(col2, b));
		return x;
	}

	btMatrix3x3 transposeTimes(const btMatrix3x3& m) const;
	btMatrix3x3 timesTranspose(const btMatrix3x3& m) const;

	SIMD_FORCE_INLINE btScalar tdotx(const btVector3& v) const
	{
		return m_el[0].x() * v.x() + m_el[1].x() * v.y() + m_el[2].x() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdoty(const btVector3& v) const
	{
		return m_el[0].y() * v.x() + m_el[1].y() * v.y() + m_el[2].y() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdotz(const btVector3& v) const
	{
		return m_el[0].z() * v.x() + m_el[1].z() * v.y() + m_el[2].z() * v.z();
	}

	///extractRotation is from "A robust method to extract the rotational part of deformations"
	///See http://dl.acm.org/citation.cfm?doid=2994258.2994269
	///decomposes a matrix A in a orthogonal matrix R and a
	///symmetric matrix S:
	///A = R*S.
	///note that R can include both rotation and scaling.
	SIMD_FORCE_INLINE void extractRotation(btQuaternion & q, btScalar tolerance = 1.0e-9, int maxIter = 100)
	{
		int iter = 0;
		btScalar w;
		const btMatrix3x3& A = *this;
		for (iter = 0; iter < maxIter; iter++)
		{
			btMatrix3x3 R(q);
			btVector3 omega = (R.getColumn(0).cross(A.getColumn(0)) + R.getColumn(1).cross(A.getColumn(1)) + R.getColumn(2).cross(A.getColumn(2))) * (btScalar(1.0) / btFabs(R.getColumn(0).dot(A.getColumn(0)) + R.getColumn(1).dot(A.getColumn(1)) + R.getColumn(2).dot(A.getColumn(2))) +
																																					  tolerance);
			w = omega.norm();
			if (w < tolerance)
				break;
			q = btQuaternion(btVector3((btScalar(1.0) / w) * omega), w) *
				q;
			q.normalize();
		}
	}

	/**@brief diagonalizes this matrix by the Jacobi method.
	* @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
	* coordinate system, i.e., old_this = rot * new_this * rot^T.
	* @param threshold See iteration
	* @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied
	* by the sum of the absolute values of the diagonal, or when maxSteps have been executed.
	*
	* Note that this matrix is assumed to be symmetric.
	*/
	void diagonalize(btMatrix3x3 & rot, btScalar threshold, int maxSteps)
	{
		rot.setIdentity();
		for (int step = maxSteps; step > 0; step--)
		{
			// find off-diagonal element [p][q] with largest magnitude
			int p = 0;
			int q = 1;
			int r = 2;
			btScalar max = btFabs(m_el[0][1]);
			btScalar v = btFabs(m_el[0][2]);
			if (v > max)
			{
				q = 2;
				r = 1;
				max = v;
			}
			v = btFabs(m_el[1][2]);
			if (v > max)
			{
				p = 1;
				q = 2;
				r = 0;
				max = v;
			}

			btScalar t = threshold * (btFabs(m_el[0][0]) + btFabs(m_el[1][1]) + btFabs(m_el[2][2]));
			if (max <= t)
			{
				if (max <= SIMD_EPSILON * t)
				{
					return;
				}
				step = 1;
			}

			// compute Jacobi rotation J which leads to a zero for element [p][q]
			btScalar mpq = m_el[p][q];
			btScalar theta = (m_el[q][q] - m_el[p][p]) / (2 * mpq);
			btScalar theta2 = theta * theta;
			btScalar cos;
			btScalar sin;
			if (theta2 * theta2 < btScalar(10 / SIMD_EPSILON))
			{
				t = (theta >= 0) ? 1 / (theta + btSqrt(1 + theta2))
								 : 1 / (theta - btSqrt(1 + theta2));
				cos = 1 / btSqrt(1 + t * t);
				sin = cos * t;
			}
			else
			{
				// approximation for large theta-value, i.e., a nearly diagonal matrix
				t = 1 / (theta * (2 + btScalar(0.5) / theta2));
				cos = 1 - btScalar(0.5) * t * t;
				sin = cos * t;
			}

			// apply rotation to matrix (this = J^T * this * J)
			m_el[p][q] = m_el[q][p] = 0;
			m_el[p][p] -= t * mpq;
			m_el[q][q] += t * mpq;
			btScalar mrp = m_el[r][p];
			btScalar mrq = m_el[r][q];
			m_el[r][p] = m_el[p][r] = cos * mrp - sin * mrq;
			m_el[r][q] = m_el[q][r] = cos * mrq + sin * mrp;

			// apply rotation to rot (rot = rot * J)
			for (int i = 0; i < 3; i++)
			{
				btVector3& row = rot[i];
				mrp = row[p];
				mrq = row[q];
				row[p] = cos * mrp - sin * mrq;
				row[q] = cos * mrq + sin * mrp;
			}
		}
	}

	/**@brief Calculate the matrix cofactor 
	* @param r1 The first row to use for calculating the cofactor
	* @param c1 The first column to use for calculating the cofactor
	* @param r1 The second row to use for calculating the cofactor
	* @param c1 The second column to use for calculating the cofactor
	* See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
	*/
	btScalar cofac(int r1, int c1, int r2, int c2) const
	{
		return m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];
	}

	void serialize(struct btMatrix3x3Data & dataOut) const;

	void serializeFloat(struct btMatrix3x3FloatData & dataOut) const;

	void deSerialize(const struct btMatrix3x3Data& dataIn);

	void deSerializeFloat(const struct btMatrix3x3FloatData& dataIn);

	void deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn);
};

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator*=(const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 rv00, rv01, rv02;
	__m128 rv10, rv11, rv12;
	__m128 rv20, rv21, rv22;
	__m128 mv0, mv1, mv2;

	rv02 = m_el[0].mVec128;
	rv12 = m_el[1].mVec128;
	rv22 = m_el[2].mVec128;

	mv0 = _mm_and_ps(m[0].mVec128, btvFFF0fMask);
	mv1 = _mm_and_ps(m[1].mVec128, btvFFF0fMask);
	mv2 = _mm_and_ps(m[2].mVec128, btvFFF0fMask);

	// rv0
	rv00 = bt_splat_ps(rv02, 0);
	rv01 = bt_splat_ps(rv02, 1);
	rv02 = bt_splat_ps(rv02, 2);

	rv00 = _mm_mul_ps(rv00, mv0);
	rv01 = _mm_mul_ps(rv01, mv1);
	rv02 = _mm_mul_ps(rv02, mv2);

	// rv1
	rv10 = bt_splat_ps(rv12, 0);
	rv11 = bt_splat_ps(rv12, 1);
	rv12 = bt_splat_ps(rv12, 2);

	rv10 = _mm_mul_ps(rv10, mv0);
	rv11 = _mm_mul_ps(rv11, mv1);
	rv12 = _mm_mul_ps(rv12, mv2);

	// rv2
	rv20 = bt_splat_ps(rv22, 0);
	rv21 = bt_splat_ps(rv22, 1);
	rv22 = bt_splat_ps(rv22, 2);

	rv20 = _mm_mul_ps(rv20, mv0);
	rv21 = _mm_mul_ps(rv21, mv1);
	rv22 = _mm_mul_ps(rv22, mv2);

	rv00 = _mm_add_ps(rv00, rv01);
	rv10 = _mm_add_ps(rv10, rv11);
	rv20 = _mm_add_ps(rv20, rv21);

	m_el[0].mVec128 = _mm_add_ps(rv00, rv02);
	m_el[1].mVec128 = _mm_add_ps(rv10, rv12);
	m_el[2].mVec128 = _mm_add_ps(rv20, rv22);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m_el[0].mVec128;
	v1 = m_el[1].mVec128;
	v2 = m_el[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	m_el[0].mVec128 = rv0;
	m_el[1].mVec128 = rv1;
	m_el[2].mVec128 = rv2;
#else
	setValue(
		m.tdotx(m_el[0]), m.tdoty(m_el[0]), m.tdotz(m_el[0]),
		m.tdotx(m_el[1]), m.tdoty(m_el[1]), m.tdotz(m_el[1]),
		m.tdotx(m_el[2]), m.tdoty(m_el[2]), m.tdotz(m_el[2]));
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator+=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 + m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 + m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 + m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] + m.m_el[0][0],
		m_el[0][1] + m.m_el[0][1],
		m_el[0][2] + m.m_el[0][2],
		m_el[1][0] + m.m_el[1][0],
		m_el[1][1] + m.m_el[1][1],
		m_el[1][2] + m.m_el[1][2],
		m_el[2][0] + m.m_el[2][0],
		m_el[2][1] + m.m_el[2][1],
		m_el[2][2] + m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m, const btScalar& k)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vk = bt_splat_ps(_mm_load_ss((float*)&k), 0x80);
	return btMatrix3x3(
		_mm_mul_ps(m[0].mVec128, vk),
		_mm_mul_ps(m[1].mVec128, vk),
		_mm_mul_ps(m[2].mVec128, vk));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		vmulq_n_f32(m[0].mVec128, k),
		vmulq_n_f32(m[1].mVec128, k),
		vmulq_n_f32(m[2].mVec128, k));
#else
	return btMatrix3x3(
		m[0].x() * k, m[0].y() * k, m[0].z() * k,
		m[1].x() * k, m[1].y() * k, m[1].z() * k,
		m[2].x() * k, m[2].y() * k, m[2].z() * k);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator+(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 + m2[0].mVec128,
		m1[1].mVec128 + m2[1].mVec128,
		m1[2].mVec128 + m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] + m2[0][0],
		m1[0][1] + m2[0][1],
		m1[0][2] + m2[0][2],

		m1[1][0] + m2[1][0],
		m1[1][1] + m2[1][1],
		m1[1][2] + m2[1][2],

		m1[2][0] + m2[2][0],
		m1[2][1] + m2[2][1],
		m1[2][2] + m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator-(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 - m2[0].mVec128,
		m1[1].mVec128 - m2[1].mVec128,
		m1[2].mVec128 - m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] - m2[0][0],
		m1[0][1] - m2[0][1],
		m1[0][2] - m2[0][2],

		m1[1][0] - m2[1][0],
		m1[1][1] - m2[1][1],
		m1[1][2] - m2[1][2],

		m1[2][0] - m2[2][0],
		m1[2][1] - m2[2][1],
		m1[2][2] - m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator-=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 - m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 - m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 - m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] - m.m_el[0][0],
		m_el[0][1] - m.m_el[0][1],
		m_el[0][2] - m.m_el[0][2],
		m_el[1][0] - m.m_el[1][0],
		m_el[1][1] - m.m_el[1][1],
		m_el[1][2] - m.m_el[1][2],
		m_el[2][0] - m.m_el[2][0],
		m_el[2][1] - m.m_el[2][1],
		m_el[2][2] - m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btScalar
btMatrix3x3::determinant() const
{
	return btTriple((*this)[0], (*this)[1], (*this)[2]);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::absolute() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	return btMatrix3x3(
		_mm_and_ps(m_el[0].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[1].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[2].mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		(float32x4_t)vandq_s32((int32x4_t)m_el[0].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[1].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[2].mVec128, btv3AbsMask));
#else
	return btMatrix3x3(
		btFabs(m_el[0].x()), btFabs(m_el[0].y()), btFabs(m_el[0].z()),
		btFabs(m_el[1].x()), btFabs(m_el[1].y()), btFabs(m_el[1].z()),
		btFabs(m_el[2].x()), btFabs(m_el[2].y()), btFabs(m_el[2].z()));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transpose() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 v0 = m_el[0].mVec128;
	__m128 v1 = m_el[1].mVec128;
	__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
	__m128 vT;

	v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

	vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
	v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

	v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
	v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
	v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

	return btMatrix3x3(v0, v1, v2);
#elif defined(BT_USE_NEON)
	// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
	static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
	float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
	float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
	float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
	float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
	float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
	float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0
	return btMatrix3x3(v0, v1, v2);
#else
	return btMatrix3x3(m_el[0].x(), m_el[1].x(), m_el[2].x(),
					   m_el[0].y(), m_el[1].y(), m_el[2].y(),
					   m_el[0].z(), m_el[1].z(), m_el[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::adjoint() const
{
	return btMatrix3x3(cofac(1, 1, 2, 2), cofac(0, 2, 2, 1), cofac(0, 1, 1, 2),
					   cofac(1, 2, 2, 0), cofac(0, 0, 2, 2), cofac(0, 2, 1, 0),
					   cofac(1, 0, 2, 1), cofac(0, 1, 2, 0), cofac(0, 0, 1, 1));
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::inverse() const
{
	btVector3 co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));
	btScalar det = (*this)[0].dot(co);
	//btFullAssert(det != btScalar(0.0));
	btAssert(det != btScalar(0.0));
	btScalar s = btScalar(1.0) / det;
	return btMatrix3x3(co.x() * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
					   co.y() * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
					   co.z() * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transposeTimes(const btMatrix3x3& m) const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	// zeros w
	//    static const __m128i xyzMask = (const __m128i){ -1ULL, 0xffffffffULL };
	__m128 row = m_el[0].mVec128;
	__m128 m0 = _mm_and_ps(m.getRow(0).mVec128, btvFFF0fMask);
	__m128 m1 = _mm_and_ps(m.getRow(1).mVec128, btvFFF0fMask);
	__m128 m2 = _mm_and_ps(m.getRow(2).mVec128, btvFFF0fMask);
	__m128 r0 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0));
	__m128 r1 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0x55));
	__m128 r2 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0xaa));
	row = m_el[1].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0xaa)));
	row = m_el[2].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	// zeros w
	static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
	float32x4_t m0 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(0).mVec128, xyzMask);
	float32x4_t m1 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(1).mVec128, xyzMask);
	float32x4_t m2 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(2).mVec128, xyzMask);
	float32x4_t row = m_el[0].mVec128;
	float32x4_t r0 = vmulq_lane_f32(m0, vget_low_f32(row), 0);
	float32x4_t r1 = vmulq_lane_f32(m0, vget_low_f32(row), 1);
	float32x4_t r2 = vmulq_lane_f32(m0, vget_high_f32(row), 0);
	row = m_el[1].mVec128;
	r0 = vmlaq_lane_f32(r0, m1, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m1, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m1, vget_high_f32(row), 0);
	row = m_el[2].mVec128;
	r0 = vmlaq_lane_f32(r0, m2, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m2, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m2, vget_high_f32(row), 0);
	return btMatrix3x3(r0, r1, r2);
#else
	return btMatrix3x3(
		m_el[0].x() * m[0].x() + m_el[1].x() * m[1].x() + m_el[2].x() * m[2].x(),
		m_el[0].x() * m[0].y() + m_el[1].x() * m[1].y() + m_el[2].x() * m[2].y(),
		m_el[0].x() * m[0].z() + m_el[1].x() * m[1].z() + m_el[2].x() * m[2].z(),
		m_el[0].y() * m[0].x() + m_el[1].y() * m[1].x() + m_el[2].y() * m[2].x(),
		m_el[0].y() * m[0].y() + m_el[1].y() * m[1].y() + m_el[2].y() * m[2].y(),
		m_el[0].y() * m[0].z() + m_el[1].y() * m[1].z() + m_el[2].y() * m[2].z(),
		m_el[0].z() * m[0].x() + m_el[1].z() * m[1].x() + m_el[2].z() * m[2].x(),
		m_el[0].z() * m[0].y() + m_el[1].z() * m[1].y() + m_el[2].z() * m[2].y(),
		m_el[0].z() * m[0].z() + m_el[1].z() * m[1].z() + m_el[2].z() * m[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::timesTranspose(const btMatrix3x3& m) const
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 a0 = m_el[0].mVec128;
	__m128 a1 = m_el[1].mVec128;
	__m128 a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	__m128 mx = mT[0].mVec128;
	__m128 my = mT[1].mVec128;
	__m128 mz = mT[2].mVec128;

	__m128 r0 = _mm_mul_ps(mx, _mm_shuffle_ps(a0, a0, 0x00));
	__m128 r1 = _mm_mul_ps(mx, _mm_shuffle_ps(a1, a1, 0x00));
	__m128 r2 = _mm_mul_ps(mx, _mm_shuffle_ps(a2, a2, 0x00));
	r0 = _mm_add_ps(r0, _mm_mul_ps(my, _mm_shuffle_ps(a0, a0, 0x55)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(my, _mm_shuffle_ps(a1, a1, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(my, _mm_shuffle_ps(a2, a2, 0x55)));
	r0 = _mm_add_ps(r0, _mm_mul_ps(mz, _mm_shuffle_ps(a0, a0, 0xaa)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(mz, _mm_shuffle_ps(a1, a1, 0xaa)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(mz, _mm_shuffle_ps(a2, a2, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	float32x4_t a0 = m_el[0].mVec128;
	float32x4_t a1 = m_el[1].mVec128;
	float32x4_t a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	float32x4_t mx = mT[0].mVec128;
	float32x4_t my = mT[1].mVec128;
	float32x4_t mz = mT[2].mVec128;

	float32x4_t r0 = vmulq_lane_f32(mx, vget_low_f32(a0), 0);
	float32x4_t r1 = vmulq_lane_f32(mx, vget_low_f32(a1), 0);
	float32x4_t r2 = vmulq_lane_f32(mx, vget_low_f32(a2), 0);
	r0 = vmlaq_lane_f32(r0, my, vget_low_f32(a0), 1);
	r1 = vmlaq_lane_f32(r1, my, vget_low_f32(a1), 1);
	r2 = vmlaq_lane_f32(r2, my, vget_low_f32(a2), 1);
	r0 = vmlaq_lane_f32(r0, mz, vget_high_f32(a0), 0);
	r1 = vmlaq_lane_f32(r1, mz, vget_high_f32(a1), 0);
	r2 = vmlaq_lane_f32(r2, mz, vget_high_f32(a2), 0);
	return btMatrix3x3(r0, r1, r2);

#else
	return btMatrix3x3(
		m_el[0].dot(m[0]), m_el[0].dot(m[1]), m_el[0].dot(m[2]),
		m_el[1].dot(m[0]), m_el[1].dot(m[1]), m_el[1].dot(m[2]),
		m_el[2].dot(m[0]), m_el[2].dot(m[1]), m_el[2].dot(m[2]));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btMatrix3x3& m, const btVector3& v)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return v.dot3(m[0], m[1], m[2]);
#else
	return btVector3(m[0].dot(v), m[1].dot(v), m[2].dot(v));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	const __m128 vv = v.mVec128;

	__m128 c0 = bt_splat_ps(vv, 0);
	__m128 c1 = bt_splat_ps(vv, 1);
	__m128 c2 = bt_splat_ps(vv, 2);

	c0 = _mm_mul_ps(c0, _mm_and_ps(m[0].mVec128, btvFFF0fMask));
	c1 = _mm_mul_ps(c1, _mm_and_ps(m[1].mVec128, btvFFF0fMask));
	c0 = _mm_add_ps(c0, c1);
	c2 = _mm_mul_ps(c2, _mm_and_ps(m[2].mVec128, btvFFF0fMask));

	return btVector3(_mm_add_ps(c0, c2));
#elif defined(BT_USE_NEON)
	const float32x4_t vv = v.mVec128;
	const float32x2_t vlo = vget_low_f32(vv);
	const float32x2_t vhi = vget_high_f32(vv);

	float32x4_t c0, c1, c2;

	c0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	c1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	c2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	c0 = vmulq_lane_f32(c0, vlo, 0);
	c1 = vmulq_lane_f32(c1, vlo, 1);
	c2 = vmulq_lane_f32(c2, vhi, 0);
	c0 = vaddq_f32(c0, c1);
	c0 = vaddq_f32(c0, c2);

	return btVector3(c0);
#else
	return btVector3(m.tdotx(v), m.tdoty(v), m.tdotz(v));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 m10 = m1[0].mVec128;
	__m128 m11 = m1[1].mVec128;
	__m128 m12 = m1[2].mVec128;

	__m128 m2v = _mm_and_ps(m2[0].mVec128, btvFFF0fMask);

	__m128 c0 = bt_splat_ps(m10, 0);
	__m128 c1 = bt_splat_ps(m11, 0);
	__m128 c2 = bt_splat_ps(m12, 0);

	c0 = _mm_mul_ps(c0, m2v);
	c1 = _mm_mul_ps(c1, m2v);
	c2 = _mm_mul_ps(c2, m2v);

	m2v = _mm_and_ps(m2[1].mVec128, btvFFF0fMask);

	__m128 c0_1 = bt_splat_ps(m10, 1);
	__m128 c1_1 = bt_splat_ps(m11, 1);
	__m128 c2_1 = bt_splat_ps(m12, 1);

	c0_1 = _mm_mul_ps(c0_1, m2v);
	c1_1 = _mm_mul_ps(c1_1, m2v);
	c2_1 = _mm_mul_ps(c2_1, m2v);

	m2v = _mm_and_ps(m2[2].mVec128, btvFFF0fMask);

	c0 = _mm_add_ps(c0, c0_1);
	c1 = _mm_add_ps(c1, c1_1);
	c2 = _mm_add_ps(c2, c2_1);

	m10 = bt_splat_ps(m10, 2);
	m11 = bt_splat_ps(m11, 2);
	m12 = bt_splat_ps(m12, 2);

	m10 = _mm_mul_ps(m10, m2v);
	m11 = _mm_mul_ps(m11, m2v);
	m12 = _mm_mul_ps(m12, m2v);

	c0 = _mm_add_ps(c0, m10);
	c1 = _mm_add_ps(c1, m11);
	c2 = _mm_add_ps(c2, m12);

	return btMatrix3x3(c0, c1, c2);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m1[0].mVec128;
	v1 = m1[1].mVec128;
	v2 = m1[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m2[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m2[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m2[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	return btMatrix3x3(rv0, rv1, rv2);

#else
	return btMatrix3x3(
		m2.tdotx(m1[0]), m2.tdoty(m1[0]), m2.tdotz(m1[0]),
		m2.tdotx(m1[1]), m2.tdoty(m1[1]), m2.tdotz(m1[1]),
		m2.tdotx(m1[2]), m2.tdoty(m1[2]), m2.tdotz(m1[2]));
#endif
}

/*
SIMD_FORCE_INLINE btMatrix3x3 btMultTransposeLeft(const btMatrix3x3& m1, const btMatrix3x3& m2) {
return btMatrix3x3(
m1[0][0] * m2[0][0] + m1[1][0] * m2[1][0] + m1[2][0] * m2[2][0],
m1[0][0] * m2[0][1] + m1[1][0] * m2[1][1] + m1[2][0] * m2[2][1],
m1[0][0] * m2[0][2] + m1[1][0] * m2[1][2] + m1[2][0] * m2[2][2],
m1[0][1] * m2[0][0] + m1[1][1] * m2[1][0] + m1[2][1] * m2[2][0],
m1[0][1] * m2[0][1] + m1[1][1] * m2[1][1] + m1[2][1] * m2[2][1],
m1[0][1] * m2[0][2] + m1[1][1] * m2[1][2] + m1[2][1] * m2[2][2],
m1[0][2] * m2[0][0] + m1[1][2] * m2[1][0] + m1[2][2] * m2[2][0],
m1[0][2] * m2[0][1] + m1[1][2] * m2[1][1] + m1[2][2] * m2[2][1],
m1[0][2] * m2[0][2] + m1[1][2] * m2[1][2] + m1[2][2] * m2[2][2]);
}
*/

/**@brief Equality operator between two matrices
* It will test all elements are equal.  */
SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 c0, c1, c2;

	c0 = _mm_cmpeq_ps(m1[0].mVec128, m2[0].mVec128);
	c1 = _mm_cmpeq_ps(m1[1].mVec128, m2[1].mVec128);
	c2 = _mm_cmpeq_ps(m1[2].mVec128, m2[2].mVec128);

	c0 = _mm_and_ps(c0, c1);
	c0 = _mm_and_ps(c0, c2);

	int m = _mm_movemask_ps((__m128)c0);
	return (0x7 == (m & 0x7));

#else
	return (m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&
			m1[0][1] == m2[0][1] && m1[1][1] == m2[1][1] && m1[2][1] == m2[2][1] &&
			m1[0][2] == m2[0][2] && m1[1][2] == m2[1][2] && m1[2][2] == m2[2][2]);
#endif
}

///for serialization
struct btMatrix3x3FloatData
{
	btVector3FloatData m_el[3];
};

///for serialization
struct btMatrix3x3DoubleData
{
	btVector3DoubleData m_el[3];
};

SIMD_FORCE_INLINE void btMatrix3x3::serialize(struct btMatrix3x3Data& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serialize(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::serializeFloat(struct btMatrix3x3FloatData& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serializeFloat(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerialize(const struct btMatrix3x3Data& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerialize(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeFloat(const struct btMatrix3x3FloatData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeFloat(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeDouble(dataIn.m_el[i]);
}

#endif  //BT_MATRIX3x3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRANSFORM_H
#define BT_TRANSFORM_H

#include "LinearMath/btMatrix3x3.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTransformData btTransformDoubleData
#else
#define btTransformData btTransformFloatData
#endif

/**@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
 *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
ATTRIBUTE_ALIGNED16(class)
btTransform
{
	///Storage for the rotation
	btMatrix3x3 m_basis;
	///Storage for the translation
	btVector3 m_origin;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();
	/**@brief No initialization constructor */
	btTransform() {}
	/**@brief Constructor from btQuaternion (optional btVector3 )
   * @param q Rotation from quaternion 
   * @param c Translation from Vector (default 0,0,0) */
	explicit SIMD_FORCE_INLINE btTransform(const btQuaternion& q,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(q),
		  m_origin(c)
	{
	}

	/**@brief Constructor from btMatrix3x3 (optional btVector3)
   * @param b Rotation from Matrix 
   * @param c Translation from Vector default (0,0,0)*/
	explicit SIMD_FORCE_INLINE btTransform(const btMatrix3x3& b,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(b),
		  m_origin(c)
	{
	}
	/**@brief Copy constructor */
	SIMD_FORCE_INLINE btTransform(const btTransform& other)
		: m_basis(other.m_basis),
		  m_origin(other.m_origin)
	{
	}
	/**@brief Assignment Operator */
	SIMD_FORCE_INLINE btTransform& operator=(const btTransform& other)
	{
		m_basis = other.m_basis;
		m_origin = other.m_origin;
		return *this;
	}

	/**@brief Set the current transform as the value of the product of two transforms
   * @param t1 Transform 1
   * @param t2 Transform 2
   * This = Transform1 * Transform2 */
	SIMD_FORCE_INLINE void mult(const btTransform& t1, const btTransform& t2)
	{
		m_basis = t1.m_basis * t2.m_basis;
		m_origin = t1(t2.m_origin);
	}

	/*		void multInverseLeft(const btTransform& t1, const btTransform& t2) {
			btVector3 v = t2.m_origin - t1.m_origin;
			m_basis = btMultTransposeLeft(t1.m_basis, t2.m_basis);
			m_origin = v * t1.m_basis;
		}
		*/

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator()(const btVector3& x) const
	{
		return x.dot3(m_basis[0], m_basis[1], m_basis[2]) + m_origin;
	}

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator*(const btVector3& x) const
	{
		return (*this)(x);
	}

	/**@brief Return the transform of the btQuaternion */
	SIMD_FORCE_INLINE btQuaternion operator*(const btQuaternion& q) const
	{
		return getRotation() * q;
	}

	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE btMatrix3x3& getBasis() { return m_basis; }
	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE const btMatrix3x3& getBasis() const { return m_basis; }

	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE btVector3& getOrigin() { return m_origin; }
	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE const btVector3& getOrigin() const { return m_origin; }

	/**@brief Return a quaternion representing the rotation */
	btQuaternion getRotation() const
	{
		btQuaternion q;
		m_basis.getRotation(q);
		return q;
	}

	/**@brief Set from an array 
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void setFromOpenGLMatrix(const btScalar* m)
	{
		m_basis.setFromOpenGLSubMatrix(m);
		m_origin.setValue(m[12], m[13], m[14]);
	}

	/**@brief Fill an array representation
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void getOpenGLMatrix(btScalar * m) const
	{
		m_basis.getOpenGLSubMatrix(m);
		m[12] = m_origin.x();
		m[13] = m_origin.y();
		m[14] = m_origin.z();
		m[15] = btScalar(1.0);
	}

	/**@brief Set the translational element
   * @param origin The vector to set the translation to */
	SIMD_FORCE_INLINE void setOrigin(const btVector3& origin)
	{
		m_origin = origin;
	}

	SIMD_FORCE_INLINE btVector3 invXform(const btVector3& inVec) const;

	/**@brief Set the rotational element by btMatrix3x3 */
	SIMD_FORCE_INLINE void setBasis(const btMatrix3x3& basis)
	{
		m_basis = basis;
	}

	/**@brief Set the rotational element by btQuaternion */
	SIMD_FORCE_INLINE void setRotation(const btQuaternion& q)
	{
		m_basis.setRotation(q);
	}

	/**@brief Set this transformation to the identity */
	void setIdentity()
	{
		m_basis.setIdentity();
		m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	/**@brief Multiply this Transform by another(this = this * another) 
   * @param t The other transform */
	btTransform& operator*=(const btTransform& t)
	{
		m_origin += m_basis * t.m_origin;
		m_basis *= t.m_basis;
		return *this;
	}

	/**@brief Return the inverse of this transform */
	btTransform inverse() const
	{
		btMatrix3x3 inv = m_basis.transpose();
		return btTransform(inv, inv * -m_origin);
	}

	/**@brief Return the inverse of this transform times the other transform
   * @param t The other transform 
   * return this.inverse() * the other */
	btTransform inverseTimes(const btTransform& t) const;

	/**@brief Return the product of this transform and the other */
	btTransform operator*(const btTransform& t) const;

	/**@brief Return an identity transform */
	static const btTransform& getIdentity()
	{
		static const btTransform identityTransform(btMatrix3x3::getIdentity());
		return identityTransform;
	}

	void serialize(struct btTransformData & dataOut) const;

	void serializeFloat(struct btTransformFloatData & dataOut) const;

	void deSerialize(const struct btTransformData& dataIn);

	void deSerializeDouble(const struct btTransformDoubleData& dataIn);

	void deSerializeFloat(const struct btTransformFloatData& dataIn);
};

SIMD_FORCE_INLINE btVector3
btTransform::invXform(const btVector3& inVec) const
{
	btVector3 v = inVec - m_origin;
	return (m_basis.transpose() * v);
}

SIMD_FORCE_INLINE btTransform
btTransform::inverseTimes(const btTransform& t) const
{
	btVector3 v = t.getOrigin() - m_origin;
	return btTransform(m_basis.transposeTimes(t.m_basis),
					   v * m_basis);
}

SIMD_FORCE_INLINE btTransform
	btTransform::operator*(const btTransform& t) const
{
	return btTransform(m_basis * t.m_basis,
					   (*this)(t.m_origin));
}

/**@brief Test if two transforms have all elements equal */
SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)
{
	return (t1.getBasis() == t2.getBasis() &&
			t1.getOrigin() == t2.getOrigin());
}

///for serialization
struct btTransformFloatData
{
	btMatrix3x3FloatData m_basis;
	btVector3FloatData m_origin;
};

struct btTransformDoubleData
{
	btMatrix3x3DoubleData m_basis;
	btVector3DoubleData m_origin;
};

SIMD_FORCE_INLINE void btTransform::serialize(btTransformData& dataOut) const
{
	m_basis.serialize(dataOut.m_basis);
	m_origin.serialize(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::serializeFloat(btTransformFloatData& dataOut) const
{
	m_basis.serializeFloat(dataOut.m_basis);
	m_origin.serializeFloat(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerialize(const btTransformData& dataIn)
{
	m_basis.deSerialize(dataIn.m_basis);
	m_origin.deSerialize(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeFloat(const btTransformFloatData& dataIn)
{
	m_basis.deSerializeFloat(dataIn.m_basis);
	m_origin.deSerializeFloat(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeDouble(const btTransformDoubleData& dataIn)
{
	m_basis.deSerializeDouble(dataIn.m_basis);
	m_origin.deSerializeDouble(dataIn.m_origin);
}

#endif  //BT_TRANSFORM_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MOTIONSTATE_H
#define BT_MOTIONSTATE_H

#include "LinearMath/btTransform.h"

///The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
///For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
class btMotionState
{
public:
	virtual ~btMotionState()
	{
	}

	virtual void getWorldTransform(btTransform& worldTrans) const = 0;

	//Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& worldTrans) = 0;
};

#endif  //BT_MOTIONSTATE_H





#ifndef BT_DEFAULT_MOTION_STATE_H
#define BT_DEFAULT_MOTION_STATE_H

#include "LinearMath/btMotionState.h"

///The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
ATTRIBUTE_ALIGNED16(struct)
btDefaultMotionState : public btMotionState
{
	btTransform m_graphicsWorldTrans;
	btTransform m_centerOfMassOffset;
	btTransform m_startWorldTrans;
	void* m_userPointer;

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btDefaultMotionState(const btTransform& startTrans = btTransform::getIdentity(), const btTransform& centerOfMassOffset = btTransform::getIdentity())
		: m_graphicsWorldTrans(startTrans),
		  m_centerOfMassOffset(centerOfMassOffset),
		  m_startWorldTrans(startTrans),
		  m_userPointer(0)

	{
	}

	///synchronizes world transform from user to physics
	virtual void getWorldTransform(btTransform & centerOfMassWorldTrans) const
	{
		centerOfMassWorldTrans = m_graphicsWorldTrans * m_centerOfMassOffset.inverse();
	}

	///synchronizes world transform from physics to user
	///Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& centerOfMassWorldTrans)
	{
		m_graphicsWorldTrans = centerOfMassWorldTrans * m_centerOfMassOffset;
	}
};

#endif  //BT_DEFAULT_MOTION_STATE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_BROADPHASE_PROXY_H
#define BT_BROADPHASE_PROXY_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedAllocator.h"

/// btDispatcher uses these types
/// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
/// to facilitate type checking
/// CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
enum BroadphaseNativeTypes
{
	// polyhedral convex shapes
	BOX_SHAPE_PROXYTYPE,
	TRIANGLE_SHAPE_PROXYTYPE,
	TETRAHEDRAL_SHAPE_PROXYTYPE,
	CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE,
	CONVEX_HULL_SHAPE_PROXYTYPE,
	CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE,
	CUSTOM_POLYHEDRAL_SHAPE_TYPE,
	//implicit convex shapes
	IMPLICIT_CONVEX_SHAPES_START_HERE,
	SPHERE_SHAPE_PROXYTYPE,
	MULTI_SPHERE_SHAPE_PROXYTYPE,
	CAPSULE_SHAPE_PROXYTYPE,
	CONE_SHAPE_PROXYTYPE,
	CONVEX_SHAPE_PROXYTYPE,
	CYLINDER_SHAPE_PROXYTYPE,
	UNIFORM_SCALING_SHAPE_PROXYTYPE,
	MINKOWSKI_SUM_SHAPE_PROXYTYPE,
	MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE,
	BOX_2D_SHAPE_PROXYTYPE,
	CONVEX_2D_SHAPE_PROXYTYPE,
	CUSTOM_CONVEX_SHAPE_TYPE,
	//concave shapes
	CONCAVE_SHAPES_START_HERE,
	//keep all the convex shapetype below here, for the check IsConvexShape in broadphase proxy!
	TRIANGLE_MESH_SHAPE_PROXYTYPE,
	SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE,
	///used for demo integration FAST/Swift collision library and Bullet
	FAST_CONCAVE_MESH_PROXYTYPE,
	//terrain
	TERRAIN_SHAPE_PROXYTYPE,
	///Used for GIMPACT Trimesh integration
	GIMPACT_SHAPE_PROXYTYPE,
	///Multimaterial mesh
	MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE,

	EMPTY_SHAPE_PROXYTYPE,
	STATIC_PLANE_PROXYTYPE,
	CUSTOM_CONCAVE_SHAPE_TYPE,
	SDF_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE,
	CONCAVE_SHAPES_END_HERE,

	COMPOUND_SHAPE_PROXYTYPE,

	SOFTBODY_SHAPE_PROXYTYPE,
	HFFLUID_SHAPE_PROXYTYPE,
	HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE,
	INVALID_SHAPE_PROXYTYPE,

	MAX_BROADPHASE_COLLISION_TYPES

};

///The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
///It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
ATTRIBUTE_ALIGNED16(struct)
btBroadphaseProxy
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///optional filtering to cull potential collisions
	enum CollisionFilterGroups
	{
		DefaultFilter = 1,
		StaticFilter = 2,
		KinematicFilter = 4,
		DebrisFilter = 8,
		SensorTrigger = 16,
		CharacterFilter = 32,
		AllFilter = -1  //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger
	};

	//Usually the client btCollisionObject or Rigidbody class
	void* m_clientObject;
	int m_collisionFilterGroup;
	int m_collisionFilterMask;

	int m_uniqueId;  //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

	btVector3 m_aabbMin;
	btVector3 m_aabbMax;

	SIMD_FORCE_INLINE int getUid() const
	{
		return m_uniqueId;
	}

	//used for memory pools
	btBroadphaseProxy() : m_clientObject(0)
	{
	}

	btBroadphaseProxy(const btVector3& aabbMin, const btVector3& aabbMax, void* userPtr, int collisionFilterGroup, int collisionFilterMask)
		: m_clientObject(userPtr),
		  m_collisionFilterGroup(collisionFilterGroup),
		  m_collisionFilterMask(collisionFilterMask),
		  m_aabbMin(aabbMin),
		  m_aabbMax(aabbMax)
	{
	}

	static SIMD_FORCE_INLINE bool isPolyhedral(int proxyType)
	{
		return (proxyType < IMPLICIT_CONVEX_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isConvex(int proxyType)
	{
		return (proxyType < CONCAVE_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isNonMoving(int proxyType)
	{
		return (isConcave(proxyType) && !(proxyType == GIMPACT_SHAPE_PROXYTYPE));
	}

	static SIMD_FORCE_INLINE bool isConcave(int proxyType)
	{
		return ((proxyType > CONCAVE_SHAPES_START_HERE) &&
				(proxyType < CONCAVE_SHAPES_END_HERE));
	}
	static SIMD_FORCE_INLINE bool isCompound(int proxyType)
	{
		return (proxyType == COMPOUND_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isSoftBody(int proxyType)
	{
		return (proxyType == SOFTBODY_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isInfinite(int proxyType)
	{
		return (proxyType == STATIC_PLANE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isConvex2d(int proxyType)
	{
		return (proxyType == BOX_2D_SHAPE_PROXYTYPE) || (proxyType == CONVEX_2D_SHAPE_PROXYTYPE);
	}
};

class btCollisionAlgorithm;

struct btBroadphaseProxy;

///The btBroadphasePair class contains a pair of aabb-overlapping objects.
///A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
ATTRIBUTE_ALIGNED16(struct)
btBroadphasePair
{
	btBroadphasePair()
		: m_pProxy0(0),
		  m_pProxy1(0),
		  m_algorithm(0),
		  m_internalInfo1(0)
	{
	}

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btBroadphasePair(btBroadphaseProxy & proxy0, btBroadphaseProxy & proxy1)
	{
		//keep them sorted, so the std::set operations work
		if (proxy0.m_uniqueId < proxy1.m_uniqueId)
		{
			m_pProxy0 = &proxy0;
			m_pProxy1 = &proxy1;
		}
		else
		{
			m_pProxy0 = &proxy1;
			m_pProxy1 = &proxy0;
		}

		m_algorithm = 0;
		m_internalInfo1 = 0;
	}

	btBroadphaseProxy* m_pProxy0;
	btBroadphaseProxy* m_pProxy1;

	mutable btCollisionAlgorithm* m_algorithm;
	union {
		void* m_internalInfo1;
		int m_internalTmpValue;
	};  //don't use this data, it will be removed in future version.
};

/*
//comparison for set operation, see Solid DT_Encounter
SIMD_FORCE_INLINE bool operator<(const btBroadphasePair& a, const btBroadphasePair& b) 
{ 
    return a.m_pProxy0 < b.m_pProxy0 || 
        (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 < b.m_pProxy1); 
}
*/

class btBroadphasePairSortPredicate
{
public:
	bool operator()(const btBroadphasePair& a, const btBroadphasePair& b) const
	{
		const int uidA0 = a.m_pProxy0 ? a.m_pProxy0->m_uniqueId : -1;
		const int uidB0 = b.m_pProxy0 ? b.m_pProxy0->m_uniqueId : -1;
		const int uidA1 = a.m_pProxy1 ? a.m_pProxy1->m_uniqueId : -1;
		const int uidB1 = b.m_pProxy1 ? b.m_pProxy1->m_uniqueId : -1;

		return uidA0 > uidB0 ||
			   (a.m_pProxy0 == b.m_pProxy0 && uidA1 > uidB1) ||
			   (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 == b.m_pProxy1 && a.m_algorithm > b.m_algorithm);
	}
};

SIMD_FORCE_INLINE bool operator==(const btBroadphasePair& a, const btBroadphasePair& b)
{
	return (a.m_pProxy0 == b.m_pProxy0) && (a.m_pProxy1 == b.m_pProxy1);
}

#endif  //BT_BROADPHASE_PROXY_H




#include <string.h>



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_SHAPE_H
#define BT_COLLISION_SHAPE_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
class btSerializer;

///The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
ATTRIBUTE_ALIGNED16(class)
btCollisionShape
{
protected:
	int m_shapeType;
	void* m_userPointer;
	int m_userIndex;
	int m_userIndex2;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCollisionShape() : m_shapeType(INVALID_SHAPE_PROXYTYPE), m_userPointer(0), m_userIndex(-1), m_userIndex2(-1)
	{
	}

	virtual ~btCollisionShape()
	{
	}

	///getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getBoundingSphere(btVector3 & center, btScalar & radius) const;

	///getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
	virtual btScalar getAngularMotionDisc() const;

	virtual btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;

	///calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
	///result is conservative
	void calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const;

	SIMD_FORCE_INLINE bool isPolyhedral() const
	{
		return btBroadphaseProxy::isPolyhedral(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex2d() const
	{
		return btBroadphaseProxy::isConvex2d(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex() const
	{
		return btBroadphaseProxy::isConvex(getShapeType());
	}
	SIMD_FORCE_INLINE bool isNonMoving() const
	{
		return btBroadphaseProxy::isNonMoving(getShapeType());
	}
	SIMD_FORCE_INLINE bool isConcave() const
	{
		return btBroadphaseProxy::isConcave(getShapeType());
	}
	SIMD_FORCE_INLINE bool isCompound() const
	{
		return btBroadphaseProxy::isCompound(getShapeType());
	}

	SIMD_FORCE_INLINE bool isSoftBody() const
	{
		return btBroadphaseProxy::isSoftBody(getShapeType());
	}

	///isInfinite is used to catch simulation error (aabb check)
	SIMD_FORCE_INLINE bool isInfinite() const
	{
		return btBroadphaseProxy::isInfinite(getShapeType());
	}

#ifndef __SPU__
	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const = 0;

	//debugging support
	virtual const char* getName() const = 0;
#endif  //__SPU__

	int getShapeType() const
	{
		return m_shapeType;
	}

	///the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
	///See Bullet/Demos/RollingFrictionDemo for an example
	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		return btVector3(1, 1, 1);
	}
	virtual void setMargin(btScalar margin) = 0;
	virtual btScalar getMargin() const = 0;

	///optional user data pointer
	void setUserPointer(void* userPtr)
	{
		m_userPointer = userPtr;
	}

	void* getUserPointer() const
	{
		return m_userPointer;
	}
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	virtual void serializeSingleShape(btSerializer * serializer) const;
};

// clang-format off
// parser needs * with the name
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionShapeData
{
	char	*m_name;
	int		m_shapeType;
	char	m_padding[4];
};
// clang-format on
SIMD_FORCE_INLINE int btCollisionShape::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionShapeData);
}

#endif  //BT_COLLISION_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "LinearMath/btSerializer.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletCollisionProbe();

	void btBulletCollisionProbe() {}
}

void btCollisionShape::getBoundingSphere(btVector3& center, btScalar& radius) const
{
	btTransform tr;
	tr.setIdentity();
	btVector3 aabbMin, aabbMax;

	getAabb(tr, aabbMin, aabbMax);

	radius = (aabbMax - aabbMin).length() * btScalar(0.5);
	center = (aabbMin + aabbMax) * btScalar(0.5);
}

btScalar btCollisionShape::getContactBreakingThreshold(btScalar defaultContactThreshold) const
{
	return getAngularMotionDisc() * defaultContactThreshold;
}

btScalar btCollisionShape::getAngularMotionDisc() const
{
	///@todo cache this value, to improve performance
	btVector3 center;
	btScalar disc;
	getBoundingSphere(center, disc);
	disc += (center).length();
	return disc;
}

void btCollisionShape::calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const
{
	//start with static aabb
	getAabb(curTrans, temporalAabbMin, temporalAabbMax);

	btScalar temporalAabbMaxx = temporalAabbMax.getX();
	btScalar temporalAabbMaxy = temporalAabbMax.getY();
	btScalar temporalAabbMaxz = temporalAabbMax.getZ();
	btScalar temporalAabbMinx = temporalAabbMin.getX();
	btScalar temporalAabbMiny = temporalAabbMin.getY();
	btScalar temporalAabbMinz = temporalAabbMin.getZ();

	// add linear motion
	btVector3 linMotion = linvel * timeStep;
	///@todo: simd would have a vector max/min operation, instead of per-element access
	if (linMotion.x() > btScalar(0.))
		temporalAabbMaxx += linMotion.x();
	else
		temporalAabbMinx += linMotion.x();
	if (linMotion.y() > btScalar(0.))
		temporalAabbMaxy += linMotion.y();
	else
		temporalAabbMiny += linMotion.y();
	if (linMotion.z() > btScalar(0.))
		temporalAabbMaxz += linMotion.z();
	else
		temporalAabbMinz += linMotion.z();

	//add conservative angular motion
	btScalar angularMotion = angvel.length() * getAngularMotionDisc() * timeStep;
	btVector3 angularMotion3d(angularMotion, angularMotion, angularMotion);
	temporalAabbMin = btVector3(temporalAabbMinx, temporalAabbMiny, temporalAabbMinz);
	temporalAabbMax = btVector3(temporalAabbMaxx, temporalAabbMaxy, temporalAabbMaxz);

	temporalAabbMin -= angularMotion3d;
	temporalAabbMax += angularMotion3d;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btCollisionShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionShapeData* shapeData = (btCollisionShapeData*)dataBuffer;
	char* name = (char*)serializer->findNameForPointer(this);
	shapeData->m_name = (char*)serializer->getUniquePointer(name);
	if (shapeData->m_name)
	{
		serializer->serializeName(name);
	}
	shapeData->m_shapeType = m_shapeType;

	// Fill padding with zeros to appease msan.
	memset(shapeData->m_padding, 0, sizeof(shapeData->m_padding));

	return "btCollisionShapeData";
}

void btCollisionShape::serializeSingleShape(btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_SHAPE_CODE, (void*)this);
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_MARGIN_H
#define BT_COLLISION_MARGIN_H

///The CONVEX_DISTANCE_MARGIN is a default collision margin for convex collision shapes derived from btConvexInternalShape.
///This collision margin is used by Gjk and some other algorithms
///Note that when creating small objects, you need to make sure to set a smaller collision margin, using the 'setMargin' API
#define CONVEX_DISTANCE_MARGIN btScalar(0.04)  // btScalar(0.1)//;//btScalar(0.01)

#endif  //BT_COLLISION_MARGIN_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_SHAPE_INTERFACE1
#define BT_CONVEX_SHAPE_INTERFACE1

#include "BulletCollision/CollisionShapes/btCollisionShape.h"

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "LinearMath/btAlignedAllocator.h"

#define MAX_PREFERRED_PENETRATION_DIRECTIONS 10

/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
ATTRIBUTE_ALIGNED16(class)
btConvexShape : public btCollisionShape
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexShape();

	virtual ~btConvexShape();

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const = 0;

////////
#ifndef __SPU__
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const = 0;
#endif  //#ifndef __SPU__

	btVector3 localGetSupportVertexWithoutMarginNonVirtual(const btVector3& vec) const;
	btVector3 localGetSupportVertexNonVirtual(const btVector3& vec) const;
	btScalar getMarginNonVirtual() const;
	void getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;

	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const = 0;

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;

	virtual void setMargin(btScalar margin) = 0;

	virtual btScalar getMargin() const = 0;

	virtual int getNumPreferredPenetrationDirections() const = 0;

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const = 0;
};

#endif  //BT_CONVEX_SHAPE_INTERFACE1





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"

///not supported on IBM SDK, until we fix the alignment of btVector3
#if defined(__CELLOS_LV2__) && defined(__SPU__)
static inline vec_float4 vec_dot3(vec_float4 vec0, vec_float4 vec1)
{
	vec_float4 result;
	result = spu_mul(vec0, vec1);
	result = spu_madd(spu_rlqwbyte(vec0, 4), spu_rlqwbyte(vec1, 4), result);
	return spu_madd(spu_rlqwbyte(vec0, 8), spu_rlqwbyte(vec1, 8), result);
}
#endif  //__SPU__

btConvexShape::btConvexShape()
{
}

btConvexShape::~btConvexShape()
{
}

void btConvexShape::project(const btTransform& trans, const btVector3& dir, btScalar& min, btScalar& max, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	btVector3 localAxis = dir * trans.getBasis();
	btVector3 vtx1 = trans(localGetSupportingVertex(localAxis));
	btVector3 vtx2 = trans(localGetSupportingVertex(-localAxis));

	min = vtx1.dot(dir);
	max = vtx2.dot(dir);
	witnesPtMax = vtx2;
	witnesPtMin = vtx1;

	if (min > max)
	{
		btScalar tmp = min;
		min = max;
		max = tmp;
		witnesPtMax = vtx1;
		witnesPtMin = vtx2;
	}
}

static btVector3 convexHullSupport(const btVector3& localDirOrg, const btVector3* points, int numPoints, const btVector3& localScaling)
{
	btVector3 vec = localDirOrg * localScaling;

#if defined(__CELLOS_LV2__) && defined(__SPU__)

	btVector3 localDir = vec;

	vec_float4 v_distMax = {-FLT_MAX, 0, 0, 0};
	vec_int4 v_idxMax = {-999, 0, 0, 0};
	int v = 0;
	int numverts = numPoints;

	for (; v < (int)numverts - 4; v += 4)
	{
		vec_float4 p0 = vec_dot3(points[v].get128(), localDir.get128());
		vec_float4 p1 = vec_dot3(points[v + 1].get128(), localDir.get128());
		vec_float4 p2 = vec_dot3(points[v + 2].get128(), localDir.get128());
		vec_float4 p3 = vec_dot3(points[v + 3].get128(), localDir.get128());
		const vec_int4 i0 = {v, 0, 0, 0};
		const vec_int4 i1 = {v + 1, 0, 0, 0};
		const vec_int4 i2 = {v + 2, 0, 0, 0};
		const vec_int4 i3 = {v + 3, 0, 0, 0};
		vec_uint4 retGt01 = spu_cmpgt(p0, p1);
		vec_float4 pmax01 = spu_sel(p1, p0, retGt01);
		vec_int4 imax01 = spu_sel(i1, i0, retGt01);
		vec_uint4 retGt23 = spu_cmpgt(p2, p3);
		vec_float4 pmax23 = spu_sel(p3, p2, retGt23);
		vec_int4 imax23 = spu_sel(i3, i2, retGt23);
		vec_uint4 retGt0123 = spu_cmpgt(pmax01, pmax23);
		vec_float4 pmax0123 = spu_sel(pmax23, pmax01, retGt0123);
		vec_int4 imax0123 = spu_sel(imax23, imax01, retGt0123);
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, pmax0123);
		v_distMax = spu_sel(pmax0123, v_distMax, retGtMax);
		v_idxMax = spu_sel(imax0123, v_idxMax, retGtMax);
	}
	for (; v < (int)numverts; v++)
	{
		vec_float4 p = vec_dot3(points[v].get128(), localDir.get128());
		const vec_int4 i = {v, 0, 0, 0};
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, p);
		v_distMax = spu_sel(p, v_distMax, retGtMax);
		v_idxMax = spu_sel(i, v_idxMax, retGtMax);
	}
	int ptIndex = spu_extract(v_idxMax, 0);
	const btVector3& supVec = points[ptIndex] * localScaling;
	return supVec;
#else

	btScalar maxDot;
	long ptIndex = vec.maxDot(points, numPoints, maxDot);
	btAssert(ptIndex >= 0);
	if (ptIndex < 0)
	{
		ptIndex = 0;
	}
	btVector3 supVec = points[ptIndex] * localScaling;
	return supVec;
#endif  //__SPU__
}

btVector3 btConvexShape::localGetSupportVertexWithoutMarginNonVirtual(const btVector3& localDir) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			return btVector3(0, 0, 0);
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			const btVector3& halfExtents = convexShape->getImplicitShapeDimensions();

#if defined(__APPLE__) && (defined(BT_USE_SSE) || defined(BT_USE_NEON))
#if defined(BT_USE_SSE)
			return btVector3(_mm_xor_ps(_mm_and_ps(localDir.mVec128, (__m128){-0.0f, -0.0f, -0.0f, -0.0f}), halfExtents.mVec128));
#elif defined(BT_USE_NEON)
			return btVector3((float32x4_t)(((uint32x4_t)localDir.mVec128 & (uint32x4_t){0x80000000, 0x80000000, 0x80000000, 0x80000000}) ^ (uint32x4_t)halfExtents.mVec128));
#else
#error unknown vector arch
#endif
#else
			return btVector3(btFsels(localDir.x(), halfExtents.x(), -halfExtents.x()),
							 btFsels(localDir.y(), halfExtents.y(), -halfExtents.y()),
							 btFsels(localDir.z(), halfExtents.z(), -halfExtents.z()));
#endif
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btVector3 dir(localDir.getX(), localDir.getY(), localDir.getZ());
			btVector3* vertices = &triangleShape->m_vertices1[0];
			btVector3 dots = dir.dot3(vertices[0], vertices[1], vertices[2]);
			btVector3 sup = vertices[dots.maxAxis()];
			return btVector3(sup.getX(), sup.getY(), sup.getZ());
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			//mapping of halfextents/dimension onto radius/height depends on how cylinder local orientation is (upAxis)

			btVector3 halfExtents = cylShape->getImplicitShapeDimensions();
			btVector3 v(localDir.getX(), localDir.getY(), localDir.getZ());
			int cylinderUpAxis = cylShape->getUpAxis();
			int XX(1), YY(0), ZZ(2);

			switch (cylinderUpAxis)
			{
				case 0:
				{
					XX = 1;
					YY = 0;
					ZZ = 2;
				}
				break;
				case 1:
				{
					XX = 0;
					YY = 1;
					ZZ = 2;
				}
				break;
				case 2:
				{
					XX = 0;
					YY = 2;
					ZZ = 1;
				}
				break;
				default:
					btAssert(0);
					break;
			};

			btScalar radius = halfExtents[XX];
			btScalar halfHeight = halfExtents[cylinderUpAxis];

			btVector3 tmp;
			btScalar d;

			btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
			if (s != btScalar(0.0))
			{
				d = radius / s;
				tmp[XX] = v[XX] * d;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = v[ZZ] * d;
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
			else
			{
				tmp[XX] = radius;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = btScalar(0.0);
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btVector3 vec0(localDir.getX(), localDir.getY(), localDir.getZ());

			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btScalar halfHeight = capsuleShape->getHalfHeight();
			int capsuleUpAxis = capsuleShape->getUpAxis();

			btVector3 supVec(0, 0, 0);

			btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

			btVector3 vec = vec0;
			btScalar lenSqr = vec.length2();
			if (lenSqr < SIMD_EPSILON * SIMD_EPSILON)
			{
				vec.setValue(1, 0, 0);
			}
			else
			{
				btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
				vec *= rlen;
			}
			btVector3 vtx;
			btScalar newDot;
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);

				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = -halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);
				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			return btVector3(supVec.getX(), supVec.getY(), supVec.getZ());
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		{
			btConvexPointCloudShape* convexPointCloudShape = (btConvexPointCloudShape*)this;
			btVector3* points = convexPointCloudShape->getUnscaledPoints();
			int numPoints = convexPointCloudShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexPointCloudShape->getLocalScalingNV());
		}
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btConvexHullShape* convexHullShape = (btConvexHullShape*)this;
			btVector3* points = convexHullShape->getUnscaledPoints();
			int numPoints = convexHullShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexHullShape->getLocalScalingNV());
		}
		default:
#ifndef __SPU__
			return this->localGetSupportingVertexWithoutMargin(localDir);
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btVector3(btScalar(0.0f), btScalar(0.0f), btScalar(0.0f));
}

btVector3 btConvexShape::localGetSupportVertexNonVirtual(const btVector3& localDir) const
{
	btVector3 localDirNorm = localDir;
	if (localDirNorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		localDirNorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	localDirNorm.normalize();

	return localGetSupportVertexWithoutMarginNonVirtual(localDirNorm) + getMarginNonVirtual() * localDirNorm;
}

/* TODO: This should be bumped up to btCollisionShape () */
btScalar btConvexShape::getMarginNonVirtual() const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			return sphereShape->getRadius();
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			return convexShape->getMarginNV();
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			return triangleShape->getMarginNV();
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			return cylShape->getMarginNV();
		}
		case CONE_SHAPE_PROXYTYPE:
		{
			btConeShape* conShape = (btConeShape*)this;
			return conShape->getMarginNV();
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			return capsuleShape->getMarginNV();
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		/* fall through */
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexShape* convexHullShape = (btPolyhedralConvexShape*)this;
			return convexHullShape->getMarginNV();
		}
		default:
#ifndef __SPU__
			return this->getMargin();
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btScalar(0.0f);
}
#ifndef __SPU__
void btConvexShape::getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			btScalar radius = sphereShape->getImplicitShapeDimensions().getX();  // * convexShape->getLocalScaling().getX();
			btScalar margin = radius + sphereShape->getMarginNonVirtual();
			const btVector3& center = t.getOrigin();
			btVector3 extent(margin, margin, margin);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CYLINDER_SHAPE_PROXYTYPE:
		/* fall through */
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			btScalar margin = convexShape->getMarginNonVirtual();
			btVector3 halfExtents = convexShape->getImplicitShapeDimensions();
			halfExtents += btVector3(margin, margin, margin);
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

			aabbMin = center - extent;
			aabbMax = center + extent;
			break;
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btScalar margin = triangleShape->getMarginNonVirtual();
			for (int i = 0; i < 3; i++)
			{
				btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
				vec[i] = btScalar(1.);

				btVector3 sv = localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis());

				btVector3 tmp = t(sv);
				aabbMax[i] = tmp[i] + margin;
				vec[i] = btScalar(-1.);
				tmp = t(localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis()));
				aabbMin[i] = tmp[i] - margin;
			}
		}
		break;
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btVector3 halfExtents(capsuleShape->getRadius(), capsuleShape->getRadius(), capsuleShape->getRadius());
			int m_upAxis = capsuleShape->getUpAxis();
			halfExtents[m_upAxis] = capsuleShape->getRadius() + capsuleShape->getHalfHeight();
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexAabbCachingShape* convexHullShape = (btPolyhedralConvexAabbCachingShape*)this;
			btScalar margin = convexHullShape->getMarginNonVirtual();
			convexHullShape->getNonvirtualAabb(t, aabbMin, aabbMax, margin);
		}
		break;
		default:
#ifndef __SPU__
			this->getAabb(t, aabbMin, aabbMax);
#else
			btAssert(0);
#endif
			break;
	}

	// should never reach here
	btAssert(0);
}

#endif  //__SPU__





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_AABB_UTIL2
#define BT_AABB_UTIL2

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

SIMD_FORCE_INLINE void AabbExpand(btVector3& aabbMin,
								  btVector3& aabbMax,
								  const btVector3& expansionMin,
								  const btVector3& expansionMax)
{
	aabbMin = aabbMin + expansionMin;
	aabbMax = aabbMax + expansionMax;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestPointAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											 const btVector3& point)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > point.getX() || aabbMax1.getX() < point.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > point.getZ() || aabbMax1.getZ() < point.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > point.getY() || aabbMax1.getY() < point.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestAabbAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											const btVector3& aabbMin2, const btVector3& aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > aabbMax2.getX() || aabbMax1.getX() < aabbMin2.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > aabbMax2.getZ() || aabbMax1.getZ() < aabbMin2.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > aabbMax2.getY() || aabbMax1.getY() < aabbMin2.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between triangle and aabb
SIMD_FORCE_INLINE bool TestTriangleAgainstAabb2(const btVector3* vertices,
												const btVector3& aabbMin, const btVector3& aabbMax)
{
	const btVector3& p1 = vertices[0];
	const btVector3& p2 = vertices[1];
	const btVector3& p3 = vertices[2];

	if (btMin(btMin(p1[0], p2[0]), p3[0]) > aabbMax[0]) return false;
	if (btMax(btMax(p1[0], p2[0]), p3[0]) < aabbMin[0]) return false;

	if (btMin(btMin(p1[2], p2[2]), p3[2]) > aabbMax[2]) return false;
	if (btMax(btMax(p1[2], p2[2]), p3[2]) < aabbMin[2]) return false;

	if (btMin(btMin(p1[1], p2[1]), p3[1]) > aabbMax[1]) return false;
	if (btMax(btMax(p1[1], p2[1]), p3[1]) < aabbMin[1]) return false;
	return true;
}

SIMD_FORCE_INLINE int btOutcode(const btVector3& p, const btVector3& halfExtent)
{
	return (p.getX() < -halfExtent.getX() ? 0x01 : 0x0) |
		   (p.getX() > halfExtent.getX() ? 0x08 : 0x0) |
		   (p.getY() < -halfExtent.getY() ? 0x02 : 0x0) |
		   (p.getY() > halfExtent.getY() ? 0x10 : 0x0) |
		   (p.getZ() < -halfExtent.getZ() ? 0x4 : 0x0) |
		   (p.getZ() > halfExtent.getZ() ? 0x20 : 0x0);
}

SIMD_FORCE_INLINE bool btRayAabb2(const btVector3& rayFrom,
								  const btVector3& rayInvDirection,
								  const unsigned int raySign[3],
								  const btVector3 bounds[2],
								  btScalar& tmin,
								  btScalar lambda_min,
								  btScalar lambda_max)
{
	btScalar tmax, tymin, tymax, tzmin, tzmax;
	tmin = (bounds[raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tmax = (bounds[1 - raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tymin = (bounds[raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();
	tymax = (bounds[1 - raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();

	if ((tmin > tymax) || (tymin > tmax))
		return false;

	if (tymin > tmin)
		tmin = tymin;

	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();
	tzmax = (bounds[1 - raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;
	return ((tmin < lambda_max) && (tmax > lambda_min));
}

SIMD_FORCE_INLINE bool btRayAabb(const btVector3& rayFrom,
								 const btVector3& rayTo,
								 const btVector3& aabbMin,
								 const btVector3& aabbMax,
								 btScalar& param, btVector3& normal)
{
	btVector3 aabbHalfExtent = (aabbMax - aabbMin) * btScalar(0.5);
	btVector3 aabbCenter = (aabbMax + aabbMin) * btScalar(0.5);
	btVector3 source = rayFrom - aabbCenter;
	btVector3 target = rayTo - aabbCenter;
	int sourceOutcode = btOutcode(source, aabbHalfExtent);
	int targetOutcode = btOutcode(target, aabbHalfExtent);
	if ((sourceOutcode & targetOutcode) == 0x0)
	{
		btScalar lambda_enter = btScalar(0.0);
		btScalar lambda_exit = param;
		btVector3 r = target - source;
		int i;
		btScalar normSign = 1;
		btVector3 hitNormal(0, 0, 0);
		int bit = 1;

		for (int j = 0; j < 2; j++)
		{
			for (i = 0; i != 3; ++i)
			{
				if (sourceOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					if (lambda_enter <= lambda)
					{
						lambda_enter = lambda;
						hitNormal.setValue(0, 0, 0);
						hitNormal[i] = normSign;
					}
				}
				else if (targetOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					btSetMin(lambda_exit, lambda);
				}
				bit <<= 1;
			}
			normSign = btScalar(-1.);
		}
		if (lambda_enter <= lambda_exit)
		{
			param = lambda_enter;
			normal = hitNormal;
			return true;
		}
	}
	return false;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& halfExtents, btScalar margin, const btTransform& t, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btVector3 halfExtentsWithMargin = halfExtents + btVector3(margin, margin, margin);
	btMatrix3x3 abs_b = t.getBasis().absolute();
	btVector3 center = t.getOrigin();
	btVector3 extent = halfExtentsWithMargin.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& localAabbMin, const btVector3& localAabbMax, btScalar margin, const btTransform& trans, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btAssert(localAabbMin.getX() <= localAabbMax.getX());
	btAssert(localAabbMin.getY() <= localAabbMax.getY());
	btAssert(localAabbMin.getZ() <= localAabbMax.getZ());
	btVector3 localHalfExtents = btScalar(0.5) * (localAabbMax - localAabbMin);
	localHalfExtents += btVector3(margin, margin, margin);

	btVector3 localCenter = btScalar(0.5) * (localAabbMax + localAabbMin);
	btMatrix3x3 abs_b = trans.getBasis().absolute();
	btVector3 center = trans(localCenter);
	btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

#define USE_BANCHLESS 1
#ifdef USE_BANCHLESS
//This block replaces the block below and uses no branches, and replaces the 8 bit return with a 32 bit return for improved performance (~3x on XBox 360)
SIMD_FORCE_INLINE unsigned testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	return static_cast<unsigned int>(btSelect((unsigned)((aabbMin1[0] <= aabbMax2[0]) & (aabbMax1[0] >= aabbMin2[0]) & (aabbMin1[2] <= aabbMax2[2]) & (aabbMax1[2] >= aabbMin2[2]) & (aabbMin1[1] <= aabbMax2[1]) & (aabbMax1[1] >= aabbMin2[1])),
											  1, 0));
}
#else
SIMD_FORCE_INLINE bool testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1[0] > aabbMax2[0] || aabbMax1[0] < aabbMin2[0]) ? false : overlap;
	overlap = (aabbMin1[2] > aabbMax2[2] || aabbMax1[2] < aabbMin2[2]) ? false : overlap;
	overlap = (aabbMin1[1] > aabbMax2[1] || aabbMax1[1] < aabbMin2[1]) ? false : overlap;
	return overlap;
}
#endif  //USE_BANCHLESS

#endif  //BT_AABB_UTIL2





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_INTERNAL_SHAPE_H
#define BT_CONVEX_INTERNAL_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btAabbUtil2.h"

///The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
///The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
///This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
///Note that when creating small shapes (derived from btConvexInternalShape),
///you need to make sure to set a smaller collision margin, using the 'setMargin' API
///There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
ATTRIBUTE_ALIGNED16(class)
btConvexInternalShape : public btConvexShape
{
protected:
	//local scaling. collisionMargin is not scaled !
	btVector3 m_localScaling;

	btVector3 m_implicitShapeDimensions;

	btScalar m_collisionMargin;

	btScalar m_padding;

	btConvexInternalShape();

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btConvexInternalShape()
	{
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;

	const btVector3& getImplicitShapeDimensions() const
	{
		return m_implicitShapeDimensions;
	}

	///warning: use setImplicitShapeDimensions with care
	///changing a collision shape while the body is in the world is not recommended,
	///it is best to remove the body from the world, then make the change, and re-add it
	///alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'
	void setImplicitShapeDimensions(const btVector3& dimensions)
	{
		m_implicitShapeDimensions = dimensions;
	}

	void setSafeMargin(btScalar minDimension, btScalar defaultMarginMultiplier = 0.1f)
	{
		btScalar safeMargin = defaultMarginMultiplier * minDimension;
		if (safeMargin < getMargin())
		{
			setMargin(safeMargin);
		}
	}
	void setSafeMargin(const btVector3& halfExtents, btScalar defaultMarginMultiplier = 0.1f)
	{
		//see http://code.google.com/p/bullet/issues/detail?id=349
		//this margin check could could be added to other collision shapes too,
		//or add some assert/warning somewhere
		btScalar minDimension = halfExtents[halfExtents.minAxis()];
		setSafeMargin(minDimension, defaultMarginMultiplier);
	}

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		getAabbSlow(t, aabbMin, aabbMax);
	}

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void setLocalScaling(const btVector3& scaling);
	virtual const btVector3& getLocalScaling() const
	{
		return m_localScaling;
	}

	const btVector3& getLocalScalingNV() const
	{
		return m_localScaling;
	}

	virtual void setMargin(btScalar margin)
	{
		m_collisionMargin = margin;
	}
	virtual btScalar getMargin() const
	{
		return m_collisionMargin;
	}

	btScalar getMarginNV() const
	{
		return m_collisionMargin;
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 0;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		(void)penetrationVector;
		(void)index;
		btAssert(0);
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btConvexInternalShapeData
{
	btCollisionShapeData m_collisionShapeData;

	btVector3FloatData m_localScaling;

	btVector3FloatData m_implicitShapeDimensions;

	float m_collisionMargin;

	int m_padding;
};

SIMD_FORCE_INLINE int btConvexInternalShape::calculateSerializeBufferSize() const
{
	return sizeof(btConvexInternalShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btConvexInternalShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btConvexInternalShapeData* shapeData = (btConvexInternalShapeData*)dataBuffer;
	btCollisionShape::serialize(&shapeData->m_collisionShapeData, serializer);

	m_implicitShapeDimensions.serializeFloat(shapeData->m_implicitShapeDimensions);
	m_localScaling.serializeFloat(shapeData->m_localScaling);
	shapeData->m_collisionMargin = float(m_collisionMargin);

	// Fill padding with zeros to appease msan.
	shapeData->m_padding = 0;

	return "btConvexInternalShapeData";
}

///btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
class btConvexInternalAabbCachingShape : public btConvexInternalShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	btConvexInternalAabbCachingShape();

	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

public:
	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_CONVEX_INTERNAL_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"

btConvexInternalShape::btConvexInternalShape()
	: m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.)),
	  m_collisionMargin(CONVEX_DISTANCE_MARGIN)
{
}

void btConvexInternalShape::setLocalScaling(const btVector3& scaling)
{
	m_localScaling = scaling.absolute();
}

void btConvexInternalShape::getAabbSlow(const btTransform& trans, btVector3& minAabb, btVector3& maxAabb) const
{
#ifndef __SPU__
	//use localGetSupportingVertexWithoutMargin?
	btScalar margin = getMargin();
	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);

		btVector3 sv = localGetSupportingVertex(vec * trans.getBasis());

		btVector3 tmp = trans(sv);
		maxAabb[i] = tmp[i] + margin;
		vec[i] = btScalar(-1.);
		tmp = trans(localGetSupportingVertex(vec * trans.getBasis()));
		minAabb[i] = tmp[i] - margin;
	}
#endif
}

btVector3 btConvexInternalShape::localGetSupportingVertex(const btVector3& vec) const
{
#ifndef __SPU__

	btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

	if (getMargin() != btScalar(0.))
	{
		btVector3 vecnorm = vec;
		if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
		{
			vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
		}
		vecnorm.normalize();
		supVertex += getMargin() * vecnorm;
	}
	return supVertex;

#else
	btAssert(0);
	return btVector3(0, 0, 0);
#endif  //__SPU__
}

btConvexInternalAabbCachingShape::btConvexInternalAabbCachingShape()
	: btConvexInternalShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btConvexInternalAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btConvexInternalAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

void btConvexInternalAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i] + m_collisionMargin;
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i] - m_collisionMargin;
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#ifndef BT_SPHERE_MINKOWSKI_H
#define BT_SPHERE_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btSphereShape implements an implicit sphere, centered around a local origin with radius.
ATTRIBUTE_ALIGNED16(class)
btSphereShape : public btConvexInternalShape

{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btSphereShape(btScalar radius) : btConvexInternalShape()
	{
		m_shapeType = SPHERE_SHAPE_PROXYTYPE;
		m_localScaling.setValue(1.0, 1.0, 1.0);
		m_implicitShapeDimensions.setZero();
		m_implicitShapeDimensions.setX(radius);
		m_collisionMargin = radius;
		m_padding = 0;
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	btScalar getRadius() const { return m_implicitShapeDimensions.getX() * m_localScaling.getX(); }

	void setUnscaledRadius(btScalar radius)
	{
		m_implicitShapeDimensions.setX(radius);
		btConvexInternalShape::setMargin(radius);
	}

	//debugging
	virtual const char* getName() const { return "SPHERE"; }

	virtual void setMargin(btScalar margin)
	{
		btConvexInternalShape::setMargin(margin);
	}
	virtual btScalar getMargin() const
	{
		//to improve gjk behaviour, use radius+margin as the full margin, so never get into the penetration case
		//this means, non-uniform scaling is not supported anymore
		return getRadius();
	}
};

#endif  //BT_SPHERE_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"

btVector3 btSphereShape::localGetSupportingVertexWithoutMargin(const btVector3& vec) const
{
	(void)vec;
	return btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
}

void btSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	(void)vectors;

	for (int i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i].setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	}
}

btVector3 btSphereShape::localGetSupportingVertex(const btVector3& vec) const
{
	btVector3 supVertex;
	supVertex = localGetSupportingVertexWithoutMargin(vec);

	btVector3 vecnorm = vec;
	if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	vecnorm.normalize();
	supVertex += getMargin() * vecnorm;
	return supVertex;
}

//broken due to scaling
void btSphereShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	const btVector3& center = t.getOrigin();
	btVector3 extent(getMargin(), getMargin(), getMargin());
	aabbMin = center - extent;
	aabbMax = center + extent;
}

void btSphereShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	btScalar elem = btScalar(0.4) * mass * getMargin() * getMargin();
	inertia.setValue(elem, elem, elem);
}





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_HULL_COMPUTER_H
#define BT_CONVEX_HULL_COMPUTER_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullComputer
{
private:
	btScalar compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp);

public:
	class Edge
	{
	private:
		int next;
		int reverse;
		int targetVertex;

		friend class btConvexHullComputer;

	public:
		int getSourceVertex() const
		{
			return (this + reverse)->targetVertex;
		}

		int getTargetVertex() const
		{
			return targetVertex;
		}

		const Edge* getNextEdgeOfVertex() const  // clockwise list of all edges of a vertex
		{
			return this + next;
		}

		const Edge* getNextEdgeOfFace() const  // counter-clockwise list of all edges of a face
		{
			return (this + reverse)->getNextEdgeOfVertex();
		}

		const Edge* getReverseEdge() const
		{
			return this + reverse;
		}
	};

	// Vertices of the output hull
	btAlignedObjectArray<btVector3> vertices;

	// The original vertex index in the input coords array
	btAlignedObjectArray<int> original_vertex_index;

	// Edges of the output hull
	btAlignedObjectArray<Edge> edges;

	// Faces of the convex hull. Each entry is an index into the "edges" array pointing to an edge of the face. Faces are planar n-gons
	btAlignedObjectArray<int> faces;

	/*
		Compute convex hull of "count" vertices stored in "coords". "stride" is the difference in bytes
		between the addresses of consecutive vertices. If "shrink" is positive, the convex hull is shrunken
		by that amount (each face is moved by "shrink" length units towards the center along its normal).
		If "shrinkClamp" is positive, "shrink" is clamped to not exceed "shrinkClamp * innerRadius", where "innerRadius"
		is the minimum distance of a face to the center of the convex hull.

		The returned value is the amount by which the hull has been shrunken. If it is negative, the amount was so large
		that the resulting convex hull is empty.

		The output convex hull can be found in the member variables "vertices", "edges", "faces".
		*/
	btScalar compute(const float* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, false, stride, count, shrink, shrinkClamp);
	}

	// same as above, but double precision
	btScalar compute(const double* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, true, stride, count, shrink, shrinkClamp);
	}
};

#endif  //BT_CONVEX_HULL_COMPUTER_H





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btVector3.h"

#ifdef __GNUC__
#elif defined(_MSC_VER)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
typedef int int32_t;
typedef long long int int64_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
#endif

//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif

//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS

#if defined(DEBUG_CONVEX_HULL) || defined(SHOW_ITERATIONS)
#endif

// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullInternal
{
public:
	class Point64
	{
	public:
		int64_t x;
		int64_t y;
		int64_t z;

		Point64(int64_t x, int64_t y, int64_t z) : x(x), y(y), z(z)
		{
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}
	};

	class Point32
	{
	public:
		int32_t x;
		int32_t y;
		int32_t z;
		int index;

		Point32()
		{
		}

		Point32(int32_t x, int32_t y, int32_t z) : x(x), y(y), z(z), index(-1)
		{
		}

		bool operator==(const Point32& b) const
		{
			return (x == b.x) && (y == b.y) && (z == b.z);
		}

		bool operator!=(const Point32& b) const
		{
			return (x != b.x) || (y != b.y) || (z != b.z);
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		Point64 cross(const Point32& b) const
		{
			return Point64(((int64_t)y) * b.z - ((int64_t)z) * b.y, ((int64_t)z) * b.x - ((int64_t)x) * b.z, ((int64_t)x) * b.y - ((int64_t)y) * b.x);
		}

		Point64 cross(const Point64& b) const
		{
			return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
		}

		int64_t dot(const Point32& b) const
		{
			return ((int64_t)x) * b.x + ((int64_t)y) * b.y + ((int64_t)z) * b.z;
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}

		Point32 operator+(const Point32& b) const
		{
			return Point32(x + b.x, y + b.y, z + b.z);
		}

		Point32 operator-(const Point32& b) const
		{
			return Point32(x - b.x, y - b.y, z - b.z);
		}
	};

	class Int128
	{
	public:
		uint64_t low;
		uint64_t high;

		Int128()
		{
		}

		Int128(uint64_t low, uint64_t high) : low(low), high(high)
		{
		}

		Int128(uint64_t low) : low(low), high(0)
		{
		}

		Int128(int64_t value) : low(value), high((value >= 0) ? 0 : (uint64_t)-1LL)
		{
		}

		static Int128 mul(int64_t a, int64_t b);

		static Int128 mul(uint64_t a, uint64_t b);

		Int128 operator-() const
		{
			return Int128((uint64_t) - (int64_t)low, ~high + (low == 0));
		}

		Int128 operator+(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			uint64_t lo = low + b.low;
			return Int128(lo, high + b.high + (lo < low));
#endif
		}

		Int128 operator-(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"subq %[bl], %[rl]\n\t"
				"sbbq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			return *this + -b;
#endif
		}

		Int128& operator+=(const Int128& b)
		{
#ifdef USE_X86_64_ASM
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(low), [rh] "=r"(high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
#else
			uint64_t lo = low + b.low;
			if (lo < low)
			{
				++high;
			}
			low = lo;
			high += b.high;
#endif
			return *this;
		}

		Int128& operator++()
		{
			if (++low == 0)
			{
				++high;
			}
			return *this;
		}

		Int128 operator*(int64_t b) const;

		btScalar toScalar() const
		{
			return ((int64_t)high >= 0) ? btScalar(high) * (btScalar(0x100000000LL) * btScalar(0x100000000LL)) + btScalar(low)
										: -(-*this).toScalar();
		}

		int getSign() const
		{
			return ((int64_t)high < 0) ? -1 : (high || low) ? 1 : 0;
		}

		bool operator<(const Int128& b) const
		{
			return (high < b.high) || ((high == b.high) && (low < b.low));
		}

		int ucmp(const Int128& b) const
		{
			if (high < b.high)
			{
				return -1;
			}
			if (high > b.high)
			{
				return 1;
			}
			if (low < b.low)
			{
				return -1;
			}
			if (low > b.low)
			{
				return 1;
			}
			return 0;
		}
	};

	class Rational64
	{
	private:
		uint64_t m_numerator;
		uint64_t m_denominator;
		int sign;

	public:
		Rational64(int64_t numerator, int64_t denominator)
		{
			if (numerator > 0)
			{
				sign = 1;
				m_numerator = (uint64_t)numerator;
			}
			else if (numerator < 0)
			{
				sign = -1;
				m_numerator = (uint64_t)-numerator;
			}
			else
			{
				sign = 0;
				m_numerator = 0;
			}
			if (denominator > 0)
			{
				m_denominator = (uint64_t)denominator;
			}
			else if (denominator < 0)
			{
				sign = -sign;
				m_denominator = (uint64_t)-denominator;
			}
			else
			{
				m_denominator = 0;
			}
		}

		bool isNegativeInfinity() const
		{
			return (sign < 0) && (m_denominator == 0);
		}

		bool isNaN() const
		{
			return (sign == 0) && (m_denominator == 0);
		}

		int compare(const Rational64& b) const;

		btScalar toScalar() const
		{
			return sign * ((m_denominator == 0) ? SIMD_INFINITY : (btScalar)m_numerator / m_denominator);
		}
	};

	class Rational128
	{
	private:
		Int128 numerator;
		Int128 denominator;
		int sign;
		bool isInt64;

	public:
		Rational128(int64_t value)
		{
			if (value > 0)
			{
				sign = 1;
				this->numerator = value;
			}
			else if (value < 0)
			{
				sign = -1;
				this->numerator = -value;
			}
			else
			{
				sign = 0;
				this->numerator = (uint64_t)0;
			}
			this->denominator = (uint64_t)1;
			isInt64 = true;
		}

		Rational128(const Int128& numerator, const Int128& denominator)
		{
			sign = numerator.getSign();
			if (sign >= 0)
			{
				this->numerator = numerator;
			}
			else
			{
				this->numerator = -numerator;
			}
			int dsign = denominator.getSign();
			if (dsign >= 0)
			{
				this->denominator = denominator;
			}
			else
			{
				sign = -sign;
				this->denominator = -denominator;
			}
			isInt64 = false;
		}

		int compare(const Rational128& b) const;

		int compare(int64_t b) const;

		btScalar toScalar() const
		{
			return sign * ((denominator.getSign() == 0) ? SIMD_INFINITY : numerator.toScalar() / denominator.toScalar());
		}
	};

	class PointR128
	{
	public:
		Int128 x;
		Int128 y;
		Int128 z;
		Int128 denominator;

		PointR128()
		{
		}

		PointR128(Int128 x, Int128 y, Int128 z, Int128 denominator) : x(x), y(y), z(z), denominator(denominator)
		{
		}

		btScalar xvalue() const
		{
			return x.toScalar() / denominator.toScalar();
		}

		btScalar yvalue() const
		{
			return y.toScalar() / denominator.toScalar();
		}

		btScalar zvalue() const
		{
			return z.toScalar() / denominator.toScalar();
		}
	};

	class Edge;
	class Face;

	class Vertex
	{
	public:
		Vertex* next;
		Vertex* prev;
		Edge* edges;
		Face* firstNearbyFace;
		Face* lastNearbyFace;
		PointR128 point128;
		Point32 point;
		int copy;

		Vertex() : next(NULL), prev(NULL), edges(NULL), firstNearbyFace(NULL), lastNearbyFace(NULL), copy(-1)
		{
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("V%d (%d, %d, %d)", point.index, point.x, point.y, point.z);
		}

		void printGraph();
#endif

		Point32 operator-(const Vertex& b) const
		{
			return point - b.point;
		}

		Rational128 dot(const Point64& b) const
		{
			return (point.index >= 0) ? Rational128(point.dot(b))
									  : Rational128(point128.x * b.x + point128.y * b.y + point128.z * b.z, point128.denominator);
		}

		btScalar xvalue() const
		{
			return (point.index >= 0) ? btScalar(point.x) : point128.xvalue();
		}

		btScalar yvalue() const
		{
			return (point.index >= 0) ? btScalar(point.y) : point128.yvalue();
		}

		btScalar zvalue() const
		{
			return (point.index >= 0) ? btScalar(point.z) : point128.zvalue();
		}

		void receiveNearbyFaces(Vertex* src)
		{
			if (lastNearbyFace)
			{
				lastNearbyFace->nextWithSameNearbyVertex = src->firstNearbyFace;
			}
			else
			{
				firstNearbyFace = src->firstNearbyFace;
			}
			if (src->lastNearbyFace)
			{
				lastNearbyFace = src->lastNearbyFace;
			}
			for (Face* f = src->firstNearbyFace; f; f = f->nextWithSameNearbyVertex)
			{
				btAssert(f->nearbyVertex == src);
				f->nearbyVertex = this;
			}
			src->firstNearbyFace = NULL;
			src->lastNearbyFace = NULL;
		}
	};

	class Edge
	{
	public:
		Edge* next;
		Edge* prev;
		Edge* reverse;
		Vertex* target;
		Face* face;
		int copy;

		~Edge()
		{
			next = NULL;
			prev = NULL;
			reverse = NULL;
			target = NULL;
			face = NULL;
		}

		void link(Edge* n)
		{
			btAssert(reverse->target == n->reverse->target);
			next = n;
			n->prev = this;
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("E%p : %d -> %d,  n=%p p=%p   (0 %d\t%d\t%d) -> (%d %d %d)", this, reverse->target->point.index, target->point.index, next, prev,
				   reverse->target->point.x, reverse->target->point.y, reverse->target->point.z, target->point.x, target->point.y, target->point.z);
		}
#endif
	};

	class Face
	{
	public:
		Face* next;
		Vertex* nearbyVertex;
		Face* nextWithSameNearbyVertex;
		Point32 origin;
		Point32 dir0;
		Point32 dir1;

		Face() : next(NULL), nearbyVertex(NULL), nextWithSameNearbyVertex(NULL)
		{
		}

		void init(Vertex* a, Vertex* b, Vertex* c)
		{
			nearbyVertex = a;
			origin = a->point;
			dir0 = *b - *a;
			dir1 = *c - *a;
			if (a->lastNearbyFace)
			{
				a->lastNearbyFace->nextWithSameNearbyVertex = this;
			}
			else
			{
				a->firstNearbyFace = this;
			}
			a->lastNearbyFace = this;
		}

		Point64 getNormal()
		{
			return dir0.cross(dir1);
		}
	};

	template <typename UWord, typename UHWord>
	class DMul
	{
	private:
		static uint32_t high(uint64_t value)
		{
			return (uint32_t)(value >> 32);
		}

		static uint32_t low(uint64_t value)
		{
			return (uint32_t)value;
		}

		static uint64_t mul(uint32_t a, uint32_t b)
		{
			return (uint64_t)a * (uint64_t)b;
		}

		static void shlHalf(uint64_t& value)
		{
			value <<= 32;
		}

		static uint64_t high(Int128 value)
		{
			return value.high;
		}

		static uint64_t low(Int128 value)
		{
			return value.low;
		}

		static Int128 mul(uint64_t a, uint64_t b)
		{
			return Int128::mul(a, b);
		}

		static void shlHalf(Int128& value)
		{
			value.high = value.low;
			value.low = 0;
		}

	public:
		static void mul(UWord a, UWord b, UWord& resLow, UWord& resHigh)
		{
			UWord p00 = mul(low(a), low(b));
			UWord p01 = mul(low(a), high(b));
			UWord p10 = mul(high(a), low(b));
			UWord p11 = mul(high(a), high(b));
			UWord p0110 = UWord(low(p01)) + UWord(low(p10));
			p11 += high(p01);
			p11 += high(p10);
			p11 += high(p0110);
			shlHalf(p0110);
			p00 += p0110;
			if (p00 < p0110)
			{
				++p11;
			}
			resLow = p00;
			resHigh = p11;
		}
	};

private:
	class IntermediateHull
	{
	public:
		Vertex* minXy;
		Vertex* maxXy;
		Vertex* minYx;
		Vertex* maxYx;

		IntermediateHull() : minXy(NULL), maxXy(NULL), minYx(NULL), maxYx(NULL)
		{
		}

		void print();
	};

	enum Orientation
	{
		NONE,
		CLOCKWISE,
		COUNTER_CLOCKWISE
	};

	template <typename T>
	class PoolArray
	{
	private:
		T* array;
		int size;

	public:
		PoolArray<T>* next;

		PoolArray(int size) : size(size), next(NULL)
		{
			array = (T*)btAlignedAlloc(sizeof(T) * size, 16);
		}

		~PoolArray()
		{
			btAlignedFree(array);
		}

		T* init()
		{
			T* o = array;
			for (int i = 0; i < size; i++, o++)
			{
				o->next = (i + 1 < size) ? o + 1 : NULL;
			}
			return array;
		}
	};

	template <typename T>
	class Pool
	{
	private:
		PoolArray<T>* arrays;
		PoolArray<T>* nextArray;
		T* freeObjects;
		int arraySize;

	public:
		Pool() : arrays(NULL), nextArray(NULL), freeObjects(NULL), arraySize(256)
		{
		}

		~Pool()
		{
			while (arrays)
			{
				PoolArray<T>* p = arrays;
				arrays = p->next;
				p->~PoolArray<T>();
				btAlignedFree(p);
			}
		}

		void reset()
		{
			nextArray = arrays;
			freeObjects = NULL;
		}

		void setArraySize(int arraySize)
		{
			this->arraySize = arraySize;
		}

		T* newObject()
		{
			T* o = freeObjects;
			if (!o)
			{
				PoolArray<T>* p = nextArray;
				if (p)
				{
					nextArray = p->next;
				}
				else
				{
					p = new (btAlignedAlloc(sizeof(PoolArray<T>), 16)) PoolArray<T>(arraySize);
					p->next = arrays;
					arrays = p;
				}
				o = p->init();
			}
			freeObjects = o->next;
			return new (o) T();
		};

		void freeObject(T* object)
		{
			object->~T();
			object->next = freeObjects;
			freeObjects = object;
		}
	};

	btVector3 scaling;
	btVector3 center;
	Pool<Vertex> vertexPool;
	Pool<Edge> edgePool;
	Pool<Face> facePool;
	btAlignedObjectArray<Vertex*> originalVertices;
	int mergeStamp;
	int minAxis;
	int medAxis;
	int maxAxis;
	int usedEdgePairs;
	int maxUsedEdgePairs;

	static Orientation getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t);
	Edge* findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot);
	void findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1);

	Edge* newEdgePair(Vertex* from, Vertex* to);

	void removeEdgePair(Edge* edge)
	{
		Edge* n = edge->next;
		Edge* r = edge->reverse;

		btAssert(edge->target && r->target);

		if (n != edge)
		{
			n->prev = edge->prev;
			edge->prev->next = n;
			r->target->edges = n;
		}
		else
		{
			r->target->edges = NULL;
		}

		n = r->next;

		if (n != r)
		{
			n->prev = r->prev;
			r->prev->next = n;
			edge->target->edges = n;
		}
		else
		{
			edge->target->edges = NULL;
		}

		edgePool.freeObject(edge);
		edgePool.freeObject(r);
		usedEdgePairs--;
	}

	void computeInternal(int start, int end, IntermediateHull& result);

	bool mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1);

	void merge(IntermediateHull& h0, IntermediateHull& h1);

	btVector3 toBtVector(const Point32& v);

	btVector3 getBtNormal(Face* face);

	bool shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack);

public:
	Vertex* vertexList;

	void compute(const void* coords, bool doubleCoords, int stride, int count);

	btVector3 getCoordinates(const Vertex* v);

	btScalar shrink(btScalar amount, btScalar clampAmount);
};

btConvexHullInternal::Int128 btConvexHullInternal::Int128::operator*(int64_t b) const
{
	bool negative = (int64_t)high < 0;
	Int128 a = negative ? -*this : *this;
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	Int128 result = mul(a.low, (uint64_t)b);
	result.high += a.high * (uint64_t)b;
	return negative ? -result : result;
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(int64_t a, int64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("imulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");
	return result;

#else
	bool negative = a < 0;
	if (negative)
	{
		a = -a;
	}
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	DMul<uint64_t, uint32_t>::mul((uint64_t)a, (uint64_t)b, result.low, result.high);
	return negative ? -result : result;
#endif
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(uint64_t a, uint64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("mulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");

#else
	DMul<uint64_t, uint32_t>::mul(a, b, result.low, result.high);
#endif

	return result;
}

int btConvexHullInternal::Rational64::compare(const Rational64& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}

	//	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;

#ifdef USE_X86_64_ASM

	int result;
	int64_t tmp;
	int64_t dummy;
	__asm__(
		"mulq %[bn]\n\t"
		"movq %%rax, %[tmp]\n\t"
		"movq %%rdx, %%rbx\n\t"
		"movq %[tn], %%rax\n\t"
		"mulq %[bd]\n\t"
		"subq %[tmp], %%rax\n\t"
		"sbbq %%rbx, %%rdx\n\t"  // rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
		"setnsb %%bh\n\t"        // bh=1 if difference is non-negative, bh=0 otherwise
		"orq %%rdx, %%rax\n\t"
		"setnzb %%bl\n\t"      // bl=1 if difference if non-zero, bl=0 if it is zero
		"decb %%bh\n\t"        // now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
		"shll $16, %%ebx\n\t"  // ebx has same sign as difference
		: "=&b"(result), [tmp] "=&r"(tmp), "=a"(dummy)
		: "a"(m_denominator), [bn] "g"(b.m_numerator), [tn] "g"(m_numerator), [bd] "g"(b.m_denominator)
		: "%rdx", "cc");
	return result ? result ^ sign  // if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
								   // if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
				  : 0;

#else

	return sign * Int128::mul(m_numerator, b.m_denominator).ucmp(Int128::mul(m_denominator, b.m_numerator));

#endif
}

int btConvexHullInternal::Rational128::compare(const Rational128& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}
	if (isInt64)
	{
		return -b.compare(sign * (int64_t)numerator.low);
	}

	Int128 nbdLow, nbdHigh, dbnLow, dbnHigh;
	DMul<Int128, uint64_t>::mul(numerator, b.denominator, nbdLow, nbdHigh);
	DMul<Int128, uint64_t>::mul(denominator, b.numerator, dbnLow, dbnHigh);

	int cmp = nbdHigh.ucmp(dbnHigh);
	if (cmp)
	{
		return cmp * sign;
	}
	return nbdLow.ucmp(dbnLow) * sign;
}

int btConvexHullInternal::Rational128::compare(int64_t b) const
{
	if (isInt64)
	{
		int64_t a = sign * (int64_t)numerator.low;
		return (a > b) ? 1 : (a < b) ? -1 : 0;
	}
	if (b > 0)
	{
		if (sign <= 0)
		{
			return -1;
		}
	}
	else if (b < 0)
	{
		if (sign >= 0)
		{
			return 1;
		}
		b = -b;
	}
	else
	{
		return sign;
	}

	return numerator.ucmp(denominator * b) * sign;
}

btConvexHullInternal::Edge* btConvexHullInternal::newEdgePair(Vertex* from, Vertex* to)
{
	btAssert(from && to);
	Edge* e = edgePool.newObject();
	Edge* r = edgePool.newObject();
	e->reverse = r;
	r->reverse = e;
	e->copy = mergeStamp;
	r->copy = mergeStamp;
	e->target = to;
	r->target = from;
	e->face = NULL;
	r->face = NULL;
	usedEdgePairs++;
	if (usedEdgePairs > maxUsedEdgePairs)
	{
		maxUsedEdgePairs = usedEdgePairs;
	}
	return e;
}

bool btConvexHullInternal::mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1)
{
	Vertex* v0 = h0.maxYx;
	Vertex* v1 = h1.minYx;
	if ((v0->point.x == v1->point.x) && (v0->point.y == v1->point.y))
	{
		btAssert(v0->point.z < v1->point.z);
		Vertex* v1p = v1->prev;
		if (v1p == v1)
		{
			c0 = v0;
			if (v1->edges)
			{
				btAssert(v1->edges->next == v1->edges);
				v1 = v1->edges->target;
				btAssert(v1->edges->next == v1->edges);
			}
			c1 = v1;
			return false;
		}
		Vertex* v1n = v1->next;
		v1p->next = v1n;
		v1n->prev = v1p;
		if (v1 == h1.minXy)
		{
			if ((v1n->point.x < v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y < v1p->point.y)))
			{
				h1.minXy = v1n;
			}
			else
			{
				h1.minXy = v1p;
			}
		}
		if (v1 == h1.maxXy)
		{
			if ((v1n->point.x > v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y > v1p->point.y)))
			{
				h1.maxXy = v1n;
			}
			else
			{
				h1.maxXy = v1p;
			}
		}
	}

	v0 = h0.maxXy;
	v1 = h1.maxXy;
	Vertex* v00 = NULL;
	Vertex* v10 = NULL;
	int32_t sign = 1;

	for (int side = 0; side <= 1; side++)
	{
		int32_t dx = (v1->point.x - v0->point.x) * sign;
		if (dx > 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w0 = side ? v0->next : v0->prev;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					if ((dy0 <= 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx <= dy * dx0))))
					{
						v0 = w0;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w1 = side ? v1->next : v1->prev;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					int32_t dxn = (w1->point.x - v0->point.x) * sign;
					if ((dxn > 0) && (dy1 < 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx < dy * dx1))))
					{
						v1 = w1;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else if (dx < 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w1 = side ? v1->prev : v1->next;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					if ((dy1 >= 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx <= dy * dx1))))
					{
						v1 = w1;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w0 = side ? v0->prev : v0->next;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					int32_t dxn = (v1->point.x - w0->point.x) * sign;
					if ((dxn < 0) && (dy0 > 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx < dy * dx0))))
					{
						v0 = w0;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else
		{
			int32_t x = v0->point.x;
			int32_t y0 = v0->point.y;
			Vertex* w0 = v0;
			Vertex* t;
			while (((t = side ? w0->next : w0->prev) != v0) && (t->point.x == x) && (t->point.y <= y0))
			{
				w0 = t;
				y0 = t->point.y;
			}
			v0 = w0;

			int32_t y1 = v1->point.y;
			Vertex* w1 = v1;
			while (((t = side ? w1->prev : w1->next) != v1) && (t->point.x == x) && (t->point.y >= y1))
			{
				w1 = t;
				y1 = t->point.y;
			}
			v1 = w1;
		}

		if (side == 0)
		{
			v00 = v0;
			v10 = v1;

			v0 = h0.minXy;
			v1 = h1.minXy;
			sign = -1;
		}
	}

	v0->prev = v1;
	v1->next = v0;

	v00->next = v10;
	v10->prev = v00;

	if (h1.minXy->point.x < h0.minXy->point.x)
	{
		h0.minXy = h1.minXy;
	}
	if (h1.maxXy->point.x >= h0.maxXy->point.x)
	{
		h0.maxXy = h1.maxXy;
	}

	h0.maxYx = h1.maxYx;

	c0 = v00;
	c1 = v10;

	return true;
}

void btConvexHullInternal::computeInternal(int start, int end, IntermediateHull& result)
{
	int n = end - start;
	switch (n)
	{
		case 0:
			result.minXy = NULL;
			result.maxXy = NULL;
			result.minYx = NULL;
			result.maxYx = NULL;
			return;
		case 2:
		{
			Vertex* v = originalVertices[start];
			Vertex* w = v + 1;
			if (v->point != w->point)
			{
				int32_t dx = v->point.x - w->point.x;
				int32_t dy = v->point.y - w->point.y;

				if ((dx == 0) && (dy == 0))
				{
					if (v->point.z > w->point.z)
					{
						Vertex* t = w;
						w = v;
						v = t;
					}
					btAssert(v->point.z < w->point.z);
					v->next = v;
					v->prev = v;
					result.minXy = v;
					result.maxXy = v;
					result.minYx = v;
					result.maxYx = v;
				}
				else
				{
					v->next = w;
					v->prev = w;
					w->next = v;
					w->prev = v;

					if ((dx < 0) || ((dx == 0) && (dy < 0)))
					{
						result.minXy = v;
						result.maxXy = w;
					}
					else
					{
						result.minXy = w;
						result.maxXy = v;
					}

					if ((dy < 0) || ((dy == 0) && (dx < 0)))
					{
						result.minYx = v;
						result.maxYx = w;
					}
					else
					{
						result.minYx = w;
						result.maxYx = v;
					}
				}

				Edge* e = newEdgePair(v, w);
				e->link(e);
				v->edges = e;

				e = e->reverse;
				e->link(e);
				w->edges = e;

				return;
			}
			{
				Vertex* v = originalVertices[start];
				v->edges = NULL;
				v->next = v;
				v->prev = v;

				result.minXy = v;
				result.maxXy = v;
				result.minYx = v;
				result.maxYx = v;
			}

			return;
		}

		case 1:
		{
			Vertex* v = originalVertices[start];
			v->edges = NULL;
			v->next = v;
			v->prev = v;

			result.minXy = v;
			result.maxXy = v;
			result.minYx = v;
			result.maxYx = v;

			return;
		}
	}

	int split0 = start + n / 2;
	Point32 p = originalVertices[split0 - 1]->point;
	int split1 = split0;
	while ((split1 < end) && (originalVertices[split1]->point == p))
	{
		split1++;
	}
	computeInternal(start, split0, result);
	IntermediateHull hull1;
	computeInternal(split1, end, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n\nMerge\n");
	result.print();
	hull1.print();
#endif
	merge(result, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n  Result\n");
	result.print();
#endif
}

#ifdef DEBUG_CONVEX_HULL
void btConvexHullInternal::IntermediateHull::print()
{
	printf("    Hull\n");
	for (Vertex* v = minXy; v;)
	{
		printf("      ");
		v->print();
		if (v == maxXy)
		{
			printf(" maxXy");
		}
		if (v == minYx)
		{
			printf(" minYx");
		}
		if (v == maxYx)
		{
			printf(" maxYx");
		}
		if (v->next->prev != v)
		{
			printf(" Inconsistency");
		}
		printf("\n");
		v = v->next;
		if (v == minXy)
		{
			break;
		}
	}
	if (minXy)
	{
		minXy->copy = (minXy->copy == -1) ? -2 : -1;
		minXy->printGraph();
	}
}

void btConvexHullInternal::Vertex::printGraph()
{
	print();
	printf("\nEdges\n");
	Edge* e = edges;
	if (e)
	{
		do
		{
			e->print();
			printf("\n");
			e = e->next;
		} while (e != edges);
		do
		{
			Vertex* v = e->target;
			if (v->copy != copy)
			{
				v->copy = copy;
				v->printGraph();
			}
			e = e->next;
		} while (e != edges);
	}
}
#endif

btConvexHullInternal::Orientation btConvexHullInternal::getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t)
{
	btAssert(prev->reverse->target == next->reverse->target);
	if (prev->next == next)
	{
		if (prev->prev == next)
		{
			Point64 n = t.cross(s);
			Point64 m = (*prev->target - *next->reverse->target).cross(*next->target - *next->reverse->target);
			btAssert(!m.isZero());
			int64_t dot = n.dot(m);
			btAssert(dot != 0);
			return (dot > 0) ? COUNTER_CLOCKWISE : CLOCKWISE;
		}
		return COUNTER_CLOCKWISE;
	}
	else if (prev->prev == next)
	{
		return CLOCKWISE;
	}
	else
	{
		return NONE;
	}
}

btConvexHullInternal::Edge* btConvexHullInternal::findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot)
{
	Edge* minEdge = NULL;

#ifdef DEBUG_CONVEX_HULL
	printf("find max edge for %d\n", start->point.index);
#endif
	Edge* e = start->edges;
	if (e)
	{
		do
		{
			if (e->copy > mergeStamp)
			{
				Point32 t = *e->target - *start;
				Rational64 cot(t.dot(sxrxs), t.dot(rxs));
#ifdef DEBUG_CONVEX_HULL
				printf("      Angle is %f (%d) for ", (float)btAtan(cot.toScalar()), (int)cot.isNaN());
				e->print();
#endif
				if (cot.isNaN())
				{
					btAssert(ccw ? (t.dot(s) < 0) : (t.dot(s) > 0));
				}
				else
				{
					int cmp;
					if (minEdge == NULL)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp = cot.compare(minCot)) < 0)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp == 0) && (ccw == (getOrientation(minEdge, e, s, t) == COUNTER_CLOCKWISE)))
					{
						minEdge = e;
					}
				}
#ifdef DEBUG_CONVEX_HULL
				printf("\n");
#endif
			}
			e = e->next;
		} while (e != start->edges);
	}
	return minEdge;
}

void btConvexHullInternal::findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1)
{
	Edge* start0 = e0;
	Edge* start1 = e1;
	Point32 et0 = start0 ? start0->target->point : c0->point;
	Point32 et1 = start1 ? start1->target->point : c1->point;
	Point32 s = c1->point - c0->point;
	Point64 normal = ((start0 ? start0 : start1)->target->point - c0->point).cross(s);
	int64_t dist = c0->point.dot(normal);
	btAssert(!start1 || (start1->target->point.dot(normal) == dist));
	Point64 perp = s.cross(normal);
	btAssert(!perp.isZero());

#ifdef DEBUG_CONVEX_HULL
	printf("   Advancing %d %d  (%p %p, %d %d)\n", c0->point.index, c1->point.index, start0, start1, start0 ? start0->target->point.index : -1, start1 ? start1->target->point.index : -1);
#endif

	int64_t maxDot0 = et0.dot(perp);
	if (e0)
	{
		while (e0->target != stop0)
		{
			Edge* e = e0->reverse->prev;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot0)
			{
				break;
			}
			maxDot0 = dot;
			e0 = e;
			et0 = e->target->point;
		}
	}

	int64_t maxDot1 = et1.dot(perp);
	if (e1)
	{
		while (e1->target != stop1)
		{
			Edge* e = e1->reverse->next;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot1)
			{
				break;
			}
			maxDot1 = dot;
			e1 = e;
			et1 = e->target->point;
		}
	}

#ifdef DEBUG_CONVEX_HULL
	printf("   Starting at %d %d\n", et0.index, et1.index);
#endif

	int64_t dx = maxDot1 - maxDot0;
	if (dx > 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->next->reverse;
				if (f0->copy > mergeStamp)
				{
					int64_t dx0 = (f0->target->point - et0).dot(perp);
					int64_t dy0 = (f0->target->point - et0).dot(s);
					if ((dx0 == 0) ? (dy0 < 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) >= 0)))
					{
						et0 = f0->target->point;
						dx = (et1 - et0).dot(perp);
						e0 = (e0 == start0) ? NULL : f0;
						continue;
					}
				}
			}

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->reverse->next;
				if (f1->copy > mergeStamp)
				{
					Point32 d1 = f1->target->point - et1;
					if (d1.dot(normal) == 0)
					{
						int64_t dx1 = d1.dot(perp);
						int64_t dy1 = d1.dot(s);
						int64_t dxn = (f1->target->point - et0).dot(perp);
						if ((dxn > 0) && ((dx1 == 0) ? (dy1 < 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) > 0))))
						{
							e1 = f1;
							et1 = e1->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e1 == start1) && (d1.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
	else if (dx < 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->prev->reverse;
				if (f1->copy > mergeStamp)
				{
					int64_t dx1 = (f1->target->point - et1).dot(perp);
					int64_t dy1 = (f1->target->point - et1).dot(s);
					if ((dx1 == 0) ? (dy1 > 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) <= 0)))
					{
						et1 = f1->target->point;
						dx = (et1 - et0).dot(perp);
						e1 = (e1 == start1) ? NULL : f1;
						continue;
					}
				}
			}

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->reverse->prev;
				if (f0->copy > mergeStamp)
				{
					Point32 d0 = f0->target->point - et0;
					if (d0.dot(normal) == 0)
					{
						int64_t dx0 = d0.dot(perp);
						int64_t dy0 = d0.dot(s);
						int64_t dxn = (et1 - f0->target->point).dot(perp);
						if ((dxn < 0) && ((dx0 == 0) ? (dy0 > 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) < 0))))
						{
							e0 = f0;
							et0 = e0->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e0 == start0) && (d0.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
#ifdef DEBUG_CONVEX_HULL
	printf("   Advanced edges to %d %d\n", et0.index, et1.index);
#endif
}

void btConvexHullInternal::merge(IntermediateHull& h0, IntermediateHull& h1)
{
	if (!h1.maxXy)
	{
		return;
	}
	if (!h0.maxXy)
	{
		h0 = h1;
		return;
	}

	mergeStamp--;

	Vertex* c0 = NULL;
	Edge* toPrev0 = NULL;
	Edge* firstNew0 = NULL;
	Edge* pendingHead0 = NULL;
	Edge* pendingTail0 = NULL;
	Vertex* c1 = NULL;
	Edge* toPrev1 = NULL;
	Edge* firstNew1 = NULL;
	Edge* pendingHead1 = NULL;
	Edge* pendingTail1 = NULL;
	Point32 prevPoint;

	if (mergeProjection(h0, h1, c0, c1))
	{
		Point32 s = *c1 - *c0;
		Point64 normal = Point32(0, 0, -1).cross(s);
		Point64 t = s.cross(normal);
		btAssert(!t.isZero());

		Edge* e = c0->edges;
		Edge* start0 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c0).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c0).dot(t) > 0))
				{
					if (!start0 || (getOrientation(start0, e, s, Point32(0, 0, -1)) == CLOCKWISE))
					{
						start0 = e;
					}
				}
				e = e->next;
			} while (e != c0->edges);
		}

		e = c1->edges;
		Edge* start1 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c1).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c1).dot(t) > 0))
				{
					if (!start1 || (getOrientation(start1, e, s, Point32(0, 0, -1)) == COUNTER_CLOCKWISE))
					{
						start1 = e;
					}
				}
				e = e->next;
			} while (e != c1->edges);
		}

		if (start0 || start1)
		{
			findEdgeForCoplanarFaces(c0, c1, start0, start1, NULL, NULL);
			if (start0)
			{
				c0 = start0->target;
			}
			if (start1)
			{
				c1 = start1->target;
			}
		}

		prevPoint = c1->point;
		prevPoint.z++;
	}
	else
	{
		prevPoint = c1->point;
		prevPoint.x++;
	}

	Vertex* first0 = c0;
	Vertex* first1 = c1;
	bool firstRun = true;

	while (true)
	{
		Point32 s = *c1 - *c0;
		Point32 r = prevPoint - c0->point;
		Point64 rxs = r.cross(s);
		Point64 sxrxs = s.cross(rxs);

#ifdef DEBUG_CONVEX_HULL
		printf("\n  Checking %d %d\n", c0->point.index, c1->point.index);
#endif
		Rational64 minCot0(0, 0);
		Edge* min0 = findMaxAngle(false, c0, s, rxs, sxrxs, minCot0);
		Rational64 minCot1(0, 0);
		Edge* min1 = findMaxAngle(true, c1, s, rxs, sxrxs, minCot1);
		if (!min0 && !min1)
		{
			Edge* e = newEdgePair(c0, c1);
			e->link(e);
			c0->edges = e;

			e = e->reverse;
			e->link(e);
			c1->edges = e;
			return;
		}
		else
		{
			int cmp = !min0 ? 1 : !min1 ? -1 : minCot0.compare(minCot1);
#ifdef DEBUG_CONVEX_HULL
			printf("    -> Result %d\n", cmp);
#endif
			if (firstRun || ((cmp >= 0) ? !minCot1.isNegativeInfinity() : !minCot0.isNegativeInfinity()))
			{
				Edge* e = newEdgePair(c0, c1);
				if (pendingTail0)
				{
					pendingTail0->prev = e;
				}
				else
				{
					pendingHead0 = e;
				}
				e->next = pendingTail0;
				pendingTail0 = e;

				e = e->reverse;
				if (pendingTail1)
				{
					pendingTail1->next = e;
				}
				else
				{
					pendingHead1 = e;
				}
				e->prev = pendingTail1;
				pendingTail1 = e;
			}

			Edge* e0 = min0;
			Edge* e1 = min1;

#ifdef DEBUG_CONVEX_HULL
			printf("   Found min edges to %d %d\n", e0 ? e0->target->point.index : -1, e1 ? e1->target->point.index : -1);
#endif

			if (cmp == 0)
			{
				findEdgeForCoplanarFaces(c0, c1, e0, e1, NULL, NULL);
			}

			if ((cmp >= 0) && e1)
			{
				if (toPrev1)
				{
					for (Edge *e = toPrev1->next, *n = NULL; e != min1; e = n)
					{
						n = e->next;
						removeEdgePair(e);
					}
				}

				if (pendingTail1)
				{
					if (toPrev1)
					{
						toPrev1->link(pendingHead1);
					}
					else
					{
						min1->prev->link(pendingHead1);
						firstNew1 = pendingHead1;
					}
					pendingTail1->link(min1);
					pendingHead1 = NULL;
					pendingTail1 = NULL;
				}
				else if (!toPrev1)
				{
					firstNew1 = min1;
				}

				prevPoint = c1->point;
				c1 = e1->target;
				toPrev1 = e1->reverse;
			}

			if ((cmp <= 0) && e0)
			{
				if (toPrev0)
				{
					for (Edge *e = toPrev0->prev, *n = NULL; e != min0; e = n)
					{
						n = e->prev;
						removeEdgePair(e);
					}
				}

				if (pendingTail0)
				{
					if (toPrev0)
					{
						pendingHead0->link(toPrev0);
					}
					else
					{
						pendingHead0->link(min0->next);
						firstNew0 = pendingHead0;
					}
					min0->link(pendingTail0);
					pendingHead0 = NULL;
					pendingTail0 = NULL;
				}
				else if (!toPrev0)
				{
					firstNew0 = min0;
				}

				prevPoint = c0->point;
				c0 = e0->target;
				toPrev0 = e0->reverse;
			}
		}

		if ((c0 == first0) && (c1 == first1))
		{
			if (toPrev0 == NULL)
			{
				pendingHead0->link(pendingTail0);
				c0->edges = pendingTail0;
			}
			else
			{
				for (Edge *e = toPrev0->prev, *n = NULL; e != firstNew0; e = n)
				{
					n = e->prev;
					removeEdgePair(e);
				}
				if (pendingTail0)
				{
					pendingHead0->link(toPrev0);
					firstNew0->link(pendingTail0);
				}
			}

			if (toPrev1 == NULL)
			{
				pendingTail1->link(pendingHead1);
				c1->edges = pendingTail1;
			}
			else
			{
				for (Edge *e = toPrev1->next, *n = NULL; e != firstNew1; e = n)
				{
					n = e->next;
					removeEdgePair(e);
				}
				if (pendingTail1)
				{
					toPrev1->link(pendingHead1);
					pendingTail1->link(firstNew1);
				}
			}

			return;
		}

		firstRun = false;
	}
}

class pointCmp
{
public:
	bool operator()(const btConvexHullInternal::Point32& p, const btConvexHullInternal::Point32& q) const
	{
		return (p.y < q.y) || ((p.y == q.y) && ((p.x < q.x) || ((p.x == q.x) && (p.z < q.z))));
	}
};

void btConvexHullInternal::compute(const void* coords, bool doubleCoords, int stride, int count)
{
	btVector3 min(btScalar(1e30), btScalar(1e30), btScalar(1e30)), max(btScalar(-1e30), btScalar(-1e30), btScalar(-1e30));
	const char* ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}

	btVector3 s = max - min;
	maxAxis = s.maxAxis();
	minAxis = s.minAxis();
	if (minAxis == maxAxis)
	{
		minAxis = (maxAxis + 1) % 3;
	}
	medAxis = 3 - maxAxis - minAxis;

	s /= btScalar(10216);
	if (((medAxis + 1) % 3) != maxAxis)
	{
		s *= -1;
	}
	scaling = s;

	if (s[0] != 0)
	{
		s[0] = btScalar(1) / s[0];
	}
	if (s[1] != 0)
	{
		s[1] = btScalar(1) / s[1];
	}
	if (s[2] != 0)
	{
		s[2] = btScalar(1) / s[2];
	}

	center = (min + max) * btScalar(0.5);

	btAlignedObjectArray<Point32> points;
	points.resize(count);
	ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	points.quickSort(pointCmp());

	vertexPool.reset();
	vertexPool.setArraySize(count);
	originalVertices.resize(count);
	for (int i = 0; i < count; i++)
	{
		Vertex* v = vertexPool.newObject();
		v->edges = NULL;
		v->point = points[i];
		v->copy = -1;
		originalVertices[i] = v;
	}

	points.clear();

	edgePool.reset();
	edgePool.setArraySize(6 * count);

	usedEdgePairs = 0;
	maxUsedEdgePairs = 0;

	mergeStamp = -3;

	IntermediateHull hull;
	computeInternal(0, count, hull);
	vertexList = hull.minXy;
#ifdef DEBUG_CONVEX_HULL
	printf("max. edges %d (3v = %d)", maxUsedEdgePairs, 3 * count);
#endif
}

btVector3 btConvexHullInternal::toBtVector(const Point32& v)
{
	btVector3 p;
	p[medAxis] = btScalar(v.x);
	p[maxAxis] = btScalar(v.y);
	p[minAxis] = btScalar(v.z);
	return p * scaling;
}

btVector3 btConvexHullInternal::getBtNormal(Face* face)
{
	return toBtVector(face->dir0).cross(toBtVector(face->dir1)).normalized();
}

btVector3 btConvexHullInternal::getCoordinates(const Vertex* v)
{
	btVector3 p;
	p[medAxis] = v->xvalue();
	p[maxAxis] = v->yvalue();
	p[minAxis] = v->zvalue();
	return p * scaling + center;
}

btScalar btConvexHullInternal::shrink(btScalar amount, btScalar clampAmount)
{
	if (!vertexList)
	{
		return 0;
	}
	int stamp = --mergeStamp;
	btAlignedObjectArray<Vertex*> stack;
	vertexList->copy = stamp;
	stack.push_back(vertexList);
	btAlignedObjectArray<Face*> faces;

	Point32 ref = vertexList->point;
	Int128 hullCenterX(0, 0);
	Int128 hullCenterY(0, 0);
	Int128 hullCenterZ(0, 0);
	Int128 volume(0, 0);

	while (stack.size() > 0)
	{
		Vertex* v = stack[stack.size() - 1];
		stack.pop_back();
		Edge* e = v->edges;
		if (e)
		{
			do
			{
				if (e->target->copy != stamp)
				{
					e->target->copy = stamp;
					stack.push_back(e->target);
				}
				if (e->copy != stamp)
				{
					Face* face = facePool.newObject();
					face->init(e->target, e->reverse->prev->target, v);
					faces.push_back(face);
					Edge* f = e;

					Vertex* a = NULL;
					Vertex* b = NULL;
					do
					{
						if (a && b)
						{
							int64_t vol = (v->point - ref).dot((a->point - ref).cross(b->point - ref));
							btAssert(vol >= 0);
							Point32 c = v->point + a->point + b->point + ref;
							hullCenterX += vol * c.x;
							hullCenterY += vol * c.y;
							hullCenterZ += vol * c.z;
							volume += vol;
						}

						btAssert(f->copy != stamp);
						f->copy = stamp;
						f->face = face;

						a = b;
						b = f->target;

						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != v->edges);
		}
	}

	if (volume.getSign() <= 0)
	{
		return 0;
	}

	btVector3 hullCenter;
	hullCenter[medAxis] = hullCenterX.toScalar();
	hullCenter[maxAxis] = hullCenterY.toScalar();
	hullCenter[minAxis] = hullCenterZ.toScalar();
	hullCenter /= 4 * volume.toScalar();
	hullCenter *= scaling;

	int faceCount = faces.size();

	if (clampAmount > 0)
	{
		btScalar minDist = SIMD_INFINITY;
		for (int i = 0; i < faceCount; i++)
		{
			btVector3 normal = getBtNormal(faces[i]);
			btScalar dist = normal.dot(toBtVector(faces[i]->origin) - hullCenter);
			if (dist < minDist)
			{
				minDist = dist;
			}
		}

		if (minDist <= 0)
		{
			return 0;
		}

		amount = btMin(amount, minDist * clampAmount);
	}

	unsigned int seed = 243703;
	for (int i = 0; i < faceCount; i++, seed = 1664525 * seed + 1013904223)
	{
		btSwap(faces[i], faces[seed % faceCount]);
	}

	for (int i = 0; i < faceCount; i++)
	{
		if (!shiftFace(faces[i], amount, stack))
		{
			return -amount;
		}
	}

	return amount;
}

bool btConvexHullInternal::shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack)
{
	btVector3 origShift = getBtNormal(face) * -amount;
	if (scaling[0] != 0)
	{
		origShift[0] /= scaling[0];
	}
	if (scaling[1] != 0)
	{
		origShift[1] /= scaling[1];
	}
	if (scaling[2] != 0)
	{
		origShift[2] /= scaling[2];
	}
	Point32 shift((int32_t)origShift[medAxis], (int32_t)origShift[maxAxis], (int32_t)origShift[minAxis]);
	if (shift.isZero())
	{
		return true;
	}
	Point64 normal = face->getNormal();
#ifdef DEBUG_CONVEX_HULL
	printf("\nShrinking face (%d %d %d) (%d %d %d) (%d %d %d) by (%d %d %d)\n",
		   face->origin.x, face->origin.y, face->origin.z, face->dir0.x, face->dir0.y, face->dir0.z, face->dir1.x, face->dir1.y, face->dir1.z, shift.x, shift.y, shift.z);
#endif
	int64_t origDot = face->origin.dot(normal);
	Point32 shiftedOrigin = face->origin + shift;
	int64_t shiftedDot = shiftedOrigin.dot(normal);
	btAssert(shiftedDot <= origDot);
	if (shiftedDot >= origDot)
	{
		return false;
	}

	Edge* intersection = NULL;

	Edge* startEdge = face->nearbyVertex->edges;
#ifdef DEBUG_CONVEX_HULL
	printf("Start edge is ");
	startEdge->print();
	printf(", normal is (%lld %lld %lld), shifted dot is %lld\n", normal.x, normal.y, normal.z, shiftedDot);
#endif
	Rational128 optDot = face->nearbyVertex->dot(normal);
	int cmp = optDot.compare(shiftedDot);
#ifdef SHOW_ITERATIONS
	int n = 0;
#endif
	if (cmp >= 0)
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving downwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) < 0)
			{
				int c = dot.compare(shiftedDot);
				optDot = dot;
				e = e->reverse;
				startEdge = e;
				if (c < 0)
				{
					intersection = e;
					break;
				}
				cmp = c;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return false;
		}
	}
	else
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving upwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) > 0)
			{
				cmp = dot.compare(shiftedDot);
				if (cmp >= 0)
				{
					intersection = e;
					break;
				}
				optDot = dot;
				e = e->reverse;
				startEdge = e;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return true;
		}
	}

#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to find initial intersection\n", n);
#endif

	if (cmp == 0)
	{
		Edge* e = intersection->reverse->next;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (e->target->dot(normal).compare(shiftedDot) <= 0)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->next;
			if (e == intersection->reverse)
			{
				return true;
			}
#ifdef DEBUG_CONVEX_HULL
			printf("Checking for outwards edge, current edge is ");
			e->print();
			printf("\n");
#endif
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to check for complete containment\n", n);
#endif
	}

	Edge* firstIntersection = NULL;
	Edge* faceEdge = NULL;
	Edge* firstFaceEdge = NULL;

#ifdef SHOW_ITERATIONS
	int m = 0;
#endif
	while (true)
	{
#ifdef SHOW_ITERATIONS
		m++;
#endif
#ifdef DEBUG_CONVEX_HULL
		printf("Intersecting edge is ");
		intersection->print();
		printf("\n");
#endif
		if (cmp == 0)
		{
			Edge* e = intersection->reverse->next;
			startEdge = e;
#ifdef SHOW_ITERATIONS
			n = 0;
#endif
			while (true)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				if (e->target->dot(normal).compare(shiftedDot) >= 0)
				{
					break;
				}
				intersection = e->reverse;
				e = e->next;
				if (e == startEdge)
				{
					return true;
				}
			}
#ifdef SHOW_ITERATIONS
			printf("Needed %d iterations to advance intersection\n", n);
#endif
		}

#ifdef DEBUG_CONVEX_HULL
		printf("Advanced intersecting edge to ");
		intersection->print();
		printf(", cmp = %d\n", cmp);
#endif

		if (!firstIntersection)
		{
			firstIntersection = intersection;
		}
		else if (intersection == firstIntersection)
		{
			break;
		}

		int prevCmp = cmp;
		Edge* prevIntersection = intersection;
		Edge* prevFaceEdge = faceEdge;

		Edge* e = intersection->reverse;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (true)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->reverse->prev;
			btAssert(e != intersection->reverse);
			cmp = e->target->dot(normal).compare(shiftedDot);
#ifdef DEBUG_CONVEX_HULL
			printf("Testing edge ");
			e->print();
			printf(" -> cmp = %d\n", cmp);
#endif
			if (cmp >= 0)
			{
				intersection = e;
				break;
			}
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to find other intersection of face\n", n);
#endif

		if (cmp > 0)
		{
			Vertex* removed = intersection->target;
			e = intersection->reverse;
			if (e->prev == e)
			{
				removed->edges = NULL;
			}
			else
			{
				removed->edges = e->prev;
				e->prev->link(e->next);
				e->link(e);
			}
#ifdef DEBUG_CONVEX_HULL
			printf("1: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif

			Point64 n0 = intersection->face->getNormal();
			Point64 n1 = intersection->reverse->face->getNormal();
			int64_t m00 = face->dir0.dot(n0);
			int64_t m01 = face->dir1.dot(n0);
			int64_t m10 = face->dir0.dot(n1);
			int64_t m11 = face->dir1.dot(n1);
			int64_t r0 = (intersection->face->origin - shiftedOrigin).dot(n0);
			int64_t r1 = (intersection->reverse->face->origin - shiftedOrigin).dot(n1);
			Int128 det = Int128::mul(m00, m11) - Int128::mul(m01, m10);
			btAssert(det.getSign() != 0);
			Vertex* v = vertexPool.newObject();
			v->point.index = -1;
			v->copy = -1;
			v->point128 = PointR128(Int128::mul(face->dir0.x * r0, m11) - Int128::mul(face->dir0.x * r1, m01) + Int128::mul(face->dir1.x * r1, m00) - Int128::mul(face->dir1.x * r0, m10) + det * shiftedOrigin.x,
									Int128::mul(face->dir0.y * r0, m11) - Int128::mul(face->dir0.y * r1, m01) + Int128::mul(face->dir1.y * r1, m00) - Int128::mul(face->dir1.y * r0, m10) + det * shiftedOrigin.y,
									Int128::mul(face->dir0.z * r0, m11) - Int128::mul(face->dir0.z * r1, m01) + Int128::mul(face->dir1.z * r1, m00) - Int128::mul(face->dir1.z * r0, m10) + det * shiftedOrigin.z,
									det);
			v->point.x = (int32_t)v->point128.xvalue();
			v->point.y = (int32_t)v->point128.yvalue();
			v->point.z = (int32_t)v->point128.zvalue();
			intersection->target = v;
			v->edges = e;

			stack.push_back(v);
			stack.push_back(removed);
			stack.push_back(NULL);
		}

		if (cmp || prevCmp || (prevIntersection->reverse->next->target != intersection->target))
		{
			faceEdge = newEdgePair(prevIntersection->target, intersection->target);
			if (prevCmp == 0)
			{
				faceEdge->link(prevIntersection->reverse->next);
			}
			if ((prevCmp == 0) || prevFaceEdge)
			{
				prevIntersection->reverse->link(faceEdge);
			}
			if (cmp == 0)
			{
				intersection->reverse->prev->link(faceEdge->reverse);
			}
			faceEdge->reverse->link(intersection->reverse);
		}
		else
		{
			faceEdge = prevIntersection->reverse->next;
		}

		if (prevFaceEdge)
		{
			if (prevCmp > 0)
			{
				faceEdge->link(prevFaceEdge->reverse);
			}
			else if (faceEdge != prevFaceEdge->reverse)
			{
				stack.push_back(prevFaceEdge->target);
				while (faceEdge->next != prevFaceEdge->reverse)
				{
					Vertex* removed = faceEdge->next->target;
					removeEdgePair(faceEdge->next);
					stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
					printf("2: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
				}
				stack.push_back(NULL);
			}
		}
		faceEdge->face = face;
		faceEdge->reverse->face = intersection->face;

		if (!firstFaceEdge)
		{
			firstFaceEdge = faceEdge;
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to process all intersections\n", m);
#endif

	if (cmp > 0)
	{
		firstFaceEdge->reverse->target = faceEdge->target;
		firstIntersection->reverse->link(firstFaceEdge);
		firstFaceEdge->link(faceEdge->reverse);
	}
	else if (firstFaceEdge != faceEdge->reverse)
	{
		stack.push_back(faceEdge->target);
		while (firstFaceEdge->next != faceEdge->reverse)
		{
			Vertex* removed = firstFaceEdge->next->target;
			removeEdgePair(firstFaceEdge->next);
			stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
			printf("3: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
		}
		stack.push_back(NULL);
	}

	btAssert(stack.size() > 0);
	vertexList = stack[0];

#ifdef DEBUG_CONVEX_HULL
	printf("Removing part\n");
#endif
#ifdef SHOW_ITERATIONS
	n = 0;
#endif
	int pos = 0;
	while (pos < stack.size())
	{
		int end = stack.size();
		while (pos < end)
		{
			Vertex* kept = stack[pos++];
#ifdef DEBUG_CONVEX_HULL
			kept->print();
#endif
			bool deeper = false;
			Vertex* removed;
			while ((removed = stack[pos++]) != NULL)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				kept->receiveNearbyFaces(removed);
				while (removed->edges)
				{
					if (!deeper)
					{
						deeper = true;
						stack.push_back(kept);
					}
					stack.push_back(removed->edges->target);
					removeEdgePair(removed->edges);
				}
			}
			if (deeper)
			{
				stack.push_back(NULL);
			}
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to remove part\n", n);
#endif

	stack.resize(0);
	face->origin = shiftedOrigin;

	return true;
}

static int getVertexCopy(btConvexHullInternal::Vertex* vertex, btAlignedObjectArray<btConvexHullInternal::Vertex*>& vertices)
{
	int index = vertex->copy;
	if (index < 0)
	{
		index = vertices.size();
		vertex->copy = index;
		vertices.push_back(vertex);
#ifdef DEBUG_CONVEX_HULL
		printf("Vertex %d gets index *%d\n", vertex->point.index, index);
#endif
	}
	return index;
}

btScalar btConvexHullComputer::compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
{
	if (count <= 0)
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return 0;
	}

	btConvexHullInternal hull;
	hull.compute(coords, doubleCoords, stride, count);

	btScalar shift = 0;
	if ((shrink > 0) && ((shift = hull.shrink(shrink, shrinkClamp)) < 0))
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return shift;
	}

	vertices.resize(0);
	original_vertex_index.resize(0);
	edges.resize(0);
	faces.resize(0);

	btAlignedObjectArray<btConvexHullInternal::Vertex*> oldVertices;
	getVertexCopy(hull.vertexList, oldVertices);
	int copied = 0;
	while (copied < oldVertices.size())
	{
		btConvexHullInternal::Vertex* v = oldVertices[copied];
		vertices.push_back(hull.getCoordinates(v));
		original_vertex_index.push_back(v->point.index);
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			int firstCopy = -1;
			int prevCopy = -1;
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy < 0)
				{
					int s = edges.size();
					edges.push_back(Edge());
					edges.push_back(Edge());
					Edge* c = &edges[s];
					Edge* r = &edges[s + 1];
					e->copy = s;
					e->reverse->copy = s + 1;
					c->reverse = 1;
					r->reverse = -1;
					c->targetVertex = getVertexCopy(e->target, oldVertices);
					r->targetVertex = copied;
#ifdef DEBUG_CONVEX_HULL
					printf("      CREATE: Vertex *%d has edge to *%d\n", copied, c->getTargetVertex());
#endif
				}
				if (prevCopy >= 0)
				{
					edges[e->copy].next = prevCopy - e->copy;
				}
				else
				{
					firstCopy = e->copy;
				}
				prevCopy = e->copy;
				e = e->next;
			} while (e != firstEdge);
			edges[firstCopy].next = prevCopy - firstCopy;
		}
		copied++;
	}

	for (int i = 0; i < copied; i++)
	{
		btConvexHullInternal::Vertex* v = oldVertices[i];
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy >= 0)
				{
#ifdef DEBUG_CONVEX_HULL
					printf("Vertex *%d has edge to *%d\n", i, edges[e->copy].getTargetVertex());
#endif
					faces.push_back(e->copy);
					btConvexHullInternal::Edge* f = e;
					do
					{
#ifdef DEBUG_CONVEX_HULL
						printf("   Face *%d\n", edges[f->copy].getTargetVertex());
#endif
						f->copy = -1;
						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != firstEdge);
		}
	}

	return shift;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBJECT_ARRAY__
#define BT_OBJECT_ARRAY__

#include "LinearMath/btScalar.h"
#include "LinearMath/btAlignedAllocator.h"

///If the platform doesn't support placement new, you can disable BT_USE_PLACEMENT_NEW
///then the btAlignedObjectArray doesn't support objects with virtual methods, and non-trivial constructors/destructors
///You can enable BT_USE_MEMCPY, then swapping elements in the array will use memcpy instead of operator=
///see discussion here: https://bulletphysics.orgphpBB2/viewtopic.php?t=1231 and
///http://www.continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=1240

#define BT_USE_PLACEMENT_NEW 1
//#define BT_USE_MEMCPY 1 //disable, because it is cumbersome to find out for each platform where memcpy is defined. It can be in <memory.h> or <string.h> or otherwise...
#define BT_ALLOW_ARRAY_COPY_OPERATOR  // enabling this can accidently perform deep copies of data if you are not careful

#ifdef BT_USE_MEMCPY
#endif  //BT_USE_MEMCPY

#ifdef BT_USE_PLACEMENT_NEW
#endif          //BT_USE_PLACEMENT_NEW

///The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
///It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
template <typename T>
//template <class T>
class btAlignedObjectArray
{
	btAlignedAllocator<T, 16> m_allocator;

	int m_size;
	int m_capacity;
	T* m_data;
	//PCK: added this line
	bool m_ownsMemory;

#ifdef BT_ALLOW_ARRAY_COPY_OPERATOR
public:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other)
	{
		copyFromArray(other);
		return *this;
	}
#else   //BT_ALLOW_ARRAY_COPY_OPERATOR
private:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other);
#endif  //BT_ALLOW_ARRAY_COPY_OPERATOR

protected:
	SIMD_FORCE_INLINE int allocSize(int size)
	{
		return (size ? size * 2 : 1);
	}
	SIMD_FORCE_INLINE void copy(int start, int end, T* dest) const
	{
		int i;
		for (i = start; i < end; ++i)
#ifdef BT_USE_PLACEMENT_NEW
			new (&dest[i]) T(m_data[i]);
#else
			dest[i] = m_data[i];
#endif  //BT_USE_PLACEMENT_NEW
	}

	SIMD_FORCE_INLINE void init()
	{
		//PCK: added this line
		m_ownsMemory = true;
		m_data = 0;
		m_size = 0;
		m_capacity = 0;
	}
	SIMD_FORCE_INLINE void destroy(int first, int last)
	{
		int i;
		for (i = first; i < last; i++)
		{
			m_data[i].~T();
		}
	}

	SIMD_FORCE_INLINE void* allocate(int size)
	{
		if (size)
			return m_allocator.allocate(size);
		return 0;
	}

	SIMD_FORCE_INLINE void deallocate()
	{
		if (m_data)
		{
			//PCK: enclosed the deallocation in this block
			if (m_ownsMemory)
			{
				m_allocator.deallocate(m_data);
			}
			m_data = 0;
		}
	}

public:
	btAlignedObjectArray()
	{
		init();
	}

	~btAlignedObjectArray()
	{
		clear();
	}

	///Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead.
	btAlignedObjectArray(const btAlignedObjectArray& otherArray)
	{
		init();

		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}

	/// return the number of elements in the array
	SIMD_FORCE_INLINE int size() const
	{
		return m_size;
	}

	SIMD_FORCE_INLINE const T& at(int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& at(int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE const T& operator[](int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& operator[](int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	///clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void clear()
	{
		destroy(0, size());

		deallocate();

		init();
	}

	SIMD_FORCE_INLINE void pop_back()
	{
		btAssert(m_size > 0);
		m_size--;
		m_data[m_size].~T();
	}

	///resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	///when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void resizeNoInitialize(int newsize)
	{
		if (newsize > size())
		{
			reserve(newsize);
		}
		m_size = newsize;
	}

	SIMD_FORCE_INLINE void resize(int newsize, const T& fillData = T())
	{
		const int curSize = size();

		if (newsize < curSize)
		{
			for (int i = newsize; i < curSize; i++)
			{
				m_data[i].~T();
			}
		}
		else
		{
			if (newsize > curSize)
			{
				reserve(newsize);
			}
#ifdef BT_USE_PLACEMENT_NEW
			for (int i = curSize; i < newsize; i++)
			{
				new (&m_data[i]) T(fillData);
			}
#endif  //BT_USE_PLACEMENT_NEW
		}

		m_size = newsize;
	}
	SIMD_FORCE_INLINE T& expandNonInitializing()
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;

		return m_data[sz];
	}

	SIMD_FORCE_INLINE T& expand(const T& fillValue = T())
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;
#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[sz]) T(fillValue);  //use the in-place new (not really allocating heap memory)
#endif

		return m_data[sz];
	}

	SIMD_FORCE_INLINE void push_back(const T& _Val)
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}

#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[m_size]) T(_Val);
#else
		m_data[size()] = _Val;
#endif  //BT_USE_PLACEMENT_NEW

		m_size++;
	}

	/// return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve()
	SIMD_FORCE_INLINE int capacity() const
	{
		return m_capacity;
	}

	SIMD_FORCE_INLINE void reserve(int _Count)
	{  // determine new minimum length of allocated storage
		if (capacity() < _Count)
		{  // not enough room, reallocate
			T* s = (T*)allocate(_Count);

			copy(0, size(), s);

			destroy(0, size());

			deallocate();

			//PCK: added this line
			m_ownsMemory = true;

			m_data = s;

			m_capacity = _Count;
		}
	}

	class less
	{
	public:
		bool operator()(const T& a, const T& b) const
		{
			return (a < b);
		}
	};

	template <typename L>
	void quickSortInternal(const L& CompareFunc, int lo, int hi)
	{
		//  lo is the lower index, hi is the upper index
		//  of the region of array a that is to be sorted
		int i = lo, j = hi;
		T x = m_data[(lo + hi) / 2];

		//  partition
		do
		{
			while (CompareFunc(m_data[i], x))
				i++;
			while (CompareFunc(x, m_data[j]))
				j--;
			if (i <= j)
			{
				swap(i, j);
				i++;
				j--;
			}
		} while (i <= j);

		//  recursion
		if (lo < j)
			quickSortInternal(CompareFunc, lo, j);
		if (i < hi)
			quickSortInternal(CompareFunc, i, hi);
	}

	template <typename L>
	void quickSort(const L& CompareFunc)
	{
		//don't sort 0 or 1 elements
		if (size() > 1)
		{
			quickSortInternal(CompareFunc, 0, size() - 1);
		}
	}

	///heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/
	template <typename L>
	void downHeap(T* pArr, int k, int n, const L& CompareFunc)
	{
		/*  PRE: a[k+1..N] is a heap */
		/* POST:  a[k..N]  is a heap */

		T temp = pArr[k - 1];
		/* k has child(s) */
		while (k <= n / 2)
		{
			int child = 2 * k;

			if ((child < n) && CompareFunc(pArr[child - 1], pArr[child]))
			{
				child++;
			}
			/* pick larger child */
			if (CompareFunc(temp, pArr[child - 1]))
			{
				/* move child up */
				pArr[k - 1] = pArr[child - 1];
				k = child;
			}
			else
			{
				break;
			}
		}
		pArr[k - 1] = temp;
	} /*downHeap*/

	void swap(int index0, int index1)
	{
#ifdef BT_USE_MEMCPY
		char temp[sizeof(T)];
		memcpy(temp, &m_data[index0], sizeof(T));
		memcpy(&m_data[index0], &m_data[index1], sizeof(T));
		memcpy(&m_data[index1], temp, sizeof(T));
#else
		T temp = m_data[index0];
		m_data[index0] = m_data[index1];
		m_data[index1] = temp;
#endif  //BT_USE_PLACEMENT_NEW
	}

	template <typename L>
	void heapSort(const L& CompareFunc)
	{
		/* sort a[0..N-1],  N.B. 0 to N-1 */
		int k;
		int n = m_size;
		for (k = n / 2; k > 0; k--)
		{
			downHeap(m_data, k, n, CompareFunc);
		}

		/* a[1..N] is now a heap */
		while (n >= 1)
		{
			swap(0, n - 1); /* largest of a[0..n-1] */

			n = n - 1;
			/* restore a[1..i-1] heap */
			downHeap(m_data, 1, n, CompareFunc);
		}
	}

	///non-recursive binary search, assumes sorted array
	int findBinarySearch(const T& key) const
	{
		int first = 0;
		int last = size() - 1;

		//assume sorted array
		while (first <= last)
		{
			int mid = (first + last) / 2;  // compute mid point.
			if (key > m_data[mid])
				first = mid + 1;  // repeat search in top half.
			else if (key < m_data[mid])
				last = mid - 1;  // repeat search in bottom half.
			else
				return mid;  // found it. return position /////
		}
		return size();  // failed to find key
	}

	int findLinearSearch(const T& key) const
	{
		int index = size();
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	int findLinearSearch2(const T& key) const
	{
		int index = -1;
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	void removeAtIndex(int index)
	{
		if (index < size())
		{
			swap(index, size() - 1);
			pop_back();
		}
	}
	void remove(const T& key)
	{
		int findIndex = findLinearSearch(key);
		removeAtIndex(findIndex);
	}

	//PCK: whole function
	void initializeFromBuffer(void* buffer, int size, int capacity)
	{
		clear();
		m_ownsMemory = false;
		m_data = (T*)buffer;
		m_size = size;
		m_capacity = capacity;
	}

	void copyFromArray(const btAlignedObjectArray& otherArray)
	{
		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}
};

#endif  //BT_OBJECT_ARRAY__





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEOMETRY_UTIL_H
#define BT_GEOMETRY_UTIL_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

///The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
class btGeometryUtil
{
public:
	static void getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut);

	static void getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut);

	// static bool isInside(const btAlignedObjectArray<btVector3>& vertices, const btVector3& planeNormal, btScalar margin);

	static bool isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin);

	static bool areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin);
};

#endif  //BT_GEOMETRY_UTIL_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btGeometryUtil.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletMathProbe();

	void btBulletMathProbe() {}
}

bool btGeometryUtil::isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		btScalar dist = btScalar(N1.dot(point)) + btScalar(N1[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool btGeometryUtil::areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin)
{
	int numvertices = vertices.size();
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];
		btScalar dist = btScalar(planeNormal.dot(N1)) + btScalar(planeNormal[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations);

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		if (planeEquation.dot(N1) > btScalar(0.999))
		{
			return false;
		}
	}
	return true;
}

void btGeometryUtil::getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut)
{
	const int numvertices = vertices.size();
	// brute force:
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];

		for (int j = i + 1; j < numvertices; j++)
		{
			const btVector3& N2 = vertices[j];

			for (int k = j + 1; k < numvertices; k++)
			{
				const btVector3& N3 = vertices[k];

				btVector3 planeEquation, edge0, edge1;
				edge0 = N2 - N1;
				edge1 = N3 - N1;
				btScalar normalSign = btScalar(1.);
				for (int ww = 0; ww < 2; ww++)
				{
					planeEquation = normalSign * edge0.cross(edge1);
					if (planeEquation.length2() > btScalar(0.0001))
					{
						planeEquation.normalize();
						if (notExist(planeEquation, planeEquationsOut))
						{
							planeEquation[3] = -planeEquation.dot(N1);

							//check if inside, and replace supportingVertexOut if needed
							if (areVerticesBehindPlane(planeEquation, vertices, btScalar(0.01)))
							{
								planeEquationsOut.push_back(planeEquation);
							}
						}
					}
					normalSign = btScalar(-1.);
				}
			}
		}
	}
}

void btGeometryUtil::getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut)
{
	const int numbrushes = planeEquations.size();
	// brute force:
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];

		for (int j = i + 1; j < numbrushes; j++)
		{
			const btVector3& N2 = planeEquations[j];

			for (int k = j + 1; k < numbrushes; k++)
			{
				const btVector3& N3 = planeEquations[k];

				btVector3 n2n3;
				n2n3 = N2.cross(N3);
				btVector3 n3n1;
				n3n1 = N3.cross(N1);
				btVector3 n1n2;
				n1n2 = N1.cross(N2);

				if ((n2n3.length2() > btScalar(0.0001)) &&
					(n3n1.length2() > btScalar(0.0001)) &&
					(n1n2.length2() > btScalar(0.0001)))
				{
					//point P out of 3 plane equations:

					//	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )
					//P =  -------------------------------------------------------------------------
					//   N1 . ( N2 * N3 )

					btScalar quotient = (N1.dot(n2n3));
					if (btFabs(quotient) > btScalar(0.000001))
					{
						quotient = btScalar(-1.) / quotient;
						n2n3 *= N1[3];
						n3n1 *= N2[3];
						n1n2 *= N3[3];
						btVector3 potentialVertex = n2n3;
						potentialVertex += n3n1;
						potentialVertex += n1n2;
						potentialVertex *= quotient;

						//check if inside, and replace supportingVertexOut if needed
						if (isPointInsidePlanes(planeEquations, potentialVertex, btScalar(0.01)))
						{
							verticesOut.push_back(potentialVertex);
						}
					}
				}
			}
		}
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans

#ifndef _BT_POLYHEDRAL_FEATURES_H
#define _BT_POLYHEDRAL_FEATURES_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btAlignedObjectArray.h"

#define TEST_INTERNAL_OBJECTS 1

struct btFace
{
	btAlignedObjectArray<int> m_indices;
	//	btAlignedObjectArray<int>	m_connectedFaces;
	btScalar m_plane[4];
};

ATTRIBUTE_ALIGNED16(class)
btConvexPolyhedron
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexPolyhedron();
	virtual ~btConvexPolyhedron();

	btAlignedObjectArray<btVector3> m_vertices;
	btAlignedObjectArray<btFace> m_faces;
	btAlignedObjectArray<btVector3> m_uniqueEdges;

	btVector3 m_localCenter;
	btVector3 m_extents;
	btScalar m_radius;
	btVector3 mC;
	btVector3 mE;

	void initialize();
	void initialize2();
	bool testContainment() const;

	void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;
};

#endif  //_BT_POLYHEDRAL_FEATURES_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_HASH_MAP_H
#define BT_HASH_MAP_H

#include "LinearMath/btAlignedObjectArray.h"

///very basic hashable string implementation, compatible with btHashMap
struct btHashString
{
	std::string m_string1;
	unsigned int m_hash;

	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		return m_hash;
	}

	btHashString()
	{
		m_string1 = "";
		m_hash = 0;
	}
	btHashString(const char* name)
		: m_string1(name)
	{
		/* magic numbers from http://www.isthe.com/chongo/tech/comp/fnv/ */
		static const unsigned int InitialFNV = 2166136261u;
		static const unsigned int FNVMultiple = 16777619u;

		/* Fowler / Noll / Vo (FNV) Hash */
		unsigned int hash = InitialFNV;

		for (int i = 0; m_string1.c_str()[i]; i++)
		{
			hash = hash ^ (m_string1.c_str()[i]); /* xor  the low 8 bits */
			hash = hash * FNVMultiple;            /* multiply by the magic number */
		}
		m_hash = hash;
	}

	bool equals(const btHashString& other) const
	{
		return (m_string1 == other.m_string1);
	}
};

const int BT_HASH_NULL = 0xffffffff;

class btHashInt
{
	int m_uid;

public:
	btHashInt()
	{
	}

	btHashInt(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	void setUid1(int uid)
	{
		m_uid = uid;
	}

	bool equals(const btHashInt& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);

		return key;
	}
};

class btHashPtr
{
	union {
		const void* m_pointer;
		unsigned int m_hashValues[2];
	};

public:
	btHashPtr()
	{
	}

	btHashPtr(const void* ptr)
		: m_pointer(ptr)
	{
	}

	const void* getPointer() const
	{
		return m_pointer;
	}

	bool equals(const btHashPtr& other) const
	{
		return getPointer() == other.getPointer();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));

		unsigned int key = VOID_IS_8 ? m_hashValues[0] + m_hashValues[1] : m_hashValues[0];
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKeyPtr
{
	int m_uid;

public:
	btHashKeyPtr(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKeyPtr<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKey
{
	int m_uid;

public:
	btHashKey(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKey<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

///The btHashMap template class implements a generic and lightweight hashmap.
///A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
template <class Key, class Value>
class btHashMap
{
protected:
	btAlignedObjectArray<int> m_hashTable;
	btAlignedObjectArray<int> m_next;

	btAlignedObjectArray<Value> m_valueArray;
	btAlignedObjectArray<Key> m_keyArray;

	void growTables(const Key& /*key*/)
	{
		int newCapacity = m_valueArray.capacity();

		if (m_hashTable.size() < newCapacity)
		{
			//grow hashtable and next table
			int curHashtableSize = m_hashTable.size();

			m_hashTable.resize(newCapacity);
			m_next.resize(newCapacity);

			int i;

			for (i = 0; i < newCapacity; ++i)
			{
				m_hashTable[i] = BT_HASH_NULL;
			}
			for (i = 0; i < newCapacity; ++i)
			{
				m_next[i] = BT_HASH_NULL;
			}

			for (i = 0; i < curHashtableSize; i++)
			{
				//const Value& value = m_valueArray[i];
				//const Key& key = m_keyArray[i];

				int hashValue = m_keyArray[i].getHash() & (m_valueArray.capacity() - 1);  // New hash value with new mask
				m_next[i] = m_hashTable[hashValue];
				m_hashTable[hashValue] = i;
			}
		}
	}

public:
	void insert(const Key& key, const Value& value)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		//replace value if the key is already there
		int index = findIndex(key);
		if (index != BT_HASH_NULL)
		{
			m_valueArray[index] = value;
			return;
		}

		int count = m_valueArray.size();
		int oldCapacity = m_valueArray.capacity();
		m_valueArray.push_back(value);
		m_keyArray.push_back(key);

		int newCapacity = m_valueArray.capacity();
		if (oldCapacity < newCapacity)
		{
			growTables(key);
			//hash with new capacity
			hash = key.getHash() & (m_valueArray.capacity() - 1);
		}
		m_next[count] = m_hashTable[hash];
		m_hashTable[hash] = count;
	}

	void remove(const Key& key)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		int pairIndex = findIndex(key);

		if (pairIndex == BT_HASH_NULL)
		{
			return;
		}

		// Remove the pair from the hash table.
		int index = m_hashTable[hash];
		btAssert(index != BT_HASH_NULL);

		int previous = BT_HASH_NULL;
		while (index != pairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == pairIndex);
			m_next[previous] = m_next[pairIndex];
		}
		else
		{
			m_hashTable[hash] = m_next[pairIndex];
		}

		// We now move the last pair into spot of the
		// pair being removed. We need to fix the hash
		// table indices to support the move.

		int lastPairIndex = m_valueArray.size() - 1;

		// If the removed pair is the last pair, we are done.
		if (lastPairIndex == pairIndex)
		{
			m_valueArray.pop_back();
			m_keyArray.pop_back();
			return;
		}

		// Remove the last pair from the hash table.
		int lastHash = m_keyArray[lastPairIndex].getHash() & (m_valueArray.capacity() - 1);

		index = m_hashTable[lastHash];
		btAssert(index != BT_HASH_NULL);

		previous = BT_HASH_NULL;
		while (index != lastPairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == lastPairIndex);
			m_next[previous] = m_next[lastPairIndex];
		}
		else
		{
			m_hashTable[lastHash] = m_next[lastPairIndex];
		}

		// Copy the last pair into the remove pair's spot.
		m_valueArray[pairIndex] = m_valueArray[lastPairIndex];
		m_keyArray[pairIndex] = m_keyArray[lastPairIndex];

		// Insert the last pair into the hash table
		m_next[pairIndex] = m_hashTable[lastHash];
		m_hashTable[lastHash] = pairIndex;

		m_valueArray.pop_back();
		m_keyArray.pop_back();
	}

	int size() const
	{
		return m_valueArray.size();
	}

	const Value* getAtIndex(int index) const
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Value* getAtIndex(int index)
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Key getKeyAtIndex(int index)
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	const Key getKeyAtIndex(int index) const
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	Value* operator[](const Key& key)
	{
		return find(key);
	}

	const Value* operator[](const Key& key) const
	{
		return find(key);
	}

	const Value* find(const Key& key) const
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	Value* find(const Key& key)
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	int findIndex(const Key& key) const
	{
		unsigned int hash = key.getHash() & (m_valueArray.capacity() - 1);

		if (hash >= (unsigned int)m_hashTable.size())
		{
			return BT_HASH_NULL;
		}

		int index = m_hashTable[hash];
		while ((index != BT_HASH_NULL) && key.equals(m_keyArray[index]) == false)
		{
			index = m_next[index];
		}
		return index;
	}

	void clear()
	{
		m_hashTable.clear();
		m_next.clear();
		m_valueArray.clear();
		m_keyArray.clear();
	}
};

#endif  //BT_HASH_MAP_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs

#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btHashMap.h"

btConvexPolyhedron::btConvexPolyhedron()
{
}
btConvexPolyhedron::~btConvexPolyhedron()
{
}

inline bool IsAlmostZero1(const btVector3& v)
{
	if (btFabs(v.x()) > 1e-6 || btFabs(v.y()) > 1e-6 || btFabs(v.z()) > 1e-6) return false;
	return true;
}

struct btInternalVertexPair
{
	btInternalVertexPair(short int v0, short int v1)
		: m_v0(v0),
		  m_v1(v1)
	{
		if (m_v1 > m_v0)
			btSwap(m_v0, m_v1);
	}
	short int m_v0;
	short int m_v1;
	int getHash() const
	{
		return m_v0 + (m_v1 << 16);
	}
	bool equals(const btInternalVertexPair& other) const
	{
		return m_v0 == other.m_v0 && m_v1 == other.m_v1;
	}
};

struct btInternalEdge
{
	btInternalEdge()
		: m_face0(-1),
		  m_face1(-1)
	{
	}
	short int m_face0;
	short int m_face1;
};

//

#ifdef TEST_INTERNAL_OBJECTS
bool btConvexPolyhedron::testContainment() const
{
	for (int p = 0; p < 8; p++)
	{
		btVector3 LocalPt;
		if (p == 0)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 1)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 2)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 3)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], -m_extents[2]);
		else if (p == 4)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 5)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 6)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 7)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], -m_extents[2]);

		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar d = LocalPt.dot(Normal) + m_faces[i].m_plane[3];
			if (d > 0.0f)
				return false;
		}
	}
	return true;
}
#endif

void btConvexPolyhedron::initialize()
{
	btHashMap<btInternalVertexPair, btInternalEdge> edges;

	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices;
		for (int j = 0; j < NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btVector3 edge = m_vertices[vp.m_v1] - m_vertices[vp.m_v0];
			edge.normalize();

			bool found = false;

			for (int p = 0; p < m_uniqueEdges.size(); p++)
			{
				if (IsAlmostZero1(m_uniqueEdges[p] - edge) ||
					IsAlmostZero1(m_uniqueEdges[p] + edge))
				{
					found = true;
					break;
				}
			}

			if (!found)
			{
				m_uniqueEdges.push_back(edge);
			}

			if (edptr)
			{
				btAssert(edptr->m_face0 >= 0);
				btAssert(edptr->m_face1 < 0);
				edptr->m_face1 = i;
			}
			else
			{
				btInternalEdge ed;
				ed.m_face0 = i;
				edges.insert(vp, ed);
			}
		}
	}

#ifdef USE_CONNECTED_FACES
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		m_faces[i].m_connectedFaces.resize(numVertices);

		for (int j = 0; j < numVertices; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btAssert(edptr);
			btAssert(edptr->m_face0 >= 0);
			btAssert(edptr->m_face1 >= 0);

			int connectedFace = (edptr->m_face0 == i) ? edptr->m_face1 : edptr->m_face0;
			m_faces[i].m_connectedFaces[j] = connectedFace;
		}
	}
#endif  //USE_CONNECTED_FACES

	initialize2();
}

void btConvexPolyhedron::initialize2()
{
	m_localCenter.setValue(0, 0, 0);
	btScalar TotalArea = 0.0f;
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices - 2;

		const btVector3& p0 = m_vertices[m_faces[i].m_indices[0]];
		for (int j = 1; j <= NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			const btVector3& p1 = m_vertices[m_faces[i].m_indices[j]];
			const btVector3& p2 = m_vertices[m_faces[i].m_indices[k]];
			btScalar Area = ((p0 - p1).cross(p0 - p2)).length() * 0.5f;
			btVector3 Center = (p0 + p1 + p2) / 3.0f;
			m_localCenter += Area * Center;
			TotalArea += Area;
		}
	}
	m_localCenter /= TotalArea;

#ifdef TEST_INTERNAL_OBJECTS
	if (1)
	{
		m_radius = FLT_MAX;
		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar dist = btFabs(m_localCenter.dot(Normal) + m_faces[i].m_plane[3]);
			if (dist < m_radius)
				m_radius = dist;
		}

		btScalar MinX = FLT_MAX;
		btScalar MinY = FLT_MAX;
		btScalar MinZ = FLT_MAX;
		btScalar MaxX = -FLT_MAX;
		btScalar MaxY = -FLT_MAX;
		btScalar MaxZ = -FLT_MAX;
		for (int i = 0; i < m_vertices.size(); i++)
		{
			const btVector3& pt = m_vertices[i];
			if (pt.x() < MinX) MinX = pt.x();
			if (pt.x() > MaxX) MaxX = pt.x();
			if (pt.y() < MinY) MinY = pt.y();
			if (pt.y() > MaxY) MaxY = pt.y();
			if (pt.z() < MinZ) MinZ = pt.z();
			if (pt.z() > MaxZ) MaxZ = pt.z();
		}
		mC.setValue(MaxX + MinX, MaxY + MinY, MaxZ + MinZ);
		mE.setValue(MaxX - MinX, MaxY - MinY, MaxZ - MinZ);

		//		const btScalar r = m_radius / sqrtf(2.0f);
		const btScalar r = m_radius / sqrtf(3.0f);
		const int LargestExtent = mE.maxAxis();
		const btScalar Step = (mE[LargestExtent] * 0.5f - r) / 1024.0f;
		m_extents[0] = m_extents[1] = m_extents[2] = r;
		m_extents[LargestExtent] = mE[LargestExtent] * 0.5f;
		bool FoundBox = false;
		for (int j = 0; j < 1024; j++)
		{
			if (testContainment())
			{
				FoundBox = true;
				break;
			}

			m_extents[LargestExtent] -= Step;
		}
		if (!FoundBox)
		{
			m_extents[0] = m_extents[1] = m_extents[2] = r;
		}
		else
		{
			// Refine the box
			const btScalar Step = (m_radius - r) / 1024.0f;
			const int e0 = (1 << LargestExtent) & 3;
			const int e1 = (1 << e0) & 3;

			for (int j = 0; j < 1024; j++)
			{
				const btScalar Saved0 = m_extents[e0];
				const btScalar Saved1 = m_extents[e1];
				m_extents[e0] += Step;
				m_extents[e1] += Step;

				if (!testContainment())
				{
					m_extents[e0] = Saved0;
					m_extents[e1] = Saved1;
					break;
				}
			}
		}
	}
#endif
}
void btConvexPolyhedron::project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	minProj = FLT_MAX;
	maxProj = -FLT_MAX;
	int numVerts = m_vertices.size();
	for (int i = 0; i < numVerts; i++)
	{
		btVector3 pt = trans * m_vertices[i];
		btScalar dp = pt.dot(dir);
		if (dp < minProj)
		{
			minProj = dp;
			witnesPtMin = pt;
		}
		if (dp > maxProj)
		{
			maxProj = dp;
			witnesPtMax = pt;
		}
	}
	if (minProj > maxProj)
	{
		btSwap(minProj, maxProj);
		btSwap(witnesPtMin, witnesPtMax);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_POLYHEDRAL_CONVEX_SHAPE_H
#define BT_POLYHEDRAL_CONVEX_SHAPE_H

#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
class btConvexPolyhedron;

///The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
ATTRIBUTE_ALIGNED16(class)
btPolyhedralConvexShape : public btConvexInternalShape
{
protected:
	btConvexPolyhedron* m_polyhedron;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btPolyhedralConvexShape();

	virtual ~btPolyhedralConvexShape();

	///optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
	///experimental/work-in-progress
	virtual bool initializePolyhedralFeatures(int shiftVerticesByMargin = 0);

	virtual void setPolyhedralFeatures(btConvexPolyhedron & polyhedron);

	const btConvexPolyhedron* getConvexPolyhedron() const
	{
		return m_polyhedron;
	}

	//brute force implementations

	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual int getNumVertices() const = 0;
	virtual int getNumEdges() const = 0;
	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const = 0;
	virtual void getVertex(int i, btVector3& vtx) const = 0;
	virtual int getNumPlanes() const = 0;
	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const = 0;
	//	virtual int getIndex(int i) const = 0 ;

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const = 0;
};

///The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
class btPolyhedralConvexAabbCachingShape : public btPolyhedralConvexShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

protected:
	btPolyhedralConvexAabbCachingShape();

public:
	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_POLYHEDRAL_CONVEX_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btGeometryUtil.h"
#include "LinearMath/btGrahamScan2dConvexHull.h"

btPolyhedralConvexShape::btPolyhedralConvexShape() : btConvexInternalShape(),
													 m_polyhedron(0)
{
}

btPolyhedralConvexShape::~btPolyhedralConvexShape()
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}
}

void btPolyhedralConvexShape::setPolyhedralFeatures(btConvexPolyhedron& polyhedron)
{
	if (m_polyhedron)
	{
		*m_polyhedron = polyhedron;
	}
	else
	{
		void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
		m_polyhedron = new (mem) btConvexPolyhedron(polyhedron);
	}
}

bool btPolyhedralConvexShape::initializePolyhedralFeatures(int shiftVerticesByMargin)
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}

	void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
	m_polyhedron = new (mem) btConvexPolyhedron;

	btAlignedObjectArray<btVector3> orgVertices;

	for (int i = 0; i < getNumVertices(); i++)
	{
		btVector3& newVertex = orgVertices.expand();
		getVertex(i, newVertex);
	}

	btConvexHullComputer conv;

	if (shiftVerticesByMargin)
	{
		btAlignedObjectArray<btVector3> planeEquations;
		btGeometryUtil::getPlaneEquationsFromVertices(orgVertices, planeEquations);

		btAlignedObjectArray<btVector3> shiftedPlaneEquations;
		for (int p = 0; p < planeEquations.size(); p++)
		{
			btVector3 plane = planeEquations[p];
			//	   btScalar margin = getMargin();
			plane[3] -= getMargin();
			shiftedPlaneEquations.push_back(plane);
		}

		btAlignedObjectArray<btVector3> tmpVertices;

		btGeometryUtil::getVerticesFromPlaneEquations(shiftedPlaneEquations, tmpVertices);

		conv.compute(&tmpVertices[0].getX(), sizeof(btVector3), tmpVertices.size(), 0.f, 0.f);
	}
	else
	{
		conv.compute(&orgVertices[0].getX(), sizeof(btVector3), orgVertices.size(), 0.f, 0.f);
	}

#ifndef BT_RECONSTRUCT_FACES

	int numVertices = conv.vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = conv.vertices[p];
	}

	int v0, v1;
	for (int j = 0; j < conv.faces.size(); j++)
	{
		btVector3 edges[3];
		int numEdges = 0;
		btFace combinedFace;
		const btConvexHullComputer::Edge* edge = &conv.edges[conv.faces[j]];
		v0 = edge->getSourceVertex();
		int prevVertex = v0;
		combinedFace.m_indices.push_back(v0);
		v1 = edge->getTargetVertex();
		while (v1 != v0)
		{
			btVector3 wa = conv.vertices[prevVertex];
			btVector3 wb = conv.vertices[v1];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			//face->addIndex(v1);
			combinedFace.m_indices.push_back(v1);
			edge = edge->getNextEdgeOfFace();
			prevVertex = v1;
			int v01 = edge->getSourceVertex();
			v1 = edge->getTargetVertex();
		}

		btAssert(combinedFace.m_indices.size() > 2);

		btVector3 faceNormal = edges[0].cross(edges[1]);
		faceNormal.normalize();

		btScalar planeEq = 1e30f;

		for (int v = 0; v < combinedFace.m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[combinedFace.m_indices[v]].dot(faceNormal);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		combinedFace.m_plane[0] = faceNormal.getX();
		combinedFace.m_plane[1] = faceNormal.getY();
		combinedFace.m_plane[2] = faceNormal.getZ();
		combinedFace.m_plane[3] = -planeEq;

		m_polyhedron->m_faces.push_back(combinedFace);
	}

#else  //BT_RECONSTRUCT_FACES

	btAlignedObjectArray<btVector3> faceNormals;
	int numFaces = conv.faces.size();
	faceNormals.resize(numFaces);
	btConvexHullComputer* convexUtil = &conv;

	btAlignedObjectArray<btFace> tmpFaces;
	tmpFaces.resize(numFaces);

	int numVertices = convexUtil->vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = convexUtil->vertices[p];
	}

	for (int i = 0; i < numFaces; i++)
	{
		int face = convexUtil->faces[i];
		//printf("face=%d\n",face);
		const btConvexHullComputer::Edge* firstEdge = &convexUtil->edges[face];
		const btConvexHullComputer::Edge* edge = firstEdge;

		btVector3 edges[3];
		int numEdges = 0;
		//compute face normals

		do
		{
			int src = edge->getSourceVertex();
			tmpFaces[i].m_indices.push_back(src);
			int targ = edge->getTargetVertex();
			btVector3 wa = convexUtil->vertices[src];

			btVector3 wb = convexUtil->vertices[targ];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			edge = edge->getNextEdgeOfFace();
		} while (edge != firstEdge);

		btScalar planeEq = 1e30f;

		if (numEdges == 2)
		{
			faceNormals[i] = edges[0].cross(edges[1]);
			faceNormals[i].normalize();
			tmpFaces[i].m_plane[0] = faceNormals[i].getX();
			tmpFaces[i].m_plane[1] = faceNormals[i].getY();
			tmpFaces[i].m_plane[2] = faceNormals[i].getZ();
			tmpFaces[i].m_plane[3] = planeEq;
		}
		else
		{
			btAssert(0);  //degenerate?
			faceNormals[i].setZero();
		}

		for (int v = 0; v < tmpFaces[i].m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[tmpFaces[i].m_indices[v]].dot(faceNormals[i]);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		tmpFaces[i].m_plane[3] = -planeEq;
	}

	//merge coplanar faces and copy them to m_polyhedron

	btScalar faceWeldThreshold = 0.999f;
	btAlignedObjectArray<int> todoFaces;
	for (int i = 0; i < tmpFaces.size(); i++)
		todoFaces.push_back(i);

	while (todoFaces.size())
	{
		btAlignedObjectArray<int> coplanarFaceGroup;
		int refFace = todoFaces[todoFaces.size() - 1];

		coplanarFaceGroup.push_back(refFace);
		btFace& faceA = tmpFaces[refFace];
		todoFaces.pop_back();

		btVector3 faceNormalA(faceA.m_plane[0], faceA.m_plane[1], faceA.m_plane[2]);
		for (int j = todoFaces.size() - 1; j >= 0; j--)
		{
			int i = todoFaces[j];
			btFace& faceB = tmpFaces[i];
			btVector3 faceNormalB(faceB.m_plane[0], faceB.m_plane[1], faceB.m_plane[2]);
			if (faceNormalA.dot(faceNormalB) > faceWeldThreshold)
			{
				coplanarFaceGroup.push_back(i);
				todoFaces.remove(i);
			}
		}

		bool did_merge = false;
		if (coplanarFaceGroup.size() > 1)
		{
			//do the merge: use Graham Scan 2d convex hull

			btAlignedObjectArray<GrahamVector3> orgpoints;
			btVector3 averageFaceNormal(0, 0, 0);

			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				//				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);

				btFace& face = tmpFaces[coplanarFaceGroup[i]];
				btVector3 faceNormal(face.m_plane[0], face.m_plane[1], face.m_plane[2]);
				averageFaceNormal += faceNormal;
				for (int f = 0; f < face.m_indices.size(); f++)
				{
					int orgIndex = face.m_indices[f];
					btVector3 pt = m_polyhedron->m_vertices[orgIndex];

					bool found = false;

					for (int i = 0; i < orgpoints.size(); i++)
					{
						//if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
						if (orgpoints[i].m_orgIndex == orgIndex)
						{
							found = true;
							break;
						}
					}
					if (!found)
						orgpoints.push_back(GrahamVector3(pt, orgIndex));
				}
			}

			btFace combinedFace;
			for (int i = 0; i < 4; i++)
				combinedFace.m_plane[i] = tmpFaces[coplanarFaceGroup[0]].m_plane[i];

			btAlignedObjectArray<GrahamVector3> hull;

			averageFaceNormal.normalize();
			GrahamScanConvexHull2D(orgpoints, hull, averageFaceNormal);

			for (int i = 0; i < hull.size(); i++)
			{
				combinedFace.m_indices.push_back(hull[i].m_orgIndex);
				for (int k = 0; k < orgpoints.size(); k++)
				{
					if (orgpoints[k].m_orgIndex == hull[i].m_orgIndex)
					{
						orgpoints[k].m_orgIndex = -1;  // invalidate...
						break;
					}
				}
			}

			// are there rejected vertices?
			bool reject_merge = false;

			for (int i = 0; i < orgpoints.size(); i++)
			{
				if (orgpoints[i].m_orgIndex == -1)
					continue;  // this is in the hull...
				// this vertex is rejected -- is anybody else using this vertex?
				for (int j = 0; j < tmpFaces.size(); j++)
				{
					btFace& face = tmpFaces[j];
					// is this a face of the current coplanar group?
					bool is_in_current_group = false;
					for (int k = 0; k < coplanarFaceGroup.size(); k++)
					{
						if (coplanarFaceGroup[k] == j)
						{
							is_in_current_group = true;
							break;
						}
					}
					if (is_in_current_group)  // ignore this face...
						continue;
					// does this face use this rejected vertex?
					for (int v = 0; v < face.m_indices.size(); v++)
					{
						if (face.m_indices[v] == orgpoints[i].m_orgIndex)
						{
							// this rejected vertex is used in another face -- reject merge
							reject_merge = true;
							break;
						}
					}
					if (reject_merge)
						break;
				}
				if (reject_merge)
					break;
			}

			if (!reject_merge)
			{
				// do this merge!
				did_merge = true;
				m_polyhedron->m_faces.push_back(combinedFace);
			}
		}
		if (!did_merge)
		{
			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				btFace face = tmpFaces[coplanarFaceGroup[i]];
				m_polyhedron->m_faces.push_back(face);
			}
		}
	}

#endif  //BT_RECONSTRUCT_FACES

	m_polyhedron->initialize();

	return true;
}

#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#endif

btVector3 btPolyhedralConvexShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);
#ifndef __SPU__
	int i;
	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	for (int k = 0; k < getNumVertices(); k += 128)
	{
		btVector3 temp[128];
		int inner_count = MIN(getNumVertices() - k, 128);
		for (i = 0; i < inner_count; i++)
			getVertex(i, temp[i]);
		i = (int)vec.maxDot(temp, inner_count, newDot);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = temp[i];
		}
	}

#endif  //__SPU__
	return supVec;
}

void btPolyhedralConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
#ifndef __SPU__
	int i;

	btVector3 vtx;
	btScalar newDot;

	for (i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
	}

	for (int j = 0; j < numVectors; j++)
	{
		const btVector3& vec = vectors[j];

		for (int k = 0; k < getNumVertices(); k += 128)
		{
			btVector3 temp[128];
			int inner_count = MIN(getNumVertices() - k, 128);
			for (i = 0; i < inner_count; i++)
				getVertex(i, temp[i]);
			i = (int)vec.maxDot(temp, inner_count, newDot);
			if (newDot > supportVerticesOut[j][3])
			{
				supportVerticesOut[j] = temp[i];
				supportVerticesOut[j][3] = newDot;
			}
		}
	}

#endif  //__SPU__
}

void btPolyhedralConvexShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
#ifndef __SPU__
	//not yet, return box inertia

	btScalar margin = getMargin();

	btTransform ident;
	ident.setIdentity();
	btVector3 aabbMin, aabbMax;
	getAabb(ident, aabbMin, aabbMax);
	btVector3 halfExtents = (aabbMax - aabbMin) * btScalar(0.5);

	btScalar lx = btScalar(2.) * (halfExtents.x() + margin);
	btScalar ly = btScalar(2.) * (halfExtents.y() + margin);
	btScalar lz = btScalar(2.) * (halfExtents.z() + margin);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(0.08333333);

	inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));
#endif  //__SPU__
}

void btPolyhedralConvexAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

btPolyhedralConvexAabbCachingShape::btPolyhedralConvexAabbCachingShape()
	: btPolyhedralConvexShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btPolyhedralConvexAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btPolyhedralConvexAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i];
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i];
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBB_BOX_MINKOWSKI_H
#define BT_OBB_BOX_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

///The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
ATTRIBUTE_ALIGNED16(class)
btBoxShape : public btPolyhedralConvexShape
{
	//btVector3	m_boxHalfExtents1; //use m_implicitShapeDimensions instead

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btVector3 getHalfExtentsWithMargin() const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;
		return halfExtents;
	}

	const btVector3& getHalfExtentsWithoutMargin() const
	{
		return m_implicitShapeDimensions;  //scaling is included, margin is not
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	SIMD_FORCE_INLINE btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		for (int i = 0; i < numVectors; i++)
		{
			const btVector3& vec = vectors[i];
			supportVerticesOut[i].setValue(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
										   btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
										   btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
		}
	}

	btBoxShape(const btVector3& boxHalfExtents);

	virtual void setMargin(btScalar collisionMargin)
	{
		//correct the m_implicitShapeDimensions for the margin
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;

		btConvexInternalShape::setMargin(collisionMargin);
		btVector3 newMargin(getMargin(), getMargin(), getMargin());
		m_implicitShapeDimensions = implicitShapeDimensionsWithMargin - newMargin;
	}
	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;
		btVector3 unScaledImplicitShapeDimensionsWithMargin = implicitShapeDimensionsWithMargin / m_localScaling;

		btConvexInternalShape::setLocalScaling(scaling);

		m_implicitShapeDimensions = (unScaledImplicitShapeDimensionsWithMargin * m_localScaling) - oldMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const
	{
		//this plane might not be aligned...
		btVector4 plane;
		getPlaneEquation(plane, i);
		planeNormal = btVector3(plane.getX(), plane.getY(), plane.getZ());
		planeSupport = localGetSupportingVertex(-planeNormal);
	}

	virtual int getNumPlanes() const
	{
		return 6;
	}

	virtual int getNumVertices() const
	{
		return 8;
	}

	virtual int getNumEdges() const
	{
		return 12;
	}

	virtual void getVertex(int i, btVector3& vtx) const
	{
		btVector3 halfExtents = getHalfExtentsWithMargin();

		vtx = btVector3(
			halfExtents.x() * (1 - (i & 1)) - halfExtents.x() * (i & 1),
			halfExtents.y() * (1 - ((i & 2) >> 1)) - halfExtents.y() * ((i & 2) >> 1),
			halfExtents.z() * (1 - ((i & 4) >> 2)) - halfExtents.z() * ((i & 4) >> 2));
	}

	virtual void getPlaneEquation(btVector4 & plane, int i) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		switch (i)
		{
			case 0:
				plane.setValue(btScalar(1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 1:
				plane.setValue(btScalar(-1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 2:
				plane.setValue(btScalar(0.), btScalar(1.), btScalar(0.), -halfExtents.y());
				break;
			case 3:
				plane.setValue(btScalar(0.), btScalar(-1.), btScalar(0.), -halfExtents.y());
				break;
			case 4:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(1.), -halfExtents.z());
				break;
			case 5:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(-1.), -halfExtents.z());
				break;
			default:
				btAssert(0);
		}
	}

	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const
	//virtual void getEdge(int i,Edge& edge) const
	{
		int edgeVert0 = 0;
		int edgeVert1 = 0;

		switch (i)
		{
			case 0:
				edgeVert0 = 0;
				edgeVert1 = 1;
				break;
			case 1:
				edgeVert0 = 0;
				edgeVert1 = 2;
				break;
			case 2:
				edgeVert0 = 1;
				edgeVert1 = 3;

				break;
			case 3:
				edgeVert0 = 2;
				edgeVert1 = 3;
				break;
			case 4:
				edgeVert0 = 0;
				edgeVert1 = 4;
				break;
			case 5:
				edgeVert0 = 1;
				edgeVert1 = 5;

				break;
			case 6:
				edgeVert0 = 2;
				edgeVert1 = 6;
				break;
			case 7:
				edgeVert0 = 3;
				edgeVert1 = 7;
				break;
			case 8:
				edgeVert0 = 4;
				edgeVert1 = 5;
				break;
			case 9:
				edgeVert0 = 4;
				edgeVert1 = 6;
				break;
			case 10:
				edgeVert0 = 5;
				edgeVert1 = 7;
				break;
			case 11:
				edgeVert0 = 6;
				edgeVert1 = 7;
				break;
			default:
				btAssert(0);
		}

		getVertex(edgeVert0, pa);
		getVertex(edgeVert1, pb);
	}

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		//btScalar minDist = 2*tolerance;

		bool result = (pt.x() <= (halfExtents.x() + tolerance)) &&
					  (pt.x() >= (-halfExtents.x() - tolerance)) &&
					  (pt.y() <= (halfExtents.y() + tolerance)) &&
					  (pt.y() >= (-halfExtents.y() - tolerance)) &&
					  (pt.z() <= (halfExtents.z() + tolerance)) &&
					  (pt.z() >= (-halfExtents.z() - tolerance));

		return result;
	}

	//debugging
	virtual const char* getName() const
	{
		return "Box";
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 6;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		switch (index)
		{
			case 0:
				penetrationVector.setValue(btScalar(1.), btScalar(0.), btScalar(0.));
				break;
			case 1:
				penetrationVector.setValue(btScalar(-1.), btScalar(0.), btScalar(0.));
				break;
			case 2:
				penetrationVector.setValue(btScalar(0.), btScalar(1.), btScalar(0.));
				break;
			case 3:
				penetrationVector.setValue(btScalar(0.), btScalar(-1.), btScalar(0.));
				break;
			case 4:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(1.));
				break;
			case 5:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(-1.));
				break;
			default:
				btAssert(0);
		}
	}
};

#endif  //BT_OBB_BOX_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btBoxShape.h"

btBoxShape::btBoxShape(const btVector3& boxHalfExtents)
	: btPolyhedralConvexShape()
{
	m_shapeType = BOX_SHAPE_PROXYTYPE;

	btVector3 margin(getMargin(), getMargin(), getMargin());
	m_implicitShapeDimensions = (boxHalfExtents * m_localScaling) - margin;

	setSafeMargin(boxHalfExtents);
};

void btBoxShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}

void btBoxShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//btScalar margin = btScalar(0.);
	btVector3 halfExtents = getHalfExtentsWithMargin();

	btScalar lx = btScalar(2.) * (halfExtents.x());
	btScalar ly = btScalar(2.) * (halfExtents.y());
	btScalar lz = btScalar(2.) * (halfExtents.z());

	inertia.setValue(mass / (btScalar(12.0)) * (ly * ly + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + ly * ly));
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CAPSULE_SHAPE_H
#define BT_CAPSULE_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
///The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
///The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
ATTRIBUTE_ALIGNED16(class)
btCapsuleShape : public btConvexInternalShape
{
protected:
	int m_upAxis;

protected:
	///only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.
	btCapsuleShape() : btConvexInternalShape() { m_shapeType = CAPSULE_SHAPE_PROXYTYPE; };

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCapsuleShape(btScalar radius, btScalar height);

	///CollisionShape Interface
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	/// btConvexShape Interface
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void setMargin(btScalar collisionMargin)
	{
		//don't override the margin for capsules, their entire radius == margin
		(void)collisionMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		btVector3 halfExtents(getRadius(), getRadius(), getRadius());
		halfExtents[m_upAxis] = getRadius() + getHalfHeight();
		btMatrix3x3 abs_b = t.getBasis().absolute();
		btVector3 center = t.getOrigin();
		btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

		aabbMin = center - extent;
		aabbMax = center + extent;
	}

	virtual const char* getName() const
	{
		return "CapsuleShape";
	}

	int getUpAxis() const
	{
		return m_upAxis;
	}

	btScalar getRadius() const
	{
		int radiusAxis = (m_upAxis + 2) % 3;
		return m_implicitShapeDimensions[radiusAxis];
	}

	btScalar getHalfHeight() const
	{
		return m_implicitShapeDimensions[m_upAxis];
	}

	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 unScaledImplicitShapeDimensions = m_implicitShapeDimensions / m_localScaling;
		btConvexInternalShape::setLocalScaling(scaling);
		m_implicitShapeDimensions = (unScaledImplicitShapeDimensions * scaling);
		//update m_collisionMargin, since entire radius==margin
		int radiusAxis = (m_upAxis + 2) % 3;
		m_collisionMargin = m_implicitShapeDimensions[radiusAxis];
	}

	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		btVector3 aniDir(0, 0, 0);
		aniDir[getUpAxis()] = 1;
		return aniDir;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	SIMD_FORCE_INLINE void deSerializeFloat(struct btCapsuleShapeData * dataBuffer);
};

///btCapsuleShapeX represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeX : public btCapsuleShape
{
public:
	btCapsuleShapeX(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleX";
	}
};

///btCapsuleShapeZ represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeZ : public btCapsuleShape
{
public:
	btCapsuleShapeZ(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleZ";
	}
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btCapsuleShapeData
{
	btConvexInternalShapeData m_convexInternalShapeData;

	int m_upAxis;

	char m_padding[4];
};

SIMD_FORCE_INLINE int btCapsuleShape::calculateSerializeBufferSize() const
{
	return sizeof(btCapsuleShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btCapsuleShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCapsuleShapeData* shapeData = (btCapsuleShapeData*)dataBuffer;

	btConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serializer);

	shapeData->m_upAxis = m_upAxis;

	// Fill padding with zeros to appease msan.
	shapeData->m_padding[0] = 0;
	shapeData->m_padding[1] = 0;
	shapeData->m_padding[2] = 0;
	shapeData->m_padding[3] = 0;

	return "btCapsuleShapeData";
}

SIMD_FORCE_INLINE void btCapsuleShape::deSerializeFloat(btCapsuleShapeData* dataBuffer)
{
	m_implicitShapeDimensions.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_implicitShapeDimensions);
	m_collisionMargin = dataBuffer->m_convexInternalShapeData.m_collisionMargin;
	m_localScaling.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_localScaling);
	//it is best to already pre-allocate the matching btCapsuleShape*(X/Z) version to match m_upAxis
	m_upAxis = dataBuffer->m_upAxis;
}

#endif  //BT_CAPSULE_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btCapsuleShape.h"

#include "LinearMath/btQuaternion.h"

btCapsuleShape::btCapsuleShape(btScalar radius, btScalar height) : btConvexInternalShape()
{
	m_collisionMargin = radius;
	m_shapeType = CAPSULE_SHAPE_PROXYTYPE;
	m_upAxis = 1;
	m_implicitShapeDimensions.setValue(radius, 0.5f * height, radius);
}

btVector3 btCapsuleShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);

	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}
	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = -getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}

	return supVec;
}

void btCapsuleShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	for (int j = 0; j < numVectors; j++)
	{
		btScalar maxDot(btScalar(-BT_LARGE_FLOAT));
		const btVector3& vec = vectors[j];

		btVector3 vtx;
		btScalar newDot;
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = -getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
	}
}

void btCapsuleShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//as an approximation, take the inertia of the box that bounds the spheres

	btTransform ident;
	ident.setIdentity();

	btScalar radius = getRadius();

	btVector3 halfExtents(radius, radius, radius);
	halfExtents[getUpAxis()] += getHalfHeight();

	btScalar lx = btScalar(2.) * (halfExtents[0]);
	btScalar ly = btScalar(2.) * (halfExtents[1]);
	btScalar lz = btScalar(2.) * (halfExtents[2]);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(.08333333);

	inertia[0] = scaledmass * (y2 + z2);
	inertia[1] = scaledmass * (x2 + z2);
	inertia[2] = scaledmass * (x2 + y2);
}

btCapsuleShapeX::btCapsuleShapeX(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 0;
	m_implicitShapeDimensions.setValue(0.5f * height, radius, radius);
}

btCapsuleShapeZ::btCapsuleShapeZ(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 2;
	m_implicitShapeDimensions.setValue(radius, radius, 0.5f * height);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_OBJECT_H
#define BT_COLLISION_OBJECT_H

#include "LinearMath/btTransform.h"

//island management, m_activationState1
#define ACTIVE_TAG 1
#define ISLAND_SLEEPING 2
#define WANTS_DEACTIVATION 3
#define DISABLE_DEACTIVATION 4
#define DISABLE_SIMULATION 5
#define FIXED_BASE_MULTI_BODY 6

struct btBroadphaseProxy;
class btCollisionShape;
struct btCollisionShapeData;
#include "LinearMath/btMotionState.h"
#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btAlignedObjectArray.h"

typedef btAlignedObjectArray<class btCollisionObject*> btCollisionObjectArray;

#ifdef BT_USE_DOUBLE_PRECISION
#define btCollisionObjectData btCollisionObjectDoubleData
#define btCollisionObjectDataName "btCollisionObjectDoubleData"
#else
#define btCollisionObjectData btCollisionObjectFloatData
#define btCollisionObjectDataName "btCollisionObjectFloatData"
#endif

/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
ATTRIBUTE_ALIGNED16(class)
btCollisionObject
{
protected:
	btTransform m_worldTransform;

	///m_interpolationWorldTransform is used for CCD and interpolation
	///it can be either previous or future (predicted) transform
	btTransform m_interpolationWorldTransform;
	//those two are experimental: just added for bullet time effect, so you can still apply impulses (directly modifying velocities)
	//without destroying the continuous interpolated motion (which uses this interpolation velocities)
	btVector3 m_interpolationLinearVelocity;
	btVector3 m_interpolationAngularVelocity;

	btVector3 m_anisotropicFriction;
	int m_hasAnisotropicFriction;
	btScalar m_contactProcessingThreshold;

	btBroadphaseProxy* m_broadphaseHandle;
	btCollisionShape* m_collisionShape;
	///m_extensionPointer is used by some internal low-level Bullet extensions.
	void* m_extensionPointer;

	///m_rootCollisionShape is temporarily used to store the original collision shape
	///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
	///If it is NULL, the m_collisionShape is not temporarily replaced.
	btCollisionShape* m_rootCollisionShape;

	int m_collisionFlags;

	int m_islandTag1;
	int m_companionId;
	int m_worldArrayIndex;  // index of object in world's collisionObjects array

	mutable int m_activationState1;
	mutable btScalar m_deactivationTime;

	btScalar m_friction;
	btScalar m_restitution;
	btScalar m_rollingFriction;   //torsional friction orthogonal to contact normal (useful to stop spheres rolling forever)
	btScalar m_spinningFriction;  // torsional friction around the contact normal (useful for grasping)
	btScalar m_contactDamping;
	btScalar m_contactStiffness;

	///m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
	///do not assign your own m_internalType unless you write a new dynamics object class.
	int m_internalType;

	///users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer

	void* m_userObjectPointer;

	int m_userIndex2;

	int m_userIndex;

	int m_userIndex3;

	///time of impact calculation
	btScalar m_hitFraction;

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar m_ccdSweptSphereRadius;

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	btScalar m_ccdMotionThreshold;

	/// If some object should have elaborate collision filtering by sub-classes
	int m_checkCollideWith;

	btAlignedObjectArray<const btCollisionObject*> m_objectsWithoutCollisionCheck;

	///internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
	int m_updateRevision;

	btVector3 m_customDebugColorRGB;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	enum CollisionFlags
	{
		CF_DYNAMIC_OBJECT = 0,
		CF_STATIC_OBJECT = 1,
		CF_KINEMATIC_OBJECT = 2,
		CF_NO_CONTACT_RESPONSE = 4,
		CF_CUSTOM_MATERIAL_CALLBACK = 8,  //this allows per-triangle material (friction/restitution)
		CF_CHARACTER_OBJECT = 16,
		CF_DISABLE_VISUALIZE_OBJECT = 32,          //disable debug drawing
		CF_DISABLE_SPU_COLLISION_PROCESSING = 64,  //disable parallel/SPU processing
		CF_HAS_CONTACT_STIFFNESS_DAMPING = 128,
		CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR = 256,
		CF_HAS_FRICTION_ANCHOR = 512,
		CF_HAS_COLLISION_SOUND_TRIGGER = 1024
	};

	enum CollisionObjectTypes
	{
		CO_COLLISION_OBJECT = 1,
		CO_RIGID_BODY = 2,
		///CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
		///It is useful for collision sensors, explosion objects, character controller etc.
		CO_GHOST_OBJECT = 4,
		CO_SOFT_BODY = 8,
		CO_HF_FLUID = 16,
		CO_USER_TYPE = 32,
		CO_FEATHERSTONE_LINK = 64
	};

	enum AnisotropicFrictionFlags
	{
		CF_ANISOTROPIC_FRICTION_DISABLED = 0,
		CF_ANISOTROPIC_FRICTION = 1,
		CF_ANISOTROPIC_ROLLING_FRICTION = 2
	};

	SIMD_FORCE_INLINE bool mergesSimulationIslands() const
	{
		///static objects, kinematic and object without contact response don't merge islands
		return ((m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT | CF_NO_CONTACT_RESPONSE)) == 0);
	}

	const btVector3& getAnisotropicFriction() const
	{
		return m_anisotropicFriction;
	}
	void setAnisotropicFriction(const btVector3& anisotropicFriction, int frictionMode = CF_ANISOTROPIC_FRICTION)
	{
		m_anisotropicFriction = anisotropicFriction;
		bool isUnity = (anisotropicFriction[0] != 1.f) || (anisotropicFriction[1] != 1.f) || (anisotropicFriction[2] != 1.f);
		m_hasAnisotropicFriction = isUnity ? frictionMode : 0;
	}
	bool hasAnisotropicFriction(int frictionMode = CF_ANISOTROPIC_FRICTION) const
	{
		return (m_hasAnisotropicFriction & frictionMode) != 0;
	}

	///the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
	///Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges
	void setContactProcessingThreshold(btScalar contactProcessingThreshold)
	{
		m_contactProcessingThreshold = contactProcessingThreshold;
	}
	btScalar getContactProcessingThreshold() const
	{
		return m_contactProcessingThreshold;
	}

	SIMD_FORCE_INLINE bool isStaticObject() const
	{
		return (m_collisionFlags & CF_STATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isKinematicObject() const
	{
		return (m_collisionFlags & CF_KINEMATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isStaticOrKinematicObject() const
	{
		return (m_collisionFlags & (CF_KINEMATIC_OBJECT | CF_STATIC_OBJECT)) != 0;
	}

	SIMD_FORCE_INLINE bool hasContactResponse() const
	{
		return (m_collisionFlags & CF_NO_CONTACT_RESPONSE) == 0;
	}

	btCollisionObject();

	virtual ~btCollisionObject();

	virtual void setCollisionShape(btCollisionShape * collisionShape)
	{
		m_updateRevision++;
		m_collisionShape = collisionShape;
		m_rootCollisionShape = collisionShape;
	}

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setIgnoreCollisionCheck(const btCollisionObject* co, bool ignoreCollisionCheck)
	{
		if (ignoreCollisionCheck)
		{
			//We don't check for duplicates. Is it ok to leave that up to the user of this API?
			//int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
			//if (index == m_objectsWithoutCollisionCheck.size())
			//{
			m_objectsWithoutCollisionCheck.push_back(co);
			//}
		}
		else
		{
			m_objectsWithoutCollisionCheck.remove(co);
		}
		m_checkCollideWith = m_objectsWithoutCollisionCheck.size() > 0;
	}

        int getNumObjectsWithoutCollision() const
	{
		return m_objectsWithoutCollisionCheck.size();
	}

	const btCollisionObject* getObjectWithoutCollision(int index)
	{
		return m_objectsWithoutCollisionCheck[index];
	}

	virtual bool checkCollideWithOverride(const btCollisionObject* co) const
	{
		int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
		if (index < m_objectsWithoutCollisionCheck.size())
		{
			return false;
		}
		return true;
	}

	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void* internalGetExtensionPointer() const
	{
		return m_extensionPointer;
	}
	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void internalSetExtensionPointer(void* pointer)
	{
		m_extensionPointer = pointer;
	}

	SIMD_FORCE_INLINE int getActivationState() const { return m_activationState1; }

	void setActivationState(int newState) const;

	void setDeactivationTime(btScalar time)
	{
		m_deactivationTime = time;
	}
	btScalar getDeactivationTime() const
	{
		return m_deactivationTime;
	}

	void forceActivationState(int newState) const;

	void activate(bool forceActivation = false) const;

	SIMD_FORCE_INLINE bool isActive() const
	{
		return ((getActivationState() != FIXED_BASE_MULTI_BODY) && (getActivationState() != ISLAND_SLEEPING) && (getActivationState() != DISABLE_SIMULATION));
	}

	void setRestitution(btScalar rest)
	{
		m_updateRevision++;
		m_restitution = rest;
	}
	btScalar getRestitution() const
	{
		return m_restitution;
	}
	void setFriction(btScalar frict)
	{
		m_updateRevision++;
		m_friction = frict;
	}
	btScalar getFriction() const
	{
		return m_friction;
	}

	void setRollingFriction(btScalar frict)
	{
		m_updateRevision++;
		m_rollingFriction = frict;
	}
	btScalar getRollingFriction() const
	{
		return m_rollingFriction;
	}
	void setSpinningFriction(btScalar frict)
	{
		m_updateRevision++;
		m_spinningFriction = frict;
	}
	btScalar getSpinningFriction() const
	{
		return m_spinningFriction;
	}
	void setContactStiffnessAndDamping(btScalar stiffness, btScalar damping)
	{
		m_updateRevision++;
		m_contactStiffness = stiffness;
		m_contactDamping = damping;

		m_collisionFlags |= CF_HAS_CONTACT_STIFFNESS_DAMPING;

		//avoid divisions by zero...
		if (m_contactStiffness < SIMD_EPSILON)
		{
			m_contactStiffness = SIMD_EPSILON;
		}
	}

	btScalar getContactStiffness() const
	{
		return m_contactStiffness;
	}

	btScalar getContactDamping() const
	{
		return m_contactDamping;
	}

	///reserved for Bullet internal usage
	int getInternalType() const
	{
		return m_internalType;
	}

	btTransform& getWorldTransform()
	{
		return m_worldTransform;
	}

	const btTransform& getWorldTransform() const
	{
		return m_worldTransform;
	}

	void setWorldTransform(const btTransform& worldTrans)
	{
		m_updateRevision++;
		m_worldTransform = worldTrans;
	}

	SIMD_FORCE_INLINE btBroadphaseProxy* getBroadphaseHandle()
	{
		return m_broadphaseHandle;
	}

	SIMD_FORCE_INLINE const btBroadphaseProxy* getBroadphaseHandle() const
	{
		return m_broadphaseHandle;
	}

	void setBroadphaseHandle(btBroadphaseProxy * handle)
	{
		m_broadphaseHandle = handle;
	}

	const btTransform& getInterpolationWorldTransform() const
	{
		return m_interpolationWorldTransform;
	}

	btTransform& getInterpolationWorldTransform()
	{
		return m_interpolationWorldTransform;
	}

	void setInterpolationWorldTransform(const btTransform& trans)
	{
		m_updateRevision++;
		m_interpolationWorldTransform = trans;
	}

	void setInterpolationLinearVelocity(const btVector3& linvel)
	{
		m_updateRevision++;
		m_interpolationLinearVelocity = linvel;
	}

	void setInterpolationAngularVelocity(const btVector3& angvel)
	{
		m_updateRevision++;
		m_interpolationAngularVelocity = angvel;
	}

	const btVector3& getInterpolationLinearVelocity() const
	{
		return m_interpolationLinearVelocity;
	}

	const btVector3& getInterpolationAngularVelocity() const
	{
		return m_interpolationAngularVelocity;
	}

	SIMD_FORCE_INLINE int getIslandTag() const
	{
		return m_islandTag1;
	}

	void setIslandTag(int tag)
	{
		m_islandTag1 = tag;
	}

	SIMD_FORCE_INLINE int getCompanionId() const
	{
		return m_companionId;
	}

	void setCompanionId(int id)
	{
		m_companionId = id;
	}

	SIMD_FORCE_INLINE int getWorldArrayIndex() const
	{
		return m_worldArrayIndex;
	}

	// only should be called by CollisionWorld
	void setWorldArrayIndex(int ix)
	{
		m_worldArrayIndex = ix;
	}

	SIMD_FORCE_INLINE btScalar getHitFraction() const
	{
		return m_hitFraction;
	}

	void setHitFraction(btScalar hitFraction)
	{
		m_hitFraction = hitFraction;
	}

	SIMD_FORCE_INLINE int getCollisionFlags() const
	{
		return m_collisionFlags;
	}

	void setCollisionFlags(int flags)
	{
		m_collisionFlags = flags;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar getCcdSweptSphereRadius() const
	{
		return m_ccdSweptSphereRadius;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	void setCcdSweptSphereRadius(btScalar radius)
	{
		m_ccdSweptSphereRadius = radius;
	}

	btScalar getCcdMotionThreshold() const
	{
		return m_ccdMotionThreshold;
	}

	btScalar getCcdSquareMotionThreshold() const
	{
		return m_ccdMotionThreshold * m_ccdMotionThreshold;
	}

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	void setCcdMotionThreshold(btScalar ccdMotionThreshold)
	{
		m_ccdMotionThreshold = ccdMotionThreshold;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void* getUserPointer() const
	{
		return m_userObjectPointer;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	int getUserIndex3() const
	{
		return m_userIndex3;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserPointer(void* userPointer)
	{
		m_userObjectPointer = userPointer;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	void setUserIndex3(int index)
	{
		m_userIndex3 = index;
	}

	int getUpdateRevisionInternal() const
	{
		return m_updateRevision;
	}

	void setCustomDebugColor(const btVector3& colorRGB)
	{
		m_customDebugColorRGB = colorRGB;
		m_collisionFlags |= CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	void removeCustomDebugColor()
	{
		m_collisionFlags &= ~CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	bool getCustomDebugColor(btVector3 & colorRGB) const
	{
		bool hasCustomColor = (0 != (m_collisionFlags & CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR));
		if (hasCustomColor)
		{
			colorRGB = m_customDebugColorRGB;
		}
		return hasCustomColor;
	}

	inline bool checkCollideWith(const btCollisionObject* co) const
	{
		if (m_checkCollideWith)
			return checkCollideWithOverride(co);

		return true;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer * serializer) const;
};

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectDoubleData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformDoubleData	m_worldTransform;
	btTransformDoubleData	m_interpolationWorldTransform;
	btVector3DoubleData		m_interpolationLinearVelocity;
	btVector3DoubleData		m_interpolationAngularVelocity;
	btVector3DoubleData		m_anisotropicFriction;
	double					m_contactProcessingThreshold;	
	double					m_deactivationTime;
	double					m_friction;
	double					m_rollingFriction;
	double                  m_contactDamping;
	double                  m_contactStiffness;
	double					m_restitution;
	double					m_hitFraction; 
	double					m_ccdSweptSphereRadius;
	double					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;//m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectFloatData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformFloatData	m_worldTransform;
	btTransformFloatData	m_interpolationWorldTransform;
	btVector3FloatData		m_interpolationLinearVelocity;
	btVector3FloatData		m_interpolationAngularVelocity;
	btVector3FloatData		m_anisotropicFriction;
	float					m_contactProcessingThreshold;	
	float					m_deactivationTime;
	float					m_friction;
	float					m_rollingFriction;
	float                   m_contactDamping;
    float                   m_contactStiffness;
	float					m_restitution;
	float					m_hitFraction; 
	float					m_ccdSweptSphereRadius;
	float					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;
};
// clang-format on

SIMD_FORCE_INLINE int btCollisionObject::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionObjectData);
}

#endif  //BT_COLLISION_OBJECT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

btCollisionObject::btCollisionObject()
	: m_interpolationLinearVelocity(0.f, 0.f, 0.f),
	  m_interpolationAngularVelocity(0.f, 0.f, 0.f),
	  m_anisotropicFriction(1.f, 1.f, 1.f),
	  m_hasAnisotropicFriction(false),
	  m_contactProcessingThreshold(BT_LARGE_FLOAT),
	  m_broadphaseHandle(0),
	  m_collisionShape(0),
	  m_extensionPointer(0),
	  m_rootCollisionShape(0),
	  m_collisionFlags(btCollisionObject::CF_STATIC_OBJECT),
	  m_islandTag1(-1),
	  m_companionId(-1),
	  m_worldArrayIndex(-1),
	  m_activationState1(1),
	  m_deactivationTime(btScalar(0.)),
	  m_friction(btScalar(0.5)),
	  m_restitution(btScalar(0.)),
	  m_rollingFriction(0.0f),
	  m_spinningFriction(0.f),
	  m_contactDamping(.1),
	  m_contactStiffness(BT_LARGE_FLOAT),
	  m_internalType(CO_COLLISION_OBJECT),
	  m_userObjectPointer(0),
	  m_userIndex2(-1),
	  m_userIndex(-1),
	  m_userIndex3(-1),
	  m_hitFraction(btScalar(1.)),
	  m_ccdSweptSphereRadius(btScalar(0.)),
	  m_ccdMotionThreshold(btScalar(0.)),
	  m_checkCollideWith(false),
	  m_updateRevision(0)
{
	m_worldTransform.setIdentity();
	m_interpolationWorldTransform.setIdentity();
}

btCollisionObject::~btCollisionObject()
{
}

void btCollisionObject::setActivationState(int newState) const
{
	if ((m_activationState1 != DISABLE_DEACTIVATION) && (m_activationState1 != DISABLE_SIMULATION))
		m_activationState1 = newState;
}

void btCollisionObject::forceActivationState(int newState) const
{
	m_activationState1 = newState;
}

void btCollisionObject::activate(bool forceActivation) const
{
	if (forceActivation || !(m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT)))
	{
		setActivationState(ACTIVE_TAG);
		m_deactivationTime = btScalar(0.);
	}
}

const char* btCollisionObject::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionObjectData* dataOut = (btCollisionObjectData*)dataBuffer;

	m_worldTransform.serialize(dataOut->m_worldTransform);
	m_interpolationWorldTransform.serialize(dataOut->m_interpolationWorldTransform);
	m_interpolationLinearVelocity.serialize(dataOut->m_interpolationLinearVelocity);
	m_interpolationAngularVelocity.serialize(dataOut->m_interpolationAngularVelocity);
	m_anisotropicFriction.serialize(dataOut->m_anisotropicFriction);
	dataOut->m_hasAnisotropicFriction = m_hasAnisotropicFriction;
	dataOut->m_contactProcessingThreshold = m_contactProcessingThreshold;
	dataOut->m_broadphaseHandle = 0;
	dataOut->m_collisionShape = serializer->getUniquePointer(m_collisionShape);
	dataOut->m_rootCollisionShape = 0;  //@todo
	dataOut->m_collisionFlags = m_collisionFlags;
	dataOut->m_islandTag1 = m_islandTag1;
	dataOut->m_companionId = m_companionId;
	dataOut->m_activationState1 = m_activationState1;
	dataOut->m_deactivationTime = m_deactivationTime;
	dataOut->m_friction = m_friction;
	dataOut->m_rollingFriction = m_rollingFriction;
	dataOut->m_contactDamping = m_contactDamping;
	dataOut->m_contactStiffness = m_contactStiffness;
	dataOut->m_restitution = m_restitution;
	dataOut->m_internalType = m_internalType;

	char* name = (char*)serializer->findNameForPointer(this);
	dataOut->m_name = (char*)serializer->getUniquePointer(name);
	if (dataOut->m_name)
	{
		serializer->serializeName(name);
	}
	dataOut->m_hitFraction = m_hitFraction;
	dataOut->m_ccdSweptSphereRadius = m_ccdSweptSphereRadius;
	dataOut->m_ccdMotionThreshold = m_ccdMotionThreshold;
	dataOut->m_checkCollideWith = m_checkCollideWith;
	if (m_broadphaseHandle)
	{
		dataOut->m_collisionFilterGroup = m_broadphaseHandle->m_collisionFilterGroup;
		dataOut->m_collisionFilterMask = m_broadphaseHandle->m_collisionFilterMask;
		dataOut->m_uniqueId = m_broadphaseHandle->m_uniqueId;
	}
	else
	{
		dataOut->m_collisionFilterGroup = 0;
		dataOut->m_collisionFilterMask = 0;
		dataOut->m_uniqueId = -1;
	}
	return btCollisionObjectDataName;
}

void btCollisionObject::serializeSingleObject(class btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_COLLISIONOBJECT_CODE, (void*)this);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_RIGIDBODY_H
#define BT_RIGIDBODY_H

#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

class btCollisionShape;
class btMotionState;
class btTypedConstraint;

extern btScalar gDeactivationTime;
extern bool gDisableDeactivation;

#ifdef BT_USE_DOUBLE_PRECISION
#define btRigidBodyData btRigidBodyDoubleData
#define btRigidBodyDataName "btRigidBodyDoubleData"
#else
#define btRigidBodyData btRigidBodyFloatData
#define btRigidBodyDataName "btRigidBodyFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

enum btRigidBodyFlags
{
	BT_DISABLE_WORLD_GRAVITY = 1,
	///BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
	///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
	///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
	BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT = 2,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD = 4,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY = 8,
	BT_ENABLE_GYROPSCOPIC_FORCE = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY,
};

///The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
///It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
///There are 3 types of rigid bodies:
///- A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
///- B) Fixed objects with zero mass. They are not moving (basically collision objects)
///- C) Kinematic objects, which are objects without mass, but the user can move them. There is one-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
///Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
///Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
class btRigidBody : public btCollisionObject
{
	btMatrix3x3 m_invInertiaTensorWorld;
	btVector3 m_linearVelocity;
	btVector3 m_angularVelocity;
	btScalar m_inverseMass;
	btVector3 m_linearFactor;

	btVector3 m_gravity;
	btVector3 m_gravity_acceleration;
	btVector3 m_invInertiaLocal;
	btVector3 m_totalForce;
	btVector3 m_totalTorque;

	btScalar m_linearDamping;
	btScalar m_angularDamping;

	bool m_additionalDamping;
	btScalar m_additionalDampingFactor;
	btScalar m_additionalLinearDampingThresholdSqr;
	btScalar m_additionalAngularDampingThresholdSqr;
	btScalar m_additionalAngularDampingFactor;

	btScalar m_linearSleepingThreshold;
	btScalar m_angularSleepingThreshold;

	//m_optionalMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* m_optionalMotionState;

	//keep track of typed constraints referencing this rigid body, to disable collision between linked bodies
	btAlignedObjectArray<btTypedConstraint*> m_constraintRefs;

	int m_rigidbodyFlags;

	int m_debugBodyId;

protected:
	ATTRIBUTE_ALIGNED16(btVector3 m_deltaLinearVelocity);
	btVector3 m_deltaAngularVelocity;
	btVector3 m_angularFactor;
	btVector3 m_invMass;
	btVector3 m_pushVelocity;
	btVector3 m_turnVelocity;

public:
	///The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
	///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
	///You can use the motion state to synchronize the world transform between physics and graphics objects.
	///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
	///m_startWorldTransform is only used when you don't provide a motion state.
	struct btRigidBodyConstructionInfo
	{
		btScalar m_mass;

		///When a motionState is provided, the rigid body will initialize its world transform from the motion state
		///In this case, m_startWorldTransform is ignored.
		btMotionState* m_motionState;
		btTransform m_startWorldTransform;

		btCollisionShape* m_collisionShape;
		btVector3 m_localInertia;
		btScalar m_linearDamping;
		btScalar m_angularDamping;

		///best simulation results when friction is non-zero
		btScalar m_friction;
		///the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
		///See Bullet/Demos/RollingFrictionDemo for usage
		btScalar m_rollingFriction;
		btScalar m_spinningFriction;  //torsional friction around contact normal

		///best simulation results using zero restitution.
		btScalar m_restitution;

		btScalar m_linearSleepingThreshold;
		btScalar m_angularSleepingThreshold;

		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		bool m_additionalDamping;
		btScalar m_additionalDampingFactor;
		btScalar m_additionalLinearDampingThresholdSqr;
		btScalar m_additionalAngularDampingThresholdSqr;
		btScalar m_additionalAngularDampingFactor;

		btRigidBodyConstructionInfo(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0)) : m_mass(mass),
																																									   m_motionState(motionState),
																																									   m_collisionShape(collisionShape),
																																									   m_localInertia(localInertia),
																																									   m_linearDamping(btScalar(0.)),
																																									   m_angularDamping(btScalar(0.)),
																																									   m_friction(btScalar(0.5)),
																																									   m_rollingFriction(btScalar(0)),
																																									   m_spinningFriction(btScalar(0)),
																																									   m_restitution(btScalar(0.)),
																																									   m_linearSleepingThreshold(btScalar(0.8)),
																																									   m_angularSleepingThreshold(btScalar(1.f)),
																																									   m_additionalDamping(false),
																																									   m_additionalDampingFactor(btScalar(0.005)),
																																									   m_additionalLinearDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingFactor(btScalar(0.01))
		{
			m_startWorldTransform.setIdentity();
		}
	};

	///btRigidBody constructor using construction info
	btRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

	///btRigidBody constructor for backwards compatibility.
	///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
	btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0));

	virtual ~btRigidBody()
	{
		//No constraints should point to this rigidbody
		//Remove constraints from the dynamics world before you delete the related rigidbodies.
		btAssert(m_constraintRefs.size() == 0);
	}

protected:
	///setupRigidBody is only used internally by the constructor
	void setupRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

public:
	void proceedToTransform(const btTransform& newTrans);

	///to keep collision detection and dynamics separate we don't store a rigidbody pointer
	///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
	static const btRigidBody* upcast(const btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (const btRigidBody*)colObj;
		return 0;
	}
	static btRigidBody* upcast(btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (btRigidBody*)colObj;
		return 0;
	}

	/// continuous collision detection needs prediction
	void predictIntegratedTransform(btScalar step, btTransform& predictedTransform);

	void saveKinematicState(btScalar step);

	void applyGravity();
    
    void clearGravity();

	void setGravity(const btVector3& acceleration);

	const btVector3& getGravity() const
	{
		return m_gravity_acceleration;
	}

	void setDamping(btScalar lin_damping, btScalar ang_damping);

	btScalar getLinearDamping() const
	{
		return m_linearDamping;
	}

	btScalar getAngularDamping() const
	{
		return m_angularDamping;
	}

	btScalar getLinearSleepingThreshold() const
	{
		return m_linearSleepingThreshold;
	}

	btScalar getAngularSleepingThreshold() const
	{
		return m_angularSleepingThreshold;
	}

	void applyDamping(btScalar timeStep);

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setMassProps(btScalar mass, const btVector3& inertia);

	const btVector3& getLinearFactor() const
	{
		return m_linearFactor;
	}
	void setLinearFactor(const btVector3& linearFactor)
	{
		m_linearFactor = linearFactor;
		m_invMass = m_linearFactor * m_inverseMass;
	}
	btScalar getInvMass() const { return m_inverseMass; }
	btScalar getMass() const { return m_inverseMass == btScalar(0.) ? btScalar(0.) : btScalar(1.0) / m_inverseMass; }
	const btMatrix3x3& getInvInertiaTensorWorld() const
	{
		return m_invInertiaTensorWorld;
	}

	void integrateVelocities(btScalar step);

	void setCenterOfMassTransform(const btTransform& xform);

	void applyCentralForce(const btVector3& force)
	{
		m_totalForce += force * m_linearFactor;
	}

	const btVector3& getTotalForce() const
	{
		return m_totalForce;
	};

	const btVector3& getTotalTorque() const
	{
		return m_totalTorque;
	};

	const btVector3& getInvInertiaDiagLocal() const
	{
		return m_invInertiaLocal;
	};

	void setInvInertiaDiagLocal(const btVector3& diagInvInertia)
	{
		m_invInertiaLocal = diagInvInertia;
	}

	void setSleepingThresholds(btScalar linear, btScalar angular)
	{
		m_linearSleepingThreshold = linear;
		m_angularSleepingThreshold = angular;
	}

	void applyTorque(const btVector3& torque)
	{
		m_totalTorque += torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_totalTorque);
		#endif
	}

	void applyForce(const btVector3& force, const btVector3& rel_pos)
	{
		applyCentralForce(force);
		applyTorque(rel_pos.cross(force * m_linearFactor));
	}

	void applyCentralImpulse(const btVector3& impulse)
	{
		m_linearVelocity += impulse * m_linearFactor * m_inverseMass;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	void applyTorqueImpulse(const btVector3& torque)
	{
		m_angularVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	void applyImpulse(const btVector3& impulse, const btVector3& rel_pos)
	{
		if (m_inverseMass != btScalar(0.))
		{
			applyCentralImpulse(impulse);
			if (m_angularFactor)
			{
				applyTorqueImpulse(rel_pos.cross(impulse * m_linearFactor));
			}
		}
	}
    
    void applyPushImpulse(const btVector3& impulse, const btVector3& rel_pos)
    {
        if (m_inverseMass != btScalar(0.))
        {
            applyCentralPushImpulse(impulse);
            if (m_angularFactor)
            {
                applyTorqueTurnImpulse(rel_pos.cross(impulse * m_linearFactor));
            }
        }
    }
    
    btVector3 getPushVelocity() const
    {
        return m_pushVelocity;
    }
    
    btVector3 getTurnVelocity() const
    {
        return m_turnVelocity;
    }
    
    void setPushVelocity(const btVector3& v)
    {
        m_pushVelocity = v;
    }

    #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
    void clampVelocity(btVector3& v) const {
        v.setX(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getX()))
        );
        v.setY(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getY()))
        );
        v.setZ(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getZ()))
        );
    }
    #endif

    void setTurnVelocity(const btVector3& v)
    {
        m_turnVelocity = v;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }
    
    void applyCentralPushImpulse(const btVector3& impulse)
    {
        m_pushVelocity += impulse * m_linearFactor * m_inverseMass;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_pushVelocity);
        #endif
    }
    
    void applyTorqueTurnImpulse(const btVector3& torque)
    {
        m_turnVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }

	void clearForces()
	{
		m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
		m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	void updateInertiaTensor();

	const btVector3& getCenterOfMassPosition() const
	{
		return m_worldTransform.getOrigin();
	}
	btQuaternion getOrientation() const;

	const btTransform& getCenterOfMassTransform() const
	{
		return m_worldTransform;
	}
	const btVector3& getLinearVelocity() const
	{
		return m_linearVelocity;
	}
	const btVector3& getAngularVelocity() const
	{
		return m_angularVelocity;
	}

	inline void setLinearVelocity(const btVector3& lin_vel)
	{
		m_updateRevision++;
		m_linearVelocity = lin_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	inline void setAngularVelocity(const btVector3& ang_vel)
	{
		m_updateRevision++;
		m_angularVelocity = ang_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	btVector3 getVelocityInLocalPoint(const btVector3& rel_pos) const
	{
		//we also calculate lin/ang velocity for kinematic objects
		return m_linearVelocity + m_angularVelocity.cross(rel_pos);

		//for kinematic objects, we could also use use:
		//		return 	(m_worldTransform(rel_pos) - m_interpolationWorldTransform(rel_pos)) / m_kinematicTimeStep;
	}
    
    btVector3 getPushVelocityInLocalPoint(const btVector3& rel_pos) const
    {
        //we also calculate lin/ang velocity for kinematic objects
        return m_pushVelocity + m_turnVelocity.cross(rel_pos);
    }

	void translate(const btVector3& v)
	{
		m_worldTransform.getOrigin() += v;
	}

	void getAabb(btVector3& aabbMin, btVector3& aabbMax) const;

	SIMD_FORCE_INLINE btScalar computeImpulseDenominator(const btVector3& pos, const btVector3& normal) const
	{
		btVector3 r0 = pos - getCenterOfMassPosition();

		btVector3 c0 = (r0).cross(normal);

		btVector3 vec = (c0 * getInvInertiaTensorWorld()).cross(r0);

		return m_inverseMass + normal.dot(vec);
	}

	SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis) const
	{
		btVector3 vec = axis * getInvInertiaTensorWorld();
		return axis.dot(vec);
	}

	SIMD_FORCE_INLINE void updateDeactivation(btScalar timeStep)
	{
		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == DISABLE_DEACTIVATION))
			return;

		if ((getLinearVelocity().length2() < m_linearSleepingThreshold * m_linearSleepingThreshold) &&
			(getAngularVelocity().length2() < m_angularSleepingThreshold * m_angularSleepingThreshold))
		{
			m_deactivationTime += timeStep;
		}
		else
		{
			m_deactivationTime = btScalar(0.);
			setActivationState(0);
		}
	}

	SIMD_FORCE_INLINE bool wantsSleeping()
	{
		if (getActivationState() == DISABLE_DEACTIVATION)
			return false;

		//disable deactivation
		if (gDisableDeactivation || (gDeactivationTime == btScalar(0.)))
			return false;

		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == WANTS_DEACTIVATION))
			return true;

		if (m_deactivationTime > gDeactivationTime)
		{
			return true;
		}
		return false;
	}

	const btBroadphaseProxy* getBroadphaseProxy() const
	{
		return m_broadphaseHandle;
	}
	btBroadphaseProxy* getBroadphaseProxy()
	{
		return m_broadphaseHandle;
	}
	void setNewBroadphaseProxy(btBroadphaseProxy* broadphaseProxy)
	{
		m_broadphaseHandle = broadphaseProxy;
	}

	//btMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* getMotionState()
	{
		return m_optionalMotionState;
	}
	const btMotionState* getMotionState() const
	{
		return m_optionalMotionState;
	}
	void setMotionState(btMotionState* motionState)
	{
		m_optionalMotionState = motionState;
		if (m_optionalMotionState)
			motionState->getWorldTransform(m_worldTransform);
	}

	//for experimental overriding of friction/contact solver func
	int m_contactSolverType;
	int m_frictionSolverType;

	void setAngularFactor(const btVector3& angFac)
	{
		m_updateRevision++;
		m_angularFactor = angFac;
	}

	void setAngularFactor(btScalar angFac)
	{
		m_updateRevision++;
		m_angularFactor.setValue(angFac, angFac, angFac);
	}
	const btVector3& getAngularFactor() const
	{
		return m_angularFactor;
	}

	//is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
	bool isInWorld() const
	{
		return (getBroadphaseProxy() != 0);
	}

	void addConstraintRef(btTypedConstraint* c);
	void removeConstraintRef(btTypedConstraint* c);

	btTypedConstraint* getConstraintRef(int index)
	{
		return m_constraintRefs[index];
	}

	int getNumConstraintRefs() const
	{
		return m_constraintRefs.size();
	}

	void setFlags(int flags)
	{
		m_rigidbodyFlags = flags;
	}

	int getFlags() const
	{
		return m_rigidbodyFlags;
	}

	///perform implicit force computation in world space
	btVector3 computeGyroscopicImpulseImplicit_World(btScalar dt) const;

	///perform implicit force computation in body space (inertial frame)
	btVector3 computeGyroscopicImpulseImplicit_Body(btScalar step) const;

	///explicit version is best avoided, it gains energy
	btVector3 computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const;
	btVector3 getLocalInertia() const;

	///////////////////////////////////////////////

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer* serializer) const;
};

//@todo add m_optionalMotionState and m_constraintRefs to btRigidBodyData
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyFloatData
{
	btCollisionObjectFloatData m_collisionObjectData;
	btMatrix3x3FloatData m_invInertiaTensorWorld;
	btVector3FloatData m_linearVelocity;
	btVector3FloatData m_angularVelocity;
	btVector3FloatData m_angularFactor;
	btVector3FloatData m_linearFactor;
	btVector3FloatData m_gravity;
	btVector3FloatData m_gravity_acceleration;
	btVector3FloatData m_invInertiaLocal;
	btVector3FloatData m_totalForce;
	btVector3FloatData m_totalTorque;
	float m_inverseMass;
	float m_linearDamping;
	float m_angularDamping;
	float m_additionalDampingFactor;
	float m_additionalLinearDampingThresholdSqr;
	float m_additionalAngularDampingThresholdSqr;
	float m_additionalAngularDampingFactor;
	float m_linearSleepingThreshold;
	float m_angularSleepingThreshold;
	int m_additionalDamping;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyDoubleData
{
	btCollisionObjectDoubleData m_collisionObjectData;
	btMatrix3x3DoubleData m_invInertiaTensorWorld;
	btVector3DoubleData m_linearVelocity;
	btVector3DoubleData m_angularVelocity;
	btVector3DoubleData m_angularFactor;
	btVector3DoubleData m_linearFactor;
	btVector3DoubleData m_gravity;
	btVector3DoubleData m_gravity_acceleration;
	btVector3DoubleData m_invInertiaLocal;
	btVector3DoubleData m_totalForce;
	btVector3DoubleData m_totalTorque;
	double m_inverseMass;
	double m_linearDamping;
	double m_angularDamping;
	double m_additionalDampingFactor;
	double m_additionalLinearDampingThresholdSqr;
	double m_additionalAngularDampingThresholdSqr;
	double m_additionalAngularDampingFactor;
	double m_linearSleepingThreshold;
	double m_angularSleepingThreshold;
	int m_additionalDamping;
	char m_padding[4];
};

#endif  //BT_RIGIDBODY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMotionState.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "LinearMath/btSerializer.h"

//'temporarily' global variables
btScalar gDeactivationTime = btScalar(2.);
bool gDisableDeactivation = false;
static int uniqueId = 0;

btRigidBody::btRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	setupRigidBody(constructionInfo);
}

btRigidBody::btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia)
{
	btRigidBodyConstructionInfo cinfo(mass, motionState, collisionShape, localInertia);
	setupRigidBody(cinfo);
}

void btRigidBody::setupRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	m_internalType = CO_RIGID_BODY;

	m_linearVelocity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	m_angularFactor.setValue(1, 1, 1);
	m_linearFactor.setValue(1, 1, 1);
	m_gravity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_gravity_acceleration.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0)),
		setDamping(constructionInfo.m_linearDamping, constructionInfo.m_angularDamping);

	m_linearSleepingThreshold = constructionInfo.m_linearSleepingThreshold;
	m_angularSleepingThreshold = constructionInfo.m_angularSleepingThreshold;
	m_optionalMotionState = constructionInfo.m_motionState;
	m_contactSolverType = 0;
	m_frictionSolverType = 0;
	m_additionalDamping = constructionInfo.m_additionalDamping;
	m_additionalDampingFactor = constructionInfo.m_additionalDampingFactor;
	m_additionalLinearDampingThresholdSqr = constructionInfo.m_additionalLinearDampingThresholdSqr;
	m_additionalAngularDampingThresholdSqr = constructionInfo.m_additionalAngularDampingThresholdSqr;
	m_additionalAngularDampingFactor = constructionInfo.m_additionalAngularDampingFactor;

	if (m_optionalMotionState)
	{
		m_optionalMotionState->getWorldTransform(m_worldTransform);
	}
	else
	{
		m_worldTransform = constructionInfo.m_startWorldTransform;
	}

	m_interpolationWorldTransform = m_worldTransform;
	m_interpolationLinearVelocity.setValue(0, 0, 0);
	m_interpolationAngularVelocity.setValue(0, 0, 0);

	//moved to btCollisionObject
	m_friction = constructionInfo.m_friction;
	m_rollingFriction = constructionInfo.m_rollingFriction;
	m_spinningFriction = constructionInfo.m_spinningFriction;

	m_restitution = constructionInfo.m_restitution;

	setCollisionShape(constructionInfo.m_collisionShape);
	m_debugBodyId = uniqueId++;

	setMassProps(constructionInfo.m_mass, constructionInfo.m_localInertia);
	updateInertiaTensor();

	m_rigidbodyFlags = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;

	m_deltaLinearVelocity.setZero();
	m_deltaAngularVelocity.setZero();
	m_invMass = m_inverseMass * m_linearFactor;
	m_pushVelocity.setZero();
	m_turnVelocity.setZero();
}

void btRigidBody::predictIntegratedTransform(btScalar timeStep, btTransform& predictedTransform)
{
	btTransformUtil::integrateTransform(m_worldTransform, m_linearVelocity, m_angularVelocity, timeStep, predictedTransform);
}

void btRigidBody::saveKinematicState(btScalar timeStep)
{
	//todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities
	if (timeStep != btScalar(0.))
	{
		//if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform
		if (getMotionState())
			getMotionState()->getWorldTransform(m_worldTransform);
		btVector3 linVel, angVel;

		btTransformUtil::calculateVelocity(m_interpolationWorldTransform, m_worldTransform, timeStep, m_linearVelocity, m_angularVelocity);
		m_interpolationLinearVelocity = m_linearVelocity;
		m_interpolationAngularVelocity = m_angularVelocity;
		m_interpolationWorldTransform = m_worldTransform;
		//printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());
	}
}

void btRigidBody::getAabb(btVector3& aabbMin, btVector3& aabbMax) const
{
	getCollisionShape()->getAabb(m_worldTransform, aabbMin, aabbMax);
}

void btRigidBody::setGravity(const btVector3& acceleration)
{
	if (m_inverseMass != btScalar(0.0))
	{
		m_gravity = acceleration * (btScalar(1.0) / m_inverseMass);
	}
	m_gravity_acceleration = acceleration;
}

void btRigidBody::setDamping(btScalar lin_damping, btScalar ang_damping)
{
#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearDamping = btMax(lin_damping, btScalar(0.0));
	m_angularDamping = btMax(ang_damping, btScalar(0.0));
#else
	m_linearDamping = btClamped(lin_damping, btScalar(0.0), btScalar(1.0));
	m_angularDamping = btClamped(ang_damping, btScalar(0.0), btScalar(1.0));
#endif
}

///applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping
void btRigidBody::applyDamping(btScalar timeStep)
{
	//On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74
	//todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway

#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearVelocity *= btMax((btScalar(1.0) - timeStep * m_linearDamping), btScalar(0.0));
	m_angularVelocity *= btMax((btScalar(1.0) - timeStep * m_angularDamping), btScalar(0.0));
#else
	m_linearVelocity *= btPow(btScalar(1) - m_linearDamping, timeStep);
	m_angularVelocity *= btPow(btScalar(1) - m_angularDamping, timeStep);
#endif

	if (m_additionalDamping)
	{
		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		if ((m_angularVelocity.length2() < m_additionalAngularDampingThresholdSqr) &&
			(m_linearVelocity.length2() < m_additionalLinearDampingThresholdSqr))
		{
			m_angularVelocity *= m_additionalDampingFactor;
			m_linearVelocity *= m_additionalDampingFactor;
		}

		btScalar speed = m_linearVelocity.length();
		if (speed < m_linearDamping)
		{
			btScalar dampVel = btScalar(0.005);
			if (speed > dampVel)
			{
				btVector3 dir = m_linearVelocity.normalized();
				m_linearVelocity -= dir * dampVel;
			}
			else
			{
				m_linearVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}

		btScalar angSpeed = m_angularVelocity.length();
		if (angSpeed < m_angularDamping)
		{
			btScalar angDampVel = btScalar(0.005);
			if (angSpeed > angDampVel)
			{
				btVector3 dir = m_angularVelocity.normalized();
				m_angularVelocity -= dir * angDampVel;
			}
			else
			{
				m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}
	}
}

void btRigidBody::applyGravity()
{
	if (isStaticOrKinematicObject())
		return;

	applyCentralForce(m_gravity);
}

void btRigidBody::clearGravity()
{
    if (isStaticOrKinematicObject())
        return;
    
    applyCentralForce(-m_gravity);
}

void btRigidBody::proceedToTransform(const btTransform& newTrans)
{
	setCenterOfMassTransform(newTrans);
}

void btRigidBody::setMassProps(btScalar mass, const btVector3& inertia)
{
	if (mass == btScalar(0.))
	{
		m_collisionFlags |= btCollisionObject::CF_STATIC_OBJECT;
		m_inverseMass = btScalar(0.);
	}
	else
	{
		m_collisionFlags &= (~btCollisionObject::CF_STATIC_OBJECT);
		m_inverseMass = btScalar(1.0) / mass;
	}

	//Fg = m * a
	m_gravity = mass * m_gravity_acceleration;

	m_invInertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
							   inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
							   inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));

	m_invMass = m_linearFactor * m_inverseMass;
}

void btRigidBody::updateInertiaTensor()
{
	m_invInertiaTensorWorld = m_worldTransform.getBasis().scaled(m_invInertiaLocal) * m_worldTransform.getBasis().transpose();
}

btVector3 btRigidBody::getLocalInertia() const
{
	btVector3 inertiaLocal;
	const btVector3 inertia = m_invInertiaLocal;
	inertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
						  inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
						  inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));
	return inertiaLocal;
}

inline btVector3 evalEulerEqn(const btVector3& w1, const btVector3& w0, const btVector3& T, const btScalar dt,
							  const btMatrix3x3& I)
{
	const btVector3 w2 = I * w1 + w1.cross(I * w1) * dt - (T * dt + I * w0);
	return w2;
}

inline btMatrix3x3 evalEulerEqnDeriv(const btVector3& w1, const btVector3& w0, const btScalar dt,
									 const btMatrix3x3& I)
{
	btMatrix3x3 w1x, Iw1x;
	const btVector3 Iwi = (I * w1);
	w1.getSkewSymmetricMatrix(&w1x[0], &w1x[1], &w1x[2]);
	Iwi.getSkewSymmetricMatrix(&Iw1x[0], &Iw1x[1], &Iw1x[2]);

	const btMatrix3x3 dfw1 = I + (w1x * I - Iw1x) * dt;
	return dfw1;
}

btVector3 btRigidBody::computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const
{
	btVector3 inertiaLocal = getLocalInertia();
	btMatrix3x3 inertiaTensorWorld = getWorldTransform().getBasis().scaled(inertiaLocal) * getWorldTransform().getBasis().transpose();
	btVector3 tmp = inertiaTensorWorld * getAngularVelocity();
	btVector3 gf = getAngularVelocity().cross(tmp);
	btScalar l2 = gf.length2();
	if (l2 > maxGyroscopicForce * maxGyroscopicForce)
	{
		gf *= btScalar(1.) / btSqrt(l2) * maxGyroscopicForce;
	}
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_Body(btScalar step) const
{
	btVector3 idl = getLocalInertia();
	btVector3 omega1 = getAngularVelocity();
	btQuaternion q = getWorldTransform().getRotation();

	// Convert to body coordinates
	btVector3 omegab = quatRotate(q.inverse(), omega1);
	btMatrix3x3 Ib;
	Ib.setValue(idl.x(), 0, 0,
				0, idl.y(), 0,
				0, 0, idl.z());

	btVector3 ibo = Ib * omegab;

	// Residual vector
	btVector3 f = step * omegab.cross(ibo);

	btMatrix3x3 skew0;
	omegab.getSkewSymmetricMatrix(&skew0[0], &skew0[1], &skew0[2]);
	btVector3 om = Ib * omegab;
	btMatrix3x3 skew1;
	om.getSkewSymmetricMatrix(&skew1[0], &skew1[1], &skew1[2]);

	// Jacobian
	btMatrix3x3 J = Ib + (skew0 * Ib - skew1) * step;

	//	btMatrix3x3 Jinv = J.inverse();
	//	btVector3 omega_div = Jinv*f;
	btVector3 omega_div = J.solve33(f);

	// Single Newton-Raphson update
	omegab = omegab - omega_div;  //Solve33(J, f);
	// Back to world coordinates
	btVector3 omega2 = quatRotate(q, omegab);
	btVector3 gf = omega2 - omega1;
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_World(btScalar step) const
{
	// use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.
	// calculate using implicit euler step so it's stable.

	const btVector3 inertiaLocal = getLocalInertia();
	const btVector3 w0 = getAngularVelocity();

	btMatrix3x3 I;

	I = m_worldTransform.getBasis().scaled(inertiaLocal) *
		m_worldTransform.getBasis().transpose();

	// use newtons method to find implicit solution for new angular velocity (w')
	// f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0
	// df/dw' = I + 1xIw'*step + w'xI*step

	btVector3 w1 = w0;

	// one step of newton's method
	{
		const btVector3 fw = evalEulerEqn(w1, w0, btVector3(0, 0, 0), step, I);
		const btMatrix3x3 dfw = evalEulerEqnDeriv(w1, w0, step, I);

		btVector3 dw;
		dw = dfw.solve33(fw);
		//const btMatrix3x3 dfw_inv = dfw.inverse();
		//dw = dfw_inv*fw;

		w1 -= dw;
	}

	btVector3 gf = (w1 - w0);
	return gf;
}

void btRigidBody::integrateVelocities(btScalar step)
{
	if (isStaticOrKinematicObject())
		return;

	m_linearVelocity += m_totalForce * (m_inverseMass * step);
	m_angularVelocity += m_invInertiaTensorWorld * m_totalTorque * step;

#define MAX_ANGVEL SIMD_HALF_PI
	/// clamp angular velocity. collision calculations will fail on higher angular velocities
	btScalar angvel = m_angularVelocity.length();
	if (angvel * step > MAX_ANGVEL)
	{
		m_angularVelocity *= (MAX_ANGVEL / step) / angvel;
	}
	#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
	clampVelocity(m_angularVelocity);
	#endif
}

btQuaternion btRigidBody::getOrientation() const
{
	btQuaternion orn;
	m_worldTransform.getBasis().getRotation(orn);
	return orn;
}

void btRigidBody::setCenterOfMassTransform(const btTransform& xform)
{
	if (isKinematicObject())
	{
		m_interpolationWorldTransform = m_worldTransform;
	}
	else
	{
		m_interpolationWorldTransform = xform;
	}
	m_interpolationLinearVelocity = getLinearVelocity();
	m_interpolationAngularVelocity = getAngularVelocity();
	m_worldTransform = xform;
	updateInertiaTensor();
}

void btRigidBody::addConstraintRef(btTypedConstraint* c)
{
	///disable collision with the 'other' body

	int index = m_constraintRefs.findLinearSearch(c);
	//don't add constraints that are already referenced
	//btAssert(index == m_constraintRefs.size());
	if (index == m_constraintRefs.size())
	{
		m_constraintRefs.push_back(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, true);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, true);
		}
	}
}

void btRigidBody::removeConstraintRef(btTypedConstraint* c)
{
	int index = m_constraintRefs.findLinearSearch(c);
	//don't remove constraints that are not referenced
	if (index < m_constraintRefs.size())
	{
		m_constraintRefs.remove(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, false);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, false);
		}
	}
}

int btRigidBody::calculateSerializeBufferSize() const
{
	int sz = sizeof(btRigidBodyData);
	return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btRigidBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
	btRigidBodyData* rbd = (btRigidBodyData*)dataBuffer;

	btCollisionObject::serialize(&rbd->m_collisionObjectData, serializer);

	m_invInertiaTensorWorld.serialize(rbd->m_invInertiaTensorWorld);
	m_linearVelocity.serialize(rbd->m_linearVelocity);
	m_angularVelocity.serialize(rbd->m_angularVelocity);
	rbd->m_inverseMass = m_inverseMass;
	m_angularFactor.serialize(rbd->m_angularFactor);
	m_linearFactor.serialize(rbd->m_linearFactor);
	m_gravity.serialize(rbd->m_gravity);
	m_gravity_acceleration.serialize(rbd->m_gravity_acceleration);
	m_invInertiaLocal.serialize(rbd->m_invInertiaLocal);
	m_totalForce.serialize(rbd->m_totalForce);
	m_totalTorque.serialize(rbd->m_totalTorque);
	rbd->m_linearDamping = m_linearDamping;
	rbd->m_angularDamping = m_angularDamping;
	rbd->m_additionalDamping = m_additionalDamping;
	rbd->m_additionalDampingFactor = m_additionalDampingFactor;
	rbd->m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;
	rbd->m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;
	rbd->m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;
	rbd->m_linearSleepingThreshold = m_linearSleepingThreshold;
	rbd->m_angularSleepingThreshold = m_angularSleepingThreshold;

	// Fill padding with zeros to appease msan.
#ifdef BT_USE_DOUBLE_PRECISION
	memset(rbd->m_padding, 0, sizeof(rbd->m_padding));
#endif

	return btRigidBodyDataName;
}

void btRigidBody::serializeSingleObject(class btSerializer* serializer) const
{
	btChunk* chunk = serializer->allocate(calculateSerializeBufferSize(), 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, (void*)this);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_JACOBIAN_ENTRY_H
#define BT_JACOBIAN_ENTRY_H

#include "LinearMath/btMatrix3x3.h"

//notes:
// Another memory optimization would be to store m_1MinvJt in the remaining 3 w components
// which makes the btJacobianEntry memory layout 16 bytes
// if you only are interested in angular part, just feed massInvA and massInvB zero

/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
ATTRIBUTE_ALIGNED16(class)
btJacobianEntry
{
public:
	btJacobianEntry(){};
	//constraint between two different rigidbodies
	btJacobianEntry(
		const btMatrix3x3& world2A,
		const btMatrix3x3& world2B,
		const btVector3& rel_pos1, const btVector3& rel_pos2,
		const btVector3& jointAxis,
		const btVector3& inertiaInvA,
		const btScalar massInvA,
		const btVector3& inertiaInvB,
		const btScalar massInvB)
		: m_linearJointAxis(jointAxis)
	{
		m_aJ = world2A * (rel_pos1.cross(m_linearJointAxis));
		m_bJ = world2B * (rel_pos2.cross(-m_linearJointAxis));
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = massInvA + m_0MinvJt.dot(m_aJ) + massInvB + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//angular constraint between two different rigidbodies
	btJacobianEntry(const btVector3& jointAxis,
					const btMatrix3x3& world2A,
					const btMatrix3x3& world2B,
					const btVector3& inertiaInvA,
					const btVector3& inertiaInvB)
		: m_linearJointAxis(btVector3(btScalar(0.), btScalar(0.), btScalar(0.)))
	{
		m_aJ = world2A * jointAxis;
		m_bJ = world2B * -jointAxis;
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = m_0MinvJt.dot(m_aJ) + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//angular constraint between two different rigidbodies
	btJacobianEntry(const btVector3& axisInA,
					const btVector3& axisInB,
					const btVector3& inertiaInvA,
					const btVector3& inertiaInvB)
		: m_linearJointAxis(btVector3(btScalar(0.), btScalar(0.), btScalar(0.))), m_aJ(axisInA), m_bJ(-axisInB)
	{
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = m_0MinvJt.dot(m_aJ) + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//constraint on one rigidbody
	btJacobianEntry(
		const btMatrix3x3& world2A,
		const btVector3& rel_pos1, const btVector3& rel_pos2,
		const btVector3& jointAxis,
		const btVector3& inertiaInvA,
		const btScalar massInvA)
		: m_linearJointAxis(jointAxis)
	{
		m_aJ = world2A * (rel_pos1.cross(jointAxis));
		m_bJ = world2A * (rel_pos2.cross(-jointAxis));
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
		m_Adiag = massInvA + m_0MinvJt.dot(m_aJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	btScalar getDiagonal() const { return m_Adiag; }

	// for two constraints on the same rigidbody (for example vehicle friction)
	btScalar getNonDiagonal(const btJacobianEntry& jacB, const btScalar massInvA) const
	{
		const btJacobianEntry& jacA = *this;
		btScalar lin = massInvA * jacA.m_linearJointAxis.dot(jacB.m_linearJointAxis);
		btScalar ang = jacA.m_0MinvJt.dot(jacB.m_aJ);
		return lin + ang;
	}

	// for two constraints on sharing two same rigidbodies (for example two contact points between two rigidbodies)
	btScalar getNonDiagonal(const btJacobianEntry& jacB, const btScalar massInvA, const btScalar massInvB) const
	{
		const btJacobianEntry& jacA = *this;
		btVector3 lin = jacA.m_linearJointAxis * jacB.m_linearJointAxis;
		btVector3 ang0 = jacA.m_0MinvJt * jacB.m_aJ;
		btVector3 ang1 = jacA.m_1MinvJt * jacB.m_bJ;
		btVector3 lin0 = massInvA * lin;
		btVector3 lin1 = massInvB * lin;
		btVector3 sum = ang0 + ang1 + lin0 + lin1;
		return sum[0] + sum[1] + sum[2];
	}

	btScalar getRelativeVelocity(const btVector3& linvelA, const btVector3& angvelA, const btVector3& linvelB, const btVector3& angvelB)
	{
		btVector3 linrel = linvelA - linvelB;
		btVector3 angvela = angvelA * m_aJ;
		btVector3 angvelb = angvelB * m_bJ;
		linrel *= m_linearJointAxis;
		angvela += angvelb;
		angvela += linrel;
		btScalar rel_vel2 = angvela[0] + angvela[1] + angvela[2];
		return rel_vel2 + SIMD_EPSILON;
	}
	//private:

	btVector3 m_linearJointAxis;
	btVector3 m_aJ;
	btVector3 m_bJ;
	btVector3 m_0MinvJt;
	btVector3 m_1MinvJt;
	//Optimization: can be stored in the w/last component of one of the vectors
	btScalar m_Adiag;
};

#endif  //BT_JACOBIAN_ENTRY_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRANSFORM_UTIL_H
#define BT_TRANSFORM_UTIL_H

#include "LinearMath/btTransform.h"
#define ANGULAR_MOTION_THRESHOLD btScalar(0.5) * SIMD_HALF_PI

SIMD_FORCE_INLINE btVector3 btAabbSupport(const btVector3& halfExtents, const btVector3& supportDir)
{
	return btVector3(supportDir.x() < btScalar(0.0) ? -halfExtents.x() : halfExtents.x(),
					 supportDir.y() < btScalar(0.0) ? -halfExtents.y() : halfExtents.y(),
					 supportDir.z() < btScalar(0.0) ? -halfExtents.z() : halfExtents.z());
}

/// Utils related to temporal transforms
class btTransformUtil
{
public:
	static void integrateTransform(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btTransform& predictedTransform)
	{
		predictedTransform.setOrigin(curTrans.getOrigin() + linvel * timeStep);
		//	#define QUATERNION_DERIVATIVE
#ifdef QUATERNION_DERIVATIVE
		btQuaternion predictedOrn = curTrans.getRotation();
		predictedOrn += (angvel * predictedOrn) * (timeStep * btScalar(0.5));
		predictedOrn.safeNormalize();
#else
		//Exponential map
		//google for "Practical Parameterization of Rotations Using the Exponential Map", F. Sebastian Grassia

		btVector3 axis;
		btScalar fAngle2 = angvel.length2();
		btScalar fAngle = 0;
		if (fAngle2 > SIMD_EPSILON)
		{
			fAngle = btSqrt(fAngle2);
		}

		//limit the angular motion
		if (fAngle * timeStep > ANGULAR_MOTION_THRESHOLD)
		{
			fAngle = ANGULAR_MOTION_THRESHOLD / timeStep;
		}

		if (fAngle < btScalar(0.001))
		{
			// use Taylor's expansions of sync function
			axis = angvel * (btScalar(0.5) * timeStep - (timeStep * timeStep * timeStep) * (btScalar(0.020833333333)) * fAngle * fAngle);
		}
		else
		{
			// sync(fAngle) = sin(c*fAngle)/t
			axis = angvel * (btSin(btScalar(0.5) * fAngle * timeStep) / fAngle);
		}
		btQuaternion dorn(axis.x(), axis.y(), axis.z(), btCos(fAngle * timeStep * btScalar(0.5)));
		btQuaternion orn0 = curTrans.getRotation();

		btQuaternion predictedOrn = dorn * orn0;
		predictedOrn.safeNormalize();
#endif
		if (predictedOrn.length2() > SIMD_EPSILON)
		{
			predictedTransform.setRotation(predictedOrn);
		}
		else
		{
			predictedTransform.setBasis(curTrans.getBasis());
		}
	}

	static void calculateVelocityQuaternion(const btVector3& pos0, const btVector3& pos1, const btQuaternion& orn0, const btQuaternion& orn1, btScalar timeStep, btVector3& linVel, btVector3& angVel)
	{
		linVel = (pos1 - pos0) / timeStep;
		btVector3 axis;
		btScalar angle;
		if (orn0 != orn1)
		{
			calculateDiffAxisAngleQuaternion(orn0, orn1, axis, angle);
			angVel = axis * angle / timeStep;
		}
		else
		{
			angVel.setValue(0, 0, 0);
		}
	}

	static void calculateDiffAxisAngleQuaternion(const btQuaternion& orn0, const btQuaternion& orn1a, btVector3& axis, btScalar& angle)
	{
		btQuaternion orn1 = orn0.nearest(orn1a);
		btQuaternion dorn = orn1 * orn0.inverse();
		angle = dorn.getAngle();
		axis = btVector3(dorn.x(), dorn.y(), dorn.z());
		axis[3] = btScalar(0.);
		//check for axis length
		btScalar len = axis.length2();
		if (len < SIMD_EPSILON * SIMD_EPSILON)
			axis = btVector3(btScalar(1.), btScalar(0.), btScalar(0.));
		else
			axis /= btSqrt(len);
	}

	static void calculateVelocity(const btTransform& transform0, const btTransform& transform1, btScalar timeStep, btVector3& linVel, btVector3& angVel)
	{
		linVel = (transform1.getOrigin() - transform0.getOrigin()) / timeStep;
		btVector3 axis;
		btScalar angle;
		calculateDiffAxisAngle(transform0, transform1, axis, angle);
		angVel = axis * angle / timeStep;
	}

	static void calculateDiffAxisAngle(const btTransform& transform0, const btTransform& transform1, btVector3& axis, btScalar& angle)
	{
		btMatrix3x3 dmat = transform1.getBasis() * transform0.getBasis().inverse();
		btQuaternion dorn;
		dmat.getRotation(dorn);

		///floating point inaccuracy can lead to w component > 1..., which breaks
		dorn.normalize();

		angle = dorn.getAngle();
		axis = btVector3(dorn.x(), dorn.y(), dorn.z());
		axis[3] = btScalar(0.);
		//check for axis length
		btScalar len = axis.length2();
		if (len < SIMD_EPSILON * SIMD_EPSILON)
			axis = btVector3(btScalar(1.), btScalar(0.), btScalar(0.));
		else
			axis /= btSqrt(len);
	}
};

///The btConvexSeparatingDistanceUtil can help speed up convex collision detection
///by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
class btConvexSeparatingDistanceUtil
{
	btQuaternion m_ornA;
	btQuaternion m_ornB;
	btVector3 m_posA;
	btVector3 m_posB;

	btVector3 m_separatingNormal;

	btScalar m_boundingRadiusA;
	btScalar m_boundingRadiusB;
	btScalar m_separatingDistance;

public:
	btConvexSeparatingDistanceUtil(btScalar boundingRadiusA, btScalar boundingRadiusB)
		: m_boundingRadiusA(boundingRadiusA),
		  m_boundingRadiusB(boundingRadiusB),
		  m_separatingDistance(0.f)
	{
	}

	btScalar getConservativeSeparatingDistance()
	{
		return m_separatingDistance;
	}

	void updateSeparatingDistance(const btTransform& transA, const btTransform& transB)
	{
		const btVector3& toPosA = transA.getOrigin();
		const btVector3& toPosB = transB.getOrigin();
		btQuaternion toOrnA = transA.getRotation();
		btQuaternion toOrnB = transB.getRotation();

		if (m_separatingDistance > 0.f)
		{
			btVector3 linVelA, angVelA, linVelB, angVelB;
			btTransformUtil::calculateVelocityQuaternion(m_posA, toPosA, m_ornA, toOrnA, btScalar(1.), linVelA, angVelA);
			btTransformUtil::calculateVelocityQuaternion(m_posB, toPosB, m_ornB, toOrnB, btScalar(1.), linVelB, angVelB);
			btScalar maxAngularProjectedVelocity = angVelA.length() * m_boundingRadiusA + angVelB.length() * m_boundingRadiusB;
			btVector3 relLinVel = (linVelB - linVelA);
			btScalar relLinVelocLength = relLinVel.dot(m_separatingNormal);
			if (relLinVelocLength < 0.f)
			{
				relLinVelocLength = 0.f;
			}

			btScalar projectedMotion = maxAngularProjectedVelocity + relLinVelocLength;
			m_separatingDistance -= projectedMotion;
		}

		m_posA = toPosA;
		m_posB = toPosB;
		m_ornA = toOrnA;
		m_ornB = toOrnB;
	}

	void initSeparatingDistance(const btVector3& separatingVector, btScalar separatingDistance, const btTransform& transA, const btTransform& transB)
	{
		m_separatingDistance = separatingDistance;

		if (m_separatingDistance > 0.f)
		{
			m_separatingNormal = separatingVector;

			const btVector3& toPosA = transA.getOrigin();
			const btVector3& toPosB = transB.getOrigin();
			btQuaternion toOrnA = transA.getRotation();
			btQuaternion toOrnB = transB.getRotation();
			m_posA = toPosA;
			m_posB = toPosB;
			m_ornA = toOrnA;
			m_ornB = toOrnB;
		}
	}
};

#endif  //BT_TRANSFORM_UTIL_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SOLVER_BODY_H
#define BT_SOLVER_BODY_H

class btRigidBody;
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"

#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btTransformUtil.h"

///Until we get other contributions, only use SIMD on Windows, when using Visual Studio 2008 or later, and not double precision
#ifdef BT_USE_SSE
#define USE_SIMD 1
#endif  //

#ifdef USE_SIMD

struct btSimdScalar
{
	SIMD_FORCE_INLINE btSimdScalar()
	{
	}

	SIMD_FORCE_INLINE btSimdScalar(float fl)
		: m_vec128(_mm_set1_ps(fl))
	{
	}

	SIMD_FORCE_INLINE btSimdScalar(__m128 v128)
		: m_vec128(v128)
	{
	}
	union {
		__m128 m_vec128;
		float m_floats[4];
		int m_ints[4];
		btScalar m_unusedPadding;
	};
	SIMD_FORCE_INLINE __m128 get128()
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE const __m128 get128() const
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE void set128(__m128 v128)
	{
		m_vec128 = v128;
	}

	SIMD_FORCE_INLINE operator __m128()
	{
		return m_vec128;
	}
	SIMD_FORCE_INLINE operator const __m128() const
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE operator float() const
	{
		return m_floats[0];
	}
};

///@brief Return the elementwise product of two btSimdScalar
SIMD_FORCE_INLINE btSimdScalar
operator*(const btSimdScalar& v1, const btSimdScalar& v2)
{
	return btSimdScalar(_mm_mul_ps(v1.get128(), v2.get128()));
}

///@brief Return the elementwise product of two btSimdScalar
SIMD_FORCE_INLINE btSimdScalar
operator+(const btSimdScalar& v1, const btSimdScalar& v2)
{
	return btSimdScalar(_mm_add_ps(v1.get128(), v2.get128()));
}

#else
#define btSimdScalar btScalar
#endif

///The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
ATTRIBUTE_ALIGNED16(struct)
btSolverBody
{
	BT_DECLARE_ALIGNED_ALLOCATOR();
	btTransform m_worldTransform;
	btVector3 m_deltaLinearVelocity;
	btVector3 m_deltaAngularVelocity;
	btVector3 m_angularFactor;
	btVector3 m_linearFactor;
	btVector3 m_invMass;
	btVector3 m_pushVelocity;
	btVector3 m_turnVelocity;
	btVector3 m_linearVelocity;
	btVector3 m_angularVelocity;
	btVector3 m_externalForceImpulse;
	btVector3 m_externalTorqueImpulse;

	btRigidBody* m_originalBody;
	void setWorldTransform(const btTransform& worldTransform)
	{
		m_worldTransform = worldTransform;
	}

	const btTransform& getWorldTransform() const
	{
		return m_worldTransform;
	}

	SIMD_FORCE_INLINE void getVelocityInLocalPointNoDelta(const btVector3& rel_pos, btVector3& velocity) const
	{
		if (m_originalBody)
			velocity = m_linearVelocity + m_externalForceImpulse + (m_angularVelocity + m_externalTorqueImpulse).cross(rel_pos);
		else
			velocity.setValue(0, 0, 0);
	}

	SIMD_FORCE_INLINE void getVelocityInLocalPointObsolete(const btVector3& rel_pos, btVector3& velocity) const
	{
		if (m_originalBody)
			velocity = m_linearVelocity + m_deltaLinearVelocity + (m_angularVelocity + m_deltaAngularVelocity).cross(rel_pos);
		else
			velocity.setValue(0, 0, 0);
	}

	SIMD_FORCE_INLINE void getAngularVelocity(btVector3 & angVel) const
	{
		if (m_originalBody)
			angVel = m_angularVelocity + m_deltaAngularVelocity;
		else
			angVel.setValue(0, 0, 0);
	}

	//Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
	SIMD_FORCE_INLINE void applyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_deltaLinearVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_deltaAngularVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	SIMD_FORCE_INLINE void internalApplyPushImpulse(const btVector3& linearComponent, const btVector3& angularComponent, btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_pushVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_turnVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	const btVector3& getDeltaLinearVelocity() const
	{
		return m_deltaLinearVelocity;
	}

	const btVector3& getDeltaAngularVelocity() const
	{
		return m_deltaAngularVelocity;
	}

	const btVector3& getPushVelocity() const
	{
		return m_pushVelocity;
	}

	const btVector3& getTurnVelocity() const
	{
		return m_turnVelocity;
	}

	////////////////////////////////////////////////
	///some internal methods, don't use them

	btVector3& internalGetDeltaLinearVelocity()
	{
		return m_deltaLinearVelocity;
	}

	btVector3& internalGetDeltaAngularVelocity()
	{
		return m_deltaAngularVelocity;
	}

	const btVector3& internalGetAngularFactor() const
	{
		return m_angularFactor;
	}

	const btVector3& internalGetInvMass() const
	{
		return m_invMass;
	}

	void internalSetInvMass(const btVector3& invMass)
	{
		m_invMass = invMass;
	}

	btVector3& internalGetPushVelocity()
	{
		return m_pushVelocity;
	}

	btVector3& internalGetTurnVelocity()
	{
		return m_turnVelocity;
	}

	SIMD_FORCE_INLINE void internalGetVelocityInLocalPointObsolete(const btVector3& rel_pos, btVector3& velocity) const
	{
		velocity = m_linearVelocity + m_deltaLinearVelocity + (m_angularVelocity + m_deltaAngularVelocity).cross(rel_pos);
	}

	SIMD_FORCE_INLINE void internalGetAngularVelocity(btVector3 & angVel) const
	{
		angVel = m_angularVelocity + m_deltaAngularVelocity;
	}

	//Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
	SIMD_FORCE_INLINE void internalApplyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_deltaLinearVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_deltaAngularVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	void writebackVelocity()
	{
		if (m_originalBody)
		{
			m_linearVelocity += m_deltaLinearVelocity;
			m_angularVelocity += m_deltaAngularVelocity;

			//m_originalBody->setCompanionId(-1);
		}
	}

	void writebackVelocityAndTransform(btScalar timeStep, btScalar splitImpulseTurnErp)
	{
		(void)timeStep;
		if (m_originalBody)
		{
			m_linearVelocity += m_deltaLinearVelocity;
			m_angularVelocity += m_deltaAngularVelocity;

			//correct the position/orientation based on push/turn recovery
			btTransform newTransform;
			if (m_pushVelocity[0] != 0.f || m_pushVelocity[1] != 0 || m_pushVelocity[2] != 0 || m_turnVelocity[0] != 0.f || m_turnVelocity[1] != 0 || m_turnVelocity[2] != 0)
			{
				//	btQuaternion orn = m_worldTransform.getRotation();
				btTransformUtil::integrateTransform(m_worldTransform, m_pushVelocity, m_turnVelocity * splitImpulseTurnErp, timeStep, newTransform);
				m_worldTransform = newTransform;
			}
			//m_worldTransform.setRotation(orn);
			//m_originalBody->setCompanionId(-1);
		}
	}
};

#endif  //BT_SOLVER_BODY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SOLVER_CONSTRAINT_H
#define BT_SOLVER_CONSTRAINT_H

class btRigidBody;
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "LinearMath/btAlignedObjectArray.h"

//#define NO_FRICTION_TANGENTIALS 1
#include "BulletDynamics/ConstraintSolver/btSolverBody.h"

///1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
ATTRIBUTE_ALIGNED16(struct)
btSolverConstraint
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btVector3 m_relpos1CrossNormal;
	btVector3 m_contactNormal1;

	btVector3 m_relpos2CrossNormal;
	btVector3 m_contactNormal2;  //usually m_contactNormal2 == -m_contactNormal1, but not always

	btVector3 m_angularComponentA;
	btVector3 m_angularComponentB;

	mutable btSimdScalar m_appliedPushImpulse;
	mutable btSimdScalar m_appliedImpulse;

	btScalar m_friction;
	btScalar m_jacDiagABInv;
	btScalar m_rhs;
	btScalar m_cfm;

	btScalar m_lowerLimit;
	btScalar m_upperLimit;
	btScalar m_rhsPenetration;
	union {
		void* m_originalContactPoint;
		btScalar m_unusedPadding4;
		int m_numRowsForNonContactConstraint;
	};

	int m_overrideNumSolverIterations;
	int m_frictionIndex;
	int m_solverBodyIdA;
	int m_solverBodyIdB;

	enum btSolverConstraintType
	{
		BT_SOLVER_CONTACT_1D = 0,
		BT_SOLVER_FRICTION_1D
	};
};

typedef btAlignedObjectArray<btSolverConstraint> btConstraintArray;

#endif  //BT_SOLVER_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2010 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TYPED_CONSTRAINT_H
#define BT_TYPED_CONSTRAINT_H

#include "LinearMath/btScalar.h"
#include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTypedConstraintData2 btTypedConstraintDoubleData
#define btTypedConstraintDataName "btTypedConstraintDoubleData"
#else
#define btTypedConstraintData2 btTypedConstraintFloatData
#define btTypedConstraintDataName "btTypedConstraintFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

class btSerializer;

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
enum btTypedConstraintType
{
	POINT2POINT_CONSTRAINT_TYPE = 3,
	HINGE_CONSTRAINT_TYPE,
	CONETWIST_CONSTRAINT_TYPE,
	D6_CONSTRAINT_TYPE,
	SLIDER_CONSTRAINT_TYPE,
	CONTACT_CONSTRAINT_TYPE,
	D6_SPRING_CONSTRAINT_TYPE,
	GEAR_CONSTRAINT_TYPE,
	FIXED_CONSTRAINT_TYPE,
	D6_SPRING_2_CONSTRAINT_TYPE,
	MAX_CONSTRAINT_TYPE
};

enum btConstraintParams
{
	BT_CONSTRAINT_ERP = 1,
	BT_CONSTRAINT_STOP_ERP,
	BT_CONSTRAINT_CFM,
	BT_CONSTRAINT_STOP_CFM
};

#if 1
#define btAssertConstrParams(_par) btAssert(_par)
#else
#define btAssertConstrParams(_par)
#endif

ATTRIBUTE_ALIGNED16(struct)
btJointFeedback
{
	BT_DECLARE_ALIGNED_ALLOCATOR();
	btVector3 m_appliedForceBodyA;
	btVector3 m_appliedTorqueBodyA;
	btVector3 m_appliedForceBodyB;
	btVector3 m_appliedTorqueBodyB;
};

///TypedConstraint is the baseclass for Bullet constraints and vehicles
ATTRIBUTE_ALIGNED16(class)
btTypedConstraint : public btTypedObject
{
	int m_userConstraintType;

	union {
		int m_userConstraintId;
		void* m_userConstraintPtr;
	};

	btScalar m_breakingImpulseThreshold;
	bool m_isEnabled;
	bool m_needsFeedback;
	int m_overrideNumSolverIterations;

	btTypedConstraint& operator=(btTypedConstraint& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

protected:
	btRigidBody& m_rbA;
	btRigidBody& m_rbB;
	btScalar m_appliedImpulse;
	btScalar m_dbgDrawSize;
	btJointFeedback* m_jointFeedback;

	///internal method used by the constraint solver, don't use them directly
	btScalar getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btTypedConstraint(){};
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA);
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA, btRigidBody & rbB);

	struct btConstraintInfo1
	{
		int m_numConstraintRows, nub;
	};

	static btRigidBody& getFixedBody();

	struct btConstraintInfo2
	{
		// integrator parameters: frames per second (1/stepsize), default error
		// reduction parameter (0..1).
		btScalar fps, erp;

		// for the first and second body, pointers to two (linear and angular)
		// n*3 jacobian sub matrices, stored by rows. these matrices will have
		// been initialized to 0 on entry. if the second body is zero then the
		// J2xx pointers may be 0.
		btScalar *m_J1linearAxis, *m_J1angularAxis, *m_J2linearAxis, *m_J2angularAxis;

		// elements to jump from one row to the next in J's
		int rowskip;

		// right hand sides of the equation J*v = c + cfm * lambda. cfm is the
		// "constraint force mixing" vector. c is set to zero on entry, cfm is
		// set to a constant value (typically very small or zero) value on entry.
		btScalar *m_constraintError, *cfm;

		// lo and hi limits for variables (set to -/+ infinity on entry).
		btScalar *m_lowerLimit, *m_upperLimit;

		// number of solver iterations
		int m_numIterations;

		//damping of the velocity
		btScalar m_damping;
	};

	int getOverrideNumSolverIterations() const
	{
		return m_overrideNumSolverIterations;
	}

	///override the number of constraint solver iterations used to solve this constraint
	///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
	void setOverrideNumSolverIterations(int overideNumIterations)
	{
		m_overrideNumSolverIterations = overideNumIterations;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void buildJacobian(){};

	///internal method used by the constraint solver, don't use them directly
	virtual void setupSolverConstraint(btConstraintArray & ca, int solverBodyA, int solverBodyB, btScalar timeStep)
	{
		(void)ca;
		(void)solverBodyA;
		(void)solverBodyB;
		(void)timeStep;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo1(btConstraintInfo1 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo2(btConstraintInfo2 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	void internalSetAppliedImpulse(btScalar appliedImpulse)
	{
		m_appliedImpulse = appliedImpulse;
	}
	///internal method used by the constraint solver, don't use them directly
	btScalar internalGetAppliedImpulse()
	{
		return m_appliedImpulse;
	}

	btScalar getBreakingImpulseThreshold() const
	{
		return m_breakingImpulseThreshold;
	}

	void setBreakingImpulseThreshold(btScalar threshold)
	{
		m_breakingImpulseThreshold = threshold;
	}

	bool isEnabled() const
	{
		return m_isEnabled;
	}

	void setEnabled(bool enabled)
	{
		m_isEnabled = enabled;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void solveConstraintObsolete(btSolverBody& /*bodyA*/, btSolverBody& /*bodyB*/, btScalar /*timeStep*/){};

	const btRigidBody& getRigidBodyA() const
	{
		return m_rbA;
	}
	const btRigidBody& getRigidBodyB() const
	{
		return m_rbB;
	}

	btRigidBody& getRigidBodyA()
	{
		return m_rbA;
	}
	btRigidBody& getRigidBodyB()
	{
		return m_rbB;
	}

	int getUserConstraintType() const
	{
		return m_userConstraintType;
	}

	void setUserConstraintType(int userConstraintType)
	{
		m_userConstraintType = userConstraintType;
	};

	void setUserConstraintId(int uid)
	{
		m_userConstraintId = uid;
	}

	int getUserConstraintId() const
	{
		return m_userConstraintId;
	}

	void setUserConstraintPtr(void* ptr)
	{
		m_userConstraintPtr = ptr;
	}

	void* getUserConstraintPtr()
	{
		return m_userConstraintPtr;
	}

	void setJointFeedback(btJointFeedback * jointFeedback)
	{
		m_jointFeedback = jointFeedback;
	}

	const btJointFeedback* getJointFeedback() const
	{
		return m_jointFeedback;
	}

	btJointFeedback* getJointFeedback()
	{
		return m_jointFeedback;
	}

	int getUid() const
	{
		return m_userConstraintId;
	}

	bool needsFeedback() const
	{
		return m_needsFeedback;
	}

	///enableFeedback will allow to read the applied linear and angular impulse
	///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
	void enableFeedback(bool needsFeedback)
	{
		m_needsFeedback = needsFeedback;
	}

	///getAppliedImpulse is an estimated total applied impulse.
	///This feedback could be used to determine breaking constraints or playing sounds.
	btScalar getAppliedImpulse() const
	{
		btAssert(m_needsFeedback);
		return m_appliedImpulse;
	}

	btTypedConstraintType getConstraintType() const
	{
		return btTypedConstraintType(m_objectType);
	}

	void setDbgDrawSize(btScalar dbgDrawSize)
	{
		m_dbgDrawSize = dbgDrawSize;
	}
	btScalar getDbgDrawSize()
	{
		return m_dbgDrawSize;
	}

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1) = 0;

	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const = 0;

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

// returns angle in range [-SIMD_2_PI, SIMD_2_PI], closest to one of the limits
// all arguments should be normalized angles (i.e. in range [-SIMD_PI, SIMD_PI])
SIMD_FORCE_INLINE btScalar btAdjustAngleToLimits(btScalar angleInRadians, btScalar angleLowerLimitInRadians, btScalar angleUpperLimitInRadians)
{
	if (angleLowerLimitInRadians >= angleUpperLimitInRadians)
	{
		return angleInRadians;
	}
	else if (angleInRadians < angleLowerLimitInRadians)
	{
		btScalar diffLo = btFabs(btNormalizeAngle(angleLowerLimitInRadians - angleInRadians));
		btScalar diffHi = btFabs(btNormalizeAngle(angleUpperLimitInRadians - angleInRadians));
		return (diffLo < diffHi) ? angleInRadians : (angleInRadians + SIMD_2_PI);
	}
	else if (angleInRadians > angleUpperLimitInRadians)
	{
		btScalar diffHi = btFabs(btNormalizeAngle(angleInRadians - angleUpperLimitInRadians));
		btScalar diffLo = btFabs(btNormalizeAngle(angleInRadians - angleLowerLimitInRadians));
		return (diffLo < diffHi) ? (angleInRadians - SIMD_2_PI) : angleInRadians;
	}
	else
	{
		return angleInRadians;
	}
}

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btTypedConstraintFloatData
{
	btRigidBodyFloatData		*m_rbA;
	btRigidBodyFloatData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64

#define BT_BACKWARDS_COMPATIBLE_SERIALIZATION
#ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
///this structure is not used, except for loading pre-2.82 .bullet files
struct	btTypedConstraintData
{
	btRigidBodyData		*m_rbA;
	btRigidBodyData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};
#endif //BACKWARDS_COMPATIBLE

struct	btTypedConstraintDoubleData
{
	btRigidBodyDoubleData		*m_rbA;
	btRigidBodyDoubleData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	double	m_appliedImpulse;
	double	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	double	m_breakingImpulseThreshold;
	int		m_isEnabled;
	char	padding[4];
	
};

// clang-format on

SIMD_FORCE_INLINE int btTypedConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btTypedConstraintData2);
}

class btAngularLimit
{
private:
	btScalar
		m_center,
		m_halfRange,
		m_softness,
		m_biasFactor,
		m_relaxationFactor,
		m_correction,
		m_sign;

	bool
		m_solveLimit;

public:
	/// Default constructor initializes limit as inactive, allowing free constraint movement
	btAngularLimit()
		: m_center(0.0f),
		  m_halfRange(-1.0f),
		  m_softness(0.9f),
		  m_biasFactor(0.3f),
		  m_relaxationFactor(1.0f),
		  m_correction(0.0f),
		  m_sign(0.0f),
		  m_solveLimit(false)
	{
	}

	/// Sets all limit's parameters.
	/// When low > high limit becomes inactive.
	/// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
	void set(btScalar low, btScalar high, btScalar _softness = 0.9f, btScalar _biasFactor = 0.3f, btScalar _relaxationFactor = 1.0f);

	/// Checks conastaint angle against limit. If limit is active and the angle violates the limit
	/// correction is calculated.
	void test(const btScalar angle);

	/// Returns limit's softness
	inline btScalar getSoftness() const
	{
		return m_softness;
	}

	/// Returns limit's bias factor
	inline btScalar getBiasFactor() const
	{
		return m_biasFactor;
	}

	/// Returns limit's relaxation factor
	inline btScalar getRelaxationFactor() const
	{
		return m_relaxationFactor;
	}

	/// Returns correction value evaluated when test() was invoked
	inline btScalar getCorrection() const
	{
		return m_correction;
	}

	/// Returns sign value evaluated when test() was invoked
	inline btScalar getSign() const
	{
		return m_sign;
	}

	/// Gives half of the distance between min and max limit angle
	inline btScalar getHalfRange() const
	{
		return m_halfRange;
	}

	/// Returns true when the last test() invocation recognized limit violation
	inline bool isLimit() const
	{
		return m_solveLimit;
	}

	/// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
	/// returned is modified so it equals to the limit closest to given angle.
	void fit(btScalar& angle) const;

	/// Returns correction value multiplied by sign value
	btScalar getError() const;

	btScalar getLow() const;

	btScalar getHigh() const;
};

#endif  //BT_TYPED_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btSerializer.h"

#define DEFAULT_DEBUGDRAW_SIZE btScalar(0.05f)

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(getFixedBody()),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA, btRigidBody& rbB)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(rbB),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btScalar btTypedConstraint::getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact)
{
	if (lowLim > uppLim)
	{
		return btScalar(1.0f);
	}
	else if (lowLim == uppLim)
	{
		return btScalar(0.0f);
	}
	btScalar lim_fact = btScalar(1.0f);
	btScalar delta_max = vel / timeFact;
	if (delta_max < btScalar(0.0f))
	{
		if ((pos >= lowLim) && (pos < (lowLim - delta_max)))
		{
			lim_fact = (lowLim - pos) / delta_max;
		}
		else if (pos < lowLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else if (delta_max > btScalar(0.0f))
	{
		if ((pos <= uppLim) && (pos > (uppLim - delta_max)))
		{
			lim_fact = (uppLim - pos) / delta_max;
		}
		else if (pos > uppLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else
	{
		lim_fact = btScalar(0.0f);
	}
	return lim_fact;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btTypedConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btTypedConstraintData2* tcd = (btTypedConstraintData2*)dataBuffer;

	tcd->m_rbA = (btRigidBodyData*)serializer->getUniquePointer(&m_rbA);
	tcd->m_rbB = (btRigidBodyData*)serializer->getUniquePointer(&m_rbB);
	char* name = (char*)serializer->findNameForPointer(this);
	tcd->m_name = (char*)serializer->getUniquePointer(name);
	if (tcd->m_name)
	{
		serializer->serializeName(name);
	}

	tcd->m_objectType = m_objectType;
	tcd->m_needsFeedback = m_needsFeedback;
	tcd->m_overrideNumSolverIterations = m_overrideNumSolverIterations;
	tcd->m_breakingImpulseThreshold = m_breakingImpulseThreshold;
	tcd->m_isEnabled = m_isEnabled ? 1 : 0;

	tcd->m_userConstraintId = m_userConstraintId;
	tcd->m_userConstraintType = m_userConstraintType;

	tcd->m_appliedImpulse = m_appliedImpulse;
	tcd->m_dbgDrawSize = m_dbgDrawSize;

	tcd->m_disableCollisionsBetweenLinkedBodies = false;

	int i;
	for (i = 0; i < m_rbA.getNumConstraintRefs(); i++)
		if (m_rbA.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;
	for (i = 0; i < m_rbB.getNumConstraintRefs(); i++)
		if (m_rbB.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;

	return btTypedConstraintDataName;
}

btRigidBody& btTypedConstraint::getFixedBody()
{
	static btRigidBody s_fixed(0, 0, 0);
	s_fixed.setMassProps(btScalar(0.), btVector3(btScalar(0.), btScalar(0.), btScalar(0.)));
	return s_fixed;
}

void btAngularLimit::set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor)
{
	m_halfRange = (high - low) / 2.0f;
	m_center = btNormalizeAngle(low + m_halfRange);
	m_softness = _softness;
	m_biasFactor = _biasFactor;
	m_relaxationFactor = _relaxationFactor;
}

void btAngularLimit::test(const btScalar angle)
{
	m_correction = 0.0f;
	m_sign = 0.0f;
	m_solveLimit = false;

	if (m_halfRange >= 0.0f)
	{
		btScalar deviation = btNormalizeAngle(angle - m_center);
		if (deviation < -m_halfRange)
		{
			m_solveLimit = true;
			m_correction = -(deviation + m_halfRange);
			m_sign = +1.0f;
		}
		else if (deviation > m_halfRange)
		{
			m_solveLimit = true;
			m_correction = m_halfRange - deviation;
			m_sign = -1.0f;
		}
	}
}

btScalar btAngularLimit::getError() const
{
	return m_correction * m_sign;
}

void btAngularLimit::fit(btScalar& angle) const
{
	if (m_halfRange > 0.0f)
	{
		btScalar relativeAngle = btNormalizeAngle(angle - m_center);
		if (!btEqual(relativeAngle, m_halfRange))
		{
			if (relativeAngle > 0.0f)
			{
				angle = getHigh();
			}
			else
			{
				angle = getLow();
			}
		}
	}
}

btScalar btAngularLimit::getLow() const
{
	return btNormalizeAngle(m_center - m_halfRange);
}

btScalar btAngularLimit::getHigh() const
{
	return btNormalizeAngle(m_center + m_halfRange);
}



#ifdef __cplusplus
extern "C" {
#endif

void _wrap_Swig_free_mbt_c407977658d33772(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  Swig_free(arg1);
  
}


void *_wrap_Swig_malloc_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (void *)Swig_malloc(arg1);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetVersion_mbt_c407977658d33772() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetVersion();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsDoublePrecision_mbt_c407977658d33772() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btIsDoublePrecision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_0_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btInfMaskConverter *)new btInfMaskConverter(arg1);
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_1_mbt_c407977658d33772() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)new btInfMaskConverter();
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


void _wrap_delete_btInfMaskConverter_mbt_c407977658d33772(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btInfinityMask_set_mbt_c407977658d33772(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  btInfinityMask = *arg1;
  
}


btInfMaskConverter *_wrap_btInfinityMask_get_mbt_c407977658d33772() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)&btInfinityMask;
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetInfinityMask_mbt_c407977658d33772() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetInfinityMask();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSqrt_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSqrt(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFabs_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btFabs(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCos_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btCos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSin_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTan_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btTan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAcos_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAcos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAsin_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAsin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAtan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btExp_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btExp(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLog_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btLog(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPow_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btPow(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFmod_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btFmod(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2Fast_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2Fast(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btFuzzyZero_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (bool)btFuzzyZero(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btEqual_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGreaterEqual_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btGreaterEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsNegative_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (int)btIsNegative(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRadians_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btRadians(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDegrees_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btDegrees(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFsel_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btFsel(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btMachineIsLittleEndian_mbt_c407977658d33772() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)btMachineIsLittleEndian();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_0_mbt_c407977658d33772(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  
  result = (unsigned int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_1_mbt_c407977658d33772(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSelect__SWIG_2_mbt_c407977658d33772(intgo _swig_go_0, float _swig_go_1, float _swig_go_2) {
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  arg3 = (float)_swig_go_2; 
  
  result = (float)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_0_mbt_c407977658d33772(intgo _swig_go_0) {
  unsigned int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_1_mbt_c407977658d33772(short _swig_go_0) {
  unsigned short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (unsigned short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_2_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_3_mbt_c407977658d33772(short _swig_go_0) {
  short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndianFloat_mbt_c407977658d33772(float _swig_go_0) {
  float arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (float)_swig_go_0; 
  
  result = (unsigned int)btSwapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btUnswapEndianFloat_mbt_c407977658d33772(intgo _swig_go_0) {
  unsigned int arg1 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (float)btUnswapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSwapEndianDouble_mbt_c407977658d33772(double _swig_go_0, char *_swig_go_1) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (double)_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  btSwapEndianDouble(arg1,arg2);
  
}


double _wrap_btUnswapEndianDouble_mbt_c407977658d33772(char *_swig_go_0) {
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(unsigned char **)&_swig_go_0; 
  
  result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLargeDot_mbt_c407977658d33772(float *_swig_go_0, float *_swig_go_1, intgo _swig_go_2) {
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btScalar **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btNormalizeAngle_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btNormalizeAngle(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedObject *_wrap_new_btTypedObject_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  btTypedObject *result = 0 ;
  btTypedObject *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btTypedObject *)new btTypedObject(arg1);
  *(btTypedObject **)&_swig_go_result = (btTypedObject *)result; 
  return _swig_go_result;
}


void _wrap_btTypedObject_m_objectType_set_mbt_c407977658d33772(btTypedObject *_swig_go_0, intgo _swig_go_1) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedObject_m_objectType_get_mbt_c407977658d33772(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedObject_getObjectType_mbt_c407977658d33772(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int)((btTypedObject const *)arg1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedObject_mbt_c407977658d33772(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void *_wrap_btAlignedAllocInternal_mbt_c407977658d33772(long long _swig_go_0, intgo _swig_go_1) {
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)btAlignedAllocInternal(SWIG_STD_MOVE(arg1),arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btAlignedFreeInternal_mbt_c407977658d33772(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btAlignedFreeInternal(arg1);
  
}


void _wrap_btAlignedAllocSetCustom_mbt_c407977658d33772(void* _swig_go_0, void* _swig_go_1) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  btFreeFunc *arg2 = (btFreeFunc *) 0 ;
  
  arg1 = *(btAllocFunc **)&_swig_go_0; 
  arg2 = *(btFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustom(arg1,arg2);
  
}


void _wrap_btAlignedAllocSetCustomAligned_mbt_c407977658d33772(void* _swig_go_0, void* _swig_go_1) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  btAlignedFreeFunc *arg2 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = *(btAlignedAllocFunc **)&_swig_go_0; 
  arg2 = *(btAlignedFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustomAligned(arg1,arg2);
  
}


void *_wrap_btAllocDefault_mbt_c407977658d33772(long long _swig_go_0) {
  size_t arg1 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  
  result = (void *)btAllocDefault(SWIG_STD_MOVE(arg1));
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btFreeDefault_mbt_c407977658d33772(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btFreeDefault(arg1);
  
}


void _wrap_sAllocFunc_set_mbt_c407977658d33772(void* _swig_go_0) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  
  arg1 = *(btAllocFunc **)&_swig_go_0; 
  
  sAllocFunc = arg1;
  
}


void* _wrap_sAllocFunc_get_mbt_c407977658d33772() {
  btAllocFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAllocFunc *)sAllocFunc;
  *(btAllocFunc **)&_swig_go_result = (btAllocFunc *)result; 
  return _swig_go_result;
}


void _wrap_sFreeFunc_set_mbt_c407977658d33772(void* _swig_go_0) {
  btFreeFunc *arg1 = (btFreeFunc *) 0 ;
  
  arg1 = *(btFreeFunc **)&_swig_go_0; 
  
  sFreeFunc = arg1;
  
}


void* _wrap_sFreeFunc_get_mbt_c407977658d33772() {
  btFreeFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btFreeFunc *)sFreeFunc;
  *(btFreeFunc **)&_swig_go_result = (btFreeFunc *)result; 
  return _swig_go_result;
}


void *_wrap_btAlignedAllocDefault_mbt_c407977658d33772(long long _swig_go_0, intgo _swig_go_1) {
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)btAlignedAllocDefault(SWIG_STD_MOVE(arg1),arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btAlignedFreeDefault_mbt_c407977658d33772(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btAlignedFreeDefault(arg1);
  
}


void _wrap_sAlignedAllocFunc_set_mbt_c407977658d33772(void* _swig_go_0) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  
  arg1 = *(btAlignedAllocFunc **)&_swig_go_0; 
  
  sAlignedAllocFunc = arg1;
  
}


void* _wrap_sAlignedAllocFunc_get_mbt_c407977658d33772() {
  btAlignedAllocFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAlignedAllocFunc *)sAlignedAllocFunc;
  *(btAlignedAllocFunc **)&_swig_go_result = (btAlignedAllocFunc *)result; 
  return _swig_go_result;
}


void _wrap_sAlignedFreeFunc_set_mbt_c407977658d33772(void* _swig_go_0) {
  btAlignedFreeFunc *arg1 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = *(btAlignedFreeFunc **)&_swig_go_0; 
  
  sAlignedFreeFunc = arg1;
  
}


void* _wrap_sAlignedFreeFunc_get_mbt_c407977658d33772() {
  btAlignedFreeFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAlignedFreeFunc *)sAlignedFreeFunc;
  *(btAlignedFreeFunc **)&_swig_go_result = (btAlignedFreeFunc *)result; 
  return _swig_go_result;
}


void _wrap_btVector3_m_floats_set_mbt_c407977658d33772(btVector3 *_swig_go_0, float *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btVector3_m_floats_get_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_0_mbt_c407977658d33772() {
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  
  result = (btVector3 *)new btVector3();
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_1_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


float _wrap_btVector3_dot_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length2_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_norm_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_safeNorm_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_safeNormalize_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalize_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalized_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_rotate_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_angle_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_absolute_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_cross_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_triple_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_minAxis_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_maxAxis_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_furthestAxis_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_closestAxis_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_setInterpolate3_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector3_lerp_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_getX_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getY_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getZ_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setX_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btVector3_setY_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btVector3_setZ_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btVector3_setW_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btVector3_x_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_y_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_z_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_w_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setMax_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setMin_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setValue_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btVector3_getSkewSymmetricMatrix_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector3_setZero_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


bool _wrap_btVector3_isZero_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector3_fuzzyZero_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_serialize_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_0_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_1_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeFloat_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btVector3_deSerializeFloat_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeDouble_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btVector3_deSerializeDouble_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector3_maxDot_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector3_minDot_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_dot3_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_delete_btVector3_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btDot_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_0_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCross_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btTriple_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_lerp_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_0_mbt_c407977658d33772() {
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  
  result = (btVector4 *)new btVector4();
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_1_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_btVector4_absolute4_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  btVector4 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = ((btVector4 const *)arg1)->absolute4();
  *(btVector4 **)&_swig_go_result = new btVector4(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getW_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (btScalar)((btVector4 const *)arg1)->getW();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis4_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->maxAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis4_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->minAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis4_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->closestAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setValue_mbt_c407977658d33772(btVector4 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_delete_btVector4_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtVector4_M_floats_mbt_c407977658d33772(btVector4 *_swig_go_0, float *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ;
  
}


float *_wrap_GetbtVector4_M_floats_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *)(btScalar *) ((swig_b0)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_dot_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length2_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_norm_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_safeNorm_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance2_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_safeNormalize_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalize_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalized_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_rotate_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_angle_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_absolute_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_cross_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_triple_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_furthestAxis_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setInterpolate3_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector4_lerp_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getX_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getY_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getZ_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setX_mbt_c407977658d33772(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btVector4_setY_mbt_c407977658d33772(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btVector4_setZ_mbt_c407977658d33772(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btVector4_setW_mbt_c407977658d33772(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btVector4_x_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_y_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_z_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_w_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setMax_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_setMin_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_getSkewSymmetricMatrix_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector4_setZero_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZero();
  
}


bool _wrap_btVector4_isZero_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector4_fuzzyZero_mbt_c407977658d33772(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_serialize_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serialize(*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_0_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_1_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeFloat_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeFloat(*arg2);
  
}


void _wrap_btVector4_deSerializeFloat_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeDouble_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeDouble(*arg2);
  
}


void _wrap_btVector4_deSerializeDouble_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector4_maxDot_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector4_minDot_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_dot3_mbt_c407977658d33772(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSwapScalarEndian_mbt_c407977658d33772(float _swig_go_0, float *_swig_go_1) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btSwapScalarEndian((float const &)*arg1,*arg2);
  
}


void _wrap_btSwapVector3Endian_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
  
}


void _wrap_btUnSwapVector3Endian_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  btUnSwapVector3Endian(*arg1);
  
}


void _wrap_btVector3FloatData_m_floats_set_mbt_c407977658d33772(btVector3FloatData *_swig_go_0, float *_swig_go_1) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btVector3FloatData_m_floats_get_mbt_c407977658d33772(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3FloatData *_wrap_new_btVector3FloatData_mbt_c407977658d33772() {
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  
  result = (btVector3FloatData *)new btVector3FloatData();
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3FloatData_mbt_c407977658d33772(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btVector3DoubleData_m_floats_set_mbt_c407977658d33772(btVector3DoubleData *_swig_go_0, double *_swig_go_1) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btVector3DoubleData_m_floats_get_mbt_c407977658d33772(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3DoubleData *_wrap_new_btVector3DoubleData_mbt_c407977658d33772() {
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  
  result = (btVector3DoubleData *)new btVector3DoubleData();
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3DoubleData_mbt_c407977658d33772(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuadWord_getX_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getY_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getZ_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setX_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btQuadWord_setY_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btQuadWord_setZ_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btQuadWord_setW_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btQuadWord_x_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_y_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_z_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_w_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setValue__SWIG_0_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuadWord_setValue__SWIG_1_mbt_c407977658d33772(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


btQuadWord *_wrap_new_btQuadWord__SWIG_0_mbt_c407977658d33772() {
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  
  result = (btQuadWord *)new btQuadWord();
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_1_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_2_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setMax_mbt_c407977658d33772(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuadWord_setMin_mbt_c407977658d33772(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMin((btQuadWord const &)*arg2);
  
}


void _wrap_delete_btQuadWord_mbt_c407977658d33772(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  delete arg1;
  
}


btQuaternion *_wrap_new_btQuaternion__SWIG_0_mbt_c407977658d33772() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *)new btQuaternion();
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_1_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_2_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  
  result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_3_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setRotation_mbt_c407977658d33772(btQuaternion *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
  
}


void _wrap_btQuaternion_setEuler_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setEulerZYX_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_getEulerZYX_mbt_c407977658d33772(btQuaternion *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btQuaternion const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


float _wrap_btQuaternion_dot_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length2_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_safeNormalize_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->safeNormalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalize_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->normalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalized_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->normalized();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


float _wrap_btQuaternion_angle_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_angleShortestPath_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngle_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngle();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngleShortestPath_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btQuaternion_getAxis_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->getAxis();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_inverse_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->inverse();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_farthest_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_nearest_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_slerp_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_getIdentity_mbt_c407977658d33772() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *) &btQuaternion::getIdentity();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getW_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuaternion const *)arg1)->getW();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_serialize_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serialize(*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_0_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_1_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeFloat_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btQuaternion_deSerializeFloat_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeDouble_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btQuaternion_deSerializeDouble_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_delete_btQuaternion_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuaternion_getX_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getY_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getZ_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setX_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btQuaternion_setY_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btQuaternion_setZ_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btQuaternion_setW_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btQuaternion_x_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_y_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_z_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_w_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setValue__SWIG_0_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setValue__SWIG_1_mbt_c407977658d33772(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_btQuaternion_setMax_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuaternion_setMin_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMin((btQuadWord const &)*arg2);
  
}


float _wrap_dot_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_length_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)length((btQuaternion const &)*arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_1_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_inverse_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = inverse((btQuaternion const &)*arg1);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_slerp_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btVector3 *_wrap_quatRotate_mbt_c407977658d33772(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuat_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuatNormalize2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuatNormalize2(*arg1,*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btQuaternionFloatData_m_floats_set_mbt_c407977658d33772(btQuaternionFloatData *_swig_go_0, float *_swig_go_1) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btQuaternionFloatData_m_floats_get_mbt_c407977658d33772(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionFloatData *_wrap_new_btQuaternionFloatData_mbt_c407977658d33772() {
  btQuaternionFloatData *result = 0 ;
  btQuaternionFloatData *_swig_go_result;
  
  
  result = (btQuaternionFloatData *)new btQuaternionFloatData();
  *(btQuaternionFloatData **)&_swig_go_result = (btQuaternionFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionFloatData_mbt_c407977658d33772(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuaternionDoubleData_m_floats_set_mbt_c407977658d33772(btQuaternionDoubleData *_swig_go_0, double *_swig_go_1) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btQuaternionDoubleData_m_floats_get_mbt_c407977658d33772(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionDoubleData *_wrap_new_btQuaternionDoubleData_mbt_c407977658d33772() {
  btQuaternionDoubleData *result = 0 ;
  btQuaternionDoubleData *_swig_go_result;
  
  
  result = (btQuaternionDoubleData *)new btQuaternionDoubleData();
  *(btQuaternionDoubleData **)&_swig_go_result = (btQuaternionDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionDoubleData_mbt_c407977658d33772(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_0_mbt_c407977658d33772() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *)new btMatrix3x3();
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_1_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_2_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_3_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_4_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getColumn_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getRow_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_setFromOpenGLSubMatrix_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
  
}


void _wrap_btMatrix3x3_setValue_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, float _swig_go_9) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  arg10 = (btScalar *)&_swig_go_9; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
  
}


void _wrap_btMatrix3x3_setRotation_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btMatrix3x3_setEulerYPR_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btMatrix3x3_setEulerZYX_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setEulerZYX(arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_setIdentity_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


void _wrap_btMatrix3x3_setZero_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


btMatrix3x3 *_wrap_btMatrix3x3_getIdentity_mbt_c407977658d33772() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_getOpenGLSubMatrix_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
  
}


void _wrap_btMatrix3x3_getRotation_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
  
}


void _wrap_btMatrix3x3_getEulerYPR_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_0_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = (unsigned int)_swig_go_4; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_1_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


btMatrix3x3 *_wrap_btMatrix3x3_scaled_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_determinant_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_adjoint_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->adjoint();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_absolute_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->absolute();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transpose_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->transpose();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_inverse_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->inverse();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_solve33_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->solve33((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotx_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdoty_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotz_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_extractRotation__SWIG_0_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->extractRotation(*arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_1_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->extractRotation(*arg2,arg3);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_2_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->extractRotation(*arg2);
  
}


void _wrap_btMatrix3x3_diagonalize_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->diagonalize(*arg2,arg3,arg4);
  
}


float _wrap_btMatrix3x3_cofac_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_serialize_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btMatrix3x3_serializeFloat_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btMatrix3x3_deSerialize_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeFloat_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeDouble_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
  
}


void _wrap_delete_btMatrix3x3_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3FloatData_m_el_set_mbt_c407977658d33772(btMatrix3x3FloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[3]) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btMatrix3x3FloatData_m_el_get_mbt_c407977658d33772(btMatrix3x3FloatData *_swig_go_0))[3] {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_el);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3FloatData *_wrap_new_btMatrix3x3FloatData_mbt_c407977658d33772() {
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  
  result = (btMatrix3x3FloatData *)new btMatrix3x3FloatData();
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3FloatData_mbt_c407977658d33772(btMatrix3x3FloatData *_swig_go_0) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3DoubleData_m_el_set_mbt_c407977658d33772(btMatrix3x3DoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[3]) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btMatrix3x3DoubleData_m_el_get_mbt_c407977658d33772(btMatrix3x3DoubleData *_swig_go_0))[3] {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_el);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3DoubleData *_wrap_new_btMatrix3x3DoubleData_mbt_c407977658d33772() {
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  
  result = (btMatrix3x3DoubleData *)new btMatrix3x3DoubleData();
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3DoubleData_mbt_c407977658d33772(btMatrix3x3DoubleData *_swig_go_0) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btTransform *_wrap_new_btTransform__SWIG_0_mbt_c407977658d33772() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *)new btTransform();
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_1_mbt_c407977658d33772(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_2_mbt_c407977658d33772(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_3_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_4_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_5_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btTransform const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTransform_mult_mbt_c407977658d33772(btTransform *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_0_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &(arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_1_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_0_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_1_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btTransform_getRotation_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->getRotation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setFromOpenGLMatrix_mbt_c407977658d33772(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
  
}


void _wrap_btTransform_getOpenGLMatrix_mbt_c407977658d33772(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
  
}


void _wrap_btTransform_setOrigin_mbt_c407977658d33772(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setOrigin((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btTransform_invXform_mbt_c407977658d33772(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setBasis_mbt_c407977658d33772(btTransform *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  (arg1)->setBasis((btMatrix3x3 const &)*arg2);
  
}


void _wrap_btTransform_setRotation_mbt_c407977658d33772(btTransform *_swig_go_0, btQuaternion *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btTransform_setIdentity_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


btTransform *_wrap_btTransform_inverse_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->inverse();
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_inverseTimes_mbt_c407977658d33772(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_getIdentity_mbt_c407977658d33772() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *) &btTransform::getIdentity();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransform_serialize_mbt_c407977658d33772(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serialize(*arg2);
  
}


void _wrap_btTransform_serializeFloat_mbt_c407977658d33772(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btTransform_deSerialize_mbt_c407977658d33772(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btTransformFloatData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeDouble_mbt_c407977658d33772(btTransform *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeFloat_mbt_c407977658d33772(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
  
}


void _wrap_delete_btTransform_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformFloatData_m_basis_set_mbt_c407977658d33772(btTransformFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btTransformFloatData_m_basis_get_mbt_c407977658d33772(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_basis);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformFloatData_m_origin_set_mbt_c407977658d33772(btTransformFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3FloatData *_wrap_btTransformFloatData_m_origin_get_mbt_c407977658d33772(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_origin);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


btTransformFloatData *_wrap_new_btTransformFloatData_mbt_c407977658d33772() {
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  
  result = (btTransformFloatData *)new btTransformFloatData();
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformFloatData_mbt_c407977658d33772(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformDoubleData_m_basis_set_mbt_c407977658d33772(btTransformDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btTransformDoubleData_m_basis_get_mbt_c407977658d33772(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_basis);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformDoubleData_m_origin_set_mbt_c407977658d33772(btTransformDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3DoubleData *_wrap_btTransformDoubleData_m_origin_get_mbt_c407977658d33772(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_origin);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


btTransformDoubleData *_wrap_new_btTransformDoubleData_mbt_c407977658d33772() {
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  
  result = (btTransformDoubleData *)new btTransformDoubleData();
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformDoubleData_mbt_c407977658d33772(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btMotionState_mbt_c407977658d33772(btMotionState *_swig_go_0) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMotionState_getWorldTransform_mbt_c407977658d33772(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btMotionState_setWorldTransform_mbt_c407977658d33772(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btDefaultMotionState_m_graphicsWorldTrans_set_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_graphicsWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_graphicsWorldTrans_get_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_graphicsWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_centerOfMassOffset_set_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_centerOfMassOffset = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_centerOfMassOffset_get_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_centerOfMassOffset);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_startWorldTrans_set_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_startWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_startWorldTrans_get_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_startWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_userPointer_set_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, void *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_userPointer = arg2;
  
}


void *_wrap_btDefaultMotionState_m_userPointer_get_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_userPointer);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_0_mbt_c407977658d33772(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1,(btTransform const &)*arg2);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_1_mbt_c407977658d33772(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_2_mbt_c407977658d33772() {
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  
  result = (btDefaultMotionState *)new btDefaultMotionState();
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_getWorldTransform_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btDefaultMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btDefaultMotionState_setWorldTransform_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_delete_btDefaultMotionState_mbt_c407977658d33772(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BOX_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TETRAHEDRAL_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TETRAHEDRAL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_HULL_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_HULL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_POLYHEDRAL_SHAPE_TYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_POLYHEDRAL_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_IMPLICIT_CONVEX_SHAPES_START_HERE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = IMPLICIT_CONVEX_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SPHERE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTI_SPHERE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTI_SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CAPSULE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CAPSULE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CYLINDER_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CYLINDER_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_UNIFORM_SCALING_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = UNIFORM_SCALING_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_SUM_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_SUM_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BOX_2D_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_2D_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONVEX_SHAPE_TYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONVEX_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_START_HERE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FAST_CONCAVE_MESH_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = FAST_CONCAVE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TERRAIN_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TERRAIN_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GIMPACT_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = GIMPACT_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_EMPTY_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = EMPTY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_STATIC_PLANE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = STATIC_PLANE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONCAVE_SHAPE_TYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONCAVE_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SDF_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SDF_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_END_HERE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_END_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_COMPOUND_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = COMPOUND_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOFTBODY_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SOFTBODY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_INVALID_SHAPE_PROXYTYPE_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = INVALID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_BROADPHASE_COLLISION_TYPES_mbt_c407977658d33772() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MAX_BROADPHASE_COLLISION_TYPES;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DefaultFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DefaultFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_StaticFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::StaticFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_KinematicFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::KinematicFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DebrisFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DebrisFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SensorTrigger_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::SensorTrigger;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CharacterFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::CharacterFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_AllFilter_btBroadphaseProxy_mbt_c407977658d33772() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::AllFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_clientObject_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, void *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_clientObject = arg2;
  
}


void *_wrap_btBroadphaseProxy_m_clientObject_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_clientObject);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterGroup_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterGroup_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterMask_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterMask_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_uniqueId_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_uniqueId_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMin_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMin = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMin_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMin);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMax_set_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMax = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMax_get_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMax);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


intgo _wrap_btBroadphaseProxy_getUid_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int)((btBroadphaseProxy const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_0_mbt_c407977658d33772() {
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_1_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, void *_swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  void *arg3 = (void *) 0 ;
  int arg4 ;
  int arg5 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isPolyhedral_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isPolyhedral(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isNonMoving_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isNonMoving(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConcave_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConcave(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isCompound_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isCompound(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isSoftBody_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isSoftBody(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isInfinite_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isInfinite(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex2d_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex2d(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseProxy_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_0_mbt_c407977658d33772() {
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  
  result = (btBroadphasePair *)new btBroadphasePair();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_1_mbt_c407977658d33772(btBroadphaseProxy *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphaseProxy *arg1 = 0 ;
  btBroadphaseProxy *arg2 = 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (btBroadphasePair *)new btBroadphasePair(*arg1,*arg2);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy0_set_mbt_c407977658d33772(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy0 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy0_get_mbt_c407977658d33772(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy0);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy1_set_mbt_c407977658d33772(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy1 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy1_get_mbt_c407977658d33772(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy1);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_algorithm_set_mbt_c407977658d33772(btBroadphasePair *_swig_go_0, btCollisionAlgorithm *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *arg2 = (btCollisionAlgorithm *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btCollisionAlgorithm **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_algorithm = arg2;
  
}


btCollisionAlgorithm *_wrap_btBroadphasePair_m_algorithm_get_mbt_c407977658d33772(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btCollisionAlgorithm *) ((arg1)->m_algorithm);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePair_mbt_c407977658d33772(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePairSortPredicate *_wrap_new_btBroadphasePairSortPredicate_mbt_c407977658d33772() {
  btBroadphasePairSortPredicate *result = 0 ;
  btBroadphasePairSortPredicate *_swig_go_result;
  
  
  result = (btBroadphasePairSortPredicate *)new btBroadphasePairSortPredicate();
  *(btBroadphasePairSortPredicate **)&_swig_go_result = (btBroadphasePairSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePairSortPredicate_mbt_c407977658d33772(btBroadphasePairSortPredicate *_swig_go_0) {
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  
  arg1 = *(btBroadphasePairSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btCollisionShape_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionShape_getAabb_mbt_c407977658d33772(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCollisionShape_getBoundingSphere_mbt_c407977658d33772(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCollisionShape_getAngularMotionDisc_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionShape_getContactBreakingThreshold_mbt_c407977658d33772(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateTemporalAabb_mbt_c407977658d33772(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCollisionShape_isPolyhedral_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex2d_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isNonMoving_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConcave_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isCompound_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isSoftBody_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isInfinite_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setLocalScaling_mbt_c407977658d33772(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionShape_getLocalScaling_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateLocalInertia_mbt_c407977658d33772(btCollisionShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btCollisionShape_getName_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (char *)((btCollisionShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_getShapeType_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setMargin_mbt_c407977658d33772(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btCollisionShape_getMargin_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserPointer_mbt_c407977658d33772(btCollisionShape *_swig_go_0, void *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void *_wrap_btCollisionShape_getUserPointer_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex_mbt_c407977658d33772(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex2_mbt_c407977658d33772(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex2_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_calculateSerializeBufferSize_mbt_c407977658d33772(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionShape_serialize_mbt_c407977658d33772(btCollisionShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_serializeSingleShape_mbt_c407977658d33772(btCollisionShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
  
}


void _wrap_btCollisionShapeData_m_name_set_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_name_get_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_shapeType_set_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0, intgo _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_shapeType = arg2;
  
}


intgo _wrap_btCollisionShapeData_m_shapeType_get_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_shapeType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_padding_set_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_padding_get_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCollisionShapeData *_wrap_new_btCollisionShapeData_mbt_c407977658d33772() {
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  
  result = (btCollisionShapeData *)new btCollisionShapeData();
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionShapeData_mbt_c407977658d33772(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBulletCollisionProbe_mbt_c407977658d33772() {
  btBulletCollisionProbe();
  
}


void _wrap_delete_btConvexShape_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertex_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexShape_getMarginNonVirtual_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getAabbNonVirtual_mbt_c407977658d33772(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_project_mbt_c407977658d33772(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexShape_getAabb_mbt_c407977658d33772(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_getAabbSlow_mbt_c407977658d33772(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_setLocalScaling_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexShape_getLocalScaling_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setMargin_mbt_c407977658d33772(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexShape_getMargin_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_btConvexShape_getBoundingSphere_mbt_c407977658d33772(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexShape_getAngularMotionDisc_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexShape_getContactBreakingThreshold_mbt_c407977658d33772(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateTemporalAabb_mbt_c407977658d33772(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexShape_isPolyhedral_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex2d_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isNonMoving_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConcave_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isCompound_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isSoftBody_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isInfinite_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateLocalInertia_mbt_c407977658d33772(btConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexShape_getName_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getShapeType_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = ((btCollisionShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserPointer_mbt_c407977658d33772(btConvexShape *_swig_go_0, void *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void *_wrap_btConvexShape_getUserPointer_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (void *)((btCollisionShape const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex_mbt_c407977658d33772(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex2_mbt_c407977658d33772(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex2_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_calculateSerializeBufferSize_mbt_c407977658d33772(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexShape_serialize_mbt_c407977658d33772(btConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btConvexShape_serializeSingleShape_mbt_c407977658d33772(btConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->serializeSingleShape(arg2);
  
}


btVector3 *_wrap_convexHullSupport_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = convexHullSupport((btVector3 const &)*arg1,(btVector3 const *)arg2,arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_AabbExpand_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  AabbExpand(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


bool _wrap_TestPointAgainstAabb2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestPointAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestAabbAgainstAabb2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (bool)TestAabbAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestTriangleAgainstAabb2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestTriangleAgainstAabb2((btVector3 const *)arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btOutcode_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (int)btOutcode((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb2_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo *_swig_go_2, btVector3 (*_swig_go_3)[2], float *_swig_go_4, float _swig_go_5, float _swig_go_6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int *arg3 = (unsigned int *) (unsigned int *)0 ;
  btVector3 *arg4 = (btVector3 *) (btVector3 *)0 ;
  btScalar *arg5 = 0 ;
  btScalar arg6 ;
  btScalar arg7 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(unsigned int **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  
  result = (bool)btRayAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(unsigned int const (*))arg3,(btVector3 const (*))arg4,*arg5,arg6,arg7);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  result = (bool)btRayAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransformAabb__SWIG_0_mbt_c407977658d33772(btVector3 *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  btTransformAabb((btVector3 const &)*arg1,arg2,(btTransform const &)*arg3,*arg4,*arg5);
  
}


void _wrap_btTransformAabb__SWIG_1_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  btTransformAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,*arg5,*arg6);
  
}


intgo _wrap_testQuantizedAabbAgainstQuantizedAabb_mbt_c407977658d33772(short *_swig_go_0, short *_swig_go_1, short *_swig_go_2, short *_swig_go_3) {
  unsigned short *arg1 = (unsigned short *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  unsigned short *arg3 = (unsigned short *) 0 ;
  unsigned short *arg4 = (unsigned short *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(unsigned short **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(unsigned short **)&_swig_go_2; 
  arg4 = *(unsigned short **)&_swig_go_3; 
  
  result = (unsigned int)testQuantizedAabbAgainstQuantizedAabb((unsigned short const *)arg1,(unsigned short const *)arg2,(unsigned short const *)arg3,(unsigned short const *)arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShape_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setImplicitShapeDimensions_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_getAabb_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_getAabbSlow_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_setLocalScaling_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexInternalShape_getLocalScaling_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setMargin_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexInternalShape_getMargin_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNV_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalShape_calculateSerializeBufferSize_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalShape_serialize_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNonVirtual_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = (btScalar)((btConvexShape const *)swig_b0)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getAabbNonVirtual_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_project_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalShape_getBoundingSphere_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalShape_getAngularMotionDisc_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getContactBreakingThreshold_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateTemporalAabb_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalShape_isPolyhedral_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex2d_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isNonMoving_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConcave_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isCompound_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isSoftBody_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isInfinite_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateLocalInertia_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalShape_getName_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (char *)((btCollisionShape const *)swig_b1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getShapeType_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = ((btCollisionShape const *)swig_b1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserPointer_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalShape_getUserPointer_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (void *)((btCollisionShape const *)swig_b1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex2_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex2_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_serializeSingleShape_mbt_c407977658d33772(btConvexInternalShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->serializeSingleShape(arg2);
  
}


void _wrap_btConvexInternalShapeData_m_collisionShapeData_set_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShapeData = *arg2;
  
}


btCollisionShapeData *_wrap_btConvexInternalShapeData_m_collisionShapeData_get_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *)& ((arg1)->m_collisionShapeData);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_localScaling_set_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localScaling = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_localScaling_get_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_localScaling);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_implicitShapeDimensions_set_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_implicitShapeDimensions = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_implicitShapeDimensions_get_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_implicitShapeDimensions);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_collisionMargin_set_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0, float _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionMargin = arg2;
  
}


float _wrap_btConvexInternalShapeData_m_collisionMargin_get_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_collisionMargin);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_padding_set_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btConvexInternalShapeData_m_padding_get_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexInternalShapeData *_wrap_new_btConvexInternalShapeData_mbt_c407977658d33772() {
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  
  result = (btConvexInternalShapeData *)new btConvexInternalShapeData();
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShapeData_mbt_c407977658d33772(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexInternalAabbCachingShape_setLocalScaling_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabb_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btConvexInternalAabbCachingShape_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertex_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getImplicitShapeDimensions_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setImplicitShapeDimensions_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabbSlow_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScaling_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScalingNV_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setMargin_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btConvexInternalAabbCachingShape_getMargin_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNV_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_calculateSerializeBufferSize_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_serialize_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNonVirtual_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getAabbNonVirtual_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_project_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_getBoundingSphere_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalAabbCachingShape_getAngularMotionDisc_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getContactBreakingThreshold_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateTemporalAabb_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalAabbCachingShape_isPolyhedral_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex2d_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isNonMoving_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConcave_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isCompound_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isSoftBody_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isInfinite_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateLocalInertia_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_getName_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getShapeType_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserPointer_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalAabbCachingShape_getUserPointer_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex2_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex2_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_serializeSingleShape_mbt_c407977658d33772(btConvexInternalAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


btSphereShape *_wrap_new_btSphereShape_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  btSphereShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btSphereShape *)new btSphereShape(arg1);
  *(btSphereShape **)&_swig_go_result = (btSphereShape *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertex_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btSphereShape_calculateLocalInertia_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btSphereShape_getAabb_mbt_c407977658d33772(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


float _wrap_btSphereShape_getRadius_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUnscaledRadius_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setUnscaledRadius(arg2);
  
}


_gostring_ _wrap_btSphereShape_getName_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (char *)((btSphereShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setMargin_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btSphereShape_getMargin_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSphereShape_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btSphereShape_getImplicitShapeDimensions_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setImplicitShapeDimensions_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_getAabbSlow_mbt_c407977658d33772(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_setLocalScaling_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btSphereShape_getLocalScaling_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getLocalScalingNV_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNV_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btSphereShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btSphereShape_calculateSerializeBufferSize_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btSphereShape_serialize_mbt_c407977658d33772(btSphereShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNonVirtual_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getAabbNonVirtual_mbt_c407977658d33772(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_project_mbt_c407977658d33772(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btSphereShape_getBoundingSphere_mbt_c407977658d33772(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btSphereShape_getAngularMotionDisc_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getContactBreakingThreshold_mbt_c407977658d33772(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_calculateTemporalAabb_mbt_c407977658d33772(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btSphereShape_isPolyhedral_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex2d_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isNonMoving_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConcave_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isCompound_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isSoftBody_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isInfinite_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getShapeType_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserPointer_mbt_c407977658d33772(btSphereShape *_swig_go_0, void *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btSphereShape_getUserPointer_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex_mbt_c407977658d33772(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex2_mbt_c407977658d33772(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex2_mbt_c407977658d33772(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_serializeSingleShape_mbt_c407977658d33772(btSphereShape *_swig_go_0, btSerializer *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_btConvexHullComputer_vertices_set_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexHullComputer_vertices_get_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_original_vertex_index_set_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->original_vertex_index = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_original_vertex_index_get_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->original_vertex_index);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_edges_set_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *arg2 = (btAlignedObjectArray< btConvexHullComputer::Edge > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_1; 
  
  if (arg1) (arg1)->edges = *arg2;
  
}


btAlignedObjectArray< btConvexHullComputer::Edge > *_wrap_btConvexHullComputer_edges_get_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *result = 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)& ((arg1)->edges);
  *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_faces_set_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->faces = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_faces_get_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->faces);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_0_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, float *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((float const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_1_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0, double *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((double const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullComputer *_wrap_new_btConvexHullComputer_mbt_c407977658d33772() {
  btConvexHullComputer *result = 0 ;
  btConvexHullComputer *_swig_go_result;
  
  
  result = (btConvexHullComputer *)new btConvexHullComputer();
  *(btConvexHullComputer **)&_swig_go_result = (btConvexHullComputer *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullComputer_mbt_c407977658d33772(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexHullInternal_vertexList_set_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertexList = arg2;
  
}


btConvexHullInternal::Vertex *_wrap_btConvexHullInternal_vertexList_get_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *result = 0 ;
  btConvexHullInternal::Vertex *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  result = (btConvexHullInternal::Vertex *) ((arg1)->vertexList);
  *(btConvexHullInternal::Vertex **)&_swig_go_result = (btConvexHullInternal::Vertex *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullInternal_compute_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0, void *_swig_go_1, bool _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  void *arg2 = (void *) 0 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  (arg1)->compute((void const *)arg2,arg3,arg4,arg5);
  
}


btVector3 *_wrap_btConvexHullInternal_getCoordinates_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  result = (arg1)->getCoordinates((btConvexHullInternal::Vertex const *)arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexHullInternal_shrink_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)(arg1)->shrink(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullInternal *_wrap_new_btConvexHullInternal_mbt_c407977658d33772() {
  btConvexHullInternal *result = 0 ;
  btConvexHullInternal *_swig_go_result;
  
  
  result = (btConvexHullInternal *)new btConvexHullInternal();
  *(btConvexHullInternal **)&_swig_go_result = (btConvexHullInternal *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullInternal_mbt_c407977658d33772(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  delete arg1;
  
}


pointCmp *_wrap_new_pointCmp_mbt_c407977658d33772() {
  pointCmp *result = 0 ;
  pointCmp *_swig_go_result;
  
  
  result = (pointCmp *)new pointCmp();
  *(pointCmp **)&_swig_go_result = (pointCmp *)result; 
  return _swig_go_result;
}


void _wrap_delete_pointCmp_mbt_c407977658d33772(pointCmp *_swig_go_0) {
  pointCmp *arg1 = (pointCmp *) 0 ;
  
  arg1 = *(pointCmp **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_getVertexCopy_mbt_c407977658d33772(btConvexHullInternal::Vertex *_swig_go_0, btAlignedObjectArray< btConvexHullInternal::Vertex * > *_swig_go_1) {
  btConvexHullInternal::Vertex *arg1 = (btConvexHullInternal::Vertex *) 0 ;
  btAlignedObjectArray< btConvexHullInternal::Vertex * > *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexHullInternal::Vertex **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullInternal::Vertex * > **)&_swig_go_1; 
  
  result = (int)getVertexCopy(arg1,*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeometryUtil_getPlaneEquationsFromVertices_mbt_c407977658d33772(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getPlaneEquationsFromVertices(*arg1,*arg2);
  
}


void _wrap_btGeometryUtil_getVerticesFromPlaneEquations_mbt_c407977658d33772(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getVerticesFromPlaneEquations((btAlignedObjectArray< btVector3 > const &)*arg1,*arg2);
  
}


bool _wrap_btGeometryUtil_isPointInsidePlanes_mbt_c407977658d33772(btAlignedObjectArray< btVector3 > *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::isPointInsidePlanes((btAlignedObjectArray< btVector3 > const &)*arg1,(btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeometryUtil_areVerticesBehindPlane_mbt_c407977658d33772(btVector3 *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::areVerticesBehindPlane((btVector3 const &)*arg1,(btAlignedObjectArray< btVector3 > const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeometryUtil *_wrap_new_btGeometryUtil_mbt_c407977658d33772() {
  btGeometryUtil *result = 0 ;
  btGeometryUtil *_swig_go_result;
  
  
  result = (btGeometryUtil *)new btGeometryUtil();
  *(btGeometryUtil **)&_swig_go_result = (btGeometryUtil *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeometryUtil_mbt_c407977658d33772(btGeometryUtil *_swig_go_0) {
  btGeometryUtil *arg1 = (btGeometryUtil *) 0 ;
  
  arg1 = *(btGeometryUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBulletMathProbe_mbt_c407977658d33772() {
  btBulletMathProbe();
  
}


bool _wrap_notExist_mbt_c407977658d33772(btVector3 *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  result = (bool)notExist((btVector3 const &)*arg1,(btAlignedObjectArray< btVector3 > const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btFace_m_indices_set_mbt_c407977658d33772(btFace *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_indices = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btFace_m_indices_get_mbt_c407977658d33772(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->m_indices);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btFace_m_plane_set_mbt_c407977658d33772(btFace *_swig_go_0, float *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_plane;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btFace_m_plane_get_mbt_c407977658d33772(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_plane);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btFace *_wrap_new_btFace_mbt_c407977658d33772() {
  btFace *result = 0 ;
  btFace *_swig_go_result;
  
  
  result = (btFace *)new btFace();
  *(btFace **)&_swig_go_result = (btFace *)result; 
  return _swig_go_result;
}


void _wrap_delete_btFace_mbt_c407977658d33772(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  delete arg1;
  
}


btConvexPolyhedron *_wrap_new_btConvexPolyhedron_mbt_c407977658d33772() {
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  
  result = (btConvexPolyhedron *)new btConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexPolyhedron_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexPolyhedron_m_vertices_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_vertices_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_faces_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btFace > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *arg2 = (btAlignedObjectArray< btFace > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btFace > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_faces = *arg2;
  
}


btAlignedObjectArray< btFace > *_wrap_btConvexPolyhedron_m_faces_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *result = 0 ;
  btAlignedObjectArray< btFace > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btFace > *)& ((arg1)->m_faces);
  *(btAlignedObjectArray< btFace > **)&_swig_go_result = (btAlignedObjectArray< btFace > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_uniqueEdges_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueEdges = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_uniqueEdges_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_uniqueEdges);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_localCenter_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localCenter = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_localCenter_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_localCenter);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_extents_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_extents = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_extents_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_extents);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_radius_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, float _swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_radius = arg2;
  
}


float _wrap_btConvexPolyhedron_m_radius_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_radius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mC_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mC = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mC_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mC);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mE_set_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mE = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mE_get_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mE);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_initialize_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize();
  
}


void _wrap_btConvexPolyhedron_initialize2_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize2();
  
}


bool _wrap_btConvexPolyhedron_testContainment_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (bool)((btConvexPolyhedron const *)arg1)->testContainment();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_project_mbt_c407977658d33772(btConvexPolyhedron *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexPolyhedron const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btHashString_m_string1_set_mbt_c407977658d33772(btHashString *_swig_go_0, std::string *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string arg2 ;
  std::string *argp2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  argp2 = (std::string *)_swig_go_1;
  if (argp2 == NULL) {
    _swig_gopanic("Attempt to dereference null std::string");
  }
  arg2 = (std::string)*argp2;
  
  
  if (arg1) (arg1)->m_string1 = arg2;
  
}


std::string *_wrap_btHashString_m_string1_get_mbt_c407977658d33772(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string result;
  std::string *_swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result =  ((arg1)->m_string1);
  *(std::string **)&_swig_go_result = new std::string(result); 
  return _swig_go_result;
}


void _wrap_btHashString_m_hash_set_mbt_c407977658d33772(btHashString *_swig_go_0, intgo _swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int arg2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hash = arg2;
  
}


intgo _wrap_btHashString_m_hash_get_mbt_c407977658d33772(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int) ((arg1)->m_hash);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashString_getHash_mbt_c407977658d33772(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int)((btHashString const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_0_mbt_c407977658d33772() {
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  result = (btHashString *)new btHashString();
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_1_mbt_c407977658d33772(_gostring_ _swig_go_0) {
  char *arg1 = (char *) 0 ;
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  result = (btHashString *)new btHashString((char const *)arg1);
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  free(arg1); 
  return _swig_go_result;
}


bool _wrap_btHashString_equals_mbt_c407977658d33772(btHashString *_swig_go_0, btHashString *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  btHashString *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = *(btHashString **)&_swig_go_1; 
  
  result = (bool)((btHashString const *)arg1)->equals((btHashString const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashString_mbt_c407977658d33772(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_HASH_NULL_get_mbt_c407977658d33772() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)(int)BT_HASH_NULL;
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_0_mbt_c407977658d33772() {
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  
  result = (btHashInt *)new btHashInt();
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_1_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btHashInt *)new btHashInt(arg1);
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getUid1_mbt_c407977658d33772(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (int)((btHashInt const *)arg1)->getUid1();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHashInt_setUid1_mbt_c407977658d33772(btHashInt *_swig_go_0, intgo _swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int arg2 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUid1(arg2);
  
}


bool _wrap_btHashInt_equals_mbt_c407977658d33772(btHashInt *_swig_go_0, btHashInt *_swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  btHashInt *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = *(btHashInt **)&_swig_go_1; 
  
  result = (bool)((btHashInt const *)arg1)->equals((btHashInt const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getHash_mbt_c407977658d33772(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (unsigned int)((btHashInt const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashInt_mbt_c407977658d33772(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  delete arg1;
  
}


btHashPtr *_wrap_new_btHashPtr__SWIG_0_mbt_c407977658d33772() {
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  
  result = (btHashPtr *)new btHashPtr();
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


btHashPtr *_wrap_new_btHashPtr__SWIG_1_mbt_c407977658d33772(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  arg1 = *(void **)&_swig_go_0; 
  
  result = (btHashPtr *)new btHashPtr((void const *)arg1);
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


void *_wrap_btHashPtr_getPointer_mbt_c407977658d33772(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (void *)((btHashPtr const *)arg1)->getPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


bool _wrap_btHashPtr_equals_mbt_c407977658d33772(btHashPtr *_swig_go_0, btHashPtr *_swig_go_1) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  btHashPtr *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  arg2 = *(btHashPtr **)&_swig_go_1; 
  
  result = (bool)((btHashPtr const *)arg1)->equals((btHashPtr const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashPtr_getHash_mbt_c407977658d33772(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (unsigned int)((btHashPtr const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashPtr_mbt_c407977658d33772(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_IsAlmostZero1_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)IsAlmostZero1((btVector3 const &)*arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btInternalVertexPair *_wrap_new_btInternalVertexPair_mbt_c407977658d33772(short _swig_go_0, short _swig_go_1) {
  short arg1 ;
  short arg2 ;
  btInternalVertexPair *result = 0 ;
  btInternalVertexPair *_swig_go_result;
  
  arg1 = (short)_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  result = (btInternalVertexPair *)new btInternalVertexPair(arg1,arg2);
  *(btInternalVertexPair **)&_swig_go_result = (btInternalVertexPair *)result; 
  return _swig_go_result;
}


void _wrap_btInternalVertexPair_m_v0_set_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0, short _swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_v0 = arg2;
  
}


short _wrap_btInternalVertexPair_m_v0_get_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_v0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btInternalVertexPair_m_v1_set_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0, short _swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_v1 = arg2;
  
}


short _wrap_btInternalVertexPair_m_v1_get_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_v1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btInternalVertexPair_getHash_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (int)((btInternalVertexPair const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btInternalVertexPair_equals_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0, btInternalVertexPair *_swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  btInternalVertexPair *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = *(btInternalVertexPair **)&_swig_go_1; 
  
  result = (bool)((btInternalVertexPair const *)arg1)->equals((btInternalVertexPair const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btInternalVertexPair_mbt_c407977658d33772(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  delete arg1;
  
}


btInternalEdge *_wrap_new_btInternalEdge_mbt_c407977658d33772() {
  btInternalEdge *result = 0 ;
  btInternalEdge *_swig_go_result;
  
  
  result = (btInternalEdge *)new btInternalEdge();
  *(btInternalEdge **)&_swig_go_result = (btInternalEdge *)result; 
  return _swig_go_result;
}


void _wrap_btInternalEdge_m_face0_set_mbt_c407977658d33772(btInternalEdge *_swig_go_0, short _swig_go_1) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_face0 = arg2;
  
}


short _wrap_btInternalEdge_m_face0_get_mbt_c407977658d33772(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_face0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btInternalEdge_m_face1_set_mbt_c407977658d33772(btInternalEdge *_swig_go_0, short _swig_go_1) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_face1 = arg2;
  
}


short _wrap_btInternalEdge_m_face1_get_mbt_c407977658d33772(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_face1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btInternalEdge_mbt_c407977658d33772(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btPolyhedralConvexShape_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setPolyhedralFeatures_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  (arg1)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexShape_calculateLocalInertia_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumVertices_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumEdges_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getEdge_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getVertex_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumPlanes_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPlane_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexShape_isInside_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertex_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getImplicitShapeDimensions_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setImplicitShapeDimensions_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_getAabb_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getAabbSlow_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_setLocalScaling_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScaling_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScalingNV_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setMargin_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexShape_getMargin_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNV_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_calculateSerializeBufferSize_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_serialize_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNonVirtual_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getAabbNonVirtual_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_project_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexShape_getBoundingSphere_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexShape_getAngularMotionDisc_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getContactBreakingThreshold_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_calculateTemporalAabb_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexShape_isPolyhedral_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex2d_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isNonMoving_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConcave_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isCompound_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isSoftBody_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isInfinite_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_getName_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getShapeType_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserPointer_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexShape_getUserPointer_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex2_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex2_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_serializeSingleShape_mbt_c407977658d33772(btPolyhedralConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabb_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btPolyhedralConvexAabbCachingShape_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_0_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_1_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setPolyhedralFeatures_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexAabbCachingShape_getConvexPolyhedron_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = ((btPolyhedralConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateLocalInertia_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumVertices_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumEdges_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getEdge_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getVertex_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPlanes_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPlane_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInside_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)((btPolyhedralConvexShape const *)swig_b0)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertex_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getImplicitShapeDimensions_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setImplicitShapeDimensions_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbSlow_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScaling_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScalingNV_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setMargin_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMargin_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNV_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_calculateSerializeBufferSize_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_serialize_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNonVirtual_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbNonVirtual_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_project_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getBoundingSphere_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getAngularMotionDisc_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getContactBreakingThreshold_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateTemporalAabb_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isPolyhedral_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex2d_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isNonMoving_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConcave_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isCompound_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isSoftBody_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInfinite_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_getName_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (char *)((btCollisionShape const *)swig_b3)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getShapeType_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserPointer_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexAabbCachingShape_getUserPointer_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex2_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex2_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_serializeSingleShape_mbt_c407977658d33772(btPolyhedralConvexAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertex_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


btBoxShape *_wrap_new_btBoxShape_mbt_c407977658d33772(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  btBoxShape *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
  *(btBoxShape **)&_swig_go_result = (btBoxShape *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btBoxShape_setLocalScaling_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabb_mbt_c407977658d33772(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_calculateLocalInertia_mbt_c407977658d33772(btBoxShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlane_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


intgo _wrap_btBoxShape_getNumPlanes_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumVertices_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumEdges_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getVertex_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlaneEquation_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector4 *_swig_go_1, intgo _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector4 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
  
}


void _wrap_btBoxShape_getEdge_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


bool _wrap_btBoxShape_isInside_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_getName_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (char *)((btBoxShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_delete_btBoxShape_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_0_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_1_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setPolyhedralFeatures_mbt_c407977658d33772(btBoxShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btBoxShape_getConvexPolyhedron_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getImplicitShapeDimensions_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setImplicitShapeDimensions_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btBoxShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabbSlow_mbt_c407977658d33772(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btBoxShape_getLocalScaling_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getLocalScalingNV_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMargin_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNV_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_calculateSerializeBufferSize_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_serialize_mbt_c407977658d33772(btBoxShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNonVirtual_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getAabbNonVirtual_mbt_c407977658d33772(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_project_mbt_c407977658d33772(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btBoxShape_getBoundingSphere_mbt_c407977658d33772(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btBoxShape_getAngularMotionDisc_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getContactBreakingThreshold_mbt_c407977658d33772(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_calculateTemporalAabb_mbt_c407977658d33772(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btBoxShape_isPolyhedral_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex2d_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isNonMoving_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConcave_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isCompound_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isSoftBody_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isInfinite_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getShapeType_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserPointer_mbt_c407977658d33772(btBoxShape *_swig_go_0, void *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btBoxShape_getUserPointer_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex2_mbt_c407977658d33772(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex2_mbt_c407977658d33772(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_serializeSingleShape_mbt_c407977658d33772(btBoxShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btCapsuleShape *_wrap_new_btCapsuleShape__SWIG_1_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShape *result = 0 ;
  btCapsuleShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShape *)new btCapsuleShape(arg1,arg2);
  *(btCapsuleShape **)&_swig_go_result = (btCapsuleShape *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateLocalInertia_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCapsuleShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btCapsuleShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShape_setMargin_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btCapsuleShape_getAabb_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


_gostring_ _wrap_btCapsuleShape_getName_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getUpAxis_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getRadius_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getHalfHeight_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setLocalScaling_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShape_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = ((btCapsuleShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_calculateSerializeBufferSize_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShape_serialize_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCapsuleShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_deSerializeFloat_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat(arg2);
  
}


void _wrap_delete_btCapsuleShape_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertex_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_0_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_1_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_2_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_3_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_getAabbSlow_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShape_getLocalScaling_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getLocalScalingNV_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMargin_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNV_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getPreferredPenetrationDirection_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNonVirtual_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getAabbNonVirtual_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShape_project_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShape_getBoundingSphere_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShape_getAngularMotionDisc_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getContactBreakingThreshold_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateTemporalAabb_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShape_isPolyhedral_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex2d_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isNonMoving_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConcave_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isCompound_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isSoftBody_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isInfinite_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getShapeType_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserPointer_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, void *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShape_getUserPointer_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex2_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex2_mbt_c407977658d33772(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_serializeSingleShape_mbt_c407977658d33772(btCapsuleShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


btCapsuleShapeX *_wrap_new_btCapsuleShapeX_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeX *result = 0 ;
  btCapsuleShapeX *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeX *)new btCapsuleShapeX(arg1,arg2);
  *(btCapsuleShapeX **)&_swig_go_result = (btCapsuleShapeX *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_getName_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeX const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeX_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeX_calculateLocalInertia_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeX_setMargin_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_getAabb_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeX_getUpAxis_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getRadius_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getHalfHeight_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setLocalScaling_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_calculateSerializeBufferSize_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_serialize_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_deSerializeFloat_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertex_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_0_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_1_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_2_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_3_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_getAabbSlow_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScaling_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScalingNV_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMargin_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNV_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getPreferredPenetrationDirection_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNonVirtual_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getAabbNonVirtual_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeX_project_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeX_getBoundingSphere_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeX_getAngularMotionDisc_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getContactBreakingThreshold_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_calculateTemporalAabb_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeX_isPolyhedral_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex2d_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isNonMoving_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConcave_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isCompound_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isSoftBody_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isInfinite_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getShapeType_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserPointer_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeX_getUserPointer_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex2_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex2_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_serializeSingleShape_mbt_c407977658d33772(btCapsuleShapeX *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btCapsuleShapeZ *_wrap_new_btCapsuleShapeZ_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeZ *result = 0 ;
  btCapsuleShapeZ *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeZ *)new btCapsuleShapeZ(arg1,arg2);
  *(btCapsuleShapeZ **)&_swig_go_result = (btCapsuleShapeZ *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_getName_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeZ const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeZ_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeZ_calculateLocalInertia_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeZ_setMargin_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabb_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeZ_getUpAxis_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getRadius_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getHalfHeight_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setLocalScaling_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getAnisotropicRollingFrictionDirection_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_calculateSerializeBufferSize_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_serialize_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_deSerializeFloat_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertex_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setImplicitShapeDimensions_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_0_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_1_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_2_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_3_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabbSlow_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScaling_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScalingNV_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMargin_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNV_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getNumPreferredPenetrationDirections_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getPreferredPenetrationDirection_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexWithoutMarginNonVirtual_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexNonVirtual_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNonVirtual_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getAabbNonVirtual_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeZ_project_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeZ_getBoundingSphere_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeZ_getAngularMotionDisc_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getContactBreakingThreshold_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_calculateTemporalAabb_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeZ_isPolyhedral_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex2d_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isNonMoving_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConcave_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isCompound_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isSoftBody_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isInfinite_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getShapeType_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserPointer_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeZ_getUserPointer_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex2_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex2_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_serializeSingleShape_mbt_c407977658d33772(btCapsuleShapeZ *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


void _wrap_btCapsuleShapeData_m_convexInternalShapeData_set_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0, btConvexInternalShapeData *_swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *arg2 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = *(btConvexInternalShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexInternalShapeData = *arg2;
  
}


btConvexInternalShapeData *_wrap_btCapsuleShapeData_m_convexInternalShapeData_get_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (btConvexInternalShapeData *)& ((arg1)->m_convexInternalShapeData);
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_upAxis_set_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_upAxis = arg2;
  
}


intgo _wrap_btCapsuleShapeData_m_upAxis_get_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_upAxis);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_padding_set_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCapsuleShapeData_m_padding_get_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCapsuleShapeData *_wrap_new_btCapsuleShapeData_mbt_c407977658d33772() {
  btCapsuleShapeData *result = 0 ;
  btCapsuleShapeData *_swig_go_result;
  
  
  result = (btCapsuleShapeData *)new btCapsuleShapeData();
  *(btCapsuleShapeData **)&_swig_go_result = (btCapsuleShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeData_mbt_c407977658d33772(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_CF_DYNAMIC_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DYNAMIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_STATIC_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_STATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_KINEMATIC_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_KINEMATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_NO_CONTACT_RESPONSE_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_NO_CONTACT_RESPONSE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CUSTOM_MATERIAL_CALLBACK_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CHARACTER_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CHARACTER_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_VISUALIZE_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_SPU_COLLISION_PROCESSING_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CONTACT_STIFFNESS_DAMPING_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_FRICTION_ANCHOR_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_FRICTION_ANCHOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_COLLISION_SOUND_TRIGGER_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_COLLISION_SOUND_TRIGGER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_COLLISION_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_COLLISION_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_RIGID_BODY_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_RIGID_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_GHOST_OBJECT_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_GHOST_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_SOFT_BODY_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_SOFT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_HF_FLUID_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_HF_FLUID;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_USER_TYPE_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_USER_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_FEATHERSTONE_LINK_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_FEATHERSTONE_LINK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_DISABLED_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION_DISABLED;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_ROLLING_FRICTION_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_mergesSimulationIslands_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getAnisotropicFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactProcessingThreshold_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btCollisionObject_getContactProcessingThreshold_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticObject_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isKinematicObject_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticOrKinematicObject_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasContactResponse_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_new_btCollisionObject_mbt_c407977658d33772() {
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  
  result = (btCollisionObject *)new btCollisionObject();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObject_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObject_setCollisionShape_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btCollisionShape *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  (arg1)->setCollisionShape(arg2);
  
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIgnoreCollisionCheck_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btCollisionObject_getNumObjectsWithoutCollision_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btCollisionObject_getObjectWithoutCollision_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btCollisionObject *)(arg1)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWithOverride_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btCollisionObject_internalGetExtensionPointer_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_internalSetExtensionPointer_mbt_c407977658d33772(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btCollisionObject_getActivationState_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setActivationState_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->setActivationState(arg2);
  
}


void _wrap_btCollisionObject_setDeactivationTime_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDeactivationTime(arg2);
  
}


float _wrap_btCollisionObject_getDeactivationTime_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_forceActivationState_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->forceActivationState(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0, bool _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->activate(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  ((btCollisionObject const *)arg1)->activate();
  
}


bool _wrap_btCollisionObject_isActive_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRestitution_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRestitution(arg2);
  
}


float _wrap_btCollisionObject_getRestitution_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setFriction(arg2);
  
}


float _wrap_btCollisionObject_getFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRollingFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRollingFriction(arg2);
  
}


float _wrap_btCollisionObject_getRollingFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setSpinningFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSpinningFriction(arg2);
  
}


float _wrap_btCollisionObject_getSpinningFriction_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactStiffnessAndDamping_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btCollisionObject_getContactStiffness_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getContactDamping_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getInternalType_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldTransform_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setBroadphaseHandle_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setInterpolationWorldTransform_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationLinearVelocity_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationAngularVelocity_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getIslandTag_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIslandTag_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setIslandTag(arg2);
  
}


intgo _wrap_btCollisionObject_getCompanionId_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCompanionId_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCompanionId(arg2);
  
}


intgo _wrap_btCollisionObject_getWorldArrayIndex_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldArrayIndex_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setWorldArrayIndex(arg2);
  
}


float _wrap_btCollisionObject_getHitFraction_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setHitFraction_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setHitFraction(arg2);
  
}


intgo _wrap_btCollisionObject_getCollisionFlags_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCollisionFlags_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCollisionFlags(arg2);
  
}


float _wrap_btCollisionObject_getCcdSweptSphereRadius_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdSweptSphereRadius_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btCollisionObject_getCcdMotionThreshold_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getCcdSquareMotionThreshold_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdMotionThreshold_mbt_c407977658d33772(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btCollisionObject_getUserPointer_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex2_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex3_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setUserPointer_mbt_c407977658d33772(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex2_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex3_mbt_c407977658d33772(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex3(arg2);
  
}


intgo _wrap_btCollisionObject_getUpdateRevisionInternal_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCustomDebugColor_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_removeCustomDebugColor_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  (arg1)->removeCustomDebugColor();
  
}


bool _wrap_btCollisionObject_getCustomDebugColor_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWith_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_calculateSerializeBufferSize_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionObject_serialize_mbt_c407977658d33772(btCollisionObject *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObject_serializeSingleObject_mbt_c407977658d33772(btCollisionObject *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
  
}


void _wrap_btCollisionObjectDoubleData_m_broadphaseHandle_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_broadphaseHandle_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionShape_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_collisionShape_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rootCollisionShape_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectDoubleData_m_rootCollisionShape_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_name_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectDoubleData_m_name_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_worldTransform_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_worldTransform_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_worldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_anisotropicFriction_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_anisotropicFriction_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_deactivationTime_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_deactivationTime_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_friction_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_friction_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rollingFriction_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_rollingFriction_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactDamping_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactDamping_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactStiffness_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactStiffness_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_restitution_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_restitution_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hitFraction_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_hitFraction_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFlags_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFlags_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_islandTag1_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_islandTag1_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_companionId_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_companionId_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_activationState1_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_activationState1_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_internalType_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_internalType_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_checkCollideWith_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_checkCollideWith_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_uniqueId_set_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_uniqueId_get_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectDoubleData *_wrap_new_btCollisionObjectDoubleData_mbt_c407977658d33772() {
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  
  result = (btCollisionObjectDoubleData *)new btCollisionObjectDoubleData();
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectDoubleData_mbt_c407977658d33772(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObjectFloatData_m_broadphaseHandle_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_broadphaseHandle_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionShape_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_collisionShape_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rootCollisionShape_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectFloatData_m_rootCollisionShape_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_name_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectFloatData_m_name_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_worldTransform_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_worldTransform_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_worldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_anisotropicFriction_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_anisotropicFriction_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_deactivationTime_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_deactivationTime_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_friction_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_friction_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rollingFriction_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_rollingFriction_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactDamping_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactDamping_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactStiffness_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactStiffness_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_restitution_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_restitution_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hitFraction_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_hitFraction_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFlags_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFlags_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_islandTag1_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_islandTag1_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_companionId_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_companionId_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_activationState1_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_activationState1_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_internalType_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_internalType_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_checkCollideWith_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_checkCollideWith_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterMask_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterMask_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_uniqueId_set_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_uniqueId_get_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectFloatData *_wrap_new_btCollisionObjectFloatData_mbt_c407977658d33772() {
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  
  result = (btCollisionObjectFloatData *)new btCollisionObjectFloatData();
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectFloatData_mbt_c407977658d33772(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gDeactivationTime_set_mbt_c407977658d33772(float _swig_go_0) {
  btScalar arg1 ;
  
  arg1 = (btScalar)_swig_go_0; 
  
  gDeactivationTime = arg1;
  
}


float _wrap_gDeactivationTime_get_mbt_c407977658d33772() {
  btScalar result;
  float _swig_go_result;
  
  
  result = (btScalar)gDeactivationTime;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gDisableDeactivation_set_mbt_c407977658d33772(bool _swig_go_0) {
  bool arg1 ;
  
  arg1 = (bool)_swig_go_0; 
  
  gDisableDeactivation = arg1;
  
}


bool _wrap_gDisableDeactivation_get_mbt_c407977658d33772() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)gDisableDeactivation;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BT_DISABLE_WORLD_GRAVITY_mbt_c407977658d33772() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_DISABLE_WORLD_GRAVITY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT_mbt_c407977658d33772() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD_mbt_c407977658d33772() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY_mbt_c407977658d33772() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROPSCOPIC_FORCE_mbt_c407977658d33772() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROPSCOPIC_FORCE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_0_mbt_c407977658d33772(btRigidBody::btRigidBodyConstructionInfo *_swig_go_0) {
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btRigidBody::btRigidBodyConstructionInfo **)&_swig_go_0; 
  
  result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_1_mbt_c407977658d33772(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_2_mbt_c407977658d33772(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBody_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBody_proceedToTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->proceedToTransform((btTransform const &)*arg2);
  
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_0_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_1_mbt_c407977658d33772(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast(arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_predictIntegratedTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->predictIntegratedTransform(arg2,*arg3);
  
}


void _wrap_btRigidBody_saveKinematicState_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->saveKinematicState(arg2);
  
}


void _wrap_btRigidBody_applyGravity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->applyGravity();
  
}


void _wrap_btRigidBody_clearGravity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearGravity();
  
}


void _wrap_btRigidBody_setGravity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getGravity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getLinearDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getLinearSleepingThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularSleepingThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_applyDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->applyDamping(arg2);
  
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMassProps_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getLinearFactor_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearFactor_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearFactor((btVector3 const &)*arg2);
  
}


float _wrap_btRigidBody_getInvMass_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getMass_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_integrateVelocities_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->integrateVelocities(arg2);
  
}


void _wrap_btRigidBody_setCenterOfMassTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralForce_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralForce((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getTotalForce_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTotalTorque_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInvInertiaDiagLocal_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setSleepingThresholds_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSleepingThresholds(arg2,arg3);
  
}


void _wrap_btRigidBody_applyTorque_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorque((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyForce_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyCentralImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyPushImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyPushImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getPushVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTurnVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getTurnVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_setPushVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setPushVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setTurnVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setTurnVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralPushImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralPushImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueTurnImpulse_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueTurnImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_clearForces_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btRigidBody_updateInertiaTensor_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->updateInertiaTensor();
  
}


btVector3 *_wrap_btRigidBody_getCenterOfMassPosition_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btRigidBody_getOrientation_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getOrientation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getCenterOfMassTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLinearVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAngularVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getPushVelocityInLocalPoint_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_translate_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->translate((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_getAabb_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
  
}


float _wrap_btRigidBody_computeImpulseDenominator_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_computeAngularImpulseDenominator_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_updateDeactivation_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateDeactivation(arg2);
  
}


bool _wrap_btRigidBody_wantsSleeping_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)(arg1)->wantsSleeping();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setNewBroadphaseProxy_mbt_c407977658d33772(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setNewBroadphaseProxy(arg2);
  
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)(arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMotionState_mbt_c407977658d33772(btRigidBody *_swig_go_0, btMotionState *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  
  (arg1)->setMotionState(arg2);
  
}


void _wrap_btRigidBody_m_contactSolverType_set_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_contactSolverType_get_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_contactSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_m_frictionSolverType_set_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_frictionSolverType_get_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_frictionSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAngularFactor__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularFactor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularFactor__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setAngularFactor(arg2);
  
}


btVector3 *_wrap_btRigidBody_getAngularFactor_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isInWorld_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)((btRigidBody const *)arg1)->isInWorld();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_addConstraintRef_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraintRef(arg2);
  
}


void _wrap_btRigidBody_removeConstraintRef_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraintRef(arg2);
  
}


btTypedConstraint *_wrap_btRigidBody_getConstraintRef_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getNumConstraintRefs_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFlags_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setFlags(arg2);
  
}


intgo _wrap_btRigidBody_getFlags_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_World_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_World(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_Body_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_Body(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicForceExplicit_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicForceExplicit(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLocalInertia_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getLocalInertia();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_calculateSerializeBufferSize_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btRigidBody_serialize_mbt_c407977658d33772(btRigidBody *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btRigidBody_serializeSingleObject_mbt_c407977658d33772(btRigidBody *_swig_go_0, btSerializer *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
  
}


bool _wrap_btRigidBody_mergesSimulationIslands_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAnisotropicFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactProcessingThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btRigidBody_getContactProcessingThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticObject_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isKinematicObject_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticOrKinematicObject_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasContactResponse_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionShape_mbt_c407977658d33772(btRigidBody *_swig_go_0, btCollisionShape *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionShape(arg2);
  
}


void _wrap_btRigidBody_setIgnoreCollisionCheck_mbt_c407977658d33772(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btRigidBody_getNumObjectsWithoutCollision_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btRigidBody_getObjectWithoutCollision_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btCollisionObject *)(swig_b0)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWithOverride_mbt_c407977658d33772(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btRigidBody_internalGetExtensionPointer_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_internalSetExtensionPointer_mbt_c407977658d33772(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btRigidBody_getActivationState_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setActivationState_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->setActivationState(arg2);
  
}


void _wrap_btRigidBody_setDeactivationTime_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setDeactivationTime(arg2);
  
}


float _wrap_btRigidBody_getDeactivationTime_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_forceActivationState_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->forceActivationState(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0, bool _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate();
  
}


bool _wrap_btRigidBody_isActive_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRestitution_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRestitution(arg2);
  
}


float _wrap_btRigidBody_getRestitution_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setFriction(arg2);
  
}


float _wrap_btRigidBody_getFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRollingFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRollingFriction(arg2);
  
}


float _wrap_btRigidBody_getRollingFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setSpinningFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setSpinningFriction(arg2);
  
}


float _wrap_btRigidBody_getSpinningFriction_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactStiffnessAndDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getContactStiffness_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getContactDamping_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getInternalType_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)(swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)((btCollisionObject const *)swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setBroadphaseHandle_mbt_c407977658d33772(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_0_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_1_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInterpolationWorldTransform_mbt_c407977658d33772(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationLinearVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationAngularVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getInterpolationLinearVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInterpolationAngularVelocity_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getIslandTag_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setIslandTag_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIslandTag(arg2);
  
}


intgo _wrap_btRigidBody_getCompanionId_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCompanionId_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCompanionId(arg2);
  
}


intgo _wrap_btRigidBody_getWorldArrayIndex_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldArrayIndex_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldArrayIndex(arg2);
  
}


float _wrap_btRigidBody_getHitFraction_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setHitFraction_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setHitFraction(arg2);
  
}


intgo _wrap_btRigidBody_getCollisionFlags_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionFlags_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionFlags(arg2);
  
}


float _wrap_btRigidBody_getCcdSweptSphereRadius_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdSweptSphereRadius_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btRigidBody_getCcdMotionThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getCcdSquareMotionThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdMotionThreshold_mbt_c407977658d33772(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btRigidBody_getUserPointer_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex2_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex3_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setUserPointer_mbt_c407977658d33772(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void _wrap_btRigidBody_setUserIndex_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


void _wrap_btRigidBody_setUserIndex2_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


void _wrap_btRigidBody_setUserIndex3_mbt_c407977658d33772(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex3(arg2);
  
}


intgo _wrap_btRigidBody_getUpdateRevisionInternal_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCustomDebugColor_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_removeCustomDebugColor_mbt_c407977658d33772(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->removeCustomDebugColor();
  
}


bool _wrap_btRigidBody_getCustomDebugColor_mbt_c407977658d33772(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWith_mbt_c407977658d33772(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_collisionObjectData_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectFloatData *_wrap_btRigidBodyFloatData_m_collisionObjectData_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearVelocity_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearVelocity_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularVelocity_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularVelocity_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularFactor_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularFactor_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearFactor_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearFactor_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_acceleration_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_acceleration_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaLocal_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaLocal_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalForce_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalForce_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalForce);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalTorque_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalTorque_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalTorque);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_inverseMass_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_inverseMass_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearDamping_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearDamping_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularDamping_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularDamping_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDampingFactor_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalDampingFactor_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDamping_set_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyFloatData_m_additionalDamping_get_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


btRigidBodyFloatData *_wrap_new_btRigidBodyFloatData_mbt_c407977658d33772() {
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  
  result = (btRigidBodyFloatData *)new btRigidBodyFloatData();
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyFloatData_mbt_c407977658d33772(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBodyDoubleData_m_collisionObjectData_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectDoubleData *_wrap_btRigidBodyDoubleData_m_collisionObjectData_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearVelocity_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearVelocity_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularVelocity_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularVelocity_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularFactor_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularFactor_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearFactor_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearFactor_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_acceleration_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_acceleration_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaLocal_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaLocal_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalForce_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalForce_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalForce);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalTorque_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalTorque_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalTorque);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_inverseMass_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_inverseMass_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearDamping_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearDamping_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularDamping_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularDamping_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDamping_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyDoubleData_m_additionalDamping_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_padding_set_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btRigidBodyDoubleData_m_padding_get_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btRigidBodyDoubleData *_wrap_new_btRigidBodyDoubleData_mbt_c407977658d33772() {
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  
  result = (btRigidBodyDoubleData *)new btRigidBodyDoubleData();
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyDoubleData_mbt_c407977658d33772(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_uniqueId_set_mbt_c407977658d33772(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  uniqueId = arg1;
  
}


intgo _wrap_uniqueId_get_mbt_c407977658d33772() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)uniqueId;
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_evalEulerEqn_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btMatrix3x3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btMatrix3x3 *arg5 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  
  result = evalEulerEqn((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,(btMatrix3x3 const &)*arg5);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_evalEulerEqnDeriv_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btMatrix3x3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btMatrix3x3 **)&_swig_go_3; 
  
  result = evalEulerEqnDeriv((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btMatrix3x3 const &)*arg4);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_0_mbt_c407977658d33772() {
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  
  result = (btJacobianEntry *)new btJacobianEntry();
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_1_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, float _swig_go_6, btVector3 *_swig_go_7, float _swig_go_8) {
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btVector3 *arg8 = 0 ;
  btScalar arg9 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,(btVector3 const &)*arg8,arg9);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_2_mbt_c407977658d33772(btVector3 *_swig_go_0, btMatrix3x3 *_swig_go_1, btMatrix3x3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = *(btMatrix3x3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btMatrix3x3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_3_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_4_mbt_c407977658d33772(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, float _swig_go_5) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar arg6 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getDiagonal_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getDiagonal();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getNonDiagonal__SWIG_0_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btJacobianEntry *_swig_go_1, float _swig_go_2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btJacobianEntry **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getNonDiagonal__SWIG_1_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btJacobianEntry *_swig_go_1, float _swig_go_2, float _swig_go_3) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btJacobianEntry **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getRelativeVelocity_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  result = (btScalar)(arg1)->getRelativeVelocity((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_linearJointAxis_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearJointAxis = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_linearJointAxis_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearJointAxis);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_aJ_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aJ = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_aJ_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aJ);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_bJ_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bJ = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_bJ_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_bJ);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_0MinvJt_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_0MinvJt = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_0MinvJt_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_0MinvJt);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_1MinvJt_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_1MinvJt = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_1MinvJt_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_1MinvJt);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_Adiag_set_mbt_c407977658d33772(btJacobianEntry *_swig_go_0, float _swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_Adiag = arg2;
  
}


float _wrap_btJacobianEntry_m_Adiag_get_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_Adiag);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btJacobianEntry_mbt_c407977658d33772(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btAabbSupport_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = btAabbSupport((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTransformUtil_integrateTransform_mbt_c407977658d33772(btTransform *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btTransform *_swig_go_4) {
  btTransform *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btTransform *arg5 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  
  btTransformUtil::integrateTransform((btTransform const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,*arg5);
  
}


void _wrap_btTransformUtil_calculateVelocityQuaternion_mbt_c407977658d33772(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btQuaternion *_swig_go_2, btQuaternion *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion *arg3 = 0 ;
  btQuaternion *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btQuaternion **)&_swig_go_2; 
  arg4 = *(btQuaternion **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btTransformUtil::calculateVelocityQuaternion((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btQuaternion const &)*arg3,(btQuaternion const &)*arg4,arg5,*arg6,*arg7);
  
}


void _wrap_btTransformUtil_calculateDiffAxisAngleQuaternion_mbt_c407977658d33772(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btTransformUtil::calculateDiffAxisAngleQuaternion((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btTransformUtil_calculateVelocity_mbt_c407977658d33772(btTransform *_swig_go_0, btTransform *_swig_go_1, float _swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  btTransformUtil::calculateVelocity((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,*arg4,*arg5);
  
}


void _wrap_btTransformUtil_calculateDiffAxisAngle_mbt_c407977658d33772(btTransform *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btTransformUtil::calculateDiffAxisAngle((btTransform const &)*arg1,(btTransform const &)*arg2,*arg3,*arg4);
  
}


btTransformUtil *_wrap_new_btTransformUtil_mbt_c407977658d33772() {
  btTransformUtil *result = 0 ;
  btTransformUtil *_swig_go_result;
  
  
  result = (btTransformUtil *)new btTransformUtil();
  *(btTransformUtil **)&_swig_go_result = (btTransformUtil *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformUtil_mbt_c407977658d33772(btTransformUtil *_swig_go_0) {
  btTransformUtil *arg1 = (btTransformUtil *) 0 ;
  
  arg1 = *(btTransformUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


btConvexSeparatingDistanceUtil *_wrap_new_btConvexSeparatingDistanceUtil_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btConvexSeparatingDistanceUtil *result = 0 ;
  btConvexSeparatingDistanceUtil *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btConvexSeparatingDistanceUtil *)new btConvexSeparatingDistanceUtil(arg1,arg2);
  *(btConvexSeparatingDistanceUtil **)&_swig_go_result = (btConvexSeparatingDistanceUtil *)result; 
  return _swig_go_result;
}


float _wrap_btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance_mbt_c407977658d33772(btConvexSeparatingDistanceUtil *_swig_go_0) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getConservativeSeparatingDistance();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexSeparatingDistanceUtil_updateSeparatingDistance_mbt_c407977658d33772(btConvexSeparatingDistanceUtil *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->updateSeparatingDistance((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btConvexSeparatingDistanceUtil_initSeparatingDistance_mbt_c407977658d33772(btConvexSeparatingDistanceUtil *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  
  (arg1)->initSeparatingDistance((btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,(btTransform const &)*arg5);
  
}


void _wrap_delete_btConvexSeparatingDistanceUtil_mbt_c407977658d33772(btConvexSeparatingDistanceUtil *_swig_go_0) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSolverBody_m_worldTransform_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btTransform *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransform *_wrap_btSolverBody_m_worldTransform_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_worldTransform);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_deltaLinearVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_deltaLinearVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_deltaLinearVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_deltaLinearVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_deltaAngularVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_deltaAngularVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_deltaAngularVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_deltaAngularVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_angularFactor_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_angularFactor_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularFactor);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_linearFactor_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_linearFactor_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearFactor);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_invMass_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invMass = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_invMass_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_invMass);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_pushVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pushVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_pushVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_pushVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_turnVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_turnVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_turnVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_turnVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_linearVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_linearVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_angularVelocity_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_angularVelocity_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_externalForceImpulse_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_externalForceImpulse = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_externalForceImpulse_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_externalForceImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_externalTorqueImpulse_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_externalTorqueImpulse = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_externalTorqueImpulse_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_externalTorqueImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_originalBody_set_mbt_c407977658d33772(btSolverBody *_swig_go_0, btRigidBody *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_originalBody = arg2;
  
}


btRigidBody *_wrap_btSolverBody_m_originalBody_get_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btRigidBody *) ((arg1)->m_originalBody);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_setWorldTransform_mbt_c407977658d33772(btSolverBody *_swig_go_0, btTransform *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


btTransform *_wrap_btSolverBody_getWorldTransform_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btTransform *) &((btSolverBody const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_getVelocityInLocalPointNoDelta_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->getVelocityInLocalPointNoDelta((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_getVelocityInLocalPointObsolete_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->getVelocityInLocalPointObsolete((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_getAngularVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btSolverBody const *)arg1)->getAngularVelocity(*arg2);
  
}


void _wrap_btSolverBody_applyImpulse_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btSolverBody_internalApplyPushImpulse_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->internalApplyPushImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btSolverBody_getDeltaLinearVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getDeltaLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getDeltaAngularVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getDeltaAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getPushVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getPushVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getTurnVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getTurnVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetDeltaLinearVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetDeltaLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetDeltaAngularVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetDeltaAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetAngularFactor_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->internalGetAngularFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetInvMass_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->internalGetInvMass();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_internalSetInvMass_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->internalSetInvMass((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btSolverBody_internalGetPushVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetPushVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetTurnVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetTurnVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_internalGetVelocityInLocalPointObsolete_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->internalGetVelocityInLocalPointObsolete((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_internalGetAngularVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btSolverBody const *)arg1)->internalGetAngularVelocity(*arg2);
  
}


void _wrap_btSolverBody_internalApplyImpulse_mbt_c407977658d33772(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->internalApplyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btSolverBody_writebackVelocity_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  (arg1)->writebackVelocity();
  
}


void _wrap_btSolverBody_writebackVelocityAndTransform_mbt_c407977658d33772(btSolverBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->writebackVelocityAndTransform(arg2,arg3);
  
}


btSolverBody *_wrap_new_btSolverBody_mbt_c407977658d33772() {
  btSolverBody *result = 0 ;
  btSolverBody *_swig_go_result;
  
  
  result = (btSolverBody *)new btSolverBody();
  *(btSolverBody **)&_swig_go_result = (btSolverBody *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSolverBody_mbt_c407977658d33772(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSolverConstraint_m_relpos1CrossNormal_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_relpos1CrossNormal = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_relpos1CrossNormal_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_relpos1CrossNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_contactNormal1_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contactNormal1 = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_contactNormal1_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_contactNormal1);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_relpos2CrossNormal_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_relpos2CrossNormal = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_relpos2CrossNormal_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_relpos2CrossNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_contactNormal2_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contactNormal2 = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_contactNormal2_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_contactNormal2);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_angularComponentA_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularComponentA = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_angularComponentA_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularComponentA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_angularComponentB_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularComponentB = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_angularComponentB_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularComponentB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_appliedPushImpulse_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedPushImpulse = arg2;
  
}


float _wrap_btSolverConstraint_m_appliedPushImpulse_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedPushImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_appliedImpulse_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btSolverConstraint_m_appliedImpulse_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_friction_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btSolverConstraint_m_friction_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_jacDiagABInv_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_jacDiagABInv = arg2;
  
}


float _wrap_btSolverConstraint_m_jacDiagABInv_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_jacDiagABInv);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_rhs_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_rhs = arg2;
  
}


float _wrap_btSolverConstraint_m_rhs_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_rhs);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_cfm_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_cfm = arg2;
  
}


float _wrap_btSolverConstraint_m_cfm_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_cfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_lowerLimit_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_lowerLimit = arg2;
  
}


float _wrap_btSolverConstraint_m_lowerLimit_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_lowerLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_upperLimit_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_upperLimit = arg2;
  
}


float _wrap_btSolverConstraint_m_upperLimit_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_upperLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_rhsPenetration_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_rhsPenetration = arg2;
  
}


float _wrap_btSolverConstraint_m_rhsPenetration_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_rhsPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_overrideNumSolverIterations_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btSolverConstraint_m_overrideNumSolverIterations_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_frictionIndex_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionIndex = arg2;
  
}


intgo _wrap_btSolverConstraint_m_frictionIndex_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_frictionIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_solverBodyIdA_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverBodyIdA = arg2;
  
}


intgo _wrap_btSolverConstraint_m_solverBodyIdA_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverBodyIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_solverBodyIdB_set_mbt_c407977658d33772(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverBodyIdB = arg2;
  
}


intgo _wrap_btSolverConstraint_m_solverBodyIdB_get_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverBodyIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOLVER_CONTACT_1D_btSolverConstraint_mbt_c407977658d33772() {
  btSolverConstraint::btSolverConstraintType result;
  intgo _swig_go_result;
  
  
  result = btSolverConstraint::BT_SOLVER_CONTACT_1D;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOLVER_FRICTION_1D_btSolverConstraint_mbt_c407977658d33772() {
  btSolverConstraint::btSolverConstraintType result;
  intgo _swig_go_result;
  
  
  result = btSolverConstraint::BT_SOLVER_FRICTION_1D;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btSolverConstraint *_wrap_new_btSolverConstraint_mbt_c407977658d33772() {
  btSolverConstraint *result = 0 ;
  btSolverConstraint *_swig_go_result;
  
  
  result = (btSolverConstraint *)new btSolverConstraint();
  *(btSolverConstraint **)&_swig_go_result = (btSolverConstraint *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSolverConstraint_mbt_c407977658d33772(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_POINT2POINT_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = POINT2POINT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HINGE_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = HINGE_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONETWIST_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONETWIST_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SLIDER_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = SLIDER_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONTACT_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONTACT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GEAR_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = GEAR_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FIXED_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = FIXED_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_2_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_2_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_CONSTRAINT_TYPE_mbt_c407977658d33772() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = MAX_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_ERP_mbt_c407977658d33772() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_ERP_mbt_c407977658d33772() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_CFM_mbt_c407977658d33772() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_CFM_mbt_c407977658d33772() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyA_set_mbt_c407977658d33772(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyA_get_mbt_c407977658d33772(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyA_set_mbt_c407977658d33772(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyA_get_mbt_c407977658d33772(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyB_set_mbt_c407977658d33772(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyB_get_mbt_c407977658d33772(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyB_set_mbt_c407977658d33772(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyB_get_mbt_c407977658d33772(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_new_btJointFeedback_mbt_c407977658d33772() {
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  
  result = (btJointFeedback *)new btJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


void _wrap_delete_btJointFeedback_mbt_c407977658d33772(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btTypedConstraint_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btTypedConstraint_getFixedBody_mbt_c407977658d33772() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getOverrideNumSolverIterations_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setOverrideNumSolverIterations_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btTypedConstraint_buildJacobian_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btTypedConstraint_setupSolverConstraint_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, btAlignedObjectArray< btSolverConstraint > *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btTypedConstraint_getInfo1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btTypedConstraint_getInfo2_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btTypedConstraint_internalSetAppliedImpulse_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btTypedConstraint_internalGetAppliedImpulse_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getBreakingImpulseThreshold_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setBreakingImpulseThreshold_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btTypedConstraint_isEnabled_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setEnabled_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setEnabled(arg2);
  
}


void _wrap_btTypedConstraint_solveConstraintObsolete_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUserConstraintType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintType(arg2);
  
}


void _wrap_btTypedConstraint_setUserConstraintId_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintId(arg2);
  
}


intgo _wrap_btTypedConstraint_getUserConstraintId_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintPtr_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, void *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btTypedConstraint_getUserConstraintPtr_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (void *)(arg1)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setJointFeedback_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  (arg1)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)(arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUid_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTypedConstraint_needsFeedback_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_enableFeedback_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->enableFeedback(arg2);
  
}


float _wrap_btTypedConstraint_getAppliedImpulse_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getConstraintType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setDbgDrawSize_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDbgDrawSize(arg2);
  
}


float _wrap_btTypedConstraint_getDbgDrawSize_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setParam__SWIG_0_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btTypedConstraint_setParam__SWIG_1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


float _wrap_btTypedConstraint_getParam__SWIG_0_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getParam__SWIG_1_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_calculateSerializeBufferSize_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTypedConstraint_serialize_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_SetbtTypedConstraint_M_objectType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  if (swig_b0) (swig_b0)->m_objectType = arg2;
  
}


intgo _wrap_GetbtTypedConstraint_M_objectType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int) ((swig_b0)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getObjectType_mbt_c407977658d33772(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int)((btTypedObject const *)swig_b0)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAdjustAngleToLimits_mbt_c407977658d33772(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbA_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbA_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbA);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbB_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbB_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbB);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_name_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintFloatData_m_name_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_objectType_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_objectType_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintType_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintType_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintId_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintId_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_needsFeedback_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_needsFeedback_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_appliedImpulse_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_appliedImpulse_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_dbgDrawSize_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_dbgDrawSize_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_isEnabled_set_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_isEnabled_get_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintFloatData *_wrap_new_btTypedConstraintFloatData_mbt_c407977658d33772() {
  btTypedConstraintFloatData *result = 0 ;
  btTypedConstraintFloatData *_swig_go_result;
  
  
  result = (btTypedConstraintFloatData *)new btTypedConstraintFloatData();
  *(btTypedConstraintFloatData **)&_swig_go_result = (btTypedConstraintFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintFloatData_mbt_c407977658d33772(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintData_m_rbA_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintData_m_rbA_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbA);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_rbB_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintData_m_rbB_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbB);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_name_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintData_m_name_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_objectType_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_objectType_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintType_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintType_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintId_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintId_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_needsFeedback_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_needsFeedback_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_appliedImpulse_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintData_m_appliedImpulse_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_dbgDrawSize_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintData_m_dbgDrawSize_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_overrideNumSolverIterations_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_overrideNumSolverIterations_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_breakingImpulseThreshold_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintData_m_breakingImpulseThreshold_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_isEnabled_set_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_isEnabled_get_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintData *_wrap_new_btTypedConstraintData_mbt_c407977658d33772() {
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  
  result = (btTypedConstraintData *)new btTypedConstraintData();
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintData_mbt_c407977658d33772(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintDoubleData_m_rbA_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbA_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbA);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_rbB_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbB_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbB);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_name_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_m_name_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_objectType_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_objectType_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintType_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintType_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintId_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintId_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_needsFeedback_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_needsFeedback_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_appliedImpulse_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_appliedImpulse_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_isEnabled_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_isEnabled_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_padding_set_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->padding, (const char *)arg2, 4-1);
      arg1->padding[4-1] = 0;
    } else {
      arg1->padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_padding_get_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btTypedConstraintDoubleData *_wrap_new_btTypedConstraintDoubleData_mbt_c407977658d33772() {
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  
  result = (btTypedConstraintDoubleData *)new btTypedConstraintDoubleData();
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintDoubleData_mbt_c407977658d33772(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btAngularLimit *_wrap_new_btAngularLimit_mbt_c407977658d33772() {
  btAngularLimit *result = 0 ;
  btAngularLimit *_swig_go_result;
  
  
  result = (btAngularLimit *)new btAngularLimit();
  *(btAngularLimit **)&_swig_go_result = (btAngularLimit *)result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_set__SWIG_0_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->set(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_btAngularLimit_set__SWIG_1_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->set(arg2,arg3,arg4,arg5);
  
}


void _wrap_btAngularLimit_set__SWIG_2_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->set(arg2,arg3,arg4);
  
}


void _wrap_btAngularLimit_set__SWIG_3_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->set(arg2,arg3);
  
}


void _wrap_btAngularLimit_test_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float _swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->test(arg2);
  
}


float _wrap_btAngularLimit_getSoftness_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getBiasFactor_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getRelaxationFactor_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getCorrection_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getSign_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSign();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHalfRange_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btAngularLimit_isLimit_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (bool)((btAngularLimit const *)arg1)->isLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_fit_mbt_c407977658d33772(btAngularLimit *_swig_go_0, float *_swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btAngularLimit const *)arg1)->fit(*arg2);
  
}


float _wrap_btAngularLimit_getError_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getError();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getLow_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getLow();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHigh_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btAngularLimit_mbt_c407977658d33772(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  delete arg1;
  
}


#ifdef __cplusplus
}
#endif

