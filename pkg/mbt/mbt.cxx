/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

// source: C:\MMD\mlib_go\pkg\mbt\bullet.i


extern
#ifdef __cplusplus
  "C"
#endif
  void cgo_panic__mbt_c1af402c8cb9fdfb(const char*);
static void _swig_gopanic(const char *p) {
  cgo_panic__mbt_c1af402c8cb9fdfb(p);
}



#define SWIG_VERSION 0x040200
#define SWIGGO
#define SWIGMODULE mbt
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 


/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif



#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>



typedef ptrdiff_t intgo;
typedef size_t uintgo;


# if !defined(__clang__) && (defined(__i386__) || defined(__x86_64__))
#   define SWIGSTRUCTPACKED __attribute__((__packed__, __gcc_struct__))
# else
#   define SWIGSTRUCTPACKED __attribute__((__packed__))
# endif



typedef struct { char *p; intgo n; } _gostring_;
typedef struct { void* array; intgo len; intgo cap; } _goslice_;



static _gostring_ Swig_AllocateString(const char *p, size_t l) {
  _gostring_ ret;
  ret.p = (char*)malloc(l);
  memcpy(ret.p, p, l);
  ret.n = l;
  return ret;
}


#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


static void Swig_free(void* p) {
  free(p);
}

static void* Swig_malloc(int c) {
  return malloc(c);
}


    #include <cmath>
    #include <string>


#define FLT_EPSILON      1.192092896e-07F        // smallest such that 1.0+FLT_EPSILON != 1.0
#define FLT_MAX          3.402823466e+38F        // max value



/* 7.12.4 Trigonometric functions: Double in C89 */
  extern float __cdecl sinf(float _X);
  extern long double __cdecl sinl(long double);

  extern float __cdecl cosf(float _X);
  extern long double __cdecl cosl(long double);

  extern float __cdecl tanf(float _X);
  extern long double __cdecl tanl(long double);
  extern float __cdecl asinf(float _X);
  extern long double __cdecl asinl(long double);

  extern float __cdecl acosf (float);
  extern long double __cdecl acosl (long double);

  extern float __cdecl atanf (float);
  extern long double __cdecl atanl (long double);

  extern float __cdecl atan2f (float, float);
  extern long double __cdecl atan2l (long double, long double);

/* 7.12.6.1 Double in C89 */
  extern float __cdecl expf(float _X);

/* 7.12.6.7 Double in C89 */
  extern float __cdecl logf (float);

/* 7.12.7.4 The pow functions. Double in C89 */
  extern float __cdecl powf(float _X,float _Y);

/* 7.12.7.5 The sqrt functions. Double in C89. */
  extern float __cdecl sqrtf (float);

/* 7.12.7.2 The fabs functions: Double in C89 */
  extern  float __cdecl fabsf (float x);

/* 7.12.10.1 Double in C89 */
  extern float __cdecl fmodf (float, float);




/*
Copyright (c) 2003-2009 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SCALAR_H
#define BT_SCALAR_H

#ifdef BT_MANAGED_CODE
//Aligned data types not supported in managed code
#pragma unmanaged
#endif


/* SVN $Revision$ on $Date$ from http://bullet.googlecode.com*/
#define BT_BULLET_VERSION 326

inline int btGetVersion()
{
	return BT_BULLET_VERSION;
}

inline int btIsDoublePrecision()
{
  #ifdef BT_USE_DOUBLE_PRECISION
  return true;
  #else
  return false;
  #endif
}


// The following macro "BT_NOT_EMPTY_FILE" can be put into a file
// in order suppress the MS Visual C++ Linker warning 4221
//
// warning LNK4221: no public symbols found; archive member will be inaccessible
//
// This warning occurs on PC and XBOX when a file compiles out completely
// has no externally visible symbols which may be dependant on configuration
// #defines and options.
//
// see more https://stackoverflow.com/questions/1822887/what-is-the-best-way-to-eliminate-ms-visual-c-linker-warning-warning-lnk422

#if defined(_MSC_VER)
#define BT_NOT_EMPTY_FILE_CAT_II(p, res) res
#define BT_NOT_EMPTY_FILE_CAT_I(a, b) BT_NOT_EMPTY_FILE_CAT_II(~, a##b)
#define BT_NOT_EMPTY_FILE_CAT(a, b) BT_NOT_EMPTY_FILE_CAT_I(a, b)
#define BT_NOT_EMPTY_FILE                                      \
	namespace                                                  \
	{                                                          \
	char BT_NOT_EMPTY_FILE_CAT(NoEmptyFileDummy, __COUNTER__); \
	}
#else
#define BT_NOT_EMPTY_FILE
#endif

// clang and most formatting tools don't support indentation of preprocessor guards, so turn it off
// clang-format off
#if defined(DEBUG) || defined (_DEBUG)
	#define BT_DEBUG
#endif

#ifdef _WIN32
	#if  defined(__GNUC__)	// it should handle both MINGW and CYGWIN
        	#define SIMD_FORCE_INLINE        __inline__ __attribute__((always_inline))
        	#define ATTRIBUTE_ALIGNED16(a)   a __attribute__((aligned(16)))
        	#define ATTRIBUTE_ALIGNED64(a)   a __attribute__((aligned(64)))
        	#define ATTRIBUTE_ALIGNED128(a)  a __attribute__((aligned(128)))
    	#elif ( defined(_MSC_VER) && _MSC_VER < 1300 )
		#define SIMD_FORCE_INLINE inline
		#define ATTRIBUTE_ALIGNED16(a) a
		#define ATTRIBUTE_ALIGNED64(a) a
		#define ATTRIBUTE_ALIGNED128(a) a
	#elif defined(_M_ARM)
		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec() a
		#define ATTRIBUTE_ALIGNED64(a) __declspec() a
		#define ATTRIBUTE_ALIGNED128(a) __declspec () a
	#else//__MINGW32__
		//#define BT_HAS_ALIGNED_ALLOCATOR
		#pragma warning(disable : 4324) // disable padding warning
//			#pragma warning(disable:4530) // Disable the exception disable but used in MSCV Stl warning.
		#pragma warning(disable:4996) //Turn off warnings about deprecated C routines
//			#pragma warning(disable:4786) // Disable the "debug name too long" warning

		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec(align(16)) a
		#define ATTRIBUTE_ALIGNED64(a) __declspec(align(64)) a
		#define ATTRIBUTE_ALIGNED128(a) __declspec (align(128)) a
		#ifdef _XBOX
			#define BT_USE_VMX128

 			#define BT_HAVE_NATIVE_FSEL
 			#define btFsel(a,b,c) __fsel((a),(b),(c))
		#else

#if defined (_M_ARM) || defined (_M_ARM64)
            //Do not turn SSE on for ARM (may want to turn on BT_USE_NEON however)
#elif (defined (_WIN32) && (_MSC_VER) && _MSC_VER >= 1400) && (!defined (BT_USE_DOUBLE_PRECISION))

#ifdef __clang__
#define __BT_DISABLE_SSE__
#endif
#ifndef __BT_DISABLE_SSE__
			#if _MSC_VER>1400
				#define BT_USE_SIMD_VECTOR3
			#endif
			#define BT_USE_SSE
#endif//__BT_DISABLE_SSE__
			#ifdef BT_USE_SSE

#if (_MSC_FULL_VER >= 170050727)//Visual Studio 2012 can compile SSE4/FMA3 (but SSE4/FMA3 is not enabled by default)
			#define BT_ALLOW_SSE4
#endif //(_MSC_FULL_VER >= 160040219)

			//BT_USE_SSE_IN_API is disabled under Windows by default, because 
			//it makes it harder to integrate Bullet into your application under Windows 
			//(structured embedding Bullet structs/classes need to be 16-byte aligned)
			//with relatively little performance gain
			//If you are not embedded Bullet data in your classes, or make sure that you align those classes on 16-byte boundaries
			//you can manually enable this line or set it in the build system for a bit of performance gain (a few percent, dependent on usage)
			//#define BT_USE_SSE_IN_API
			#endif //BT_USE_SSE
#endif

		#endif//_XBOX

	#endif //__MINGW32__

	#ifdef BT_DEBUG
		#ifdef _MSC_VER
			#define btAssert(x) { if(!(x)){printf("Assert " __FILE__ ":%u (%s)\n", __LINE__, #x);__debugbreak();	}}
		#else//_MSC_VER
			#define btAssert assert
		#endif//_MSC_VER
	#else
		#define btAssert(x)
	#endif
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

#else//_WIN32
	
	#if defined	(__CELLOS_LV2__)
		#define SIMD_FORCE_INLINE inline __attribute__((always_inline))
		#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
		#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
		#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
		#ifndef assert
		#endif
		#ifdef BT_DEBUG
			#ifdef __SPU__
				#define printf spu_printf
				#define btAssert(x) {if(!(x)){printf("Assert " __FILE__ ":%u ("#x")\n", __LINE__);spu_hcmpeq(0,0);}}
			#else
				#define btAssert assert
			#endif
	
		#else//BT_DEBUG
				#define btAssert(x)
		#endif//BT_DEBUG
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

	#else//defined	(__CELLOS_LV2__)

		#ifdef USE_LIBSPE2

			#define SIMD_FORCE_INLINE __inline
			#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
			#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
			#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
			#ifndef assert
			#endif
	#ifdef BT_DEBUG
			#define btAssert assert
	#else
			#define btAssert(x)
	#endif
			//btFullAssert is optional, slows down a lot
			#define btFullAssert(x)


			#define btLikely(_c)   __builtin_expect((_c), 1)
			#define btUnlikely(_c) __builtin_expect((_c), 0)
		

		#else//USE_LIBSPE2
	//non-windows systems

			#if (defined (__APPLE__) && (!defined (BT_USE_DOUBLE_PRECISION)))
				#if defined (__i386__) || defined (__x86_64__)
					#define BT_USE_SIMD_VECTOR3
					#define BT_USE_SSE
					//BT_USE_SSE_IN_API is enabled on Mac OSX by default, because memory is automatically aligned on 16-byte boundaries
					//if apps run into issues, we will disable the next line
					#define BT_USE_SSE_IN_API
					#ifdef BT_USE_SSE
						// include appropriate SSE level
						#if defined (__SSE4_1__)
						#elif defined (__SSSE3__)
						#elif defined (__SSE3__)
						#else
						#endif
					#endif //BT_USE_SSE
				#elif defined( __ARM_NEON__ )
					#ifdef __clang__
						#define BT_USE_NEON 1
						#define BT_USE_SIMD_VECTOR3
		
						#if defined BT_USE_NEON && defined (__clang__)
						#endif//BT_USE_NEON
				   #endif //__clang__
				#endif//__arm__

				#define SIMD_FORCE_INLINE inline __attribute__ ((always_inline))
			///@todo: check out alignment methods for other platforms/compilers
				#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
				 #if defined (__i386__) || defined (__x86_64__)
				 #define btAssert(x)\
				{\
				if(!(x))\
				{\
					printf("Assert %s in line %d, file %s\n",#x, __LINE__, __FILE__);\
					asm volatile ("int3");\
				}\
				}
				#else//defined (__i386__) || defined (__x86_64__)
					#define btAssert assert
				#endif//defined (__i386__) || defined (__x86_64__)
				#else//defined(DEBUG) || defined (_DEBUG)
					#define btAssert(x)
				#endif//defined(DEBUG) || defined (_DEBUG)

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c

			#else//__APPLE__

				#define SIMD_FORCE_INLINE inline
				///@todo: check out alignment methods for other platforms/compilers
				///#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				///#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				///#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#define ATTRIBUTE_ALIGNED16(a) a
				#define ATTRIBUTE_ALIGNED64(a) a
				#define ATTRIBUTE_ALIGNED128(a) a
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
					#define btAssert assert
				#else
					#define btAssert(x)
				#endif

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c
			#endif //__APPLE__ 
		#endif // LIBSPE2
	#endif	//__CELLOS_LV2__
#endif//_WIN32


///The btScalar type abstracts floating point numbers, to easily switch between double and single floating point precision.
#if defined(BT_USE_DOUBLE_PRECISION)
	typedef double btScalar;
	//this number could be bigger in double precision
	#define BT_LARGE_FLOAT 1e30
#else
	typedef float btScalar;
	//keep BT_LARGE_FLOAT*BT_LARGE_FLOAT < FLT_MAX
	#define BT_LARGE_FLOAT 1e18f
#endif

#ifdef BT_USE_SSE
	typedef __m128 btSimdFloat4;
#endif  //BT_USE_SSE

#if defined(BT_USE_SSE)
	//#if defined BT_USE_SSE_IN_API && defined (BT_USE_SSE)
	#ifdef _WIN32

		#ifndef BT_NAN
			static int btNanMask = 0x7F800001;
			#define BT_NAN (*(float *)&btNanMask)
		#endif

		#ifndef BT_INFINITY
			static int btInfinityMask = 0x7F800000;
			#define BT_INFINITY (*(float *)&btInfinityMask)
			inline int btGetInfinityMask()  //suppress stupid compiler warning
			{
				return btInfinityMask;
			}
		#endif



	//use this, in case there are clashes (such as xnamath.h)
	#ifndef BT_NO_SIMD_OPERATOR_OVERLOADS
	inline __m128 operator+(const __m128 A, const __m128 B)
	{
		return _mm_add_ps(A, B);
	}

	inline __m128 operator-(const __m128 A, const __m128 B)
	{
		return _mm_sub_ps(A, B);
	}

	inline __m128 operator*(const __m128 A, const __m128 B)
	{
		return _mm_mul_ps(A, B);
	}
	#endif  //BT_NO_SIMD_OPERATOR_OVERLOADS

	#define btCastfTo128i(a) (_mm_castps_si128(a))
	#define btCastfTo128d(a) (_mm_castps_pd(a))
	#define btCastiTo128f(a) (_mm_castsi128_ps(a))
	#define btCastdTo128f(a) (_mm_castpd_ps(a))
	#define btCastdTo128i(a) (_mm_castpd_si128(a))
	#define btAssign128(r0, r1, r2, r3) _mm_setr_ps(r0, r1, r2, r3)

	#else  //_WIN32

		#define btCastfTo128i(a) ((__m128i)(a))
		#define btCastfTo128d(a) ((__m128d)(a))
		#define btCastiTo128f(a) ((__m128)(a))
		#define btCastdTo128f(a) ((__m128)(a))
		#define btCastdTo128i(a) ((__m128i)(a))
		#define btAssign128(r0, r1, r2, r3) \
			(__m128) { r0, r1, r2, r3 }
		#define BT_INFINITY INFINITY
		#define BT_NAN NAN
	#endif  //_WIN32
#else//BT_USE_SSE

	#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
	#else  //BT_USE_NEON

	#ifndef BT_INFINITY
	struct btInfMaskConverter
	{
		union {
			float mask;
			int intmask;
		};
		btInfMaskConverter(int _mask = 0x7F800000)
			: intmask(_mask)
		{
		}
	};
	static btInfMaskConverter btInfinityMask = 0x7F800000;
	#define BT_INFINITY (btInfinityMask.mask)
	inline int btGetInfinityMask()  //suppress stupid compiler warning
	{
		return btInfinityMask.intmask;
	}
	#endif
	#endif  //BT_USE_NEON

#endif  //BT_USE_SSE

#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
#endif//BT_USE_NEON

#define BT_DECLARE_ALIGNED_ALLOCATOR()                                                                     \
	SIMD_FORCE_INLINE void *operator new(size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); }   \
	SIMD_FORCE_INLINE void operator delete(void *ptr) { btAlignedFree(ptr); }                              \
	SIMD_FORCE_INLINE void *operator new(size_t, void *ptr) { return ptr; }                                \
	SIMD_FORCE_INLINE void operator delete(void *, void *) {}                                              \
	SIMD_FORCE_INLINE void *operator new[](size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); } \
	SIMD_FORCE_INLINE void operator delete[](void *ptr) { btAlignedFree(ptr); }                            \
	SIMD_FORCE_INLINE void *operator new[](size_t, void *ptr) { return ptr; }                              \
	SIMD_FORCE_INLINE void operator delete[](void *, void *) {}

#if defined(BT_USE_DOUBLE_PRECISION) || defined(BT_FORCE_DOUBLE_FUNCTIONS)

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar x)
	{
		return sqrt(x);
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabs(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cos(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sin(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tan(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return acos(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return asin(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atan(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return exp(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return log(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return pow(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmod(x, y); }

#else//BT_USE_DOUBLE_PRECISION

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar y)
	{
	#ifdef USE_APPROXIMATION
	#ifdef __LP64__
		float xhalf = 0.5f * y;
		int i = *(int *)&y;
		i = 0x5f375a86 - (i >> 1);
		y = *(float *)&i;
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = 1 / y;
		return y;
	#else
		double x, z, tempf;
		unsigned long *tfptr = ((unsigned long *)&tempf) + 1;
		tempf = y;
		*tfptr = (0xbfcdd90a - *tfptr) >> 1; /* estimate of 1/sqrt(y) */
		x = tempf;
		z = y * btScalar(0.5);
		x = (btScalar(1.5) * x) - (x * x) * (x * z); /* iteration formula     */
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		return x * y;
	#endif
	#else
		return sqrtf(y);
	#endif
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabsf(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cosf(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sinf(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tanf(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return acosf(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return asinf(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atanf(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2f(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return expf(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return logf(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return powf(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmodf(x, y); }

#endif//BT_USE_DOUBLE_PRECISION

#define SIMD_PI btScalar(3.1415926535897932384626433832795029)
#define SIMD_2_PI (btScalar(2.0) * SIMD_PI)
#define SIMD_HALF_PI (SIMD_PI * btScalar(0.5))
#define SIMD_RADS_PER_DEG (SIMD_2_PI / btScalar(360.0))
#define SIMD_DEGS_PER_RAD (btScalar(360.0) / SIMD_2_PI)
#define SIMDSQRT12 btScalar(0.7071067811865475244008443621048490)
#define btRecipSqrt(x) ((btScalar)(btScalar(1.0) / btSqrt(btScalar(x)))) /* reciprocal square root */
#define btRecip(x) (btScalar(1.0) / btScalar(x))

#ifdef BT_USE_DOUBLE_PRECISION
	#define SIMD_EPSILON DBL_EPSILON
	#define SIMD_INFINITY DBL_MAX
	#define BT_ONE 1.0
	#define BT_ZERO 0.0
	#define BT_TWO 2.0
	#define BT_HALF 0.5
#else
	#define SIMD_EPSILON FLT_EPSILON
	#define SIMD_INFINITY FLT_MAX
	#define BT_ONE 1.0f
	#define BT_ZERO 0.0f
	#define BT_TWO 2.0f
	#define BT_HALF 0.5f
#endif

// clang-format on

SIMD_FORCE_INLINE btScalar btAtan2Fast(btScalar y, btScalar x)
{
	btScalar coeff_1 = SIMD_PI / 4.0f;
	btScalar coeff_2 = 3.0f * coeff_1;
	btScalar abs_y = btFabs(y);
	btScalar angle;
	if (x >= 0.0f)
	{
		btScalar r = (x - abs_y) / (x + abs_y);
		angle = coeff_1 - coeff_1 * r;
	}
	else
	{
		btScalar r = (x + abs_y) / (abs_y - x);
		angle = coeff_2 - coeff_1 * r;
	}
	return (y < 0.0f) ? -angle : angle;
}

SIMD_FORCE_INLINE bool btFuzzyZero(btScalar x) { return btFabs(x) < SIMD_EPSILON; }

SIMD_FORCE_INLINE bool btEqual(btScalar a, btScalar eps)
{
	return (((a) <= eps) && !((a) < -eps));
}
SIMD_FORCE_INLINE bool btGreaterEqual(btScalar a, btScalar eps)
{
	return (!((a) <= eps));
}

SIMD_FORCE_INLINE int btIsNegative(btScalar x)
{
	return x < btScalar(0.0) ? 1 : 0;
}

SIMD_FORCE_INLINE btScalar btRadians(btScalar x) { return x * SIMD_RADS_PER_DEG; }
SIMD_FORCE_INLINE btScalar btDegrees(btScalar x) { return x * SIMD_DEGS_PER_RAD; }

#define BT_DECLARE_HANDLE(name) \
	typedef struct name##__     \
	{                           \
		int unused;             \
	} * name

#ifndef btFsel
SIMD_FORCE_INLINE btScalar btFsel(btScalar a, btScalar b, btScalar c)
{
	return a >= 0 ? b : c;
}
#endif
#define btFsels(a, b, c) (btScalar) btFsel(a, b, c)

SIMD_FORCE_INLINE bool btMachineIsLittleEndian()
{
	long int i = 1;
	const char *p = (const char *)&i;
	if (p[0] == 1)  // Lowest address contains the least significant byte
		return true;
	else
		return false;
}

///btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
///Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html
SIMD_FORCE_INLINE unsigned btSelect(unsigned condition, unsigned valueIfConditionNonZero, unsigned valueIfConditionZero)
{
	// Set testNz to 0xFFFFFFFF if condition is nonzero, 0x00000000 if condition is zero
	// Rely on positive value or'ed with its negative having sign bit on
	// and zero value or'ed with its negative (which is still zero) having sign bit off
	// Use arithmetic shift right, shifting the sign bit through all 32 bits
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return ((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE int btSelect(unsigned condition, int valueIfConditionNonZero, int valueIfConditionZero)
{
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return static_cast<int>((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE float btSelect(unsigned condition, float valueIfConditionNonZero, float valueIfConditionZero)
{
#ifdef BT_HAVE_NATIVE_FSEL
	return (float)btFsel((btScalar)condition - btScalar(1.0f), valueIfConditionNonZero, valueIfConditionZero);
#else
	return (condition != 0) ? valueIfConditionNonZero : valueIfConditionZero;
#endif
}

template <typename T>
SIMD_FORCE_INLINE void btSwap(T &a, T &b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

//PCK: endian swapping functions
SIMD_FORCE_INLINE unsigned btSwapEndian(unsigned val)
{
	return (((val & 0xff000000) >> 24) | ((val & 0x00ff0000) >> 8) | ((val & 0x0000ff00) << 8) | ((val & 0x000000ff) << 24));
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(unsigned short val)
{
	return static_cast<unsigned short>(((val & 0xff00) >> 8) | ((val & 0x00ff) << 8));
}

SIMD_FORCE_INLINE unsigned btSwapEndian(int val)
{
	return btSwapEndian((unsigned)val);
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(short val)
{
	return btSwapEndian((unsigned short)val);
}

///btSwapFloat uses using char pointers to swap the endianness
////btSwapFloat/btSwapDouble will NOT return a float, because the machine might 'correct' invalid floating point values
///Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754.
///When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception.
///In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you.
///so instead of returning a float/double, we return integer/long long integer
SIMD_FORCE_INLINE unsigned int btSwapEndianFloat(float d)
{
	unsigned int a = 0;
	unsigned char *dst = (unsigned char *)&a;
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];
	return a;
}

// unswap using char pointers
SIMD_FORCE_INLINE float btUnswapEndianFloat(unsigned int a)
{
	float d = 0.0f;
	unsigned char *src = (unsigned char *)&a;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];

	return d;
}

// swap using char pointers
SIMD_FORCE_INLINE void btSwapEndianDouble(double d, unsigned char *dst)
{
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];
}

// unswap using char pointers
SIMD_FORCE_INLINE double btUnswapEndianDouble(const unsigned char *src)
{
	double d = 0.0;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];

	return d;
}

template <typename T>
SIMD_FORCE_INLINE void btSetZero(T *a, int n)
{
	T *acurr = a;
	size_t ncurr = n;
	while (ncurr > 0)
	{
		*(acurr++) = 0;
		--ncurr;
	}
}

SIMD_FORCE_INLINE btScalar btLargeDot(const btScalar *a, const btScalar *b, int n)
{
	btScalar p0, q0, m0, p1, q1, m1, sum;
	sum = 0;
	n -= 2;
	while (n >= 0)
	{
		p0 = a[0];
		q0 = b[0];
		m0 = p0 * q0;
		p1 = a[1];
		q1 = b[1];
		m1 = p1 * q1;
		sum += m0;
		sum += m1;
		a += 2;
		b += 2;
		n -= 2;
	}
	n += 2;
	while (n > 0)
	{
		sum += (*a) * (*b);
		a++;
		b++;
		n--;
	}
	return sum;
}

// returns normalized value in range [-SIMD_PI, SIMD_PI]
SIMD_FORCE_INLINE btScalar btNormalizeAngle(btScalar angleInRadians)
{
	angleInRadians = btFmod(angleInRadians, SIMD_2_PI);
	if (angleInRadians < -SIMD_PI)
	{
		return angleInRadians + SIMD_2_PI;
	}
	else if (angleInRadians > SIMD_PI)
	{
		return angleInRadians - SIMD_2_PI;
	}
	else
	{
		return angleInRadians;
	}
}

///rudimentary class to provide type info
struct btTypedObject
{
	btTypedObject(int objectType)
		: m_objectType(objectType)
	{
	}
	int m_objectType;
	inline int getObjectType() const
	{
		return m_objectType;
	}
};

///align a pointer to the provided alignment, upwards
template <typename T>
T *btAlignPointer(T *unalignedPtr, size_t alignment)
{
	struct btConvertPointerSizeT
	{
		union {
			T *ptr;
			size_t integer;
		};
	};
	btConvertPointerSizeT converter;

	const size_t bit_mask = ~(alignment - 1);
	converter.ptr = unalignedPtr;
	converter.integer += alignment - 1;
	converter.integer &= bit_mask;
	return converter.ptr;
}

#endif  //BT_SCALAR_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEN_MINMAX_H
#define BT_GEN_MINMAX_H

#include "LinearMath/btScalar.h"

template <class T>
SIMD_FORCE_INLINE const T& btMin(const T& a, const T& b)
{
	return a < b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btMax(const T& a, const T& b)
{
	return a > b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btClamped(const T& a, const T& lb, const T& ub)
{
	return a < lb ? lb : (ub < a ? ub : a);
}

template <class T>
SIMD_FORCE_INLINE void btSetMin(T& a, const T& b)
{
	if (b < a)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btSetMax(T& a, const T& b)
{
	if (a < b)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btClamp(T& a, const T& lb, const T& ub)
{
	if (a < lb)
	{
		a = lb;
	}
	else if (ub < a)
	{
		a = ub;
	}
}

#endif  //BT_GEN_MINMAX_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS
int gNumAlignedAllocs = 0;
int gNumAlignedFree = 0;
int gTotalBytesAlignedAllocs = 0;  //detect memory leaks
#endif                             //BT_DEBUG_MEMORY_ALLOCATIONST_DEBUG_ALLOCATIONS

static void *btAllocDefault(size_t size)
{
  char* data = (char*) malloc(size);
  memset(data,0,size);//keep msan happy
  return data;
}

static void btFreeDefault(void *ptr)
{
	free(ptr);
}

static btAllocFunc *sAllocFunc = btAllocDefault;
static btFreeFunc *sFreeFunc = btFreeDefault;

#if defined(BT_HAS_ALIGNED_ALLOCATOR)
static void *btAlignedAllocDefault(size_t size, int alignment)
{
	return _aligned_malloc(size, (size_t)alignment);
}

static void btAlignedFreeDefault(void *ptr)
{
	_aligned_free(ptr);
}
#elif defined(__CELLOS_LV2__)

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	return memalign(alignment, size);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	free(ptr);
}
#else

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	void *ret;
	char *real;
	real = (char *)sAllocFunc(size + sizeof(void *) + (alignment - 1));
	if (real)
	{
		ret = btAlignPointer(real + sizeof(void *), alignment);
		*((void **)(ret)-1) = (void *)(real);
	}
	else
	{
		ret = (void *)(real);
	}
  //keep msan happy
  memset((char*) ret, 0, size);
	return (ret);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	void *real;

	if (ptr)
	{
		real = *((void **)(ptr)-1);
		sFreeFunc(real);
	}
}
#endif

static btAlignedAllocFunc *sAlignedAllocFunc = btAlignedAllocDefault;
static btAlignedFreeFunc *sAlignedFreeFunc = btAlignedFreeDefault;

void btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc)
{
	sAlignedAllocFunc = allocFunc ? allocFunc : btAlignedAllocDefault;
	sAlignedFreeFunc = freeFunc ? freeFunc : btAlignedFreeDefault;
}

void btAlignedAllocSetCustom(btAllocFunc *allocFunc, btFreeFunc *freeFunc)
{
	sAllocFunc = allocFunc ? allocFunc : btAllocDefault;
	sFreeFunc = freeFunc ? freeFunc : btFreeDefault;
}

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

static int allocations_id[10241024];
static int allocations_bytes[10241024];
static int mynumallocs = 0;

int btDumpMemoryLeaks()
{
	int totalLeak = 0;

	for (int i = 0; i < mynumallocs; i++)
	{
		printf("Error: leaked memory of allocation #%d (%d bytes)\n", allocations_id[i], allocations_bytes[i]);
		totalLeak += allocations_bytes[i];
	}
	if (totalLeak)
	{
		printf("Error: memory leaks: %d allocations were not freed and leaked together %d bytes\n", mynumallocs, totalLeak);
	}
	return totalLeak;
}
//this generic allocator provides the total allocated number of bytes

struct btDebugPtrMagic
{
	union {
		void **vptrptr;
		void *vptr;
		int *iptr;
		char *cptr;
	};
};

void *btAlignedAllocInternal(size_t size, int alignment, int line, const char *filename)
{
	if (size == 0)
	{
		printf("Whaat? size==0");
		return 0;
	}
	static int allocId = 0;

	void *ret;
	char *real;

	// to find some particular memory leak, you could do something like this:
	//	if (allocId==172)
	//	{
	//		printf("catch me!\n");
	//	}
	//	if (size>1024*1024)
	//	{
	//		printf("big alloc!%d\n", size);
	//	}

	gTotalBytesAlignedAllocs += size;
	gNumAlignedAllocs++;

	int sz4prt = 4 * sizeof(void *);

	real = (char *)sAllocFunc(size + sz4prt + (alignment - 1));
	if (real)
	{
		ret = (void *)btAlignPointer(real + sz4prt, alignment);
		btDebugPtrMagic p;
		p.vptr = ret;
		p.cptr -= sizeof(void *);
		*p.vptrptr = (void *)real;
		p.cptr -= sizeof(void *);
		*p.iptr = size;
		p.cptr -= sizeof(void *);
		*p.iptr = allocId;

		allocations_id[mynumallocs] = allocId;
		allocations_bytes[mynumallocs] = size;
		mynumallocs++;
	}
	else
	{
		ret = (void *)(real);  //??
	}

	printf("allocation %d at address %x, from %s,line %d, size %d (total allocated = %d)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs);
	allocId++;

	int *ptr = (int *)ret;
	*ptr = 12;
	return (ret);
}

void btAlignedFreeInternal(void *ptr, int line, const char *filename)
{
	void *real;

	if (ptr)
	{
		gNumAlignedFree++;

		btDebugPtrMagic p;
		p.vptr = ptr;
		p.cptr -= sizeof(void *);
		real = *p.vptrptr;
		p.cptr -= sizeof(void *);
		int size = *p.iptr;
		p.cptr -= sizeof(void *);
		int allocId = *p.iptr;

		bool found = false;

		for (int i = 0; i < mynumallocs; i++)
		{
			if (allocations_id[i] == allocId)
			{
				allocations_id[i] = allocations_id[mynumallocs - 1];
				allocations_bytes[i] = allocations_bytes[mynumallocs - 1];
				mynumallocs--;
				found = true;
				break;
			}
		}

		gTotalBytesAlignedAllocs -= size;

		int diff = gNumAlignedAllocs - gNumAlignedFree;
		printf("free %d at address %x, from %s,line %d, size %d (total remain = %d in %d non-freed allocations)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs, diff);

		sFreeFunc(real);
	}
	else
	{
		//printf("deleting a NULL ptr, no effect\n");
	}
}

#else  //BT_DEBUG_MEMORY_ALLOCATIONS

void *btAlignedAllocInternal(size_t size, int alignment)
{
	void *ptr;
	ptr = sAlignedAllocFunc(size, alignment);
	//	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
	return ptr;
}

void btAlignedFreeInternal(void *ptr)
{
	if (!ptr)
	{
		return;
	}

	//	printf("btAlignedFreeInternal %x\n",ptr);
	sAlignedFreeFunc(ptr);
}

#endif  //BT_DEBUG_MEMORY_ALLOCATIONS





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_ALIGNED_ALLOCATOR
#define BT_ALIGNED_ALLOCATOR

///we probably replace this with our own aligned memory allocator
///so we replace _aligned_malloc and _aligned_free with our own
///that is better portable and more predictable

#include "LinearMath/btScalar.h"

///BT_DEBUG_MEMORY_ALLOCATIONS preprocessor can be set in build system
///for regression tests to detect memory leaks
///#define BT_DEBUG_MEMORY_ALLOCATIONS 1
#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

int btDumpMemoryLeaks();

#define btAlignedAlloc(a, b) \
	btAlignedAllocInternal(a, b, __LINE__, __FILE__)

#define btAlignedFree(ptr) \
	btAlignedFreeInternal(ptr, __LINE__, __FILE__)

void* btAlignedAllocInternal(size_t size, int alignment, int line, const char* filename);

void btAlignedFreeInternal(void* ptr, int line, const char* filename);

#else
void* btAlignedAllocInternal(size_t size, int alignment);
void btAlignedFreeInternal(void* ptr);

#define btAlignedAlloc(size, alignment) btAlignedAllocInternal(size, alignment)
#define btAlignedFree(ptr) btAlignedFreeInternal(ptr)

#endif
typedef int size_type;

typedef void*(btAlignedAllocFunc)(size_t size, int alignment);
typedef void(btAlignedFreeFunc)(void* memblock);
typedef void*(btAllocFunc)(size_t size);
typedef void(btFreeFunc)(void* memblock);

///The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
void btAlignedAllocSetCustom(btAllocFunc* allocFunc, btFreeFunc* freeFunc);
///If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
void btAlignedAllocSetCustomAligned(btAlignedAllocFunc* allocFunc, btAlignedFreeFunc* freeFunc);

///The btAlignedAllocator is a portable class for aligned memory allocations.
///Default implementations for unaligned and aligned allocations can be overridden by a custom allocator using btAlignedAllocSetCustom and btAlignedAllocSetCustomAligned.
template <typename T, unsigned Alignment>
class btAlignedAllocator
{
	typedef btAlignedAllocator<T, Alignment> self_type;

public:
	//just going down a list:
	btAlignedAllocator() {}
	/*
	btAlignedAllocator( const self_type & ) {}
	*/

	template <typename Other>
	btAlignedAllocator(const btAlignedAllocator<Other, Alignment>&)
	{
	}

	typedef const T* const_pointer;
	typedef const T& const_reference;
	typedef T* pointer;
	typedef T& reference;
	typedef T value_type;

	pointer address(reference ref) const { return &ref; }
	const_pointer address(const_reference ref) const { return &ref; }
	pointer allocate(size_type n, const_pointer* hint = 0)
	{
		(void)hint;
		return reinterpret_cast<pointer>(btAlignedAlloc(sizeof(value_type) * n, Alignment));
	}
	void construct(pointer ptr, const value_type& value) { new (ptr) value_type(value); }
	void deallocate(pointer ptr)
	{
		btAlignedFree(reinterpret_cast<void*>(ptr));
	}
	void destroy(pointer ptr) { ptr->~value_type(); }

	template <typename O>
	struct rebind
	{
		typedef btAlignedAllocator<O, Alignment> other;
	};
	template <typename O>
	self_type& operator=(const btAlignedAllocator<O, Alignment>&)
	{
		return *this;
	}

	friend bool operator==(const self_type&, const self_type&) { return true; }
};

#endif  //BT_ALIGNED_ALLOCATOR





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_VECTOR3_H
#define BT_VECTOR3_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btVector3Data btVector3DoubleData
#define btVector3DataName "btVector3DoubleData"
#else
#define btVector3Data btVector3FloatData
#define btVector3DataName "btVector3FloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#if defined BT_USE_SSE

//typedef  uint32_t __m128i __attribute__ ((vector_size(16)));

#ifdef _MSC_VER
#pragma warning(disable : 4556)  // value of intrinsic immediate argument '4294967239' is out of range '0 - 255'
#endif

#define BT_SHUFFLE(x, y, z, w) (((w) << 6 | (z) << 4 | (y) << 2 | (x)) & 0xff)
//#define bt_pshufd_ps( _a, _mask ) (__m128) _mm_shuffle_epi32((__m128i)(_a), (_mask) )
#define bt_pshufd_ps(_a, _mask) _mm_shuffle_ps((_a), (_a), (_mask))
#define bt_splat3_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, 3))
#define bt_splat_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, _i))

#define btv3AbsiMask (_mm_set_epi32(0x00000000, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvAbsMask (_mm_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvFFF0Mask (_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))
#define btv3AbsfMask btCastiTo128f(btv3AbsiMask)
#define btvFFF0fMask btCastiTo128f(btvFFF0Mask)
#define btvxyzMaskf btvFFF0fMask
#define btvAbsfMask btCastiTo128f(btvAbsMask)

//there is an issue with XCode 3.2 (LCx errors)
#define btvMzeroMask (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f))
#define v1110 (_mm_set_ps(0.0f, 1.0f, 1.0f, 1.0f))
#define vHalf (_mm_set_ps(0.5f, 0.5f, 0.5f, 0.5f))
#define v1_5 (_mm_set_ps(1.5f, 1.5f, 1.5f, 1.5f))

//const __m128 ATTRIBUTE_ALIGNED16(btvMzeroMask) = {-0.0f, -0.0f, -0.0f, -0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(v1110) = {1.0f, 1.0f, 1.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vHalf) = {0.5f, 0.5f, 0.5f, 0.5f};
//const __m128 ATTRIBUTE_ALIGNED16(v1_5)  = {1.5f, 1.5f, 1.5f, 1.5f};

#endif

#ifdef BT_USE_NEON

const float32x4_t ATTRIBUTE_ALIGNED16(btvMzeroMask) = (float32x4_t){-0.0f, -0.0f, -0.0f, -0.0f};
const int32x4_t ATTRIBUTE_ALIGNED16(btvFFF0Mask) = (int32x4_t){static_cast<int32_t>(0xFFFFFFFF),
															   static_cast<int32_t>(0xFFFFFFFF), static_cast<int32_t>(0xFFFFFFFF), 0x0};
const int32x4_t ATTRIBUTE_ALIGNED16(btvAbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF};
const int32x4_t ATTRIBUTE_ALIGNED16(btv3AbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x0};

#endif

/**@brief btVector3 can be used to represent 3D points and vectors.
 * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
 * Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
 */
ATTRIBUTE_ALIGNED16(class)
btVector3
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

#if defined(__SPU__) && defined(__CELLOS_LV2__)
	btScalar m_floats[4];

public:
	SIMD_FORCE_INLINE const vec_float4& get128() const
	{
		return *((const vec_float4*)&m_floats[0]);
	}

public:
#else                                            //__CELLOS_LV2__ __SPU__
#if defined(BT_USE_SSE) || defined(BT_USE_NEON)  // _WIN32 || ARM
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif
#endif  //__CELLOS_LV2__ __SPU__

public:
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btVector3()
	{
	}

	/**@brief Constructor from scalars 
   * @param x X value
   * @param y Y value 
   * @param z Z value 
   */
	SIMD_FORCE_INLINE btVector3(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btVector3(btSimdFloat4 v)
	{
		mVec128 = v;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btVector3(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btVector3&
	operator=(const btVector3& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	/**@brief Add a vector to this one 
 * @param The vector to add to this one */
	SIMD_FORCE_INLINE btVector3& operator+=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, v.mVec128);
#else
		m_floats[0] += v.m_floats[0];
		m_floats[1] += v.m_floats[1];
		m_floats[2] += v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Subtract a vector from this one
   * @param The vector to subtract */
	SIMD_FORCE_INLINE btVector3& operator-=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, v.mVec128);
#else
		m_floats[0] -= v.m_floats[0];
		m_floats[1] -= v.m_floats[1];
		m_floats[2] -= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Scale the vector
   * @param s Scale factor */
	SIMD_FORCE_INLINE btVector3& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
#endif
		return *this;
	}

	/**@brief Inversely scale the vector 
   * @param s Scale factor to divide by */
	SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)
	{
		btFullAssert(s != btScalar(0.0));

#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
		__m128 vs = _mm_load_ss(&s);
		vs = _mm_div_ss(v1110, vs);
		vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

		mVec128 = _mm_mul_ps(mVec128, vs);
		
		return *this;
#else
		return *this *= btScalar(1.0) / s;
#endif
	}

	/**@brief Return the dot product
   * @param v The other vector in the dot product */
	SIMD_FORCE_INLINE btScalar dot(const btVector3& v) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd = _mm_mul_ps(mVec128, v.mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);
		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, v.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_low_f32(vd));
		x = vadd_f32(x, vget_high_f32(vd));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * v.m_floats[0] +
			   m_floats[1] * v.m_floats[1] +
			   m_floats[2] * v.m_floats[2];
#endif
	}

	/**@brief Return the length of the vector squared */
	SIMD_FORCE_INLINE btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the vector */
	SIMD_FORCE_INLINE btScalar length() const
	{
		return btSqrt(length2());
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar norm() const
	{
		return length();
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar safeNorm() const
	{
		btScalar d = length2();
		//workaround for some clang/gcc issue of sqrtf(tiny number) = -INF
		if (d > SIMD_EPSILON)
			return btSqrt(d);
		return btScalar(0);
	}

	/**@brief Return the distance squared between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance2(const btVector3& v) const;

	/**@brief Return the distance between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance(const btVector3& v) const;

	SIMD_FORCE_INLINE btVector3& safeNormalize()
	{
		btScalar l2 = length2();
		//triNormal.normalize();
		if (l2 >= SIMD_EPSILON * SIMD_EPSILON)
		{
			(*this) /= btSqrt(l2);
		}
		else
		{
			setValue(1, 0, 0);
		}
		return *this;
	}

	/**@brief Normalize this vector 
   * x^2 + y^2 + z^2 = 1 */
	SIMD_FORCE_INLINE btVector3& normalize()
	{
		btAssert(!fuzzyZero());

#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// dot product first
		__m128 vd = _mm_mul_ps(mVec128, mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);

#if 0
        vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(v1110, vd);
		vd = bt_splat_ps(vd, 0x80);
		mVec128 = _mm_mul_ps(mVec128, vd);
#else

		// NR step 1/sqrt(x) - vd is x, y is output
		y = _mm_rsqrt_ss(vd);  // estimate

		//  one step NR
		z = v1_5;
		vd = _mm_mul_ss(vd, vHalf);  // vd * 0.5
		//x2 = vd;
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0 * y0
		z = _mm_sub_ss(z, vd);   // 1.5 - vd * 0.5 * y0 * y0

		y = _mm_mul_ss(y, z);  // y0 * (1.5 - vd * 0.5 * y0 * y0)

		y = bt_splat_ps(y, 0x80);
		mVec128 = _mm_mul_ps(mVec128, y);

#endif

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a normalized version of this vector */
	SIMD_FORCE_INLINE btVector3 normalized() const;

	/**@brief Return a rotated version of this vector
   * @param wAxis The axis to rotate about 
   * @param angle The angle to rotate by */
	SIMD_FORCE_INLINE btVector3 rotate(const btVector3& wAxis, const btScalar angle) const;

	/**@brief Return the angle between this and another vector
   * @param v The other vector */
	SIMD_FORCE_INLINE btScalar angle(const btVector3& v) const
	{
		btScalar s = btSqrt(length2() * v.length2());
		btFullAssert(s != btScalar(0.0));
		return btAcos(dot(v) / s);
	}

	/**@brief Return a vector with the absolute values of each element */
	SIMD_FORCE_INLINE btVector3 absolute() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector3(_mm_and_ps(mVec128, btv3AbsfMask));
#elif defined(BT_USE_NEON)
		return btVector3(vabsq_f32(mVec128));
#else
		return btVector3(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]));
#endif
	}

	/**@brief Return the cross product between this and another vector 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3 cross(const btVector3& v) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 T, V;

		T = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 3));    //	(Y Z X 0)
		V = bt_pshufd_ps(v.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, mVec128);
		T = _mm_mul_ps(T, v.mVec128);
		V = _mm_sub_ps(V, T);

		V = bt_pshufd_ps(V, BT_SHUFFLE(1, 2, 0, 3));
		return btVector3(V);
#elif defined(BT_USE_NEON)
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(mVec128);
		float32x2_t Vlow = vget_low_f32(v.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v.mVec128), 1), Vlow);

		V = vmulq_f32(V, mVec128);
		T = vmulq_f32(T, v.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);
		V = (float32x4_t)vandq_s32((int32x4_t)V, btvFFF0Mask);

		return btVector3(V);
#else
		return btVector3(
			m_floats[1] * v.m_floats[2] - m_floats[2] * v.m_floats[1],
			m_floats[2] * v.m_floats[0] - m_floats[0] * v.m_floats[2],
			m_floats[0] * v.m_floats[1] - m_floats[1] * v.m_floats[0]);
#endif
	}

	SIMD_FORCE_INLINE btScalar triple(const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// cross:
		__m128 T = _mm_shuffle_ps(v1.mVec128, v1.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)
		__m128 V = _mm_shuffle_ps(v2.mVec128, v2.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, v1.mVec128);
		T = _mm_mul_ps(T, v2.mVec128);
		V = _mm_sub_ps(V, T);

		V = _mm_shuffle_ps(V, V, BT_SHUFFLE(1, 2, 0, 3));

		// dot:
		V = _mm_mul_ps(V, mVec128);
		__m128 z = _mm_movehl_ps(V, V);
		__m128 y = _mm_shuffle_ps(V, V, 0x55);
		V = _mm_add_ss(V, y);
		V = _mm_add_ss(V, z);
		return _mm_cvtss_f32(V);

#elif defined(BT_USE_NEON)
		// cross:
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(v1.mVec128);
		float32x2_t Vlow = vget_low_f32(v2.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(v1.mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v2.mVec128), 1), Vlow);

		V = vmulq_f32(V, v1.mVec128);
		T = vmulq_f32(T, v2.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);

		// dot:
		V = vmulq_f32(mVec128, V);
		float32x2_t x = vpadd_f32(vget_low_f32(V), vget_low_f32(V));
		x = vadd_f32(x, vget_high_f32(V));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * (v1.m_floats[1] * v2.m_floats[2] - v1.m_floats[2] * v2.m_floats[1]) +
			   m_floats[1] * (v1.m_floats[2] * v2.m_floats[0] - v1.m_floats[0] * v2.m_floats[2]) +
			   m_floats[2] * (v1.m_floats[0] * v2.m_floats[1] - v1.m_floats[1] * v2.m_floats[0]);
#endif
	}

	/**@brief Return the axis with the smallest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int minAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[0] < m_floats[2] ? 0 : 2) : (m_floats[1] < m_floats[2] ? 1 : 2);
	}

	/**@brief Return the axis with the largest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int maxAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[1] < m_floats[2] ? 2 : 1) : (m_floats[0] < m_floats[2] ? 2 : 0);
	}

	SIMD_FORCE_INLINE int furthestAxis() const
	{
		return absolute().minAxis();
	}

	SIMD_FORCE_INLINE int closestAxis() const
	{
		return absolute().maxAxis();
	}

	SIMD_FORCE_INLINE void setInterpolate3(const btVector3& v0, const btVector3& v1, btScalar rt)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vrt = _mm_load_ss(&rt);  //	(rt 0 0 0)
		btScalar s = btScalar(1.0) - rt;
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		__m128 r0 = _mm_mul_ps(v0.mVec128, vs);
		vrt = bt_pshufd_ps(vrt, 0x80);  //	(rt rt rt 0.0)
		__m128 r1 = _mm_mul_ps(v1.mVec128, vrt);
		__m128 tmp3 = _mm_add_ps(r0, r1);
		mVec128 = tmp3;
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v1.mVec128, v0.mVec128);
		vl = vmulq_n_f32(vl, rt);
		mVec128 = vaddq_f32(vl, v0.mVec128);
#else
		btScalar s = btScalar(1.0) - rt;
		m_floats[0] = s * v0.m_floats[0] + rt * v1.m_floats[0];
		m_floats[1] = s * v0.m_floats[1] + rt * v1.m_floats[1];
		m_floats[2] = s * v0.m_floats[2] + rt * v1.m_floats[2];
		//don't do the unused w component
		//		m_co[3] = s * v0[3] + rt * v1[3];
#endif
	}

	/**@brief Return the linear interpolation between this and another vector 
   * @param v The other vector 
   * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
	SIMD_FORCE_INLINE btVector3 lerp(const btVector3& v, const btScalar& t) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vt = _mm_load_ss(&t);  //	(t 0 0 0)
		vt = bt_pshufd_ps(vt, 0x80);  //	(rt rt rt 0.0)
		__m128 vl = _mm_sub_ps(v.mVec128, mVec128);
		vl = _mm_mul_ps(vl, vt);
		vl = _mm_add_ps(vl, mVec128);

		return btVector3(vl);
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v.mVec128, mVec128);
		vl = vmulq_n_f32(vl, t);
		vl = vaddq_f32(vl, mVec128);

		return btVector3(vl);
#else
		return btVector3(m_floats[0] + (v.m_floats[0] - m_floats[0]) * t,
						 m_floats[1] + (v.m_floats[1] - m_floats[1]) * t,
						 m_floats[2] + (v.m_floats[2] - m_floats[2]) * t);
#endif
	}

	/**@brief Elementwise multiply this vector by the other 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_mul_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_f32(mVec128, v.mVec128);
#else
		m_floats[0] *= v.m_floats[0];
		m_floats[1] *= v.m_floats[1];
		m_floats[2] *= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btVector3& other) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btVector3& other) const
	{
		return !(*this == other);
	}

	/**@brief Set each element to the max of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.w());
#endif
	}

	/**@brief Set each element to the min of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.w());
#endif
	}

	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

	void getSkewSymmetricMatrix(btVector3 * v0, btVector3 * v1, btVector3 * v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 V = _mm_and_ps(mVec128, btvFFF0fMask);
		__m128 V0 = _mm_xor_ps(btvMzeroMask, V);
		__m128 V2 = _mm_movelh_ps(V0, V);

		__m128 V1 = _mm_shuffle_ps(V, V0, 0xCE);

		V0 = _mm_shuffle_ps(V0, V, 0xDB);
		V2 = _mm_shuffle_ps(V2, V, 0xF9);

		v0->mVec128 = V0;
		v1->mVec128 = V1;
		v2->mVec128 = V2;
#else
		v0->setValue(0., -z(), y());
		v1->setValue(z(), 0., -x());
		v2->setValue(-y(), x(), 0.);
#endif
	}

	void setZero()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = (__m128)_mm_xor_ps(mVec128, mVec128);
#elif defined(BT_USE_NEON)
		int32x4_t vi = vdupq_n_s32(0);
		mVec128 = vreinterpretq_f32_s32(vi);
#else
		setValue(btScalar(0.), btScalar(0.), btScalar(0.));
#endif
	}

	SIMD_FORCE_INLINE bool isZero() const
	{
		return m_floats[0] == btScalar(0) && m_floats[1] == btScalar(0) && m_floats[2] == btScalar(0);
	}

	SIMD_FORCE_INLINE bool fuzzyZero() const
	{
		return length2() < SIMD_EPSILON * SIMD_EPSILON;
	}

	SIMD_FORCE_INLINE void serialize(struct btVector3Data & dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3DoubleData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btVector3FloatData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btVector3DoubleData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btVector3DoubleData& dataIn);

	/**@brief returns index of maximum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The maximum dot product */
	SIMD_FORCE_INLINE long maxDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/**@brief returns index of minimum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The minimum dot product */
	SIMD_FORCE_INLINE long minDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/* create a vector as  btVector3( this->dot( btVector3 v0 ), this->dot( btVector3 v1), this->dot( btVector3 v2 ))  */
	SIMD_FORCE_INLINE btVector3 dot3(const btVector3& v0, const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 a0 = _mm_mul_ps(v0.mVec128, this->mVec128);
		__m128 a1 = _mm_mul_ps(v1.mVec128, this->mVec128);
		__m128 a2 = _mm_mul_ps(v2.mVec128, this->mVec128);
		__m128 b0 = _mm_unpacklo_ps(a0, a1);
		__m128 b1 = _mm_unpackhi_ps(a0, a1);
		__m128 b2 = _mm_unpacklo_ps(a2, _mm_setzero_ps());
		__m128 r = _mm_movelh_ps(b0, b2);
		r = _mm_add_ps(r, _mm_movehl_ps(b2, b0));
		a2 = _mm_and_ps(a2, btvxyzMaskf);
		r = _mm_add_ps(r, btCastdTo128f(_mm_move_sd(btCastfTo128d(a2), btCastfTo128d(b1))));
		return btVector3(r);

#elif defined(BT_USE_NEON)
		static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
		float32x4_t a0 = vmulq_f32(v0.mVec128, this->mVec128);
		float32x4_t a1 = vmulq_f32(v1.mVec128, this->mVec128);
		float32x4_t a2 = vmulq_f32(v2.mVec128, this->mVec128);
		float32x2x2_t zLo = vtrn_f32(vget_high_f32(a0), vget_high_f32(a1));
		a2 = (float32x4_t)vandq_u32((uint32x4_t)a2, xyzMask);
		float32x2_t b0 = vadd_f32(vpadd_f32(vget_low_f32(a0), vget_low_f32(a1)), zLo.val[0]);
		float32x2_t b1 = vpadd_f32(vpadd_f32(vget_low_f32(a2), vget_high_f32(a2)), vdup_n_f32(0.0f));
		return btVector3(vcombine_f32(b0, b1));
#else
		return btVector3(dot(v0), dot(v1), dot(v2));
#endif
	}
};

/**@brief Return the sum of two vectors (Point symantics)*/
SIMD_FORCE_INLINE btVector3
operator+(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_add_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vaddq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] + v2.m_floats[0],
		v1.m_floats[1] + v2.m_floats[1],
		v1.m_floats[2] + v2.m_floats[2]);
#endif
}

/**@brief Return the elementwise product of two vectors */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_mul_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vmulq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] * v2.m_floats[0],
		v1.m_floats[1] * v2.m_floats[1],
		v1.m_floats[2] * v2.m_floats[2]);
#endif
}

/**@brief Return the difference between two vectors */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	//	without _mm_and_ps this code causes slowdown in Concave moving
	__m128 r = _mm_sub_ps(v1.mVec128, v2.mVec128);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	float32x4_t r = vsubq_f32(v1.mVec128, v2.mVec128);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(
		v1.m_floats[0] - v2.m_floats[0],
		v1.m_floats[1] - v2.m_floats[1],
		v1.m_floats[2] - v2.m_floats[2]);
#endif
}

/**@brief Return the negative of the vector */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 r = _mm_xor_ps(v.mVec128, btvMzeroMask);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((btSimdFloat4)veorq_s32((int32x4_t)v.mVec128, (int32x4_t)btvMzeroMask));
#else
	return btVector3(-v.m_floats[0], -v.m_floats[1], -v.m_floats[2]);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btScalar& s)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
	vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
	return btVector3(_mm_mul_ps(v.mVec128, vs));
#elif defined(BT_USE_NEON)
	float32x4_t r = vmulq_n_f32(v.mVec128, s);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(v.m_floats[0] * s, v.m_floats[1] * s, v.m_floats[2] * s);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btScalar& s, const btVector3& v)
{
	return v * s;
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v, const btScalar& s)
{
	btFullAssert(s != btScalar(0.0));
#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
	__m128 vs = _mm_load_ss(&s);
    vs = _mm_div_ss(v1110, vs);
	vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

	return btVector3(_mm_mul_ps(v.mVec128, vs));
#else
	return v * (btScalar(1.0) / s);
#endif
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vec = _mm_div_ps(v1.mVec128, v2.mVec128);
	vec = _mm_and_ps(vec, btvFFF0fMask);
	return btVector3(vec);
#elif defined(BT_USE_NEON)
	float32x4_t x, y, v, m;

	x = v1.mVec128;
	y = v2.mVec128;

	v = vrecpeq_f32(y);     // v ~ 1/y
	m = vrecpsq_f32(y, v);  // m = (2-v*y)
	v = vmulq_f32(v, m);    // vv = v*m ~~ 1/y
	m = vrecpsq_f32(y, v);  // mm = (2-vv*y)
	v = vmulq_f32(v, x);    // x*vv
	v = vmulq_f32(v, m);    // (x*vv)*(2-vv*y) = x*(vv(2-vv*y)) ~~~ x/y

	return btVector3(v);
#else
	return btVector3(
		v1.m_floats[0] / v2.m_floats[0],
		v1.m_floats[1] / v2.m_floats[1],
		v1.m_floats[2] / v2.m_floats[2]);
#endif
}

/**@brief Return the dot product between two vectors */
SIMD_FORCE_INLINE btScalar
btDot(const btVector3& v1, const btVector3& v2)
{
	return v1.dot(v2);
}

/**@brief Return the distance squared between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance2(const btVector3& v1, const btVector3& v2)
{
	return v1.distance2(v2);
}

/**@brief Return the distance between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance(const btVector3& v1, const btVector3& v2)
{
	return v1.distance(v2);
}

/**@brief Return the angle between two vectors */
SIMD_FORCE_INLINE btScalar
btAngle(const btVector3& v1, const btVector3& v2)
{
	return v1.angle(v2);
}

/**@brief Return the cross product of two vectors */
SIMD_FORCE_INLINE btVector3
btCross(const btVector3& v1, const btVector3& v2)
{
	return v1.cross(v2);
}

SIMD_FORCE_INLINE btScalar
btTriple(const btVector3& v1, const btVector3& v2, const btVector3& v3)
{
	return v1.triple(v2, v3);
}

/**@brief Return the linear interpolation between two vectors
 * @param v1 One vector 
 * @param v2 The other vector 
 * @param t The ration of this to v (t = 0 => return v1, t=1 => return v2) */
SIMD_FORCE_INLINE btVector3
lerp(const btVector3& v1, const btVector3& v2, const btScalar& t)
{
	return v1.lerp(v2, t);
}

SIMD_FORCE_INLINE btScalar btVector3::distance2(const btVector3& v) const
{
	return (v - *this).length2();
}

SIMD_FORCE_INLINE btScalar btVector3::distance(const btVector3& v) const
{
	return (v - *this).length();
}

SIMD_FORCE_INLINE btVector3 btVector3::normalized() const
{
	btVector3 nrm = *this;

	return nrm.normalize();
}

SIMD_FORCE_INLINE btVector3 btVector3::rotate(const btVector3& wAxis, const btScalar _angle) const
{
	// wAxis must be a unit lenght vector

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

	__m128 O = _mm_mul_ps(wAxis.mVec128, mVec128);
	btScalar ssin = btSin(_angle);
	__m128 C = wAxis.cross(mVec128).mVec128;
	O = _mm_and_ps(O, btvFFF0fMask);
	btScalar scos = btCos(_angle);

	__m128 vsin = _mm_load_ss(&ssin);  //	(S 0 0 0)
	__m128 vcos = _mm_load_ss(&scos);  //	(S 0 0 0)

	__m128 Y = bt_pshufd_ps(O, 0xC9);  //	(Y Z X 0)
	__m128 Z = bt_pshufd_ps(O, 0xD2);  //	(Z X Y 0)
	O = _mm_add_ps(O, Y);
	vsin = bt_pshufd_ps(vsin, 0x80);  //	(S S S 0)
	O = _mm_add_ps(O, Z);
	vcos = bt_pshufd_ps(vcos, 0x80);  //	(S S S 0)

	vsin = vsin * C;
	O = O * wAxis.mVec128;
	__m128 X = mVec128 - O;

	O = O + vsin;
	vcos = vcos * X;
	O = O + vcos;

	return btVector3(O);
#else
	btVector3 o = wAxis * wAxis.dot(*this);
	btVector3 _x = *this - o;
	btVector3 _y;

	_y = wAxis.cross(*this);

	return (o + _x * btCos(_angle) + _y * btSin(_angle));
#endif
}

SIMD_FORCE_INLINE long btVector3::maxDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined _WIN32 || defined(BT_USE_SSE)
	const long scalar_cutoff = 10;
	long _maxdot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_maxdot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#endif
	if (array_count < scalar_cutoff)
#endif
	{
		btScalar maxDot1 = -SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;
		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot > maxDot1)
			{
				maxDot1 = dot;
				ptIndex = i;
			}
		}

		dotOut = maxDot1;
		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _maxdot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif
}

SIMD_FORCE_INLINE long btVector3::minDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined BT_USE_SSE
	const long scalar_cutoff = 10;
	long _mindot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_mindot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#else
#error unhandled arch!
#endif

	if (array_count < scalar_cutoff)
#endif
	{
		btScalar minDot = SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;

		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot < minDot)
			{
				minDot = dot;
				ptIndex = i;
			}
		}

		dotOut = minDot;

		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _mindot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif  //BT_USE_SIMD_VECTOR3
}

class btVector4 : public btVector3
{
public:
	SIMD_FORCE_INLINE btVector4() {}

	SIMD_FORCE_INLINE btVector4(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btVector3(_x, _y, _z)
	{
		m_floats[3] = _w;
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btVector4(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	SIMD_FORCE_INLINE btVector4(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	SIMD_FORCE_INLINE btVector4&
	operator=(const btVector4& v)
	{
		mVec128 = v.mVec128;
		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	SIMD_FORCE_INLINE btVector4 absolute4() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector4(_mm_and_ps(mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
		return btVector4(vabsq_f32(mVec128));
#else
		return btVector4(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]),
			btFabs(m_floats[3]));
#endif
	}

	btScalar getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE int maxAxis4() const
	{
		int maxIndex = -1;
		btScalar maxVal = btScalar(-BT_LARGE_FLOAT);
		if (m_floats[0] > maxVal)
		{
			maxIndex = 0;
			maxVal = m_floats[0];
		}
		if (m_floats[1] > maxVal)
		{
			maxIndex = 1;
			maxVal = m_floats[1];
		}
		if (m_floats[2] > maxVal)
		{
			maxIndex = 2;
			maxVal = m_floats[2];
		}
		if (m_floats[3] > maxVal)
		{
			maxIndex = 3;
		}

		return maxIndex;
	}

	SIMD_FORCE_INLINE int minAxis4() const
	{
		int minIndex = -1;
		btScalar minVal = btScalar(BT_LARGE_FLOAT);
		if (m_floats[0] < minVal)
		{
			minIndex = 0;
			minVal = m_floats[0];
		}
		if (m_floats[1] < minVal)
		{
			minIndex = 1;
			minVal = m_floats[1];
		}
		if (m_floats[2] < minVal)
		{
			minIndex = 2;
			minVal = m_floats[2];
		}
		if (m_floats[3] < minVal)
		{
			minIndex = 3;
		}

		return minIndex;
	}

	SIMD_FORCE_INLINE int closestAxis4() const
	{
		return absolute4().maxAxis4();
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] =m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
};

///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapScalarEndian(const btScalar& sourceVal, btScalar& destVal)
{
#ifdef BT_USE_DOUBLE_PRECISION
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[7];
	dest[1] = src[6];
	dest[2] = src[5];
	dest[3] = src[4];
	dest[4] = src[3];
	dest[5] = src[2];
	dest[6] = src[1];
	dest[7] = src[0];
#else
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[3];
	dest[1] = src[2];
	dest[2] = src[1];
	dest[3] = src[0];
#endif  //BT_USE_DOUBLE_PRECISION
}
///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapVector3Endian(const btVector3& sourceVec, btVector3& destVec)
{
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(sourceVec[i], destVec[i]);
	}
}

///btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btUnSwapVector3Endian(btVector3& vector)
{
	btVector3 swappedVec;
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(vector[i], swappedVec[i]);
	}
	vector = swappedVec;
}

template <class T>
SIMD_FORCE_INLINE void btPlaneSpace1(const T& n, T& p, T& q)
{
	if (btFabs(n[2]) > SIMDSQRT12)
	{
		// choose p in y-z plane
		btScalar a = n[1] * n[1] + n[2] * n[2];
		btScalar k = btRecipSqrt(a);
		p[0] = 0;
		p[1] = -n[2] * k;
		p[2] = n[1] * k;
		// set q = n x p
		q[0] = a * k;
		q[1] = -n[0] * p[2];
		q[2] = n[0] * p[1];
	}
	else
	{
		// choose p in x-y plane
		btScalar a = n[0] * n[0] + n[1] * n[1];
		btScalar k = btRecipSqrt(a);
		p[0] = -n[1] * k;
		p[1] = n[0] * k;
		p[2] = 0;
		// set q = n x p
		q[0] = -n[2] * p[1];
		q[1] = n[2] * p[0];
		q[2] = a * k;
	}
}

struct btVector3FloatData
{
	float m_floats[4];
};

struct btVector3DoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btVector3::serializeFloat(struct btVector3FloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeFloat(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serializeDouble(struct btVector3DoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeDouble(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serialize(struct btVector3Data& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_VECTOR3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD_QUADWORD_H
#define BT_SIMD_QUADWORD_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"

#if defined(__CELLOS_LV2) && defined(__SPU__)
#endif

/**@brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.
 */
#ifndef USE_LIBSPE2
ATTRIBUTE_ALIGNED16(class)
btQuadWord
#else
class btQuadWord
#endif
{
protected:
#if defined(__SPU__) && defined(__CELLOS_LV2__)
	union {
		vec_float4 mVec128;
		btScalar m_floats[4];
	};

public:
	vec_float4 get128() const
	{
		return mVec128;
	}

protected:
#else  //__CELLOS_LV2__ __SPU__

#if defined(BT_USE_SSE) || defined(BT_USE_NEON)
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};

public:
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif  // BT_USE_SSE

#endif  //__CELLOS_LV2__ __SPU__

public:
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

	// Set Vector
	SIMD_FORCE_INLINE btQuadWord(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuadWord(const btQuadWord& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuadWord&
	operator=(const btQuadWord& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btQuadWord& other) const
	{
#ifdef BT_USE_SSE
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btQuadWord& other) const
	{
		return !(*this == other);
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = 0.f;
	}

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] = m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btQuadWord()
	//	:m_floats[0](btScalar(0.)),m_floats[1](btScalar(0.)),m_floats[2](btScalar(0.)),m_floats[3](btScalar(0.))
	{
	}

	/**@brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = 0.0f;
	}

	/**@brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = _w;
	}

	/**@brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.m_floats[3]);
#endif
	}
	/**@brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.m_floats[3]);
#endif
	}
};

#endif  //BT_SIMD_QUADWORD_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD__QUATERNION_H_
#define BT_SIMD__QUATERNION_H_

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuadWord.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btQuaternionData btQuaternionDoubleData
#define btQuaternionDataName "btQuaternionDoubleData"
#else
#define btQuaternionData btQuaternionFloatData
#define btQuaternionDataName "btQuaternionFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#ifdef BT_USE_SSE

//const __m128 ATTRIBUTE_ALIGNED16(vOnes) = {1.0f, 1.0f, 1.0f, 1.0f};
#define vOnes (_mm_set_ps(1.0f, 1.0f, 1.0f, 1.0f))

#endif

#if defined(BT_USE_SSE)

#define vQInv (_mm_set_ps(+0.0f, -0.0f, -0.0f, -0.0f))
#define vPPPM (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f))

#elif defined(BT_USE_NEON)

const btSimdFloat4 ATTRIBUTE_ALIGNED16(vQInv) = {-0.0f, -0.0f, -0.0f, +0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(vPPPM) = {+0.0f, +0.0f, +0.0f, -0.0f};

#endif

/**@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
class btQuaternion : public btQuadWord
{
public:
	/**@brief No initialization constructor */
	btQuaternion() {}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btQuaternion(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuaternion(const btQuaternion& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuaternion&
	operator=(const btQuaternion& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	//		template <typename btScalar>
	//		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
	/**@brief Constructor from scalars */
	btQuaternion(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btQuadWord(_x, _y, _z, _w)
	{
	}
	/**@brief Axis angle Constructor
   * @param axis The axis which the rotation is around
   * @param angle The magnitude of the rotation around the angle (Radians) */
	btQuaternion(const btVector3& _axis, const btScalar& _angle)
	{
		setRotation(_axis, _angle);
	}
	/**@brief Constructor from Euler angles
   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
	btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
#ifndef BT_EULER_DEFAULT_ZYX
		setEuler(yaw, pitch, roll);
#else
		setEulerZYX(yaw, pitch, roll);
#endif
	}
	/**@brief Set the rotation using axis angle notation 
   * @param axis The axis around which to rotate
   * @param angle The magnitude of the rotation in Radians */
	void setRotation(const btVector3& axis, const btScalar& _angle)
	{
		btScalar d = axis.length();
		btAssert(d != btScalar(0.0));
		btScalar s = btSin(_angle * btScalar(0.5)) / d;
		setValue(axis.x() * s, axis.y() * s, axis.z() * s,
				 btCos(_angle * btScalar(0.5)));
	}
	/**@brief Set the quaternion using Euler angles
   * @param yaw Angle around Y
   * @param pitch Angle around X
   * @param roll Angle around Z */
	void setEuler(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitch) * btScalar(0.5);
		btScalar halfRoll = btScalar(roll) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,
				 sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
	}
	/**@brief Set the quaternion using euler angles 
   * @param yaw Angle around Z
   * @param pitch Angle around Y
   * @param roll Angle around X */
	void setEulerZYX(const btScalar& yawZ, const btScalar& pitchY, const btScalar& rollX)
	{
		btScalar halfYaw = btScalar(yawZ) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitchY) * btScalar(0.5);
		btScalar halfRoll = btScalar(rollX) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,   //x
				 cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,   //y
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,   //z
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);  //formerly yzx
	}

	/**@brief Get the euler angles from this quaternion
	   * @param yaw Angle around Z
	   * @param pitch Angle around Y
	   * @param roll Angle around X */
	void getEulerZYX(btScalar& yawZ, btScalar& pitchY, btScalar& rollX) const
	{
		btScalar squ;
		btScalar sqx;
		btScalar sqy;
		btScalar sqz;
		btScalar sarg;
		sqx = m_floats[0] * m_floats[0];
		sqy = m_floats[1] * m_floats[1];
		sqz = m_floats[2] * m_floats[2];
		squ = m_floats[3] * m_floats[3];
		sarg = btScalar(-2.) * (m_floats[0] * m_floats[2] - m_floats[3] * m_floats[1]);

		// If the pitch angle is PI/2 or -PI/2, we can only compute
		// the sum roll + yaw.  However, any combination that gives
		// the right sum will produce the correct orientation, so we
		// set rollX = 0 and compute yawZ.
		if (sarg <= -btScalar(0.99999))
		{
			pitchY = btScalar(-0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(m_floats[0], -m_floats[1]);
		}
		else if (sarg >= btScalar(0.99999))
		{
			pitchY = btScalar(0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(-m_floats[0], m_floats[1]);
		}
		else
		{
			pitchY = btAsin(sarg);
			rollX = btAtan2(2 * (m_floats[1] * m_floats[2] + m_floats[3] * m_floats[0]), squ - sqx - sqy + sqz);
			yawZ = btAtan2(2 * (m_floats[0] * m_floats[1] + m_floats[3] * m_floats[2]), squ + sqx - sqy - sqz);
		}
	}

	/**@brief Add two quaternions
   * @param q The quaternion to add to this one */
	SIMD_FORCE_INLINE btQuaternion& operator+=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, q.mVec128);
#else
		m_floats[0] += q.x();
		m_floats[1] += q.y();
		m_floats[2] += q.z();
		m_floats[3] += q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Subtract out a quaternion
   * @param q The quaternion to subtract from this one */
	btQuaternion& operator-=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, q.mVec128);
#else
		m_floats[0] -= q.x();
		m_floats[1] -= q.y();
		m_floats[2] -= q.z();
		m_floats[3] -= q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Scale this quaternion
   * @param s The scalar to scale by */
	btQuaternion& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0);     //	(S S S S)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
		m_floats[3] *= s;
#endif
		return *this;
	}

	/**@brief Multiply this quaternion by q on the right
   * @param q The other quaternion 
   * Equivilant to this = this * q */
	btQuaternion& operator*=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vQ2 = q.get128();

		__m128 A1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(0, 1, 2, 0));
		__m128 B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));

		A1 = A1 * B1;

		__m128 A2 = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 1));
		__m128 B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

		A2 = A2 * B2;

		B1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(2, 0, 1, 2));
		B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

		B1 = B1 * B2;  //	A3 *= B3

		mVec128 = bt_splat_ps(mVec128, 3);  //	A0
		mVec128 = mVec128 * vQ2;            //	A0 * B0

		A1 = A1 + A2;                //	AB12
		mVec128 = mVec128 - B1;      //	AB03 = AB0 - AB3
		A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
		mVec128 = mVec128 + A1;      //	AB03 + AB12

#elif defined(BT_USE_NEON)

		float32x4_t vQ1 = mVec128;
		float32x4_t vQ2 = q.get128();
		float32x4_t A0, A1, B1, A2, B2, A3, B3;
		float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

		{
			float32x2x2_t tmp;
			tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
			vQ1zx = tmp.val[0];

			tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
			vQ2zx = tmp.val[0];
		}
		vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

		vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

		vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
		vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

		A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
		B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

		A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
		B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

		A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
		B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

		A1 = vmulq_f32(A1, B1);
		A2 = vmulq_f32(A2, B2);
		A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
		A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

		A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
		A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

		//	change the sign of the last element
		A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
		A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

		mVec128 = A0;
#else
		setValue(
			m_floats[3] * q.x() + m_floats[0] * q.m_floats[3] + m_floats[1] * q.z() - m_floats[2] * q.y(),
			m_floats[3] * q.y() + m_floats[1] * q.m_floats[3] + m_floats[2] * q.x() - m_floats[0] * q.z(),
			m_floats[3] * q.z() + m_floats[2] * q.m_floats[3] + m_floats[0] * q.y() - m_floats[1] * q.x(),
			m_floats[3] * q.m_floats[3] - m_floats[0] * q.x() - m_floats[1] * q.y() - m_floats[2] * q.z());
#endif
		return *this;
	}
	/**@brief Return the dot product between this quaternion and another
   * @param q The other quaternion */
	btScalar dot(const btQuaternion& q) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, q.mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, q.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_high_f32(vd));
		x = vpadd_f32(x, x);
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * q.x() +
			   m_floats[1] * q.y() +
			   m_floats[2] * q.z() +
			   m_floats[3] * q.m_floats[3];
#endif
	}

	/**@brief Return the length squared of the quaternion */
	btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the quaternion */
	btScalar length() const
	{
		return btSqrt(length2());
	}
	btQuaternion& safeNormalize()
	{
		btScalar l2 = length2();
		if (l2 > SIMD_EPSILON)
		{
			normalize();
		}
		return *this;
	}
	/**@brief Normalize the quaternion 
   * Such that x^2 + y^2 + z^2 +w^2 = 1 */
	btQuaternion& normalize()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(vOnes, vd);
		vd = bt_pshufd_ps(vd, 0);  // splat
		mVec128 = _mm_mul_ps(mVec128, vd);

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a scaled version of this quaternion
   * @param s The scale factor */
	SIMD_FORCE_INLINE btQuaternion
	operator*(const btScalar& s) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x00);  //	(S S S S)

		return btQuaternion(_mm_mul_ps(mVec128, vs));
#elif defined(BT_USE_NEON)
		return btQuaternion(vmulq_n_f32(mVec128, s));
#else
		return btQuaternion(x() * s, y() * s, z() * s, m_floats[3] * s);
#endif
	}

	/**@brief Return an inversely scaled versionof this quaternion
   * @param s The inverse scale factor */
	btQuaternion operator/(const btScalar& s) const
	{
		btAssert(s != btScalar(0.0));
		return *this * (btScalar(1.0) / s);
	}

	/**@brief Inversely scale this quaternion
   * @param s The scale factor */
	btQuaternion& operator/=(const btScalar& s)
	{
		btAssert(s != btScalar(0.0));
		return *this *= btScalar(1.0) / s;
	}

	/**@brief Return a normalized version of this quaternion */
	btQuaternion normalized() const
	{
		return *this / length();
	}
	/**@brief Return the ***half*** angle between this quaternion and the other
   * @param q The other quaternion */
	btScalar angle(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		return btAcos(dot(q) / s);
	}

	/**@brief Return the angle between this quaternion and the other along the shortest path
	* @param q The other quaternion */
	btScalar angleShortestPath(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		if (dot(q) < 0)  // Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			return btAcos(dot(-q) / s) * btScalar(2.0);
		else
			return btAcos(dot(q) / s) * btScalar(2.0);
	}

	/**@brief Return the angle [0, 2Pi] of rotation represented by this quaternion */
	btScalar getAngle() const
	{
		btScalar s = btScalar(2.) * btAcos(m_floats[3]);
		return s;
	}

	/**@brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path */
	btScalar getAngleShortestPath() const
	{
		btScalar s;
		if (m_floats[3] >= 0)
			s = btScalar(2.) * btAcos(m_floats[3]);
		else
			s = btScalar(2.) * btAcos(-m_floats[3]);
		return s;
	}

	/**@brief Return the axis of the rotation represented by this quaternion */
	btVector3 getAxis() const
	{
		btScalar s_squared = 1.f - m_floats[3] * m_floats[3];

		if (s_squared < btScalar(10.) * SIMD_EPSILON)  //Check for divide by zero
			return btVector3(1.0, 0.0, 0.0);           // Arbitrary
		btScalar s = 1.f / btSqrt(s_squared);
		return btVector3(m_floats[0] * s, m_floats[1] * s, m_floats[2] * s);
	}

	/**@brief Return the inverse of this quaternion */
	btQuaternion inverse() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, vQInv));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)vQInv));
#else
		return btQuaternion(-m_floats[0], -m_floats[1], -m_floats[2], m_floats[3]);
#endif
	}

	/**@brief Return the sum of this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator+(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_add_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vaddq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() + q2.x(), q1.y() + q2.y(), q1.z() + q2.z(), q1.m_floats[3] + q2.m_floats[3]);
#endif
	}

	/**@brief Return the difference between this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator-(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_sub_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vsubq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() - q2.x(), q1.y() - q2.y(), q1.z() - q2.z(), q1.m_floats[3] - q2.m_floats[3]);
#endif
	}

	/**@brief Return the negative of this quaternion 
   * This simply negates each element */
	SIMD_FORCE_INLINE btQuaternion operator-() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, btvMzeroMask));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)btvMzeroMask));
#else
		const btQuaternion& q2 = *this;
		return btQuaternion(-q2.x(), -q2.y(), -q2.z(), -q2.m_floats[3]);
#endif
	}
	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion farthest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) > sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion nearest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) < sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
   * @param q The other quaternion to interpolate with 
   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
   * Slerp interpolates assuming constant velocity.  */
	btQuaternion slerp(const btQuaternion& q, const btScalar& t) const
	{
		const btScalar magnitude = btSqrt(length2() * q.length2());
		btAssert(magnitude > btScalar(0));

		const btScalar product = dot(q) / magnitude;
		const btScalar absproduct = btFabs(product);

		if (absproduct < btScalar(1.0 - SIMD_EPSILON))
		{
			// Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			const btScalar theta = btAcos(absproduct);
			const btScalar d = btSin(theta);
			btAssert(d > btScalar(0));

			const btScalar sign = (product < 0) ? btScalar(-1) : btScalar(1);
			const btScalar s0 = btSin((btScalar(1.0) - t) * theta) / d;
			const btScalar s1 = btSin(sign * t * theta) / d;

			return btQuaternion(
				(m_floats[0] * s0 + q.x() * s1),
				(m_floats[1] * s0 + q.y() * s1),
				(m_floats[2] * s0 + q.z() * s1),
				(m_floats[3] * s0 + q.w() * s1));
		}
		else
		{
			return *this;
		}
	}

	static const btQuaternion& getIdentity()
	{
		static const btQuaternion identityQuat(btScalar(0.), btScalar(0.), btScalar(0.), btScalar(1.));
		return identityQuat;
	}

	SIMD_FORCE_INLINE const btScalar& getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE void serialize(struct btQuaternionData& dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionDoubleData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btQuaternionFloatData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btQuaternionDoubleData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btQuaternionDoubleData& dataIn);
};

/**@brief Return the product of two quaternions */
SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q1, const btQuaternion& q2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q1.get128();
	__m128 vQ2 = q2.get128();
	__m128 A0, A1, B1, A2, B2;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x     //      vtrn
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X     // vdup vext

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));  // Y Z  X Y     // vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));  // z x  Y Y     // vtrn vdup

	A2 = A2 * B2;

	B1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));  // z x Y Z      // vtrn vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));  // Y Z x z      // vext vtrn

	B1 = B1 * B2;  //	A3 *= B3

	A0 = bt_splat_ps(vQ1, 3);  //	A0
	A0 = A0 * vQ2;             //	A0 * B0

	A1 = A1 + A2;  //	AB12
	A0 = A0 - B1;  //	AB03 = AB0 - AB3

	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A0 = A0 + A1;                //	AB03 + AB12

	return btQuaternion(A0);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q1.get128();
	float32x4_t vQ2 = q2.get128();
	float32x4_t A0, A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;
		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
	A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
	A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
	A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

	return btQuaternion(A0);

#else
	return btQuaternion(
		q1.w() * q2.x() + q1.x() * q2.w() + q1.y() * q2.z() - q1.z() * q2.y(),
		q1.w() * q2.y() + q1.y() * q2.w() + q1.z() * q2.x() - q1.x() * q2.z(),
		q1.w() * q2.z() + q1.z() * q2.w() + q1.x() * q2.y() - q1.y() * q2.x(),
		q1.w() * q2.w() - q1.x() * q2.x() - q1.y() * q2.y() - q1.z() * q2.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q, const btVector3& w)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q.get128();
	__m128 vQ2 = w.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(3, 3, 3, 0));
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(0, 1, 2, 0));

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q.get128();
	float32x4_t vQ2 = w.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1wx, vQ2zx, vQ1yz, vQ2yz, vQ1zx, vQ2xz;

	vQ1wx = vext_f32(vget_high_f32(vQ1), vget_low_f32(vQ1), 1);
	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];
	}

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ1), 1), vQ1wx);  // W W  W X
	B1 = vcombine_f32(vget_low_f32(vQ2), vQ2zx);                     // X Y  z x

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		q.w() * w.x() + q.y() * w.z() - q.z() * w.y(),
		q.w() * w.y() + q.z() * w.x() - q.x() * w.z(),
		q.w() * w.z() + q.x() * w.y() - q.y() * w.x(),
		-q.x() * w.x() - q.y() * w.y() - q.z() * w.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btVector3& w, const btQuaternion& q)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = w.get128();
	__m128 vQ2 = q.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = w.get128();
	float32x4_t vQ2 = q.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		+w.x() * q.w() + w.y() * q.z() - w.z() * q.y(),
		+w.y() * q.w() + w.z() * q.x() - w.x() * q.z(),
		+w.z() * q.w() + w.x() * q.y() - w.y() * q.x(),
		-w.x() * q.x() - w.y() * q.y() - w.z() * q.z());
#endif
}

/**@brief Calculate the dot product between two quaternions */
SIMD_FORCE_INLINE btScalar
dot(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.dot(q2);
}

/**@brief Return the length of a quaternion */
SIMD_FORCE_INLINE btScalar
length(const btQuaternion& q)
{
	return q.length();
}

/**@brief Return the angle between two quaternions*/
SIMD_FORCE_INLINE btScalar
btAngle(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.angle(q2);
}

/**@brief Return the inverse of a quaternion*/
SIMD_FORCE_INLINE btQuaternion
inverse(const btQuaternion& q)
{
	return q.inverse();
}

/**@brief Return the result of spherical linear interpolation betwen two quaternions 
 * @param q1 The first quaternion
 * @param q2 The second quaternion 
 * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
 * Slerp assumes constant velocity between positions. */
SIMD_FORCE_INLINE btQuaternion
slerp(const btQuaternion& q1, const btQuaternion& q2, const btScalar& t)
{
	return q1.slerp(q2, t);
}

SIMD_FORCE_INLINE btVector3
quatRotate(const btQuaternion& rotation, const btVector3& v)
{
	btQuaternion q = rotation * v;
	q *= rotation.inverse();
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_and_ps(q.get128(), btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((float32x4_t)vandq_s32((int32x4_t)q.get128(), btvFFF0Mask));
#else
	return btVector3(q.getX(), q.getY(), q.getZ());
#endif
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuat(const btVector3& v0, const btVector3& v1)  // Game Programming Gems 2.10. make sure v0,v1 are normalized
{
	btVector3 c = v0.cross(v1);
	btScalar d = v0.dot(v1);

	if (d < -1.0 + SIMD_EPSILON)
	{
		btVector3 n, unused;
		btPlaneSpace1(v0, n, unused);
		return btQuaternion(n.x(), n.y(), n.z(), 0.0f);  // just pick any vector that is orthogonal to v0
	}

	btScalar s = btSqrt((1.0f + d) * 2.0f);
	btScalar rs = 1.0f / s;

	return btQuaternion(c.getX() * rs, c.getY() * rs, c.getZ() * rs, s * 0.5f);
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuatNormalize2(btVector3& v0, btVector3& v1)
{
	v0.normalize();
	v1.normalize();
	return shortestArcQuat(v0, v1);
}

struct btQuaternionFloatData
{
	float m_floats[4];
};

struct btQuaternionDoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btQuaternion::serializeFloat(struct btQuaternionFloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeFloat(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serializeDouble(struct btQuaternionDoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeDouble(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serialize(struct btQuaternionData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_SIMD__QUATERNION_H_





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MATRIX3x3_H
#define BT_MATRIX3x3_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuaternion.h"

#ifdef BT_USE_SSE
//const __m128 ATTRIBUTE_ALIGNED16(v2220) = {2.0f, 2.0f, 2.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vMPPP) = {-0.0f, +0.0f, +0.0f, +0.0f};
#define vMPPP (_mm_set_ps(+0.0f, +0.0f, +0.0f, -0.0f))
#endif

#if defined(BT_USE_SSE)
#define v0000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 0.0f))
#define v1000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 1.0f))
#define v0100 (_mm_set_ps(0.0f, 0.0f, 1.0f, 0.0f))
#define v0010 (_mm_set_ps(0.0f, 1.0f, 0.0f, 0.0f))
#elif defined(BT_USE_NEON)
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0000) = {0.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v1000) = {1.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0100) = {0.0f, 1.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0010) = {0.0f, 0.0f, 1.0f, 0.0f};
#endif

#ifdef BT_USE_DOUBLE_PRECISION
#define btMatrix3x3Data btMatrix3x3DoubleData
#else
#define btMatrix3x3Data btMatrix3x3FloatData
#endif  //BT_USE_DOUBLE_PRECISION

/**@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
ATTRIBUTE_ALIGNED16(class)
btMatrix3x3
{
	///Data storage for the matrix, each vector is a row of the matrix
	btVector3 m_el[3];

public:
	/** @brief No initializaion constructor */
	btMatrix3x3() {}

	//		explicit btMatrix3x3(const btScalar *m) { setFromOpenGLSubMatrix(m); }

	/**@brief Constructor from Quaternion */
	explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }
	/*
	template <typename btScalar>
	Matrix3x3(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{ 
	setEulerYPR(yaw, pitch, roll);
	}
	*/
	/** @brief Constructor with row major formatting */
	btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				const btScalar& yx, const btScalar& yy, const btScalar& yz,
				const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		setValue(xx, xy, xz,
				 yx, yy, yz,
				 zx, zy, zz);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btMatrix3x3(const btSimdFloat4 v0, const btSimdFloat4 v1, const btSimdFloat4 v2)
	{
		m_el[0].mVec128 = v0;
		m_el[1].mVec128 = v1;
		m_el[2].mVec128 = v2;
	}

	SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
	{
		m_el[0] = v0;
		m_el[1] = v1;
		m_el[2] = v2;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& rhs)
	{
		m_el[0].mVec128 = rhs.m_el[0].mVec128;
		m_el[1].mVec128 = rhs.m_el[1].mVec128;
		m_el[2].mVec128 = rhs.m_el[2].mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& m)
	{
		m_el[0].mVec128 = m.m_el[0].mVec128;
		m_el[1].mVec128 = m.m_el[1].mVec128;
		m_el[2].mVec128 = m.m_el[2].mVec128;

		return *this;
	}

#else

	/** @brief Copy constructor */
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
	}

	/** @brief Assignment Operator */
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
		return *this;
	}
    
    SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
    {
        m_el[0] = v0;
        m_el[1] = v1;
        m_el[2] = v2;
    }

#endif

	/** @brief Get a column of the matrix as a vector 
	*  @param i Column number 0 indexed */
	SIMD_FORCE_INLINE btVector3 getColumn(int i) const
	{
		return btVector3(m_el[0][i], m_el[1][i], m_el[2][i]);
	}

	/** @brief Get a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& getRow(int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a mutable reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE btVector3& operator[](int i)
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a const reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& operator[](int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Multiply by the target matrix on the right
	*  @param m Rotation matrix to be applied 
	* Equivilant to this = this * m */
	btMatrix3x3& operator*=(const btMatrix3x3& m);

	/** @brief Adds by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this + m */
	btMatrix3x3& operator+=(const btMatrix3x3& m);

	/** @brief Substractss by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this - m */
	btMatrix3x3& operator-=(const btMatrix3x3& m);

	/** @brief Set from the rotational part of a 4x4 OpenGL matrix
	*  @param m A pointer to the beginning of the array of scalars*/
	void setFromOpenGLSubMatrix(const btScalar* m)
	{
		m_el[0].setValue(m[0], m[4], m[8]);
		m_el[1].setValue(m[1], m[5], m[9]);
		m_el[2].setValue(m[2], m[6], m[10]);
	}
	/** @brief Set the values of the matrix explicitly (row major)
	*  @param xx Top left
	*  @param xy Top Middle
	*  @param xz Top Right
	*  @param yx Middle Left
	*  @param yy Middle Middle
	*  @param yz Middle Right
	*  @param zx Bottom Left
	*  @param zy Bottom Middle
	*  @param zz Bottom Right*/
	void setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				  const btScalar& yx, const btScalar& yy, const btScalar& yz,
				  const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		m_el[0].setValue(xx, xy, xz);
		m_el[1].setValue(yx, yy, yz);
		m_el[2].setValue(zx, zy, zz);
	}

	/** @brief Set the matrix from a quaternion
	*  @param q The Quaternion to match */
	void setRotation(const btQuaternion& q)
	{
		btScalar d = q.length2();
		btFullAssert(d != btScalar(0.0));
		btScalar s = btScalar(2.0) / d;

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs, Q = q.get128();
		__m128i Qi = btCastfTo128i(Q);
		__m128 Y, Z;
		__m128 V1, V2, V3;
		__m128 V11, V21, V31;
		__m128 NQ = _mm_xor_ps(Q, btvMzeroMask);
		__m128i NQi = btCastfTo128i(NQ);

		V1 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 2, 3)));  // Y X Z W
		V2 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(0, 0, 1, 3));                 // -X -X  Y  W
		V3 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(2, 1, 0, 3)));  // Z Y X W
		V1 = _mm_xor_ps(V1, vMPPP);                                         //	change the sign of the first element

		V11 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 1, 0, 3)));  // Y Y X W
		V21 = _mm_unpackhi_ps(Q, Q);                                         //  Z  Z  W  W
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(0, 2, 0, 3));                 //  X  Z -X -W

		V2 = V2 * V1;   //
		V1 = V1 * V11;  //
		V3 = V3 * V31;  //

		V11 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(2, 3, 1, 3));                //	-Z -W  Y  W
		V11 = V11 * V21;                                                    //
		V21 = _mm_xor_ps(V21, vMPPP);                                       //	change the sign of the first element
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(3, 3, 1, 3));                //	 W  W -Y -W
		V31 = _mm_xor_ps(V31, vMPPP);                                       //	change the sign of the first element
		Y = btCastiTo128f(_mm_shuffle_epi32(NQi, BT_SHUFFLE(3, 2, 0, 3)));  // -W -Z -X -W
		Z = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 1, 3)));   //  Y  X  Y  W

		vs = _mm_load_ss(&s);
		V21 = V21 * Y;
		V31 = V31 * Z;

		V1 = V1 + V11;
		V2 = V2 + V21;
		V3 = V3 + V31;

		vs = bt_splat3_ps(vs, 0);
		//	s ready
		V1 = V1 * vs;
		V2 = V2 * vs;
		V3 = V3 * vs;

		V1 = V1 + v1000;
		V2 = V2 + v0100;
		V3 = V3 + v0010;

		m_el[0] = V1;
		m_el[1] = V2;
		m_el[2] = V3;
#else
		btScalar xs = q.x() * s, ys = q.y() * s, zs = q.z() * s;
		btScalar wx = q.w() * xs, wy = q.w() * ys, wz = q.w() * zs;
		btScalar xx = q.x() * xs, xy = q.x() * ys, xz = q.x() * zs;
		btScalar yy = q.y() * ys, yz = q.y() * zs, zz = q.z() * zs;
		setValue(
			btScalar(1.0) - (yy + zz), xy - wz, xz + wy,
			xy + wz, btScalar(1.0) - (xx + zz), yz - wx,
			xz - wy, yz + wx, btScalar(1.0) - (xx + yy));
#endif
	}

	/** @brief Set the matrix from euler angles using YPR around YXZ respectively
	*  @param yaw Yaw about Y axis
	*  @param pitch Pitch about X axis
	*  @param roll Roll about Z axis 
	*/
	void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		setEulerZYX(roll, pitch, yaw);
	}

	/** @brief Set the matrix from euler angles YPR around ZYX axes
	* @param eulerX Roll about X axis
	* @param eulerY Pitch around Y axis
	* @param eulerZ Yaw about Z axis
	* 
	* These angles are used to produce a rotation matrix. The euler
	* angles are applied in ZYX order. I.e a vector is first rotated 
	* about X then Y and then Z
	**/
	void setEulerZYX(btScalar eulerX, btScalar eulerY, btScalar eulerZ)
	{
		///@todo proposed to reverse this since it's labeled zyx but takes arguments xyz and it will match all other parts of the code
		btScalar ci(btCos(eulerX));
		btScalar cj(btCos(eulerY));
		btScalar ch(btCos(eulerZ));
		btScalar si(btSin(eulerX));
		btScalar sj(btSin(eulerY));
		btScalar sh(btSin(eulerZ));
		btScalar cc = ci * ch;
		btScalar cs = ci * sh;
		btScalar sc = si * ch;
		btScalar ss = si * sh;

		setValue(cj * ch, sj * sc - cs, sj * cc + ss,
				 cj * sh, sj * ss + cc, sj * cs - sc,
				 -sj, cj * si, cj * ci);
	}

	/**@brief Set the matrix to the identity */
	void setIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		m_el[0] = v1000;
		m_el[1] = v0100;
		m_el[2] = v0010;
#else
		setValue(btScalar(1.0), btScalar(0.0), btScalar(0.0),
				 btScalar(0.0), btScalar(1.0), btScalar(0.0),
				 btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
	}
    
    /**@brief Set the matrix to the identity */
    void setZero()
    {
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
        m_el[0] = v0000;
        m_el[1] = v0000;
        m_el[2] = v0000;
#else
        setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0));
#endif
    }

	static const btMatrix3x3& getIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		static const btMatrix3x3
			identityMatrix(v1000, v0100, v0010);
#else
		static const btMatrix3x3
			identityMatrix(
				btScalar(1.0), btScalar(0.0), btScalar(0.0),
				btScalar(0.0), btScalar(1.0), btScalar(0.0),
				btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
		return identityMatrix;
	}

	/**@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
	* @param m The array to be filled */
	void getOpenGLSubMatrix(btScalar * m) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 v0 = m_el[0].mVec128;
		__m128 v1 = m_el[1].mVec128;
		__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
		__m128* vm = (__m128*)m;
		__m128 vT;

		v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

		vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
		v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

		v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
		v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
		v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#elif defined(BT_USE_NEON)
		// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
		static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
		float32x4_t* vm = (float32x4_t*)m;
		float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
		float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
		float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
		float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
		float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
		float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#else
		m[0] = btScalar(m_el[0].x());
		m[1] = btScalar(m_el[1].x());
		m[2] = btScalar(m_el[2].x());
		m[3] = btScalar(0.0);
		m[4] = btScalar(m_el[0].y());
		m[5] = btScalar(m_el[1].y());
		m[6] = btScalar(m_el[2].y());
		m[7] = btScalar(0.0);
		m[8] = btScalar(m_el[0].z());
		m[9] = btScalar(m_el[1].z());
		m[10] = btScalar(m_el[2].z());
		m[11] = btScalar(0.0);
#endif
	}

	/**@brief Get the matrix represented as a quaternion 
	* @param q The quaternion which will be set */
	void getRotation(btQuaternion & q) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
		btScalar s, x;

		union {
			btSimdFloat4 vec;
			btScalar f[4];
		} temp;

		if (trace > btScalar(0.0))
		{
			x = trace + btScalar(1.0);

			temp.f[0] = m_el[2].y() - m_el[1].z();
			temp.f[1] = m_el[0].z() - m_el[2].x();
			temp.f[2] = m_el[1].x() - m_el[0].y();
			temp.f[3] = x;
			//temp.f[3]= s * btScalar(0.5);
		}
		else
		{
			int i, j, k;
			if (m_el[0].x() < m_el[1].y())
			{
				if (m_el[1].y() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 1;
					j = 2;
					k = 0;
				}
			}
			else
			{
				if (m_el[0].x() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 0;
					j = 1;
					k = 2;
				}
			}

			x = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);

			temp.f[3] = (m_el[k][j] - m_el[j][k]);
			temp.f[j] = (m_el[j][i] + m_el[i][j]);
			temp.f[k] = (m_el[k][i] + m_el[i][k]);
			temp.f[i] = x;
			//temp.f[i] = s * btScalar(0.5);
		}

		s = btSqrt(x);
		q.set128(temp.vec);
		s = btScalar(0.5) / s;

		q *= s;
#else
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();

		btScalar temp[4];

		if (trace > btScalar(0.0))
		{
			btScalar s = btSqrt(trace + btScalar(1.0));
			temp[3] = (s * btScalar(0.5));
			s = btScalar(0.5) / s;

			temp[0] = ((m_el[2].y() - m_el[1].z()) * s);
			temp[1] = ((m_el[0].z() - m_el[2].x()) * s);
			temp[2] = ((m_el[1].x() - m_el[0].y()) * s);
		}
		else
		{
			int i = m_el[0].x() < m_el[1].y() ? (m_el[1].y() < m_el[2].z() ? 2 : 1) : (m_el[0].x() < m_el[2].z() ? 2 : 0);
			int j = (i + 1) % 3;
			int k = (i + 2) % 3;

			btScalar s = btSqrt(m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0));
			temp[i] = s * btScalar(0.5);
			s = btScalar(0.5) / s;

			temp[3] = (m_el[k][j] - m_el[j][k]) * s;
			temp[j] = (m_el[j][i] + m_el[i][j]) * s;
			temp[k] = (m_el[k][i] + m_el[i][k]) * s;
		}
		q.setValue(temp[0], temp[1], temp[2], temp[3]);
#endif
	}

	/**@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
	* @param yaw Yaw around Y axis
	* @param pitch Pitch around X axis
	* @param roll around Z axis */
	void getEulerYPR(btScalar & yaw, btScalar & pitch, btScalar & roll) const
	{
		// first use the normal calculus
		yaw = btScalar(btAtan2(m_el[1].x(), m_el[0].x()));
		pitch = btScalar(btAsin(-m_el[2].x()));
		roll = btScalar(btAtan2(m_el[2].y(), m_el[2].z()));

		// on pitch = +/-HalfPI
		if (btFabs(pitch) == SIMD_HALF_PI)
		{
			if (yaw > 0)
				yaw -= SIMD_PI;
			else
				yaw += SIMD_PI;

			if (roll > 0)
				roll -= SIMD_PI;
			else
				roll += SIMD_PI;
		}
	};

	/**@brief Get the matrix represented as euler angles around ZYX
	* @param yaw Yaw around Z axis
	* @param pitch Pitch around Y axis
	* @param roll around X axis 
	* @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
	void getEulerZYX(btScalar & yaw, btScalar & pitch, btScalar & roll, unsigned int solution_number = 1) const
	{
		struct Euler
		{
			btScalar yaw;
			btScalar pitch;
			btScalar roll;
		};

		Euler euler_out;
		Euler euler_out2;  //second solution
		//get the pointer to the raw data

		// Check that pitch is not at a singularity
		if (btFabs(m_el[2].x()) >= 1)
		{
			euler_out.yaw = 0;
			euler_out2.yaw = 0;

			// From difference of angles formula
			btScalar delta = btAtan2(m_el[0].x(), m_el[0].z());
			if (m_el[2].x() > 0)  //gimbal locked up
			{
				euler_out.pitch = SIMD_PI / btScalar(2.0);
				euler_out2.pitch = SIMD_PI / btScalar(2.0);
				euler_out.roll = euler_out.pitch + delta;
				euler_out2.roll = euler_out.pitch + delta;
			}
			else  // gimbal locked down
			{
				euler_out.pitch = -SIMD_PI / btScalar(2.0);
				euler_out2.pitch = -SIMD_PI / btScalar(2.0);
				euler_out.roll = -euler_out.pitch + delta;
				euler_out2.roll = -euler_out.pitch + delta;
			}
		}
		else
		{
			euler_out.pitch = -btAsin(m_el[2].x());
			euler_out2.pitch = SIMD_PI - euler_out.pitch;

			euler_out.roll = btAtan2(m_el[2].y() / btCos(euler_out.pitch),
									 m_el[2].z() / btCos(euler_out.pitch));
			euler_out2.roll = btAtan2(m_el[2].y() / btCos(euler_out2.pitch),
									  m_el[2].z() / btCos(euler_out2.pitch));

			euler_out.yaw = btAtan2(m_el[1].x() / btCos(euler_out.pitch),
									m_el[0].x() / btCos(euler_out.pitch));
			euler_out2.yaw = btAtan2(m_el[1].x() / btCos(euler_out2.pitch),
									 m_el[0].x() / btCos(euler_out2.pitch));
		}

		if (solution_number == 1)
		{
			yaw = euler_out.yaw;
			pitch = euler_out.pitch;
			roll = euler_out.roll;
		}
		else
		{
			yaw = euler_out2.yaw;
			pitch = euler_out2.pitch;
			roll = euler_out2.roll;
		}
	}

	/**@brief Create a scaled copy of the matrix 
	* @param s Scaling vector The elements of the vector will scale each column */

	btMatrix3x3 scaled(const btVector3& s) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		return btMatrix3x3(m_el[0] * s, m_el[1] * s, m_el[2] * s);
#else
		return btMatrix3x3(
			m_el[0].x() * s.x(), m_el[0].y() * s.y(), m_el[0].z() * s.z(),
			m_el[1].x() * s.x(), m_el[1].y() * s.y(), m_el[1].z() * s.z(),
			m_el[2].x() * s.x(), m_el[2].y() * s.y(), m_el[2].z() * s.z());
#endif
	}

	/**@brief Return the determinant of the matrix */
	btScalar determinant() const;
	/**@brief Return the adjoint of the matrix */
	btMatrix3x3 adjoint() const;
	/**@brief Return the matrix with all values non negative */
	btMatrix3x3 absolute() const;
	/**@brief Return the transpose of the matrix */
	btMatrix3x3 transpose() const;
	/**@brief Return the inverse of the matrix */
	btMatrix3x3 inverse() const;

	/// Solve A * x = b, where b is a column vector. This is more efficient
	/// than computing the inverse in one-shot cases.
	///Solve33 is from Box2d, thanks to Erin Catto,
	btVector3 solve33(const btVector3& b) const
	{
		btVector3 col1 = getColumn(0);
		btVector3 col2 = getColumn(1);
		btVector3 col3 = getColumn(2);

		btScalar det = btDot(col1, btCross(col2, col3));
		if (btFabs(det) > SIMD_EPSILON)
		{
			det = 1.0f / det;
		}
		btVector3 x;
		x[0] = det * btDot(b, btCross(col2, col3));
		x[1] = det * btDot(col1, btCross(b, col3));
		x[2] = det * btDot(col1, btCross(col2, b));
		return x;
	}

	btMatrix3x3 transposeTimes(const btMatrix3x3& m) const;
	btMatrix3x3 timesTranspose(const btMatrix3x3& m) const;

	SIMD_FORCE_INLINE btScalar tdotx(const btVector3& v) const
	{
		return m_el[0].x() * v.x() + m_el[1].x() * v.y() + m_el[2].x() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdoty(const btVector3& v) const
	{
		return m_el[0].y() * v.x() + m_el[1].y() * v.y() + m_el[2].y() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdotz(const btVector3& v) const
	{
		return m_el[0].z() * v.x() + m_el[1].z() * v.y() + m_el[2].z() * v.z();
	}

	///extractRotation is from "A robust method to extract the rotational part of deformations"
	///See http://dl.acm.org/citation.cfm?doid=2994258.2994269
	///decomposes a matrix A in a orthogonal matrix R and a
	///symmetric matrix S:
	///A = R*S.
	///note that R can include both rotation and scaling.
	SIMD_FORCE_INLINE void extractRotation(btQuaternion & q, btScalar tolerance = 1.0e-9, int maxIter = 100)
	{
		int iter = 0;
		btScalar w;
		const btMatrix3x3& A = *this;
		for (iter = 0; iter < maxIter; iter++)
		{
			btMatrix3x3 R(q);
			btVector3 omega = (R.getColumn(0).cross(A.getColumn(0)) + R.getColumn(1).cross(A.getColumn(1)) + R.getColumn(2).cross(A.getColumn(2))) * (btScalar(1.0) / btFabs(R.getColumn(0).dot(A.getColumn(0)) + R.getColumn(1).dot(A.getColumn(1)) + R.getColumn(2).dot(A.getColumn(2))) +
																																					  tolerance);
			w = omega.norm();
			if (w < tolerance)
				break;
			q = btQuaternion(btVector3((btScalar(1.0) / w) * omega), w) *
				q;
			q.normalize();
		}
	}

	/**@brief diagonalizes this matrix by the Jacobi method.
	* @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
	* coordinate system, i.e., old_this = rot * new_this * rot^T.
	* @param threshold See iteration
	* @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied
	* by the sum of the absolute values of the diagonal, or when maxSteps have been executed.
	*
	* Note that this matrix is assumed to be symmetric.
	*/
	void diagonalize(btMatrix3x3 & rot, btScalar threshold, int maxSteps)
	{
		rot.setIdentity();
		for (int step = maxSteps; step > 0; step--)
		{
			// find off-diagonal element [p][q] with largest magnitude
			int p = 0;
			int q = 1;
			int r = 2;
			btScalar max = btFabs(m_el[0][1]);
			btScalar v = btFabs(m_el[0][2]);
			if (v > max)
			{
				q = 2;
				r = 1;
				max = v;
			}
			v = btFabs(m_el[1][2]);
			if (v > max)
			{
				p = 1;
				q = 2;
				r = 0;
				max = v;
			}

			btScalar t = threshold * (btFabs(m_el[0][0]) + btFabs(m_el[1][1]) + btFabs(m_el[2][2]));
			if (max <= t)
			{
				if (max <= SIMD_EPSILON * t)
				{
					return;
				}
				step = 1;
			}

			// compute Jacobi rotation J which leads to a zero for element [p][q]
			btScalar mpq = m_el[p][q];
			btScalar theta = (m_el[q][q] - m_el[p][p]) / (2 * mpq);
			btScalar theta2 = theta * theta;
			btScalar cos;
			btScalar sin;
			if (theta2 * theta2 < btScalar(10 / SIMD_EPSILON))
			{
				t = (theta >= 0) ? 1 / (theta + btSqrt(1 + theta2))
								 : 1 / (theta - btSqrt(1 + theta2));
				cos = 1 / btSqrt(1 + t * t);
				sin = cos * t;
			}
			else
			{
				// approximation for large theta-value, i.e., a nearly diagonal matrix
				t = 1 / (theta * (2 + btScalar(0.5) / theta2));
				cos = 1 - btScalar(0.5) * t * t;
				sin = cos * t;
			}

			// apply rotation to matrix (this = J^T * this * J)
			m_el[p][q] = m_el[q][p] = 0;
			m_el[p][p] -= t * mpq;
			m_el[q][q] += t * mpq;
			btScalar mrp = m_el[r][p];
			btScalar mrq = m_el[r][q];
			m_el[r][p] = m_el[p][r] = cos * mrp - sin * mrq;
			m_el[r][q] = m_el[q][r] = cos * mrq + sin * mrp;

			// apply rotation to rot (rot = rot * J)
			for (int i = 0; i < 3; i++)
			{
				btVector3& row = rot[i];
				mrp = row[p];
				mrq = row[q];
				row[p] = cos * mrp - sin * mrq;
				row[q] = cos * mrq + sin * mrp;
			}
		}
	}

	/**@brief Calculate the matrix cofactor 
	* @param r1 The first row to use for calculating the cofactor
	* @param c1 The first column to use for calculating the cofactor
	* @param r1 The second row to use for calculating the cofactor
	* @param c1 The second column to use for calculating the cofactor
	* See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
	*/
	btScalar cofac(int r1, int c1, int r2, int c2) const
	{
		return m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];
	}

	void serialize(struct btMatrix3x3Data & dataOut) const;

	void serializeFloat(struct btMatrix3x3FloatData & dataOut) const;

	void deSerialize(const struct btMatrix3x3Data& dataIn);

	void deSerializeFloat(const struct btMatrix3x3FloatData& dataIn);

	void deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn);
};

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator*=(const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 rv00, rv01, rv02;
	__m128 rv10, rv11, rv12;
	__m128 rv20, rv21, rv22;
	__m128 mv0, mv1, mv2;

	rv02 = m_el[0].mVec128;
	rv12 = m_el[1].mVec128;
	rv22 = m_el[2].mVec128;

	mv0 = _mm_and_ps(m[0].mVec128, btvFFF0fMask);
	mv1 = _mm_and_ps(m[1].mVec128, btvFFF0fMask);
	mv2 = _mm_and_ps(m[2].mVec128, btvFFF0fMask);

	// rv0
	rv00 = bt_splat_ps(rv02, 0);
	rv01 = bt_splat_ps(rv02, 1);
	rv02 = bt_splat_ps(rv02, 2);

	rv00 = _mm_mul_ps(rv00, mv0);
	rv01 = _mm_mul_ps(rv01, mv1);
	rv02 = _mm_mul_ps(rv02, mv2);

	// rv1
	rv10 = bt_splat_ps(rv12, 0);
	rv11 = bt_splat_ps(rv12, 1);
	rv12 = bt_splat_ps(rv12, 2);

	rv10 = _mm_mul_ps(rv10, mv0);
	rv11 = _mm_mul_ps(rv11, mv1);
	rv12 = _mm_mul_ps(rv12, mv2);

	// rv2
	rv20 = bt_splat_ps(rv22, 0);
	rv21 = bt_splat_ps(rv22, 1);
	rv22 = bt_splat_ps(rv22, 2);

	rv20 = _mm_mul_ps(rv20, mv0);
	rv21 = _mm_mul_ps(rv21, mv1);
	rv22 = _mm_mul_ps(rv22, mv2);

	rv00 = _mm_add_ps(rv00, rv01);
	rv10 = _mm_add_ps(rv10, rv11);
	rv20 = _mm_add_ps(rv20, rv21);

	m_el[0].mVec128 = _mm_add_ps(rv00, rv02);
	m_el[1].mVec128 = _mm_add_ps(rv10, rv12);
	m_el[2].mVec128 = _mm_add_ps(rv20, rv22);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m_el[0].mVec128;
	v1 = m_el[1].mVec128;
	v2 = m_el[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	m_el[0].mVec128 = rv0;
	m_el[1].mVec128 = rv1;
	m_el[2].mVec128 = rv2;
#else
	setValue(
		m.tdotx(m_el[0]), m.tdoty(m_el[0]), m.tdotz(m_el[0]),
		m.tdotx(m_el[1]), m.tdoty(m_el[1]), m.tdotz(m_el[1]),
		m.tdotx(m_el[2]), m.tdoty(m_el[2]), m.tdotz(m_el[2]));
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator+=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 + m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 + m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 + m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] + m.m_el[0][0],
		m_el[0][1] + m.m_el[0][1],
		m_el[0][2] + m.m_el[0][2],
		m_el[1][0] + m.m_el[1][0],
		m_el[1][1] + m.m_el[1][1],
		m_el[1][2] + m.m_el[1][2],
		m_el[2][0] + m.m_el[2][0],
		m_el[2][1] + m.m_el[2][1],
		m_el[2][2] + m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m, const btScalar& k)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vk = bt_splat_ps(_mm_load_ss((float*)&k), 0x80);
	return btMatrix3x3(
		_mm_mul_ps(m[0].mVec128, vk),
		_mm_mul_ps(m[1].mVec128, vk),
		_mm_mul_ps(m[2].mVec128, vk));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		vmulq_n_f32(m[0].mVec128, k),
		vmulq_n_f32(m[1].mVec128, k),
		vmulq_n_f32(m[2].mVec128, k));
#else
	return btMatrix3x3(
		m[0].x() * k, m[0].y() * k, m[0].z() * k,
		m[1].x() * k, m[1].y() * k, m[1].z() * k,
		m[2].x() * k, m[2].y() * k, m[2].z() * k);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator+(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 + m2[0].mVec128,
		m1[1].mVec128 + m2[1].mVec128,
		m1[2].mVec128 + m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] + m2[0][0],
		m1[0][1] + m2[0][1],
		m1[0][2] + m2[0][2],

		m1[1][0] + m2[1][0],
		m1[1][1] + m2[1][1],
		m1[1][2] + m2[1][2],

		m1[2][0] + m2[2][0],
		m1[2][1] + m2[2][1],
		m1[2][2] + m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator-(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 - m2[0].mVec128,
		m1[1].mVec128 - m2[1].mVec128,
		m1[2].mVec128 - m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] - m2[0][0],
		m1[0][1] - m2[0][1],
		m1[0][2] - m2[0][2],

		m1[1][0] - m2[1][0],
		m1[1][1] - m2[1][1],
		m1[1][2] - m2[1][2],

		m1[2][0] - m2[2][0],
		m1[2][1] - m2[2][1],
		m1[2][2] - m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator-=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 - m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 - m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 - m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] - m.m_el[0][0],
		m_el[0][1] - m.m_el[0][1],
		m_el[0][2] - m.m_el[0][2],
		m_el[1][0] - m.m_el[1][0],
		m_el[1][1] - m.m_el[1][1],
		m_el[1][2] - m.m_el[1][2],
		m_el[2][0] - m.m_el[2][0],
		m_el[2][1] - m.m_el[2][1],
		m_el[2][2] - m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btScalar
btMatrix3x3::determinant() const
{
	return btTriple((*this)[0], (*this)[1], (*this)[2]);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::absolute() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	return btMatrix3x3(
		_mm_and_ps(m_el[0].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[1].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[2].mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		(float32x4_t)vandq_s32((int32x4_t)m_el[0].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[1].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[2].mVec128, btv3AbsMask));
#else
	return btMatrix3x3(
		btFabs(m_el[0].x()), btFabs(m_el[0].y()), btFabs(m_el[0].z()),
		btFabs(m_el[1].x()), btFabs(m_el[1].y()), btFabs(m_el[1].z()),
		btFabs(m_el[2].x()), btFabs(m_el[2].y()), btFabs(m_el[2].z()));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transpose() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 v0 = m_el[0].mVec128;
	__m128 v1 = m_el[1].mVec128;
	__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
	__m128 vT;

	v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

	vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
	v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

	v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
	v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
	v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

	return btMatrix3x3(v0, v1, v2);
#elif defined(BT_USE_NEON)
	// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
	static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
	float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
	float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
	float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
	float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
	float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
	float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0
	return btMatrix3x3(v0, v1, v2);
#else
	return btMatrix3x3(m_el[0].x(), m_el[1].x(), m_el[2].x(),
					   m_el[0].y(), m_el[1].y(), m_el[2].y(),
					   m_el[0].z(), m_el[1].z(), m_el[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::adjoint() const
{
	return btMatrix3x3(cofac(1, 1, 2, 2), cofac(0, 2, 2, 1), cofac(0, 1, 1, 2),
					   cofac(1, 2, 2, 0), cofac(0, 0, 2, 2), cofac(0, 2, 1, 0),
					   cofac(1, 0, 2, 1), cofac(0, 1, 2, 0), cofac(0, 0, 1, 1));
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::inverse() const
{
	btVector3 co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));
	btScalar det = (*this)[0].dot(co);
	//btFullAssert(det != btScalar(0.0));
	btAssert(det != btScalar(0.0));
	btScalar s = btScalar(1.0) / det;
	return btMatrix3x3(co.x() * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
					   co.y() * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
					   co.z() * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transposeTimes(const btMatrix3x3& m) const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	// zeros w
	//    static const __m128i xyzMask = (const __m128i){ -1ULL, 0xffffffffULL };
	__m128 row = m_el[0].mVec128;
	__m128 m0 = _mm_and_ps(m.getRow(0).mVec128, btvFFF0fMask);
	__m128 m1 = _mm_and_ps(m.getRow(1).mVec128, btvFFF0fMask);
	__m128 m2 = _mm_and_ps(m.getRow(2).mVec128, btvFFF0fMask);
	__m128 r0 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0));
	__m128 r1 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0x55));
	__m128 r2 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0xaa));
	row = m_el[1].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0xaa)));
	row = m_el[2].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	// zeros w
	static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
	float32x4_t m0 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(0).mVec128, xyzMask);
	float32x4_t m1 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(1).mVec128, xyzMask);
	float32x4_t m2 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(2).mVec128, xyzMask);
	float32x4_t row = m_el[0].mVec128;
	float32x4_t r0 = vmulq_lane_f32(m0, vget_low_f32(row), 0);
	float32x4_t r1 = vmulq_lane_f32(m0, vget_low_f32(row), 1);
	float32x4_t r2 = vmulq_lane_f32(m0, vget_high_f32(row), 0);
	row = m_el[1].mVec128;
	r0 = vmlaq_lane_f32(r0, m1, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m1, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m1, vget_high_f32(row), 0);
	row = m_el[2].mVec128;
	r0 = vmlaq_lane_f32(r0, m2, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m2, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m2, vget_high_f32(row), 0);
	return btMatrix3x3(r0, r1, r2);
#else
	return btMatrix3x3(
		m_el[0].x() * m[0].x() + m_el[1].x() * m[1].x() + m_el[2].x() * m[2].x(),
		m_el[0].x() * m[0].y() + m_el[1].x() * m[1].y() + m_el[2].x() * m[2].y(),
		m_el[0].x() * m[0].z() + m_el[1].x() * m[1].z() + m_el[2].x() * m[2].z(),
		m_el[0].y() * m[0].x() + m_el[1].y() * m[1].x() + m_el[2].y() * m[2].x(),
		m_el[0].y() * m[0].y() + m_el[1].y() * m[1].y() + m_el[2].y() * m[2].y(),
		m_el[0].y() * m[0].z() + m_el[1].y() * m[1].z() + m_el[2].y() * m[2].z(),
		m_el[0].z() * m[0].x() + m_el[1].z() * m[1].x() + m_el[2].z() * m[2].x(),
		m_el[0].z() * m[0].y() + m_el[1].z() * m[1].y() + m_el[2].z() * m[2].y(),
		m_el[0].z() * m[0].z() + m_el[1].z() * m[1].z() + m_el[2].z() * m[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::timesTranspose(const btMatrix3x3& m) const
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 a0 = m_el[0].mVec128;
	__m128 a1 = m_el[1].mVec128;
	__m128 a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	__m128 mx = mT[0].mVec128;
	__m128 my = mT[1].mVec128;
	__m128 mz = mT[2].mVec128;

	__m128 r0 = _mm_mul_ps(mx, _mm_shuffle_ps(a0, a0, 0x00));
	__m128 r1 = _mm_mul_ps(mx, _mm_shuffle_ps(a1, a1, 0x00));
	__m128 r2 = _mm_mul_ps(mx, _mm_shuffle_ps(a2, a2, 0x00));
	r0 = _mm_add_ps(r0, _mm_mul_ps(my, _mm_shuffle_ps(a0, a0, 0x55)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(my, _mm_shuffle_ps(a1, a1, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(my, _mm_shuffle_ps(a2, a2, 0x55)));
	r0 = _mm_add_ps(r0, _mm_mul_ps(mz, _mm_shuffle_ps(a0, a0, 0xaa)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(mz, _mm_shuffle_ps(a1, a1, 0xaa)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(mz, _mm_shuffle_ps(a2, a2, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	float32x4_t a0 = m_el[0].mVec128;
	float32x4_t a1 = m_el[1].mVec128;
	float32x4_t a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	float32x4_t mx = mT[0].mVec128;
	float32x4_t my = mT[1].mVec128;
	float32x4_t mz = mT[2].mVec128;

	float32x4_t r0 = vmulq_lane_f32(mx, vget_low_f32(a0), 0);
	float32x4_t r1 = vmulq_lane_f32(mx, vget_low_f32(a1), 0);
	float32x4_t r2 = vmulq_lane_f32(mx, vget_low_f32(a2), 0);
	r0 = vmlaq_lane_f32(r0, my, vget_low_f32(a0), 1);
	r1 = vmlaq_lane_f32(r1, my, vget_low_f32(a1), 1);
	r2 = vmlaq_lane_f32(r2, my, vget_low_f32(a2), 1);
	r0 = vmlaq_lane_f32(r0, mz, vget_high_f32(a0), 0);
	r1 = vmlaq_lane_f32(r1, mz, vget_high_f32(a1), 0);
	r2 = vmlaq_lane_f32(r2, mz, vget_high_f32(a2), 0);
	return btMatrix3x3(r0, r1, r2);

#else
	return btMatrix3x3(
		m_el[0].dot(m[0]), m_el[0].dot(m[1]), m_el[0].dot(m[2]),
		m_el[1].dot(m[0]), m_el[1].dot(m[1]), m_el[1].dot(m[2]),
		m_el[2].dot(m[0]), m_el[2].dot(m[1]), m_el[2].dot(m[2]));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btMatrix3x3& m, const btVector3& v)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return v.dot3(m[0], m[1], m[2]);
#else
	return btVector3(m[0].dot(v), m[1].dot(v), m[2].dot(v));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	const __m128 vv = v.mVec128;

	__m128 c0 = bt_splat_ps(vv, 0);
	__m128 c1 = bt_splat_ps(vv, 1);
	__m128 c2 = bt_splat_ps(vv, 2);

	c0 = _mm_mul_ps(c0, _mm_and_ps(m[0].mVec128, btvFFF0fMask));
	c1 = _mm_mul_ps(c1, _mm_and_ps(m[1].mVec128, btvFFF0fMask));
	c0 = _mm_add_ps(c0, c1);
	c2 = _mm_mul_ps(c2, _mm_and_ps(m[2].mVec128, btvFFF0fMask));

	return btVector3(_mm_add_ps(c0, c2));
#elif defined(BT_USE_NEON)
	const float32x4_t vv = v.mVec128;
	const float32x2_t vlo = vget_low_f32(vv);
	const float32x2_t vhi = vget_high_f32(vv);

	float32x4_t c0, c1, c2;

	c0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	c1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	c2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	c0 = vmulq_lane_f32(c0, vlo, 0);
	c1 = vmulq_lane_f32(c1, vlo, 1);
	c2 = vmulq_lane_f32(c2, vhi, 0);
	c0 = vaddq_f32(c0, c1);
	c0 = vaddq_f32(c0, c2);

	return btVector3(c0);
#else
	return btVector3(m.tdotx(v), m.tdoty(v), m.tdotz(v));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 m10 = m1[0].mVec128;
	__m128 m11 = m1[1].mVec128;
	__m128 m12 = m1[2].mVec128;

	__m128 m2v = _mm_and_ps(m2[0].mVec128, btvFFF0fMask);

	__m128 c0 = bt_splat_ps(m10, 0);
	__m128 c1 = bt_splat_ps(m11, 0);
	__m128 c2 = bt_splat_ps(m12, 0);

	c0 = _mm_mul_ps(c0, m2v);
	c1 = _mm_mul_ps(c1, m2v);
	c2 = _mm_mul_ps(c2, m2v);

	m2v = _mm_and_ps(m2[1].mVec128, btvFFF0fMask);

	__m128 c0_1 = bt_splat_ps(m10, 1);
	__m128 c1_1 = bt_splat_ps(m11, 1);
	__m128 c2_1 = bt_splat_ps(m12, 1);

	c0_1 = _mm_mul_ps(c0_1, m2v);
	c1_1 = _mm_mul_ps(c1_1, m2v);
	c2_1 = _mm_mul_ps(c2_1, m2v);

	m2v = _mm_and_ps(m2[2].mVec128, btvFFF0fMask);

	c0 = _mm_add_ps(c0, c0_1);
	c1 = _mm_add_ps(c1, c1_1);
	c2 = _mm_add_ps(c2, c2_1);

	m10 = bt_splat_ps(m10, 2);
	m11 = bt_splat_ps(m11, 2);
	m12 = bt_splat_ps(m12, 2);

	m10 = _mm_mul_ps(m10, m2v);
	m11 = _mm_mul_ps(m11, m2v);
	m12 = _mm_mul_ps(m12, m2v);

	c0 = _mm_add_ps(c0, m10);
	c1 = _mm_add_ps(c1, m11);
	c2 = _mm_add_ps(c2, m12);

	return btMatrix3x3(c0, c1, c2);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m1[0].mVec128;
	v1 = m1[1].mVec128;
	v2 = m1[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m2[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m2[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m2[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	return btMatrix3x3(rv0, rv1, rv2);

#else
	return btMatrix3x3(
		m2.tdotx(m1[0]), m2.tdoty(m1[0]), m2.tdotz(m1[0]),
		m2.tdotx(m1[1]), m2.tdoty(m1[1]), m2.tdotz(m1[1]),
		m2.tdotx(m1[2]), m2.tdoty(m1[2]), m2.tdotz(m1[2]));
#endif
}

/*
SIMD_FORCE_INLINE btMatrix3x3 btMultTransposeLeft(const btMatrix3x3& m1, const btMatrix3x3& m2) {
return btMatrix3x3(
m1[0][0] * m2[0][0] + m1[1][0] * m2[1][0] + m1[2][0] * m2[2][0],
m1[0][0] * m2[0][1] + m1[1][0] * m2[1][1] + m1[2][0] * m2[2][1],
m1[0][0] * m2[0][2] + m1[1][0] * m2[1][2] + m1[2][0] * m2[2][2],
m1[0][1] * m2[0][0] + m1[1][1] * m2[1][0] + m1[2][1] * m2[2][0],
m1[0][1] * m2[0][1] + m1[1][1] * m2[1][1] + m1[2][1] * m2[2][1],
m1[0][1] * m2[0][2] + m1[1][1] * m2[1][2] + m1[2][1] * m2[2][2],
m1[0][2] * m2[0][0] + m1[1][2] * m2[1][0] + m1[2][2] * m2[2][0],
m1[0][2] * m2[0][1] + m1[1][2] * m2[1][1] + m1[2][2] * m2[2][1],
m1[0][2] * m2[0][2] + m1[1][2] * m2[1][2] + m1[2][2] * m2[2][2]);
}
*/

/**@brief Equality operator between two matrices
* It will test all elements are equal.  */
SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 c0, c1, c2;

	c0 = _mm_cmpeq_ps(m1[0].mVec128, m2[0].mVec128);
	c1 = _mm_cmpeq_ps(m1[1].mVec128, m2[1].mVec128);
	c2 = _mm_cmpeq_ps(m1[2].mVec128, m2[2].mVec128);

	c0 = _mm_and_ps(c0, c1);
	c0 = _mm_and_ps(c0, c2);

	int m = _mm_movemask_ps((__m128)c0);
	return (0x7 == (m & 0x7));

#else
	return (m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&
			m1[0][1] == m2[0][1] && m1[1][1] == m2[1][1] && m1[2][1] == m2[2][1] &&
			m1[0][2] == m2[0][2] && m1[1][2] == m2[1][2] && m1[2][2] == m2[2][2]);
#endif
}

///for serialization
struct btMatrix3x3FloatData
{
	btVector3FloatData m_el[3];
};

///for serialization
struct btMatrix3x3DoubleData
{
	btVector3DoubleData m_el[3];
};

SIMD_FORCE_INLINE void btMatrix3x3::serialize(struct btMatrix3x3Data& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serialize(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::serializeFloat(struct btMatrix3x3FloatData& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serializeFloat(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerialize(const struct btMatrix3x3Data& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerialize(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeFloat(const struct btMatrix3x3FloatData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeFloat(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeDouble(dataIn.m_el[i]);
}

#endif  //BT_MATRIX3x3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRANSFORM_H
#define BT_TRANSFORM_H

#include "LinearMath/btMatrix3x3.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTransformData btTransformDoubleData
#else
#define btTransformData btTransformFloatData
#endif

/**@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
 *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
ATTRIBUTE_ALIGNED16(class)
btTransform
{
	///Storage for the rotation
	btMatrix3x3 m_basis;
	///Storage for the translation
	btVector3 m_origin;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();
	/**@brief No initialization constructor */
	btTransform() {}
	/**@brief Constructor from btQuaternion (optional btVector3 )
   * @param q Rotation from quaternion 
   * @param c Translation from Vector (default 0,0,0) */
	explicit SIMD_FORCE_INLINE btTransform(const btQuaternion& q,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(q),
		  m_origin(c)
	{
	}

	/**@brief Constructor from btMatrix3x3 (optional btVector3)
   * @param b Rotation from Matrix 
   * @param c Translation from Vector default (0,0,0)*/
	explicit SIMD_FORCE_INLINE btTransform(const btMatrix3x3& b,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(b),
		  m_origin(c)
	{
	}
	/**@brief Copy constructor */
	SIMD_FORCE_INLINE btTransform(const btTransform& other)
		: m_basis(other.m_basis),
		  m_origin(other.m_origin)
	{
	}
	/**@brief Assignment Operator */
	SIMD_FORCE_INLINE btTransform& operator=(const btTransform& other)
	{
		m_basis = other.m_basis;
		m_origin = other.m_origin;
		return *this;
	}

	/**@brief Set the current transform as the value of the product of two transforms
   * @param t1 Transform 1
   * @param t2 Transform 2
   * This = Transform1 * Transform2 */
	SIMD_FORCE_INLINE void mult(const btTransform& t1, const btTransform& t2)
	{
		m_basis = t1.m_basis * t2.m_basis;
		m_origin = t1(t2.m_origin);
	}

	/*		void multInverseLeft(const btTransform& t1, const btTransform& t2) {
			btVector3 v = t2.m_origin - t1.m_origin;
			m_basis = btMultTransposeLeft(t1.m_basis, t2.m_basis);
			m_origin = v * t1.m_basis;
		}
		*/

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator()(const btVector3& x) const
	{
		return x.dot3(m_basis[0], m_basis[1], m_basis[2]) + m_origin;
	}

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator*(const btVector3& x) const
	{
		return (*this)(x);
	}

	/**@brief Return the transform of the btQuaternion */
	SIMD_FORCE_INLINE btQuaternion operator*(const btQuaternion& q) const
	{
		return getRotation() * q;
	}

	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE btMatrix3x3& getBasis() { return m_basis; }
	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE const btMatrix3x3& getBasis() const { return m_basis; }

	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE btVector3& getOrigin() { return m_origin; }
	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE const btVector3& getOrigin() const { return m_origin; }

	/**@brief Return a quaternion representing the rotation */
	btQuaternion getRotation() const
	{
		btQuaternion q;
		m_basis.getRotation(q);
		return q;
	}

	/**@brief Set from an array 
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void setFromOpenGLMatrix(const btScalar* m)
	{
		m_basis.setFromOpenGLSubMatrix(m);
		m_origin.setValue(m[12], m[13], m[14]);
	}

	/**@brief Fill an array representation
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void getOpenGLMatrix(btScalar * m) const
	{
		m_basis.getOpenGLSubMatrix(m);
		m[12] = m_origin.x();
		m[13] = m_origin.y();
		m[14] = m_origin.z();
		m[15] = btScalar(1.0);
	}

	/**@brief Set the translational element
   * @param origin The vector to set the translation to */
	SIMD_FORCE_INLINE void setOrigin(const btVector3& origin)
	{
		m_origin = origin;
	}

	SIMD_FORCE_INLINE btVector3 invXform(const btVector3& inVec) const;

	/**@brief Set the rotational element by btMatrix3x3 */
	SIMD_FORCE_INLINE void setBasis(const btMatrix3x3& basis)
	{
		m_basis = basis;
	}

	/**@brief Set the rotational element by btQuaternion */
	SIMD_FORCE_INLINE void setRotation(const btQuaternion& q)
	{
		m_basis.setRotation(q);
	}

	/**@brief Set this transformation to the identity */
	void setIdentity()
	{
		m_basis.setIdentity();
		m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	/**@brief Multiply this Transform by another(this = this * another) 
   * @param t The other transform */
	btTransform& operator*=(const btTransform& t)
	{
		m_origin += m_basis * t.m_origin;
		m_basis *= t.m_basis;
		return *this;
	}

	/**@brief Return the inverse of this transform */
	btTransform inverse() const
	{
		btMatrix3x3 inv = m_basis.transpose();
		return btTransform(inv, inv * -m_origin);
	}

	/**@brief Return the inverse of this transform times the other transform
   * @param t The other transform 
   * return this.inverse() * the other */
	btTransform inverseTimes(const btTransform& t) const;

	/**@brief Return the product of this transform and the other */
	btTransform operator*(const btTransform& t) const;

	/**@brief Return an identity transform */
	static const btTransform& getIdentity()
	{
		static const btTransform identityTransform(btMatrix3x3::getIdentity());
		return identityTransform;
	}

	void serialize(struct btTransformData & dataOut) const;

	void serializeFloat(struct btTransformFloatData & dataOut) const;

	void deSerialize(const struct btTransformData& dataIn);

	void deSerializeDouble(const struct btTransformDoubleData& dataIn);

	void deSerializeFloat(const struct btTransformFloatData& dataIn);
};

SIMD_FORCE_INLINE btVector3
btTransform::invXform(const btVector3& inVec) const
{
	btVector3 v = inVec - m_origin;
	return (m_basis.transpose() * v);
}

SIMD_FORCE_INLINE btTransform
btTransform::inverseTimes(const btTransform& t) const
{
	btVector3 v = t.getOrigin() - m_origin;
	return btTransform(m_basis.transposeTimes(t.m_basis),
					   v * m_basis);
}

SIMD_FORCE_INLINE btTransform
	btTransform::operator*(const btTransform& t) const
{
	return btTransform(m_basis * t.m_basis,
					   (*this)(t.m_origin));
}

/**@brief Test if two transforms have all elements equal */
SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)
{
	return (t1.getBasis() == t2.getBasis() &&
			t1.getOrigin() == t2.getOrigin());
}

///for serialization
struct btTransformFloatData
{
	btMatrix3x3FloatData m_basis;
	btVector3FloatData m_origin;
};

struct btTransformDoubleData
{
	btMatrix3x3DoubleData m_basis;
	btVector3DoubleData m_origin;
};

SIMD_FORCE_INLINE void btTransform::serialize(btTransformData& dataOut) const
{
	m_basis.serialize(dataOut.m_basis);
	m_origin.serialize(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::serializeFloat(btTransformFloatData& dataOut) const
{
	m_basis.serializeFloat(dataOut.m_basis);
	m_origin.serializeFloat(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerialize(const btTransformData& dataIn)
{
	m_basis.deSerialize(dataIn.m_basis);
	m_origin.deSerialize(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeFloat(const btTransformFloatData& dataIn)
{
	m_basis.deSerializeFloat(dataIn.m_basis);
	m_origin.deSerializeFloat(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeDouble(const btTransformDoubleData& dataIn)
{
	m_basis.deSerializeDouble(dataIn.m_basis);
	m_origin.deSerializeDouble(dataIn.m_origin);
}

#endif  //BT_TRANSFORM_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MOTIONSTATE_H
#define BT_MOTIONSTATE_H

#include "LinearMath/btTransform.h"

///The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
///For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
class btMotionState
{
public:
	virtual ~btMotionState()
	{
	}

	virtual void getWorldTransform(btTransform& worldTrans) const = 0;

	//Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& worldTrans) = 0;
};

#endif  //BT_MOTIONSTATE_H





#ifndef BT_DEFAULT_MOTION_STATE_H
#define BT_DEFAULT_MOTION_STATE_H

#include "LinearMath/btMotionState.h"

///The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
ATTRIBUTE_ALIGNED16(struct)
btDefaultMotionState : public btMotionState
{
	btTransform m_graphicsWorldTrans;
	btTransform m_centerOfMassOffset;
	btTransform m_startWorldTrans;
	void* m_userPointer;

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btDefaultMotionState(const btTransform& startTrans = btTransform::getIdentity(), const btTransform& centerOfMassOffset = btTransform::getIdentity())
		: m_graphicsWorldTrans(startTrans),
		  m_centerOfMassOffset(centerOfMassOffset),
		  m_startWorldTrans(startTrans),
		  m_userPointer(0)

	{
	}

	///synchronizes world transform from user to physics
	virtual void getWorldTransform(btTransform & centerOfMassWorldTrans) const
	{
		centerOfMassWorldTrans = m_graphicsWorldTrans * m_centerOfMassOffset.inverse();
	}

	///synchronizes world transform from physics to user
	///Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& centerOfMassWorldTrans)
	{
		m_graphicsWorldTrans = centerOfMassWorldTrans * m_centerOfMassOffset;
	}
};

#endif  //BT_DEFAULT_MOTION_STATE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_BROADPHASE_PROXY_H
#define BT_BROADPHASE_PROXY_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedAllocator.h"

/// btDispatcher uses these types
/// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
/// to facilitate type checking
/// CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
enum BroadphaseNativeTypes
{
	// polyhedral convex shapes
	BOX_SHAPE_PROXYTYPE,
	TRIANGLE_SHAPE_PROXYTYPE,
	TETRAHEDRAL_SHAPE_PROXYTYPE,
	CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE,
	CONVEX_HULL_SHAPE_PROXYTYPE,
	CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE,
	CUSTOM_POLYHEDRAL_SHAPE_TYPE,
	//implicit convex shapes
	IMPLICIT_CONVEX_SHAPES_START_HERE,
	SPHERE_SHAPE_PROXYTYPE,
	MULTI_SPHERE_SHAPE_PROXYTYPE,
	CAPSULE_SHAPE_PROXYTYPE,
	CONE_SHAPE_PROXYTYPE,
	CONVEX_SHAPE_PROXYTYPE,
	CYLINDER_SHAPE_PROXYTYPE,
	UNIFORM_SCALING_SHAPE_PROXYTYPE,
	MINKOWSKI_SUM_SHAPE_PROXYTYPE,
	MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE,
	BOX_2D_SHAPE_PROXYTYPE,
	CONVEX_2D_SHAPE_PROXYTYPE,
	CUSTOM_CONVEX_SHAPE_TYPE,
	//concave shapes
	CONCAVE_SHAPES_START_HERE,
	//keep all the convex shapetype below here, for the check IsConvexShape in broadphase proxy!
	TRIANGLE_MESH_SHAPE_PROXYTYPE,
	SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE,
	///used for demo integration FAST/Swift collision library and Bullet
	FAST_CONCAVE_MESH_PROXYTYPE,
	//terrain
	TERRAIN_SHAPE_PROXYTYPE,
	///Used for GIMPACT Trimesh integration
	GIMPACT_SHAPE_PROXYTYPE,
	///Multimaterial mesh
	MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE,

	EMPTY_SHAPE_PROXYTYPE,
	STATIC_PLANE_PROXYTYPE,
	CUSTOM_CONCAVE_SHAPE_TYPE,
	SDF_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE,
	CONCAVE_SHAPES_END_HERE,

	COMPOUND_SHAPE_PROXYTYPE,

	SOFTBODY_SHAPE_PROXYTYPE,
	HFFLUID_SHAPE_PROXYTYPE,
	HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE,
	INVALID_SHAPE_PROXYTYPE,

	MAX_BROADPHASE_COLLISION_TYPES

};

///The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
///It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
ATTRIBUTE_ALIGNED16(struct)
btBroadphaseProxy
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///optional filtering to cull potential collisions
	enum CollisionFilterGroups
	{
		DefaultFilter = 1,
		StaticFilter = 2,
		KinematicFilter = 4,
		DebrisFilter = 8,
		SensorTrigger = 16,
		CharacterFilter = 32,
		AllFilter = -1  //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger
	};

	//Usually the client btCollisionObject or Rigidbody class
	void* m_clientObject;
	int m_collisionFilterGroup;
	int m_collisionFilterMask;

	int m_uniqueId;  //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

	btVector3 m_aabbMin;
	btVector3 m_aabbMax;

	SIMD_FORCE_INLINE int getUid() const
	{
		return m_uniqueId;
	}

	//used for memory pools
	btBroadphaseProxy() : m_clientObject(0)
	{
	}

	btBroadphaseProxy(const btVector3& aabbMin, const btVector3& aabbMax, void* userPtr, int collisionFilterGroup, int collisionFilterMask)
		: m_clientObject(userPtr),
		  m_collisionFilterGroup(collisionFilterGroup),
		  m_collisionFilterMask(collisionFilterMask),
		  m_aabbMin(aabbMin),
		  m_aabbMax(aabbMax)
	{
	}

	static SIMD_FORCE_INLINE bool isPolyhedral(int proxyType)
	{
		return (proxyType < IMPLICIT_CONVEX_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isConvex(int proxyType)
	{
		return (proxyType < CONCAVE_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isNonMoving(int proxyType)
	{
		return (isConcave(proxyType) && !(proxyType == GIMPACT_SHAPE_PROXYTYPE));
	}

	static SIMD_FORCE_INLINE bool isConcave(int proxyType)
	{
		return ((proxyType > CONCAVE_SHAPES_START_HERE) &&
				(proxyType < CONCAVE_SHAPES_END_HERE));
	}
	static SIMD_FORCE_INLINE bool isCompound(int proxyType)
	{
		return (proxyType == COMPOUND_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isSoftBody(int proxyType)
	{
		return (proxyType == SOFTBODY_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isInfinite(int proxyType)
	{
		return (proxyType == STATIC_PLANE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isConvex2d(int proxyType)
	{
		return (proxyType == BOX_2D_SHAPE_PROXYTYPE) || (proxyType == CONVEX_2D_SHAPE_PROXYTYPE);
	}
};

class btCollisionAlgorithm;

struct btBroadphaseProxy;

///The btBroadphasePair class contains a pair of aabb-overlapping objects.
///A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
ATTRIBUTE_ALIGNED16(struct)
btBroadphasePair
{
	btBroadphasePair()
		: m_pProxy0(0),
		  m_pProxy1(0),
		  m_algorithm(0),
		  m_internalInfo1(0)
	{
	}

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btBroadphasePair(btBroadphaseProxy & proxy0, btBroadphaseProxy & proxy1)
	{
		//keep them sorted, so the std::set operations work
		if (proxy0.m_uniqueId < proxy1.m_uniqueId)
		{
			m_pProxy0 = &proxy0;
			m_pProxy1 = &proxy1;
		}
		else
		{
			m_pProxy0 = &proxy1;
			m_pProxy1 = &proxy0;
		}

		m_algorithm = 0;
		m_internalInfo1 = 0;
	}

	btBroadphaseProxy* m_pProxy0;
	btBroadphaseProxy* m_pProxy1;

	mutable btCollisionAlgorithm* m_algorithm;
	union {
		void* m_internalInfo1;
		int m_internalTmpValue;
	};  //don't use this data, it will be removed in future version.
};

/*
//comparison for set operation, see Solid DT_Encounter
SIMD_FORCE_INLINE bool operator<(const btBroadphasePair& a, const btBroadphasePair& b) 
{ 
    return a.m_pProxy0 < b.m_pProxy0 || 
        (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 < b.m_pProxy1); 
}
*/

class btBroadphasePairSortPredicate
{
public:
	bool operator()(const btBroadphasePair& a, const btBroadphasePair& b) const
	{
		const int uidA0 = a.m_pProxy0 ? a.m_pProxy0->m_uniqueId : -1;
		const int uidB0 = b.m_pProxy0 ? b.m_pProxy0->m_uniqueId : -1;
		const int uidA1 = a.m_pProxy1 ? a.m_pProxy1->m_uniqueId : -1;
		const int uidB1 = b.m_pProxy1 ? b.m_pProxy1->m_uniqueId : -1;

		return uidA0 > uidB0 ||
			   (a.m_pProxy0 == b.m_pProxy0 && uidA1 > uidB1) ||
			   (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 == b.m_pProxy1 && a.m_algorithm > b.m_algorithm);
	}
};

SIMD_FORCE_INLINE bool operator==(const btBroadphasePair& a, const btBroadphasePair& b)
{
	return (a.m_pProxy0 == b.m_pProxy0) && (a.m_pProxy1 == b.m_pProxy1);
}

#endif  //BT_BROADPHASE_PROXY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "LinearMath/btSerializer.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletCollisionProbe();

	void btBulletCollisionProbe() {}
}

void btCollisionShape::getBoundingSphere(btVector3& center, btScalar& radius) const
{
	btTransform tr;
	tr.setIdentity();
	btVector3 aabbMin, aabbMax;

	getAabb(tr, aabbMin, aabbMax);

	radius = (aabbMax - aabbMin).length() * btScalar(0.5);
	center = (aabbMin + aabbMax) * btScalar(0.5);
}

btScalar btCollisionShape::getContactBreakingThreshold(btScalar defaultContactThreshold) const
{
	return getAngularMotionDisc() * defaultContactThreshold;
}

btScalar btCollisionShape::getAngularMotionDisc() const
{
	///@todo cache this value, to improve performance
	btVector3 center;
	btScalar disc;
	getBoundingSphere(center, disc);
	disc += (center).length();
	return disc;
}

void btCollisionShape::calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const
{
	//start with static aabb
	getAabb(curTrans, temporalAabbMin, temporalAabbMax);

	btScalar temporalAabbMaxx = temporalAabbMax.getX();
	btScalar temporalAabbMaxy = temporalAabbMax.getY();
	btScalar temporalAabbMaxz = temporalAabbMax.getZ();
	btScalar temporalAabbMinx = temporalAabbMin.getX();
	btScalar temporalAabbMiny = temporalAabbMin.getY();
	btScalar temporalAabbMinz = temporalAabbMin.getZ();

	// add linear motion
	btVector3 linMotion = linvel * timeStep;
	///@todo: simd would have a vector max/min operation, instead of per-element access
	if (linMotion.x() > btScalar(0.))
		temporalAabbMaxx += linMotion.x();
	else
		temporalAabbMinx += linMotion.x();
	if (linMotion.y() > btScalar(0.))
		temporalAabbMaxy += linMotion.y();
	else
		temporalAabbMiny += linMotion.y();
	if (linMotion.z() > btScalar(0.))
		temporalAabbMaxz += linMotion.z();
	else
		temporalAabbMinz += linMotion.z();

	//add conservative angular motion
	btScalar angularMotion = angvel.length() * getAngularMotionDisc() * timeStep;
	btVector3 angularMotion3d(angularMotion, angularMotion, angularMotion);
	temporalAabbMin = btVector3(temporalAabbMinx, temporalAabbMiny, temporalAabbMinz);
	temporalAabbMax = btVector3(temporalAabbMaxx, temporalAabbMaxy, temporalAabbMaxz);

	temporalAabbMin -= angularMotion3d;
	temporalAabbMax += angularMotion3d;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btCollisionShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionShapeData* shapeData = (btCollisionShapeData*)dataBuffer;
	char* name = (char*)serializer->findNameForPointer(this);
	shapeData->m_name = (char*)serializer->getUniquePointer(name);
	if (shapeData->m_name)
	{
		serializer->serializeName(name);
	}
	shapeData->m_shapeType = m_shapeType;

	// Fill padding with zeros to appease msan.
	memset(shapeData->m_padding, 0, sizeof(shapeData->m_padding));

	return "btCollisionShapeData";
}

void btCollisionShape::serializeSingleShape(btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_SHAPE_CODE, (void*)this);
}



#include <string.h>



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_SHAPE_H
#define BT_COLLISION_SHAPE_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
class btSerializer;

///The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
ATTRIBUTE_ALIGNED16(class)
btCollisionShape
{
protected:
	int m_shapeType;
	void* m_userPointer;
	int m_userIndex;
	int m_userIndex2;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCollisionShape() : m_shapeType(INVALID_SHAPE_PROXYTYPE), m_userPointer(0), m_userIndex(-1), m_userIndex2(-1)
	{
	}

	virtual ~btCollisionShape()
	{
	}

	///getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getBoundingSphere(btVector3 & center, btScalar & radius) const;

	///getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
	virtual btScalar getAngularMotionDisc() const;

	virtual btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;

	///calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
	///result is conservative
	void calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const;

	SIMD_FORCE_INLINE bool isPolyhedral() const
	{
		return btBroadphaseProxy::isPolyhedral(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex2d() const
	{
		return btBroadphaseProxy::isConvex2d(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex() const
	{
		return btBroadphaseProxy::isConvex(getShapeType());
	}
	SIMD_FORCE_INLINE bool isNonMoving() const
	{
		return btBroadphaseProxy::isNonMoving(getShapeType());
	}
	SIMD_FORCE_INLINE bool isConcave() const
	{
		return btBroadphaseProxy::isConcave(getShapeType());
	}
	SIMD_FORCE_INLINE bool isCompound() const
	{
		return btBroadphaseProxy::isCompound(getShapeType());
	}

	SIMD_FORCE_INLINE bool isSoftBody() const
	{
		return btBroadphaseProxy::isSoftBody(getShapeType());
	}

	///isInfinite is used to catch simulation error (aabb check)
	SIMD_FORCE_INLINE bool isInfinite() const
	{
		return btBroadphaseProxy::isInfinite(getShapeType());
	}

#ifndef __SPU__
	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const = 0;

	//debugging support
	virtual const char* getName() const = 0;
#endif  //__SPU__

	int getShapeType() const
	{
		return m_shapeType;
	}

	///the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
	///See Bullet/Demos/RollingFrictionDemo for an example
	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		return btVector3(1, 1, 1);
	}
	virtual void setMargin(btScalar margin) = 0;
	virtual btScalar getMargin() const = 0;

	///optional user data pointer
	void setUserPointer(void* userPtr)
	{
		m_userPointer = userPtr;
	}

	void* getUserPointer() const
	{
		return m_userPointer;
	}
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	virtual void serializeSingleShape(btSerializer * serializer) const;
};

// clang-format off
// parser needs * with the name
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionShapeData
{
	char	*m_name;
	int		m_shapeType;
	char	m_padding[4];
};
// clang-format on
SIMD_FORCE_INLINE int btCollisionShape::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionShapeData);
}

#endif  //BT_COLLISION_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_MARGIN_H
#define BT_COLLISION_MARGIN_H

///The CONVEX_DISTANCE_MARGIN is a default collision margin for convex collision shapes derived from btConvexInternalShape.
///This collision margin is used by Gjk and some other algorithms
///Note that when creating small objects, you need to make sure to set a smaller collision margin, using the 'setMargin' API
#define CONVEX_DISTANCE_MARGIN btScalar(0.04)  // btScalar(0.1)//;//btScalar(0.01)

#endif  //BT_COLLISION_MARGIN_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"

///not supported on IBM SDK, until we fix the alignment of btVector3
#if defined(__CELLOS_LV2__) && defined(__SPU__)
static inline vec_float4 vec_dot3(vec_float4 vec0, vec_float4 vec1)
{
	vec_float4 result;
	result = spu_mul(vec0, vec1);
	result = spu_madd(spu_rlqwbyte(vec0, 4), spu_rlqwbyte(vec1, 4), result);
	return spu_madd(spu_rlqwbyte(vec0, 8), spu_rlqwbyte(vec1, 8), result);
}
#endif  //__SPU__

btConvexShape::btConvexShape()
{
}

btConvexShape::~btConvexShape()
{
}

void btConvexShape::project(const btTransform& trans, const btVector3& dir, btScalar& min, btScalar& max, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	btVector3 localAxis = dir * trans.getBasis();
	btVector3 vtx1 = trans(localGetSupportingVertex(localAxis));
	btVector3 vtx2 = trans(localGetSupportingVertex(-localAxis));

	min = vtx1.dot(dir);
	max = vtx2.dot(dir);
	witnesPtMax = vtx2;
	witnesPtMin = vtx1;

	if (min > max)
	{
		btScalar tmp = min;
		min = max;
		max = tmp;
		witnesPtMax = vtx1;
		witnesPtMin = vtx2;
	}
}

static btVector3 convexHullSupport(const btVector3& localDirOrg, const btVector3* points, int numPoints, const btVector3& localScaling)
{
	btVector3 vec = localDirOrg * localScaling;

#if defined(__CELLOS_LV2__) && defined(__SPU__)

	btVector3 localDir = vec;

	vec_float4 v_distMax = {-FLT_MAX, 0, 0, 0};
	vec_int4 v_idxMax = {-999, 0, 0, 0};
	int v = 0;
	int numverts = numPoints;

	for (; v < (int)numverts - 4; v += 4)
	{
		vec_float4 p0 = vec_dot3(points[v].get128(), localDir.get128());
		vec_float4 p1 = vec_dot3(points[v + 1].get128(), localDir.get128());
		vec_float4 p2 = vec_dot3(points[v + 2].get128(), localDir.get128());
		vec_float4 p3 = vec_dot3(points[v + 3].get128(), localDir.get128());
		const vec_int4 i0 = {v, 0, 0, 0};
		const vec_int4 i1 = {v + 1, 0, 0, 0};
		const vec_int4 i2 = {v + 2, 0, 0, 0};
		const vec_int4 i3 = {v + 3, 0, 0, 0};
		vec_uint4 retGt01 = spu_cmpgt(p0, p1);
		vec_float4 pmax01 = spu_sel(p1, p0, retGt01);
		vec_int4 imax01 = spu_sel(i1, i0, retGt01);
		vec_uint4 retGt23 = spu_cmpgt(p2, p3);
		vec_float4 pmax23 = spu_sel(p3, p2, retGt23);
		vec_int4 imax23 = spu_sel(i3, i2, retGt23);
		vec_uint4 retGt0123 = spu_cmpgt(pmax01, pmax23);
		vec_float4 pmax0123 = spu_sel(pmax23, pmax01, retGt0123);
		vec_int4 imax0123 = spu_sel(imax23, imax01, retGt0123);
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, pmax0123);
		v_distMax = spu_sel(pmax0123, v_distMax, retGtMax);
		v_idxMax = spu_sel(imax0123, v_idxMax, retGtMax);
	}
	for (; v < (int)numverts; v++)
	{
		vec_float4 p = vec_dot3(points[v].get128(), localDir.get128());
		const vec_int4 i = {v, 0, 0, 0};
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, p);
		v_distMax = spu_sel(p, v_distMax, retGtMax);
		v_idxMax = spu_sel(i, v_idxMax, retGtMax);
	}
	int ptIndex = spu_extract(v_idxMax, 0);
	const btVector3& supVec = points[ptIndex] * localScaling;
	return supVec;
#else

	btScalar maxDot;
	long ptIndex = vec.maxDot(points, numPoints, maxDot);
	btAssert(ptIndex >= 0);
	if (ptIndex < 0)
	{
		ptIndex = 0;
	}
	btVector3 supVec = points[ptIndex] * localScaling;
	return supVec;
#endif  //__SPU__
}

btVector3 btConvexShape::localGetSupportVertexWithoutMarginNonVirtual(const btVector3& localDir) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			return btVector3(0, 0, 0);
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			const btVector3& halfExtents = convexShape->getImplicitShapeDimensions();

#if defined(__APPLE__) && (defined(BT_USE_SSE) || defined(BT_USE_NEON))
#if defined(BT_USE_SSE)
			return btVector3(_mm_xor_ps(_mm_and_ps(localDir.mVec128, (__m128){-0.0f, -0.0f, -0.0f, -0.0f}), halfExtents.mVec128));
#elif defined(BT_USE_NEON)
			return btVector3((float32x4_t)(((uint32x4_t)localDir.mVec128 & (uint32x4_t){0x80000000, 0x80000000, 0x80000000, 0x80000000}) ^ (uint32x4_t)halfExtents.mVec128));
#else
#error unknown vector arch
#endif
#else
			return btVector3(btFsels(localDir.x(), halfExtents.x(), -halfExtents.x()),
							 btFsels(localDir.y(), halfExtents.y(), -halfExtents.y()),
							 btFsels(localDir.z(), halfExtents.z(), -halfExtents.z()));
#endif
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btVector3 dir(localDir.getX(), localDir.getY(), localDir.getZ());
			btVector3* vertices = &triangleShape->m_vertices1[0];
			btVector3 dots = dir.dot3(vertices[0], vertices[1], vertices[2]);
			btVector3 sup = vertices[dots.maxAxis()];
			return btVector3(sup.getX(), sup.getY(), sup.getZ());
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			//mapping of halfextents/dimension onto radius/height depends on how cylinder local orientation is (upAxis)

			btVector3 halfExtents = cylShape->getImplicitShapeDimensions();
			btVector3 v(localDir.getX(), localDir.getY(), localDir.getZ());
			int cylinderUpAxis = cylShape->getUpAxis();
			int XX(1), YY(0), ZZ(2);

			switch (cylinderUpAxis)
			{
				case 0:
				{
					XX = 1;
					YY = 0;
					ZZ = 2;
				}
				break;
				case 1:
				{
					XX = 0;
					YY = 1;
					ZZ = 2;
				}
				break;
				case 2:
				{
					XX = 0;
					YY = 2;
					ZZ = 1;
				}
				break;
				default:
					btAssert(0);
					break;
			};

			btScalar radius = halfExtents[XX];
			btScalar halfHeight = halfExtents[cylinderUpAxis];

			btVector3 tmp;
			btScalar d;

			btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
			if (s != btScalar(0.0))
			{
				d = radius / s;
				tmp[XX] = v[XX] * d;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = v[ZZ] * d;
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
			else
			{
				tmp[XX] = radius;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = btScalar(0.0);
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btVector3 vec0(localDir.getX(), localDir.getY(), localDir.getZ());

			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btScalar halfHeight = capsuleShape->getHalfHeight();
			int capsuleUpAxis = capsuleShape->getUpAxis();

			btVector3 supVec(0, 0, 0);

			btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

			btVector3 vec = vec0;
			btScalar lenSqr = vec.length2();
			if (lenSqr < SIMD_EPSILON * SIMD_EPSILON)
			{
				vec.setValue(1, 0, 0);
			}
			else
			{
				btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
				vec *= rlen;
			}
			btVector3 vtx;
			btScalar newDot;
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);

				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = -halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);
				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			return btVector3(supVec.getX(), supVec.getY(), supVec.getZ());
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		{
			btConvexPointCloudShape* convexPointCloudShape = (btConvexPointCloudShape*)this;
			btVector3* points = convexPointCloudShape->getUnscaledPoints();
			int numPoints = convexPointCloudShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexPointCloudShape->getLocalScalingNV());
		}
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btConvexHullShape* convexHullShape = (btConvexHullShape*)this;
			btVector3* points = convexHullShape->getUnscaledPoints();
			int numPoints = convexHullShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexHullShape->getLocalScalingNV());
		}
		default:
#ifndef __SPU__
			return this->localGetSupportingVertexWithoutMargin(localDir);
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btVector3(btScalar(0.0f), btScalar(0.0f), btScalar(0.0f));
}

btVector3 btConvexShape::localGetSupportVertexNonVirtual(const btVector3& localDir) const
{
	btVector3 localDirNorm = localDir;
	if (localDirNorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		localDirNorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	localDirNorm.normalize();

	return localGetSupportVertexWithoutMarginNonVirtual(localDirNorm) + getMarginNonVirtual() * localDirNorm;
}

/* TODO: This should be bumped up to btCollisionShape () */
btScalar btConvexShape::getMarginNonVirtual() const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			return sphereShape->getRadius();
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			return convexShape->getMarginNV();
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			return triangleShape->getMarginNV();
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			return cylShape->getMarginNV();
		}
		case CONE_SHAPE_PROXYTYPE:
		{
			btConeShape* conShape = (btConeShape*)this;
			return conShape->getMarginNV();
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			return capsuleShape->getMarginNV();
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		/* fall through */
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexShape* convexHullShape = (btPolyhedralConvexShape*)this;
			return convexHullShape->getMarginNV();
		}
		default:
#ifndef __SPU__
			return this->getMargin();
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btScalar(0.0f);
}
#ifndef __SPU__
void btConvexShape::getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			btScalar radius = sphereShape->getImplicitShapeDimensions().getX();  // * convexShape->getLocalScaling().getX();
			btScalar margin = radius + sphereShape->getMarginNonVirtual();
			const btVector3& center = t.getOrigin();
			btVector3 extent(margin, margin, margin);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CYLINDER_SHAPE_PROXYTYPE:
		/* fall through */
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			btScalar margin = convexShape->getMarginNonVirtual();
			btVector3 halfExtents = convexShape->getImplicitShapeDimensions();
			halfExtents += btVector3(margin, margin, margin);
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

			aabbMin = center - extent;
			aabbMax = center + extent;
			break;
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btScalar margin = triangleShape->getMarginNonVirtual();
			for (int i = 0; i < 3; i++)
			{
				btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
				vec[i] = btScalar(1.);

				btVector3 sv = localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis());

				btVector3 tmp = t(sv);
				aabbMax[i] = tmp[i] + margin;
				vec[i] = btScalar(-1.);
				tmp = t(localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis()));
				aabbMin[i] = tmp[i] - margin;
			}
		}
		break;
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btVector3 halfExtents(capsuleShape->getRadius(), capsuleShape->getRadius(), capsuleShape->getRadius());
			int m_upAxis = capsuleShape->getUpAxis();
			halfExtents[m_upAxis] = capsuleShape->getRadius() + capsuleShape->getHalfHeight();
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexAabbCachingShape* convexHullShape = (btPolyhedralConvexAabbCachingShape*)this;
			btScalar margin = convexHullShape->getMarginNonVirtual();
			convexHullShape->getNonvirtualAabb(t, aabbMin, aabbMax, margin);
		}
		break;
		default:
#ifndef __SPU__
			this->getAabb(t, aabbMin, aabbMax);
#else
			btAssert(0);
#endif
			break;
	}

	// should never reach here
	btAssert(0);
}

#endif  //__SPU__





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_SHAPE_INTERFACE1
#define BT_CONVEX_SHAPE_INTERFACE1

#include "BulletCollision/CollisionShapes/btCollisionShape.h"

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "LinearMath/btAlignedAllocator.h"

#define MAX_PREFERRED_PENETRATION_DIRECTIONS 10

/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
ATTRIBUTE_ALIGNED16(class)
btConvexShape : public btCollisionShape
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexShape();

	virtual ~btConvexShape();

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const = 0;

////////
#ifndef __SPU__
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const = 0;
#endif  //#ifndef __SPU__

	btVector3 localGetSupportVertexWithoutMarginNonVirtual(const btVector3& vec) const;
	btVector3 localGetSupportVertexNonVirtual(const btVector3& vec) const;
	btScalar getMarginNonVirtual() const;
	void getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;

	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const = 0;

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;

	virtual void setMargin(btScalar margin) = 0;

	virtual btScalar getMargin() const = 0;

	virtual int getNumPreferredPenetrationDirections() const = 0;

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const = 0;
};

#endif  //BT_CONVEX_SHAPE_INTERFACE1





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_AABB_UTIL2
#define BT_AABB_UTIL2

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

SIMD_FORCE_INLINE void AabbExpand(btVector3& aabbMin,
								  btVector3& aabbMax,
								  const btVector3& expansionMin,
								  const btVector3& expansionMax)
{
	aabbMin = aabbMin + expansionMin;
	aabbMax = aabbMax + expansionMax;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestPointAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											 const btVector3& point)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > point.getX() || aabbMax1.getX() < point.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > point.getZ() || aabbMax1.getZ() < point.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > point.getY() || aabbMax1.getY() < point.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestAabbAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											const btVector3& aabbMin2, const btVector3& aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > aabbMax2.getX() || aabbMax1.getX() < aabbMin2.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > aabbMax2.getZ() || aabbMax1.getZ() < aabbMin2.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > aabbMax2.getY() || aabbMax1.getY() < aabbMin2.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between triangle and aabb
SIMD_FORCE_INLINE bool TestTriangleAgainstAabb2(const btVector3* vertices,
												const btVector3& aabbMin, const btVector3& aabbMax)
{
	const btVector3& p1 = vertices[0];
	const btVector3& p2 = vertices[1];
	const btVector3& p3 = vertices[2];

	if (btMin(btMin(p1[0], p2[0]), p3[0]) > aabbMax[0]) return false;
	if (btMax(btMax(p1[0], p2[0]), p3[0]) < aabbMin[0]) return false;

	if (btMin(btMin(p1[2], p2[2]), p3[2]) > aabbMax[2]) return false;
	if (btMax(btMax(p1[2], p2[2]), p3[2]) < aabbMin[2]) return false;

	if (btMin(btMin(p1[1], p2[1]), p3[1]) > aabbMax[1]) return false;
	if (btMax(btMax(p1[1], p2[1]), p3[1]) < aabbMin[1]) return false;
	return true;
}

SIMD_FORCE_INLINE int btOutcode(const btVector3& p, const btVector3& halfExtent)
{
	return (p.getX() < -halfExtent.getX() ? 0x01 : 0x0) |
		   (p.getX() > halfExtent.getX() ? 0x08 : 0x0) |
		   (p.getY() < -halfExtent.getY() ? 0x02 : 0x0) |
		   (p.getY() > halfExtent.getY() ? 0x10 : 0x0) |
		   (p.getZ() < -halfExtent.getZ() ? 0x4 : 0x0) |
		   (p.getZ() > halfExtent.getZ() ? 0x20 : 0x0);
}

SIMD_FORCE_INLINE bool btRayAabb2(const btVector3& rayFrom,
								  const btVector3& rayInvDirection,
								  const unsigned int raySign[3],
								  const btVector3 bounds[2],
								  btScalar& tmin,
								  btScalar lambda_min,
								  btScalar lambda_max)
{
	btScalar tmax, tymin, tymax, tzmin, tzmax;
	tmin = (bounds[raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tmax = (bounds[1 - raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tymin = (bounds[raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();
	tymax = (bounds[1 - raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();

	if ((tmin > tymax) || (tymin > tmax))
		return false;

	if (tymin > tmin)
		tmin = tymin;

	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();
	tzmax = (bounds[1 - raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;
	return ((tmin < lambda_max) && (tmax > lambda_min));
}

SIMD_FORCE_INLINE bool btRayAabb(const btVector3& rayFrom,
								 const btVector3& rayTo,
								 const btVector3& aabbMin,
								 const btVector3& aabbMax,
								 btScalar& param, btVector3& normal)
{
	btVector3 aabbHalfExtent = (aabbMax - aabbMin) * btScalar(0.5);
	btVector3 aabbCenter = (aabbMax + aabbMin) * btScalar(0.5);
	btVector3 source = rayFrom - aabbCenter;
	btVector3 target = rayTo - aabbCenter;
	int sourceOutcode = btOutcode(source, aabbHalfExtent);
	int targetOutcode = btOutcode(target, aabbHalfExtent);
	if ((sourceOutcode & targetOutcode) == 0x0)
	{
		btScalar lambda_enter = btScalar(0.0);
		btScalar lambda_exit = param;
		btVector3 r = target - source;
		int i;
		btScalar normSign = 1;
		btVector3 hitNormal(0, 0, 0);
		int bit = 1;

		for (int j = 0; j < 2; j++)
		{
			for (i = 0; i != 3; ++i)
			{
				if (sourceOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					if (lambda_enter <= lambda)
					{
						lambda_enter = lambda;
						hitNormal.setValue(0, 0, 0);
						hitNormal[i] = normSign;
					}
				}
				else if (targetOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					btSetMin(lambda_exit, lambda);
				}
				bit <<= 1;
			}
			normSign = btScalar(-1.);
		}
		if (lambda_enter <= lambda_exit)
		{
			param = lambda_enter;
			normal = hitNormal;
			return true;
		}
	}
	return false;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& halfExtents, btScalar margin, const btTransform& t, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btVector3 halfExtentsWithMargin = halfExtents + btVector3(margin, margin, margin);
	btMatrix3x3 abs_b = t.getBasis().absolute();
	btVector3 center = t.getOrigin();
	btVector3 extent = halfExtentsWithMargin.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& localAabbMin, const btVector3& localAabbMax, btScalar margin, const btTransform& trans, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btAssert(localAabbMin.getX() <= localAabbMax.getX());
	btAssert(localAabbMin.getY() <= localAabbMax.getY());
	btAssert(localAabbMin.getZ() <= localAabbMax.getZ());
	btVector3 localHalfExtents = btScalar(0.5) * (localAabbMax - localAabbMin);
	localHalfExtents += btVector3(margin, margin, margin);

	btVector3 localCenter = btScalar(0.5) * (localAabbMax + localAabbMin);
	btMatrix3x3 abs_b = trans.getBasis().absolute();
	btVector3 center = trans(localCenter);
	btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

#define USE_BANCHLESS 1
#ifdef USE_BANCHLESS
//This block replaces the block below and uses no branches, and replaces the 8 bit return with a 32 bit return for improved performance (~3x on XBox 360)
SIMD_FORCE_INLINE unsigned testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	return static_cast<unsigned int>(btSelect((unsigned)((aabbMin1[0] <= aabbMax2[0]) & (aabbMax1[0] >= aabbMin2[0]) & (aabbMin1[2] <= aabbMax2[2]) & (aabbMax1[2] >= aabbMin2[2]) & (aabbMin1[1] <= aabbMax2[1]) & (aabbMax1[1] >= aabbMin2[1])),
											  1, 0));
}
#else
SIMD_FORCE_INLINE bool testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1[0] > aabbMax2[0] || aabbMax1[0] < aabbMin2[0]) ? false : overlap;
	overlap = (aabbMin1[2] > aabbMax2[2] || aabbMax1[2] < aabbMin2[2]) ? false : overlap;
	overlap = (aabbMin1[1] > aabbMax2[1] || aabbMax1[1] < aabbMin2[1]) ? false : overlap;
	return overlap;
}
#endif  //USE_BANCHLESS

#endif  //BT_AABB_UTIL2





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"

btConvexInternalShape::btConvexInternalShape()
	: m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.)),
	  m_collisionMargin(CONVEX_DISTANCE_MARGIN)
{
}

void btConvexInternalShape::setLocalScaling(const btVector3& scaling)
{
	m_localScaling = scaling.absolute();
}

void btConvexInternalShape::getAabbSlow(const btTransform& trans, btVector3& minAabb, btVector3& maxAabb) const
{
#ifndef __SPU__
	//use localGetSupportingVertexWithoutMargin?
	btScalar margin = getMargin();
	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);

		btVector3 sv = localGetSupportingVertex(vec * trans.getBasis());

		btVector3 tmp = trans(sv);
		maxAabb[i] = tmp[i] + margin;
		vec[i] = btScalar(-1.);
		tmp = trans(localGetSupportingVertex(vec * trans.getBasis()));
		minAabb[i] = tmp[i] - margin;
	}
#endif
}

btVector3 btConvexInternalShape::localGetSupportingVertex(const btVector3& vec) const
{
#ifndef __SPU__

	btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

	if (getMargin() != btScalar(0.))
	{
		btVector3 vecnorm = vec;
		if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
		{
			vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
		}
		vecnorm.normalize();
		supVertex += getMargin() * vecnorm;
	}
	return supVertex;

#else
	btAssert(0);
	return btVector3(0, 0, 0);
#endif  //__SPU__
}

btConvexInternalAabbCachingShape::btConvexInternalAabbCachingShape()
	: btConvexInternalShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btConvexInternalAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btConvexInternalAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

void btConvexInternalAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i] + m_collisionMargin;
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i] - m_collisionMargin;
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_INTERNAL_SHAPE_H
#define BT_CONVEX_INTERNAL_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btAabbUtil2.h"

///The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
///The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
///This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
///Note that when creating small shapes (derived from btConvexInternalShape),
///you need to make sure to set a smaller collision margin, using the 'setMargin' API
///There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
ATTRIBUTE_ALIGNED16(class)
btConvexInternalShape : public btConvexShape
{
protected:
	//local scaling. collisionMargin is not scaled !
	btVector3 m_localScaling;

	btVector3 m_implicitShapeDimensions;

	btScalar m_collisionMargin;

	btScalar m_padding;

	btConvexInternalShape();

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btConvexInternalShape()
	{
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;

	const btVector3& getImplicitShapeDimensions() const
	{
		return m_implicitShapeDimensions;
	}

	///warning: use setImplicitShapeDimensions with care
	///changing a collision shape while the body is in the world is not recommended,
	///it is best to remove the body from the world, then make the change, and re-add it
	///alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'
	void setImplicitShapeDimensions(const btVector3& dimensions)
	{
		m_implicitShapeDimensions = dimensions;
	}

	void setSafeMargin(btScalar minDimension, btScalar defaultMarginMultiplier = 0.1f)
	{
		btScalar safeMargin = defaultMarginMultiplier * minDimension;
		if (safeMargin < getMargin())
		{
			setMargin(safeMargin);
		}
	}
	void setSafeMargin(const btVector3& halfExtents, btScalar defaultMarginMultiplier = 0.1f)
	{
		//see http://code.google.com/p/bullet/issues/detail?id=349
		//this margin check could could be added to other collision shapes too,
		//or add some assert/warning somewhere
		btScalar minDimension = halfExtents[halfExtents.minAxis()];
		setSafeMargin(minDimension, defaultMarginMultiplier);
	}

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		getAabbSlow(t, aabbMin, aabbMax);
	}

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void setLocalScaling(const btVector3& scaling);
	virtual const btVector3& getLocalScaling() const
	{
		return m_localScaling;
	}

	const btVector3& getLocalScalingNV() const
	{
		return m_localScaling;
	}

	virtual void setMargin(btScalar margin)
	{
		m_collisionMargin = margin;
	}
	virtual btScalar getMargin() const
	{
		return m_collisionMargin;
	}

	btScalar getMarginNV() const
	{
		return m_collisionMargin;
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 0;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		(void)penetrationVector;
		(void)index;
		btAssert(0);
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btConvexInternalShapeData
{
	btCollisionShapeData m_collisionShapeData;

	btVector3FloatData m_localScaling;

	btVector3FloatData m_implicitShapeDimensions;

	float m_collisionMargin;

	int m_padding;
};

SIMD_FORCE_INLINE int btConvexInternalShape::calculateSerializeBufferSize() const
{
	return sizeof(btConvexInternalShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btConvexInternalShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btConvexInternalShapeData* shapeData = (btConvexInternalShapeData*)dataBuffer;
	btCollisionShape::serialize(&shapeData->m_collisionShapeData, serializer);

	m_implicitShapeDimensions.serializeFloat(shapeData->m_implicitShapeDimensions);
	m_localScaling.serializeFloat(shapeData->m_localScaling);
	shapeData->m_collisionMargin = float(m_collisionMargin);

	// Fill padding with zeros to appease msan.
	shapeData->m_padding = 0;

	return "btConvexInternalShapeData";
}

///btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
class btConvexInternalAabbCachingShape : public btConvexInternalShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	btConvexInternalAabbCachingShape();

	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

public:
	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_CONVEX_INTERNAL_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"

btVector3 btSphereShape::localGetSupportingVertexWithoutMargin(const btVector3& vec) const
{
	(void)vec;
	return btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
}

void btSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	(void)vectors;

	for (int i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i].setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	}
}

btVector3 btSphereShape::localGetSupportingVertex(const btVector3& vec) const
{
	btVector3 supVertex;
	supVertex = localGetSupportingVertexWithoutMargin(vec);

	btVector3 vecnorm = vec;
	if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	vecnorm.normalize();
	supVertex += getMargin() * vecnorm;
	return supVertex;
}

//broken due to scaling
void btSphereShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	const btVector3& center = t.getOrigin();
	btVector3 extent(getMargin(), getMargin(), getMargin());
	aabbMin = center - extent;
	aabbMax = center + extent;
}

void btSphereShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	btScalar elem = btScalar(0.4) * mass * getMargin() * getMargin();
	inertia.setValue(elem, elem, elem);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#ifndef BT_SPHERE_MINKOWSKI_H
#define BT_SPHERE_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btSphereShape implements an implicit sphere, centered around a local origin with radius.
ATTRIBUTE_ALIGNED16(class)
btSphereShape : public btConvexInternalShape

{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btSphereShape(btScalar radius) : btConvexInternalShape()
	{
		m_shapeType = SPHERE_SHAPE_PROXYTYPE;
		m_localScaling.setValue(1.0, 1.0, 1.0);
		m_implicitShapeDimensions.setZero();
		m_implicitShapeDimensions.setX(radius);
		m_collisionMargin = radius;
		m_padding = 0;
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	btScalar getRadius() const { return m_implicitShapeDimensions.getX() * m_localScaling.getX(); }

	void setUnscaledRadius(btScalar radius)
	{
		m_implicitShapeDimensions.setX(radius);
		btConvexInternalShape::setMargin(radius);
	}

	//debugging
	virtual const char* getName() const { return "SPHERE"; }

	virtual void setMargin(btScalar margin)
	{
		btConvexInternalShape::setMargin(margin);
	}
	virtual btScalar getMargin() const
	{
		//to improve gjk behaviour, use radius+margin as the full margin, so never get into the penetration case
		//this means, non-uniform scaling is not supported anymore
		return getRadius();
	}
};

#endif  //BT_SPHERE_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btGeometryUtil.h"
#include "LinearMath/btGrahamScan2dConvexHull.h"

btPolyhedralConvexShape::btPolyhedralConvexShape() : btConvexInternalShape(),
													 m_polyhedron(0)
{
}

btPolyhedralConvexShape::~btPolyhedralConvexShape()
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}
}

void btPolyhedralConvexShape::setPolyhedralFeatures(btConvexPolyhedron& polyhedron)
{
	if (m_polyhedron)
	{
		*m_polyhedron = polyhedron;
	}
	else
	{
		void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
		m_polyhedron = new (mem) btConvexPolyhedron(polyhedron);
	}
}

bool btPolyhedralConvexShape::initializePolyhedralFeatures(int shiftVerticesByMargin)
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}

	void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
	m_polyhedron = new (mem) btConvexPolyhedron;

	btAlignedObjectArray<btVector3> orgVertices;

	for (int i = 0; i < getNumVertices(); i++)
	{
		btVector3& newVertex = orgVertices.expand();
		getVertex(i, newVertex);
	}

	btConvexHullComputer conv;

	if (shiftVerticesByMargin)
	{
		btAlignedObjectArray<btVector3> planeEquations;
		btGeometryUtil::getPlaneEquationsFromVertices(orgVertices, planeEquations);

		btAlignedObjectArray<btVector3> shiftedPlaneEquations;
		for (int p = 0; p < planeEquations.size(); p++)
		{
			btVector3 plane = planeEquations[p];
			//	   btScalar margin = getMargin();
			plane[3] -= getMargin();
			shiftedPlaneEquations.push_back(plane);
		}

		btAlignedObjectArray<btVector3> tmpVertices;

		btGeometryUtil::getVerticesFromPlaneEquations(shiftedPlaneEquations, tmpVertices);

		conv.compute(&tmpVertices[0].getX(), sizeof(btVector3), tmpVertices.size(), 0.f, 0.f);
	}
	else
	{
		conv.compute(&orgVertices[0].getX(), sizeof(btVector3), orgVertices.size(), 0.f, 0.f);
	}

#ifndef BT_RECONSTRUCT_FACES

	int numVertices = conv.vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = conv.vertices[p];
	}

	int v0, v1;
	for (int j = 0; j < conv.faces.size(); j++)
	{
		btVector3 edges[3];
		int numEdges = 0;
		btFace combinedFace;
		const btConvexHullComputer::Edge* edge = &conv.edges[conv.faces[j]];
		v0 = edge->getSourceVertex();
		int prevVertex = v0;
		combinedFace.m_indices.push_back(v0);
		v1 = edge->getTargetVertex();
		while (v1 != v0)
		{
			btVector3 wa = conv.vertices[prevVertex];
			btVector3 wb = conv.vertices[v1];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			//face->addIndex(v1);
			combinedFace.m_indices.push_back(v1);
			edge = edge->getNextEdgeOfFace();
			prevVertex = v1;
			int v01 = edge->getSourceVertex();
			v1 = edge->getTargetVertex();
		}

		btAssert(combinedFace.m_indices.size() > 2);

		btVector3 faceNormal = edges[0].cross(edges[1]);
		faceNormal.normalize();

		btScalar planeEq = 1e30f;

		for (int v = 0; v < combinedFace.m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[combinedFace.m_indices[v]].dot(faceNormal);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		combinedFace.m_plane[0] = faceNormal.getX();
		combinedFace.m_plane[1] = faceNormal.getY();
		combinedFace.m_plane[2] = faceNormal.getZ();
		combinedFace.m_plane[3] = -planeEq;

		m_polyhedron->m_faces.push_back(combinedFace);
	}

#else  //BT_RECONSTRUCT_FACES

	btAlignedObjectArray<btVector3> faceNormals;
	int numFaces = conv.faces.size();
	faceNormals.resize(numFaces);
	btConvexHullComputer* convexUtil = &conv;

	btAlignedObjectArray<btFace> tmpFaces;
	tmpFaces.resize(numFaces);

	int numVertices = convexUtil->vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = convexUtil->vertices[p];
	}

	for (int i = 0; i < numFaces; i++)
	{
		int face = convexUtil->faces[i];
		//printf("face=%d\n",face);
		const btConvexHullComputer::Edge* firstEdge = &convexUtil->edges[face];
		const btConvexHullComputer::Edge* edge = firstEdge;

		btVector3 edges[3];
		int numEdges = 0;
		//compute face normals

		do
		{
			int src = edge->getSourceVertex();
			tmpFaces[i].m_indices.push_back(src);
			int targ = edge->getTargetVertex();
			btVector3 wa = convexUtil->vertices[src];

			btVector3 wb = convexUtil->vertices[targ];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			edge = edge->getNextEdgeOfFace();
		} while (edge != firstEdge);

		btScalar planeEq = 1e30f;

		if (numEdges == 2)
		{
			faceNormals[i] = edges[0].cross(edges[1]);
			faceNormals[i].normalize();
			tmpFaces[i].m_plane[0] = faceNormals[i].getX();
			tmpFaces[i].m_plane[1] = faceNormals[i].getY();
			tmpFaces[i].m_plane[2] = faceNormals[i].getZ();
			tmpFaces[i].m_plane[3] = planeEq;
		}
		else
		{
			btAssert(0);  //degenerate?
			faceNormals[i].setZero();
		}

		for (int v = 0; v < tmpFaces[i].m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[tmpFaces[i].m_indices[v]].dot(faceNormals[i]);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		tmpFaces[i].m_plane[3] = -planeEq;
	}

	//merge coplanar faces and copy them to m_polyhedron

	btScalar faceWeldThreshold = 0.999f;
	btAlignedObjectArray<int> todoFaces;
	for (int i = 0; i < tmpFaces.size(); i++)
		todoFaces.push_back(i);

	while (todoFaces.size())
	{
		btAlignedObjectArray<int> coplanarFaceGroup;
		int refFace = todoFaces[todoFaces.size() - 1];

		coplanarFaceGroup.push_back(refFace);
		btFace& faceA = tmpFaces[refFace];
		todoFaces.pop_back();

		btVector3 faceNormalA(faceA.m_plane[0], faceA.m_plane[1], faceA.m_plane[2]);
		for (int j = todoFaces.size() - 1; j >= 0; j--)
		{
			int i = todoFaces[j];
			btFace& faceB = tmpFaces[i];
			btVector3 faceNormalB(faceB.m_plane[0], faceB.m_plane[1], faceB.m_plane[2]);
			if (faceNormalA.dot(faceNormalB) > faceWeldThreshold)
			{
				coplanarFaceGroup.push_back(i);
				todoFaces.remove(i);
			}
		}

		bool did_merge = false;
		if (coplanarFaceGroup.size() > 1)
		{
			//do the merge: use Graham Scan 2d convex hull

			btAlignedObjectArray<GrahamVector3> orgpoints;
			btVector3 averageFaceNormal(0, 0, 0);

			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				//				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);

				btFace& face = tmpFaces[coplanarFaceGroup[i]];
				btVector3 faceNormal(face.m_plane[0], face.m_plane[1], face.m_plane[2]);
				averageFaceNormal += faceNormal;
				for (int f = 0; f < face.m_indices.size(); f++)
				{
					int orgIndex = face.m_indices[f];
					btVector3 pt = m_polyhedron->m_vertices[orgIndex];

					bool found = false;

					for (int i = 0; i < orgpoints.size(); i++)
					{
						//if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
						if (orgpoints[i].m_orgIndex == orgIndex)
						{
							found = true;
							break;
						}
					}
					if (!found)
						orgpoints.push_back(GrahamVector3(pt, orgIndex));
				}
			}

			btFace combinedFace;
			for (int i = 0; i < 4; i++)
				combinedFace.m_plane[i] = tmpFaces[coplanarFaceGroup[0]].m_plane[i];

			btAlignedObjectArray<GrahamVector3> hull;

			averageFaceNormal.normalize();
			GrahamScanConvexHull2D(orgpoints, hull, averageFaceNormal);

			for (int i = 0; i < hull.size(); i++)
			{
				combinedFace.m_indices.push_back(hull[i].m_orgIndex);
				for (int k = 0; k < orgpoints.size(); k++)
				{
					if (orgpoints[k].m_orgIndex == hull[i].m_orgIndex)
					{
						orgpoints[k].m_orgIndex = -1;  // invalidate...
						break;
					}
				}
			}

			// are there rejected vertices?
			bool reject_merge = false;

			for (int i = 0; i < orgpoints.size(); i++)
			{
				if (orgpoints[i].m_orgIndex == -1)
					continue;  // this is in the hull...
				// this vertex is rejected -- is anybody else using this vertex?
				for (int j = 0; j < tmpFaces.size(); j++)
				{
					btFace& face = tmpFaces[j];
					// is this a face of the current coplanar group?
					bool is_in_current_group = false;
					for (int k = 0; k < coplanarFaceGroup.size(); k++)
					{
						if (coplanarFaceGroup[k] == j)
						{
							is_in_current_group = true;
							break;
						}
					}
					if (is_in_current_group)  // ignore this face...
						continue;
					// does this face use this rejected vertex?
					for (int v = 0; v < face.m_indices.size(); v++)
					{
						if (face.m_indices[v] == orgpoints[i].m_orgIndex)
						{
							// this rejected vertex is used in another face -- reject merge
							reject_merge = true;
							break;
						}
					}
					if (reject_merge)
						break;
				}
				if (reject_merge)
					break;
			}

			if (!reject_merge)
			{
				// do this merge!
				did_merge = true;
				m_polyhedron->m_faces.push_back(combinedFace);
			}
		}
		if (!did_merge)
		{
			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				btFace face = tmpFaces[coplanarFaceGroup[i]];
				m_polyhedron->m_faces.push_back(face);
			}
		}
	}

#endif  //BT_RECONSTRUCT_FACES

	m_polyhedron->initialize();

	return true;
}

#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#endif

btVector3 btPolyhedralConvexShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);
#ifndef __SPU__
	int i;
	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	for (int k = 0; k < getNumVertices(); k += 128)
	{
		btVector3 temp[128];
		int inner_count = MIN(getNumVertices() - k, 128);
		for (i = 0; i < inner_count; i++)
			getVertex(i, temp[i]);
		i = (int)vec.maxDot(temp, inner_count, newDot);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = temp[i];
		}
	}

#endif  //__SPU__
	return supVec;
}

void btPolyhedralConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
#ifndef __SPU__
	int i;

	btVector3 vtx;
	btScalar newDot;

	for (i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
	}

	for (int j = 0; j < numVectors; j++)
	{
		const btVector3& vec = vectors[j];

		for (int k = 0; k < getNumVertices(); k += 128)
		{
			btVector3 temp[128];
			int inner_count = MIN(getNumVertices() - k, 128);
			for (i = 0; i < inner_count; i++)
				getVertex(i, temp[i]);
			i = (int)vec.maxDot(temp, inner_count, newDot);
			if (newDot > supportVerticesOut[j][3])
			{
				supportVerticesOut[j] = temp[i];
				supportVerticesOut[j][3] = newDot;
			}
		}
	}

#endif  //__SPU__
}

void btPolyhedralConvexShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
#ifndef __SPU__
	//not yet, return box inertia

	btScalar margin = getMargin();

	btTransform ident;
	ident.setIdentity();
	btVector3 aabbMin, aabbMax;
	getAabb(ident, aabbMin, aabbMax);
	btVector3 halfExtents = (aabbMax - aabbMin) * btScalar(0.5);

	btScalar lx = btScalar(2.) * (halfExtents.x() + margin);
	btScalar ly = btScalar(2.) * (halfExtents.y() + margin);
	btScalar lz = btScalar(2.) * (halfExtents.z() + margin);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(0.08333333);

	inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));
#endif  //__SPU__
}

void btPolyhedralConvexAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

btPolyhedralConvexAabbCachingShape::btPolyhedralConvexAabbCachingShape()
	: btPolyhedralConvexShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btPolyhedralConvexAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btPolyhedralConvexAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i];
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i];
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_POLYHEDRAL_CONVEX_SHAPE_H
#define BT_POLYHEDRAL_CONVEX_SHAPE_H

#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
class btConvexPolyhedron;

///The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
ATTRIBUTE_ALIGNED16(class)
btPolyhedralConvexShape : public btConvexInternalShape
{
protected:
	btConvexPolyhedron* m_polyhedron;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btPolyhedralConvexShape();

	virtual ~btPolyhedralConvexShape();

	///optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
	///experimental/work-in-progress
	virtual bool initializePolyhedralFeatures(int shiftVerticesByMargin = 0);

	virtual void setPolyhedralFeatures(btConvexPolyhedron & polyhedron);

	const btConvexPolyhedron* getConvexPolyhedron() const
	{
		return m_polyhedron;
	}

	//brute force implementations

	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual int getNumVertices() const = 0;
	virtual int getNumEdges() const = 0;
	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const = 0;
	virtual void getVertex(int i, btVector3& vtx) const = 0;
	virtual int getNumPlanes() const = 0;
	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const = 0;
	//	virtual int getIndex(int i) const = 0 ;

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const = 0;
};

///The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
class btPolyhedralConvexAabbCachingShape : public btPolyhedralConvexShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

protected:
	btPolyhedralConvexAabbCachingShape();

public:
	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_POLYHEDRAL_CONVEX_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btBoxShape.h"

btBoxShape::btBoxShape(const btVector3& boxHalfExtents)
	: btPolyhedralConvexShape()
{
	m_shapeType = BOX_SHAPE_PROXYTYPE;

	btVector3 margin(getMargin(), getMargin(), getMargin());
	m_implicitShapeDimensions = (boxHalfExtents * m_localScaling) - margin;

	setSafeMargin(boxHalfExtents);
};

void btBoxShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}

void btBoxShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//btScalar margin = btScalar(0.);
	btVector3 halfExtents = getHalfExtentsWithMargin();

	btScalar lx = btScalar(2.) * (halfExtents.x());
	btScalar ly = btScalar(2.) * (halfExtents.y());
	btScalar lz = btScalar(2.) * (halfExtents.z());

	inertia.setValue(mass / (btScalar(12.0)) * (ly * ly + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + ly * ly));
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBB_BOX_MINKOWSKI_H
#define BT_OBB_BOX_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

///The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
ATTRIBUTE_ALIGNED16(class)
btBoxShape : public btPolyhedralConvexShape
{
	//btVector3	m_boxHalfExtents1; //use m_implicitShapeDimensions instead

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btVector3 getHalfExtentsWithMargin() const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;
		return halfExtents;
	}

	const btVector3& getHalfExtentsWithoutMargin() const
	{
		return m_implicitShapeDimensions;  //scaling is included, margin is not
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	SIMD_FORCE_INLINE btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		for (int i = 0; i < numVectors; i++)
		{
			const btVector3& vec = vectors[i];
			supportVerticesOut[i].setValue(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
										   btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
										   btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
		}
	}

	btBoxShape(const btVector3& boxHalfExtents);

	virtual void setMargin(btScalar collisionMargin)
	{
		//correct the m_implicitShapeDimensions for the margin
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;

		btConvexInternalShape::setMargin(collisionMargin);
		btVector3 newMargin(getMargin(), getMargin(), getMargin());
		m_implicitShapeDimensions = implicitShapeDimensionsWithMargin - newMargin;
	}
	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;
		btVector3 unScaledImplicitShapeDimensionsWithMargin = implicitShapeDimensionsWithMargin / m_localScaling;

		btConvexInternalShape::setLocalScaling(scaling);

		m_implicitShapeDimensions = (unScaledImplicitShapeDimensionsWithMargin * m_localScaling) - oldMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const
	{
		//this plane might not be aligned...
		btVector4 plane;
		getPlaneEquation(plane, i);
		planeNormal = btVector3(plane.getX(), plane.getY(), plane.getZ());
		planeSupport = localGetSupportingVertex(-planeNormal);
	}

	virtual int getNumPlanes() const
	{
		return 6;
	}

	virtual int getNumVertices() const
	{
		return 8;
	}

	virtual int getNumEdges() const
	{
		return 12;
	}

	virtual void getVertex(int i, btVector3& vtx) const
	{
		btVector3 halfExtents = getHalfExtentsWithMargin();

		vtx = btVector3(
			halfExtents.x() * (1 - (i & 1)) - halfExtents.x() * (i & 1),
			halfExtents.y() * (1 - ((i & 2) >> 1)) - halfExtents.y() * ((i & 2) >> 1),
			halfExtents.z() * (1 - ((i & 4) >> 2)) - halfExtents.z() * ((i & 4) >> 2));
	}

	virtual void getPlaneEquation(btVector4 & plane, int i) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		switch (i)
		{
			case 0:
				plane.setValue(btScalar(1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 1:
				plane.setValue(btScalar(-1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 2:
				plane.setValue(btScalar(0.), btScalar(1.), btScalar(0.), -halfExtents.y());
				break;
			case 3:
				plane.setValue(btScalar(0.), btScalar(-1.), btScalar(0.), -halfExtents.y());
				break;
			case 4:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(1.), -halfExtents.z());
				break;
			case 5:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(-1.), -halfExtents.z());
				break;
			default:
				btAssert(0);
		}
	}

	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const
	//virtual void getEdge(int i,Edge& edge) const
	{
		int edgeVert0 = 0;
		int edgeVert1 = 0;

		switch (i)
		{
			case 0:
				edgeVert0 = 0;
				edgeVert1 = 1;
				break;
			case 1:
				edgeVert0 = 0;
				edgeVert1 = 2;
				break;
			case 2:
				edgeVert0 = 1;
				edgeVert1 = 3;

				break;
			case 3:
				edgeVert0 = 2;
				edgeVert1 = 3;
				break;
			case 4:
				edgeVert0 = 0;
				edgeVert1 = 4;
				break;
			case 5:
				edgeVert0 = 1;
				edgeVert1 = 5;

				break;
			case 6:
				edgeVert0 = 2;
				edgeVert1 = 6;
				break;
			case 7:
				edgeVert0 = 3;
				edgeVert1 = 7;
				break;
			case 8:
				edgeVert0 = 4;
				edgeVert1 = 5;
				break;
			case 9:
				edgeVert0 = 4;
				edgeVert1 = 6;
				break;
			case 10:
				edgeVert0 = 5;
				edgeVert1 = 7;
				break;
			case 11:
				edgeVert0 = 6;
				edgeVert1 = 7;
				break;
			default:
				btAssert(0);
		}

		getVertex(edgeVert0, pa);
		getVertex(edgeVert1, pb);
	}

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		//btScalar minDist = 2*tolerance;

		bool result = (pt.x() <= (halfExtents.x() + tolerance)) &&
					  (pt.x() >= (-halfExtents.x() - tolerance)) &&
					  (pt.y() <= (halfExtents.y() + tolerance)) &&
					  (pt.y() >= (-halfExtents.y() - tolerance)) &&
					  (pt.z() <= (halfExtents.z() + tolerance)) &&
					  (pt.z() >= (-halfExtents.z() - tolerance));

		return result;
	}

	//debugging
	virtual const char* getName() const
	{
		return "Box";
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 6;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		switch (index)
		{
			case 0:
				penetrationVector.setValue(btScalar(1.), btScalar(0.), btScalar(0.));
				break;
			case 1:
				penetrationVector.setValue(btScalar(-1.), btScalar(0.), btScalar(0.));
				break;
			case 2:
				penetrationVector.setValue(btScalar(0.), btScalar(1.), btScalar(0.));
				break;
			case 3:
				penetrationVector.setValue(btScalar(0.), btScalar(-1.), btScalar(0.));
				break;
			case 4:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(1.));
				break;
			case 5:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(-1.));
				break;
			default:
				btAssert(0);
		}
	}
};

#endif  //BT_OBB_BOX_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBJECT_ARRAY__
#define BT_OBJECT_ARRAY__

#include "LinearMath/btScalar.h"
#include "LinearMath/btAlignedAllocator.h"

///If the platform doesn't support placement new, you can disable BT_USE_PLACEMENT_NEW
///then the btAlignedObjectArray doesn't support objects with virtual methods, and non-trivial constructors/destructors
///You can enable BT_USE_MEMCPY, then swapping elements in the array will use memcpy instead of operator=
///see discussion here: https://bulletphysics.orgphpBB2/viewtopic.php?t=1231 and
///http://www.continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=1240

#define BT_USE_PLACEMENT_NEW 1
//#define BT_USE_MEMCPY 1 //disable, because it is cumbersome to find out for each platform where memcpy is defined. It can be in <memory.h> or <string.h> or otherwise...
#define BT_ALLOW_ARRAY_COPY_OPERATOR  // enabling this can accidently perform deep copies of data if you are not careful

#ifdef BT_USE_MEMCPY
#endif  //BT_USE_MEMCPY

#ifdef BT_USE_PLACEMENT_NEW
#endif          //BT_USE_PLACEMENT_NEW

///The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
///It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
template <typename T>
//template <class T>
class btAlignedObjectArray
{
	btAlignedAllocator<T, 16> m_allocator;

	int m_size;
	int m_capacity;
	T* m_data;
	//PCK: added this line
	bool m_ownsMemory;

#ifdef BT_ALLOW_ARRAY_COPY_OPERATOR
public:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other)
	{
		copyFromArray(other);
		return *this;
	}
#else   //BT_ALLOW_ARRAY_COPY_OPERATOR
private:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other);
#endif  //BT_ALLOW_ARRAY_COPY_OPERATOR

protected:
	SIMD_FORCE_INLINE int allocSize(int size)
	{
		return (size ? size * 2 : 1);
	}
	SIMD_FORCE_INLINE void copy(int start, int end, T* dest) const
	{
		int i;
		for (i = start; i < end; ++i)
#ifdef BT_USE_PLACEMENT_NEW
			new (&dest[i]) T(m_data[i]);
#else
			dest[i] = m_data[i];
#endif  //BT_USE_PLACEMENT_NEW
	}

	SIMD_FORCE_INLINE void init()
	{
		//PCK: added this line
		m_ownsMemory = true;
		m_data = 0;
		m_size = 0;
		m_capacity = 0;
	}
	SIMD_FORCE_INLINE void destroy(int first, int last)
	{
		int i;
		for (i = first; i < last; i++)
		{
			m_data[i].~T();
		}
	}

	SIMD_FORCE_INLINE void* allocate(int size)
	{
		if (size)
			return m_allocator.allocate(size);
		return 0;
	}

	SIMD_FORCE_INLINE void deallocate()
	{
		if (m_data)
		{
			//PCK: enclosed the deallocation in this block
			if (m_ownsMemory)
			{
				m_allocator.deallocate(m_data);
			}
			m_data = 0;
		}
	}

public:
	btAlignedObjectArray()
	{
		init();
	}

	~btAlignedObjectArray()
	{
		clear();
	}

	///Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead.
	btAlignedObjectArray(const btAlignedObjectArray& otherArray)
	{
		init();

		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}

	/// return the number of elements in the array
	SIMD_FORCE_INLINE int size() const
	{
		return m_size;
	}

	SIMD_FORCE_INLINE const T& at(int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& at(int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE const T& operator[](int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& operator[](int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	///clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void clear()
	{
		destroy(0, size());

		deallocate();

		init();
	}

	SIMD_FORCE_INLINE void pop_back()
	{
		btAssert(m_size > 0);
		m_size--;
		m_data[m_size].~T();
	}

	///resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	///when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void resizeNoInitialize(int newsize)
	{
		if (newsize > size())
		{
			reserve(newsize);
		}
		m_size = newsize;
	}

	SIMD_FORCE_INLINE void resize(int newsize, const T& fillData = T())
	{
		const int curSize = size();

		if (newsize < curSize)
		{
			for (int i = newsize; i < curSize; i++)
			{
				m_data[i].~T();
			}
		}
		else
		{
			if (newsize > curSize)
			{
				reserve(newsize);
			}
#ifdef BT_USE_PLACEMENT_NEW
			for (int i = curSize; i < newsize; i++)
			{
				new (&m_data[i]) T(fillData);
			}
#endif  //BT_USE_PLACEMENT_NEW
		}

		m_size = newsize;
	}
	SIMD_FORCE_INLINE T& expandNonInitializing()
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;

		return m_data[sz];
	}

	SIMD_FORCE_INLINE T& expand(const T& fillValue = T())
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;
#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[sz]) T(fillValue);  //use the in-place new (not really allocating heap memory)
#endif

		return m_data[sz];
	}

	SIMD_FORCE_INLINE void push_back(const T& _Val)
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}

#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[m_size]) T(_Val);
#else
		m_data[size()] = _Val;
#endif  //BT_USE_PLACEMENT_NEW

		m_size++;
	}

	/// return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve()
	SIMD_FORCE_INLINE int capacity() const
	{
		return m_capacity;
	}

	SIMD_FORCE_INLINE void reserve(int _Count)
	{  // determine new minimum length of allocated storage
		if (capacity() < _Count)
		{  // not enough room, reallocate
			T* s = (T*)allocate(_Count);

			copy(0, size(), s);

			destroy(0, size());

			deallocate();

			//PCK: added this line
			m_ownsMemory = true;

			m_data = s;

			m_capacity = _Count;
		}
	}

	class less
	{
	public:
		bool operator()(const T& a, const T& b) const
		{
			return (a < b);
		}
	};

	template <typename L>
	void quickSortInternal(const L& CompareFunc, int lo, int hi)
	{
		//  lo is the lower index, hi is the upper index
		//  of the region of array a that is to be sorted
		int i = lo, j = hi;
		T x = m_data[(lo + hi) / 2];

		//  partition
		do
		{
			while (CompareFunc(m_data[i], x))
				i++;
			while (CompareFunc(x, m_data[j]))
				j--;
			if (i <= j)
			{
				swap(i, j);
				i++;
				j--;
			}
		} while (i <= j);

		//  recursion
		if (lo < j)
			quickSortInternal(CompareFunc, lo, j);
		if (i < hi)
			quickSortInternal(CompareFunc, i, hi);
	}

	template <typename L>
	void quickSort(const L& CompareFunc)
	{
		//don't sort 0 or 1 elements
		if (size() > 1)
		{
			quickSortInternal(CompareFunc, 0, size() - 1);
		}
	}

	///heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/
	template <typename L>
	void downHeap(T* pArr, int k, int n, const L& CompareFunc)
	{
		/*  PRE: a[k+1..N] is a heap */
		/* POST:  a[k..N]  is a heap */

		T temp = pArr[k - 1];
		/* k has child(s) */
		while (k <= n / 2)
		{
			int child = 2 * k;

			if ((child < n) && CompareFunc(pArr[child - 1], pArr[child]))
			{
				child++;
			}
			/* pick larger child */
			if (CompareFunc(temp, pArr[child - 1]))
			{
				/* move child up */
				pArr[k - 1] = pArr[child - 1];
				k = child;
			}
			else
			{
				break;
			}
		}
		pArr[k - 1] = temp;
	} /*downHeap*/

	void swap(int index0, int index1)
	{
#ifdef BT_USE_MEMCPY
		char temp[sizeof(T)];
		memcpy(temp, &m_data[index0], sizeof(T));
		memcpy(&m_data[index0], &m_data[index1], sizeof(T));
		memcpy(&m_data[index1], temp, sizeof(T));
#else
		T temp = m_data[index0];
		m_data[index0] = m_data[index1];
		m_data[index1] = temp;
#endif  //BT_USE_PLACEMENT_NEW
	}

	template <typename L>
	void heapSort(const L& CompareFunc)
	{
		/* sort a[0..N-1],  N.B. 0 to N-1 */
		int k;
		int n = m_size;
		for (k = n / 2; k > 0; k--)
		{
			downHeap(m_data, k, n, CompareFunc);
		}

		/* a[1..N] is now a heap */
		while (n >= 1)
		{
			swap(0, n - 1); /* largest of a[0..n-1] */

			n = n - 1;
			/* restore a[1..i-1] heap */
			downHeap(m_data, 1, n, CompareFunc);
		}
	}

	///non-recursive binary search, assumes sorted array
	int findBinarySearch(const T& key) const
	{
		int first = 0;
		int last = size() - 1;

		//assume sorted array
		while (first <= last)
		{
			int mid = (first + last) / 2;  // compute mid point.
			if (key > m_data[mid])
				first = mid + 1;  // repeat search in top half.
			else if (key < m_data[mid])
				last = mid - 1;  // repeat search in bottom half.
			else
				return mid;  // found it. return position /////
		}
		return size();  // failed to find key
	}

	int findLinearSearch(const T& key) const
	{
		int index = size();
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	int findLinearSearch2(const T& key) const
	{
		int index = -1;
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	void removeAtIndex(int index)
	{
		if (index < size())
		{
			swap(index, size() - 1);
			pop_back();
		}
	}
	void remove(const T& key)
	{
		int findIndex = findLinearSearch(key);
		removeAtIndex(findIndex);
	}

	//PCK: whole function
	void initializeFromBuffer(void* buffer, int size, int capacity)
	{
		clear();
		m_ownsMemory = false;
		m_data = (T*)buffer;
		m_size = size;
		m_capacity = capacity;
	}

	void copyFromArray(const btAlignedObjectArray& otherArray)
	{
		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}
};

#endif  //BT_OBJECT_ARRAY__





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs

#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btHashMap.h"

btConvexPolyhedron::btConvexPolyhedron()
{
}
btConvexPolyhedron::~btConvexPolyhedron()
{
}

inline bool IsAlmostZero1(const btVector3& v)
{
	if (btFabs(v.x()) > 1e-6 || btFabs(v.y()) > 1e-6 || btFabs(v.z()) > 1e-6) return false;
	return true;
}

struct btInternalVertexPair
{
	btInternalVertexPair(short int v0, short int v1)
		: m_v0(v0),
		  m_v1(v1)
	{
		if (m_v1 > m_v0)
			btSwap(m_v0, m_v1);
	}
	short int m_v0;
	short int m_v1;
	int getHash() const
	{
		return m_v0 + (m_v1 << 16);
	}
	bool equals(const btInternalVertexPair& other) const
	{
		return m_v0 == other.m_v0 && m_v1 == other.m_v1;
	}
};

struct btInternalEdge
{
	btInternalEdge()
		: m_face0(-1),
		  m_face1(-1)
	{
	}
	short int m_face0;
	short int m_face1;
};

//

#ifdef TEST_INTERNAL_OBJECTS
bool btConvexPolyhedron::testContainment() const
{
	for (int p = 0; p < 8; p++)
	{
		btVector3 LocalPt;
		if (p == 0)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 1)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 2)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 3)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], -m_extents[2]);
		else if (p == 4)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 5)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 6)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 7)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], -m_extents[2]);

		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar d = LocalPt.dot(Normal) + m_faces[i].m_plane[3];
			if (d > 0.0f)
				return false;
		}
	}
	return true;
}
#endif

void btConvexPolyhedron::initialize()
{
	btHashMap<btInternalVertexPair, btInternalEdge> edges;

	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices;
		for (int j = 0; j < NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btVector3 edge = m_vertices[vp.m_v1] - m_vertices[vp.m_v0];
			edge.normalize();

			bool found = false;

			for (int p = 0; p < m_uniqueEdges.size(); p++)
			{
				if (IsAlmostZero1(m_uniqueEdges[p] - edge) ||
					IsAlmostZero1(m_uniqueEdges[p] + edge))
				{
					found = true;
					break;
				}
			}

			if (!found)
			{
				m_uniqueEdges.push_back(edge);
			}

			if (edptr)
			{
				btAssert(edptr->m_face0 >= 0);
				btAssert(edptr->m_face1 < 0);
				edptr->m_face1 = i;
			}
			else
			{
				btInternalEdge ed;
				ed.m_face0 = i;
				edges.insert(vp, ed);
			}
		}
	}

#ifdef USE_CONNECTED_FACES
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		m_faces[i].m_connectedFaces.resize(numVertices);

		for (int j = 0; j < numVertices; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btAssert(edptr);
			btAssert(edptr->m_face0 >= 0);
			btAssert(edptr->m_face1 >= 0);

			int connectedFace = (edptr->m_face0 == i) ? edptr->m_face1 : edptr->m_face0;
			m_faces[i].m_connectedFaces[j] = connectedFace;
		}
	}
#endif  //USE_CONNECTED_FACES

	initialize2();
}

void btConvexPolyhedron::initialize2()
{
	m_localCenter.setValue(0, 0, 0);
	btScalar TotalArea = 0.0f;
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices - 2;

		const btVector3& p0 = m_vertices[m_faces[i].m_indices[0]];
		for (int j = 1; j <= NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			const btVector3& p1 = m_vertices[m_faces[i].m_indices[j]];
			const btVector3& p2 = m_vertices[m_faces[i].m_indices[k]];
			btScalar Area = ((p0 - p1).cross(p0 - p2)).length() * 0.5f;
			btVector3 Center = (p0 + p1 + p2) / 3.0f;
			m_localCenter += Area * Center;
			TotalArea += Area;
		}
	}
	m_localCenter /= TotalArea;

#ifdef TEST_INTERNAL_OBJECTS
	if (1)
	{
		m_radius = FLT_MAX;
		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar dist = btFabs(m_localCenter.dot(Normal) + m_faces[i].m_plane[3]);
			if (dist < m_radius)
				m_radius = dist;
		}

		btScalar MinX = FLT_MAX;
		btScalar MinY = FLT_MAX;
		btScalar MinZ = FLT_MAX;
		btScalar MaxX = -FLT_MAX;
		btScalar MaxY = -FLT_MAX;
		btScalar MaxZ = -FLT_MAX;
		for (int i = 0; i < m_vertices.size(); i++)
		{
			const btVector3& pt = m_vertices[i];
			if (pt.x() < MinX) MinX = pt.x();
			if (pt.x() > MaxX) MaxX = pt.x();
			if (pt.y() < MinY) MinY = pt.y();
			if (pt.y() > MaxY) MaxY = pt.y();
			if (pt.z() < MinZ) MinZ = pt.z();
			if (pt.z() > MaxZ) MaxZ = pt.z();
		}
		mC.setValue(MaxX + MinX, MaxY + MinY, MaxZ + MinZ);
		mE.setValue(MaxX - MinX, MaxY - MinY, MaxZ - MinZ);

		//		const btScalar r = m_radius / sqrtf(2.0f);
		const btScalar r = m_radius / sqrtf(3.0f);
		const int LargestExtent = mE.maxAxis();
		const btScalar Step = (mE[LargestExtent] * 0.5f - r) / 1024.0f;
		m_extents[0] = m_extents[1] = m_extents[2] = r;
		m_extents[LargestExtent] = mE[LargestExtent] * 0.5f;
		bool FoundBox = false;
		for (int j = 0; j < 1024; j++)
		{
			if (testContainment())
			{
				FoundBox = true;
				break;
			}

			m_extents[LargestExtent] -= Step;
		}
		if (!FoundBox)
		{
			m_extents[0] = m_extents[1] = m_extents[2] = r;
		}
		else
		{
			// Refine the box
			const btScalar Step = (m_radius - r) / 1024.0f;
			const int e0 = (1 << LargestExtent) & 3;
			const int e1 = (1 << e0) & 3;

			for (int j = 0; j < 1024; j++)
			{
				const btScalar Saved0 = m_extents[e0];
				const btScalar Saved1 = m_extents[e1];
				m_extents[e0] += Step;
				m_extents[e1] += Step;

				if (!testContainment())
				{
					m_extents[e0] = Saved0;
					m_extents[e1] = Saved1;
					break;
				}
			}
		}
	}
#endif
}
void btConvexPolyhedron::project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	minProj = FLT_MAX;
	maxProj = -FLT_MAX;
	int numVerts = m_vertices.size();
	for (int i = 0; i < numVerts; i++)
	{
		btVector3 pt = trans * m_vertices[i];
		btScalar dp = pt.dot(dir);
		if (dp < minProj)
		{
			minProj = dp;
			witnesPtMin = pt;
		}
		if (dp > maxProj)
		{
			maxProj = dp;
			witnesPtMax = pt;
		}
	}
	if (minProj > maxProj)
	{
		btSwap(minProj, maxProj);
		btSwap(witnesPtMin, witnesPtMax);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans

#ifndef _BT_POLYHEDRAL_FEATURES_H
#define _BT_POLYHEDRAL_FEATURES_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btAlignedObjectArray.h"

#define TEST_INTERNAL_OBJECTS 1

struct btFace
{
	btAlignedObjectArray<int> m_indices;
	//	btAlignedObjectArray<int>	m_connectedFaces;
	btScalar m_plane[4];
};

ATTRIBUTE_ALIGNED16(class)
btConvexPolyhedron
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexPolyhedron();
	virtual ~btConvexPolyhedron();

	btAlignedObjectArray<btVector3> m_vertices;
	btAlignedObjectArray<btFace> m_faces;
	btAlignedObjectArray<btVector3> m_uniqueEdges;

	btVector3 m_localCenter;
	btVector3 m_extents;
	btScalar m_radius;
	btVector3 mC;
	btVector3 mE;

	void initialize();
	void initialize2();
	bool testContainment() const;

	void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;
};

#endif  //_BT_POLYHEDRAL_FEATURES_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btGeometryUtil.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletMathProbe();

	void btBulletMathProbe() {}
}

bool btGeometryUtil::isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		btScalar dist = btScalar(N1.dot(point)) + btScalar(N1[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool btGeometryUtil::areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin)
{
	int numvertices = vertices.size();
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];
		btScalar dist = btScalar(planeNormal.dot(N1)) + btScalar(planeNormal[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations);

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		if (planeEquation.dot(N1) > btScalar(0.999))
		{
			return false;
		}
	}
	return true;
}

void btGeometryUtil::getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut)
{
	const int numvertices = vertices.size();
	// brute force:
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];

		for (int j = i + 1; j < numvertices; j++)
		{
			const btVector3& N2 = vertices[j];

			for (int k = j + 1; k < numvertices; k++)
			{
				const btVector3& N3 = vertices[k];

				btVector3 planeEquation, edge0, edge1;
				edge0 = N2 - N1;
				edge1 = N3 - N1;
				btScalar normalSign = btScalar(1.);
				for (int ww = 0; ww < 2; ww++)
				{
					planeEquation = normalSign * edge0.cross(edge1);
					if (planeEquation.length2() > btScalar(0.0001))
					{
						planeEquation.normalize();
						if (notExist(planeEquation, planeEquationsOut))
						{
							planeEquation[3] = -planeEquation.dot(N1);

							//check if inside, and replace supportingVertexOut if needed
							if (areVerticesBehindPlane(planeEquation, vertices, btScalar(0.01)))
							{
								planeEquationsOut.push_back(planeEquation);
							}
						}
					}
					normalSign = btScalar(-1.);
				}
			}
		}
	}
}

void btGeometryUtil::getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut)
{
	const int numbrushes = planeEquations.size();
	// brute force:
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];

		for (int j = i + 1; j < numbrushes; j++)
		{
			const btVector3& N2 = planeEquations[j];

			for (int k = j + 1; k < numbrushes; k++)
			{
				const btVector3& N3 = planeEquations[k];

				btVector3 n2n3;
				n2n3 = N2.cross(N3);
				btVector3 n3n1;
				n3n1 = N3.cross(N1);
				btVector3 n1n2;
				n1n2 = N1.cross(N2);

				if ((n2n3.length2() > btScalar(0.0001)) &&
					(n3n1.length2() > btScalar(0.0001)) &&
					(n1n2.length2() > btScalar(0.0001)))
				{
					//point P out of 3 plane equations:

					//	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )
					//P =  -------------------------------------------------------------------------
					//   N1 . ( N2 * N3 )

					btScalar quotient = (N1.dot(n2n3));
					if (btFabs(quotient) > btScalar(0.000001))
					{
						quotient = btScalar(-1.) / quotient;
						n2n3 *= N1[3];
						n3n1 *= N2[3];
						n1n2 *= N3[3];
						btVector3 potentialVertex = n2n3;
						potentialVertex += n3n1;
						potentialVertex += n1n2;
						potentialVertex *= quotient;

						//check if inside, and replace supportingVertexOut if needed
						if (isPointInsidePlanes(planeEquations, potentialVertex, btScalar(0.01)))
						{
							verticesOut.push_back(potentialVertex);
						}
					}
				}
			}
		}
	}
}





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEOMETRY_UTIL_H
#define BT_GEOMETRY_UTIL_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

///The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
class btGeometryUtil
{
public:
	static void getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut);

	static void getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut);

	// static bool isInside(const btAlignedObjectArray<btVector3>& vertices, const btVector3& planeNormal, btScalar margin);

	static bool isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin);

	static bool areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin);
};

#endif  //BT_GEOMETRY_UTIL_H





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btVector3.h"

#ifdef __GNUC__
#elif defined(_MSC_VER)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
typedef int int32_t;
typedef long long int int64_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
#endif

//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif

//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS

#if defined(DEBUG_CONVEX_HULL) || defined(SHOW_ITERATIONS)
#endif

// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullInternal
{
public:
	class Point64
	{
	public:
		int64_t x;
		int64_t y;
		int64_t z;

		Point64(int64_t x, int64_t y, int64_t z) : x(x), y(y), z(z)
		{
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}
	};

	class Point32
	{
	public:
		int32_t x;
		int32_t y;
		int32_t z;
		int index;

		Point32()
		{
		}

		Point32(int32_t x, int32_t y, int32_t z) : x(x), y(y), z(z), index(-1)
		{
		}

		bool operator==(const Point32& b) const
		{
			return (x == b.x) && (y == b.y) && (z == b.z);
		}

		bool operator!=(const Point32& b) const
		{
			return (x != b.x) || (y != b.y) || (z != b.z);
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		Point64 cross(const Point32& b) const
		{
			return Point64(((int64_t)y) * b.z - ((int64_t)z) * b.y, ((int64_t)z) * b.x - ((int64_t)x) * b.z, ((int64_t)x) * b.y - ((int64_t)y) * b.x);
		}

		Point64 cross(const Point64& b) const
		{
			return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
		}

		int64_t dot(const Point32& b) const
		{
			return ((int64_t)x) * b.x + ((int64_t)y) * b.y + ((int64_t)z) * b.z;
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}

		Point32 operator+(const Point32& b) const
		{
			return Point32(x + b.x, y + b.y, z + b.z);
		}

		Point32 operator-(const Point32& b) const
		{
			return Point32(x - b.x, y - b.y, z - b.z);
		}
	};

	class Int128
	{
	public:
		uint64_t low;
		uint64_t high;

		Int128()
		{
		}

		Int128(uint64_t low, uint64_t high) : low(low), high(high)
		{
		}

		Int128(uint64_t low) : low(low), high(0)
		{
		}

		Int128(int64_t value) : low(value), high((value >= 0) ? 0 : (uint64_t)-1LL)
		{
		}

		static Int128 mul(int64_t a, int64_t b);

		static Int128 mul(uint64_t a, uint64_t b);

		Int128 operator-() const
		{
			return Int128((uint64_t) - (int64_t)low, ~high + (low == 0));
		}

		Int128 operator+(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			uint64_t lo = low + b.low;
			return Int128(lo, high + b.high + (lo < low));
#endif
		}

		Int128 operator-(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"subq %[bl], %[rl]\n\t"
				"sbbq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			return *this + -b;
#endif
		}

		Int128& operator+=(const Int128& b)
		{
#ifdef USE_X86_64_ASM
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(low), [rh] "=r"(high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
#else
			uint64_t lo = low + b.low;
			if (lo < low)
			{
				++high;
			}
			low = lo;
			high += b.high;
#endif
			return *this;
		}

		Int128& operator++()
		{
			if (++low == 0)
			{
				++high;
			}
			return *this;
		}

		Int128 operator*(int64_t b) const;

		btScalar toScalar() const
		{
			return ((int64_t)high >= 0) ? btScalar(high) * (btScalar(0x100000000LL) * btScalar(0x100000000LL)) + btScalar(low)
										: -(-*this).toScalar();
		}

		int getSign() const
		{
			return ((int64_t)high < 0) ? -1 : (high || low) ? 1 : 0;
		}

		bool operator<(const Int128& b) const
		{
			return (high < b.high) || ((high == b.high) && (low < b.low));
		}

		int ucmp(const Int128& b) const
		{
			if (high < b.high)
			{
				return -1;
			}
			if (high > b.high)
			{
				return 1;
			}
			if (low < b.low)
			{
				return -1;
			}
			if (low > b.low)
			{
				return 1;
			}
			return 0;
		}
	};

	class Rational64
	{
	private:
		uint64_t m_numerator;
		uint64_t m_denominator;
		int sign;

	public:
		Rational64(int64_t numerator, int64_t denominator)
		{
			if (numerator > 0)
			{
				sign = 1;
				m_numerator = (uint64_t)numerator;
			}
			else if (numerator < 0)
			{
				sign = -1;
				m_numerator = (uint64_t)-numerator;
			}
			else
			{
				sign = 0;
				m_numerator = 0;
			}
			if (denominator > 0)
			{
				m_denominator = (uint64_t)denominator;
			}
			else if (denominator < 0)
			{
				sign = -sign;
				m_denominator = (uint64_t)-denominator;
			}
			else
			{
				m_denominator = 0;
			}
		}

		bool isNegativeInfinity() const
		{
			return (sign < 0) && (m_denominator == 0);
		}

		bool isNaN() const
		{
			return (sign == 0) && (m_denominator == 0);
		}

		int compare(const Rational64& b) const;

		btScalar toScalar() const
		{
			return sign * ((m_denominator == 0) ? SIMD_INFINITY : (btScalar)m_numerator / m_denominator);
		}
	};

	class Rational128
	{
	private:
		Int128 numerator;
		Int128 denominator;
		int sign;
		bool isInt64;

	public:
		Rational128(int64_t value)
		{
			if (value > 0)
			{
				sign = 1;
				this->numerator = value;
			}
			else if (value < 0)
			{
				sign = -1;
				this->numerator = -value;
			}
			else
			{
				sign = 0;
				this->numerator = (uint64_t)0;
			}
			this->denominator = (uint64_t)1;
			isInt64 = true;
		}

		Rational128(const Int128& numerator, const Int128& denominator)
		{
			sign = numerator.getSign();
			if (sign >= 0)
			{
				this->numerator = numerator;
			}
			else
			{
				this->numerator = -numerator;
			}
			int dsign = denominator.getSign();
			if (dsign >= 0)
			{
				this->denominator = denominator;
			}
			else
			{
				sign = -sign;
				this->denominator = -denominator;
			}
			isInt64 = false;
		}

		int compare(const Rational128& b) const;

		int compare(int64_t b) const;

		btScalar toScalar() const
		{
			return sign * ((denominator.getSign() == 0) ? SIMD_INFINITY : numerator.toScalar() / denominator.toScalar());
		}
	};

	class PointR128
	{
	public:
		Int128 x;
		Int128 y;
		Int128 z;
		Int128 denominator;

		PointR128()
		{
		}

		PointR128(Int128 x, Int128 y, Int128 z, Int128 denominator) : x(x), y(y), z(z), denominator(denominator)
		{
		}

		btScalar xvalue() const
		{
			return x.toScalar() / denominator.toScalar();
		}

		btScalar yvalue() const
		{
			return y.toScalar() / denominator.toScalar();
		}

		btScalar zvalue() const
		{
			return z.toScalar() / denominator.toScalar();
		}
	};

	class Edge;
	class Face;

	class Vertex
	{
	public:
		Vertex* next;
		Vertex* prev;
		Edge* edges;
		Face* firstNearbyFace;
		Face* lastNearbyFace;
		PointR128 point128;
		Point32 point;
		int copy;

		Vertex() : next(NULL), prev(NULL), edges(NULL), firstNearbyFace(NULL), lastNearbyFace(NULL), copy(-1)
		{
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("V%d (%d, %d, %d)", point.index, point.x, point.y, point.z);
		}

		void printGraph();
#endif

		Point32 operator-(const Vertex& b) const
		{
			return point - b.point;
		}

		Rational128 dot(const Point64& b) const
		{
			return (point.index >= 0) ? Rational128(point.dot(b))
									  : Rational128(point128.x * b.x + point128.y * b.y + point128.z * b.z, point128.denominator);
		}

		btScalar xvalue() const
		{
			return (point.index >= 0) ? btScalar(point.x) : point128.xvalue();
		}

		btScalar yvalue() const
		{
			return (point.index >= 0) ? btScalar(point.y) : point128.yvalue();
		}

		btScalar zvalue() const
		{
			return (point.index >= 0) ? btScalar(point.z) : point128.zvalue();
		}

		void receiveNearbyFaces(Vertex* src)
		{
			if (lastNearbyFace)
			{
				lastNearbyFace->nextWithSameNearbyVertex = src->firstNearbyFace;
			}
			else
			{
				firstNearbyFace = src->firstNearbyFace;
			}
			if (src->lastNearbyFace)
			{
				lastNearbyFace = src->lastNearbyFace;
			}
			for (Face* f = src->firstNearbyFace; f; f = f->nextWithSameNearbyVertex)
			{
				btAssert(f->nearbyVertex == src);
				f->nearbyVertex = this;
			}
			src->firstNearbyFace = NULL;
			src->lastNearbyFace = NULL;
		}
	};

	class Edge
	{
	public:
		Edge* next;
		Edge* prev;
		Edge* reverse;
		Vertex* target;
		Face* face;
		int copy;

		~Edge()
		{
			next = NULL;
			prev = NULL;
			reverse = NULL;
			target = NULL;
			face = NULL;
		}

		void link(Edge* n)
		{
			btAssert(reverse->target == n->reverse->target);
			next = n;
			n->prev = this;
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("E%p : %d -> %d,  n=%p p=%p   (0 %d\t%d\t%d) -> (%d %d %d)", this, reverse->target->point.index, target->point.index, next, prev,
				   reverse->target->point.x, reverse->target->point.y, reverse->target->point.z, target->point.x, target->point.y, target->point.z);
		}
#endif
	};

	class Face
	{
	public:
		Face* next;
		Vertex* nearbyVertex;
		Face* nextWithSameNearbyVertex;
		Point32 origin;
		Point32 dir0;
		Point32 dir1;

		Face() : next(NULL), nearbyVertex(NULL), nextWithSameNearbyVertex(NULL)
		{
		}

		void init(Vertex* a, Vertex* b, Vertex* c)
		{
			nearbyVertex = a;
			origin = a->point;
			dir0 = *b - *a;
			dir1 = *c - *a;
			if (a->lastNearbyFace)
			{
				a->lastNearbyFace->nextWithSameNearbyVertex = this;
			}
			else
			{
				a->firstNearbyFace = this;
			}
			a->lastNearbyFace = this;
		}

		Point64 getNormal()
		{
			return dir0.cross(dir1);
		}
	};

	template <typename UWord, typename UHWord>
	class DMul
	{
	private:
		static uint32_t high(uint64_t value)
		{
			return (uint32_t)(value >> 32);
		}

		static uint32_t low(uint64_t value)
		{
			return (uint32_t)value;
		}

		static uint64_t mul(uint32_t a, uint32_t b)
		{
			return (uint64_t)a * (uint64_t)b;
		}

		static void shlHalf(uint64_t& value)
		{
			value <<= 32;
		}

		static uint64_t high(Int128 value)
		{
			return value.high;
		}

		static uint64_t low(Int128 value)
		{
			return value.low;
		}

		static Int128 mul(uint64_t a, uint64_t b)
		{
			return Int128::mul(a, b);
		}

		static void shlHalf(Int128& value)
		{
			value.high = value.low;
			value.low = 0;
		}

	public:
		static void mul(UWord a, UWord b, UWord& resLow, UWord& resHigh)
		{
			UWord p00 = mul(low(a), low(b));
			UWord p01 = mul(low(a), high(b));
			UWord p10 = mul(high(a), low(b));
			UWord p11 = mul(high(a), high(b));
			UWord p0110 = UWord(low(p01)) + UWord(low(p10));
			p11 += high(p01);
			p11 += high(p10);
			p11 += high(p0110);
			shlHalf(p0110);
			p00 += p0110;
			if (p00 < p0110)
			{
				++p11;
			}
			resLow = p00;
			resHigh = p11;
		}
	};

private:
	class IntermediateHull
	{
	public:
		Vertex* minXy;
		Vertex* maxXy;
		Vertex* minYx;
		Vertex* maxYx;

		IntermediateHull() : minXy(NULL), maxXy(NULL), minYx(NULL), maxYx(NULL)
		{
		}

		void print();
	};

	enum Orientation
	{
		NONE,
		CLOCKWISE,
		COUNTER_CLOCKWISE
	};

	template <typename T>
	class PoolArray
	{
	private:
		T* array;
		int size;

	public:
		PoolArray<T>* next;

		PoolArray(int size) : size(size), next(NULL)
		{
			array = (T*)btAlignedAlloc(sizeof(T) * size, 16);
		}

		~PoolArray()
		{
			btAlignedFree(array);
		}

		T* init()
		{
			T* o = array;
			for (int i = 0; i < size; i++, o++)
			{
				o->next = (i + 1 < size) ? o + 1 : NULL;
			}
			return array;
		}
	};

	template <typename T>
	class Pool
	{
	private:
		PoolArray<T>* arrays;
		PoolArray<T>* nextArray;
		T* freeObjects;
		int arraySize;

	public:
		Pool() : arrays(NULL), nextArray(NULL), freeObjects(NULL), arraySize(256)
		{
		}

		~Pool()
		{
			while (arrays)
			{
				PoolArray<T>* p = arrays;
				arrays = p->next;
				p->~PoolArray<T>();
				btAlignedFree(p);
			}
		}

		void reset()
		{
			nextArray = arrays;
			freeObjects = NULL;
		}

		void setArraySize(int arraySize)
		{
			this->arraySize = arraySize;
		}

		T* newObject()
		{
			T* o = freeObjects;
			if (!o)
			{
				PoolArray<T>* p = nextArray;
				if (p)
				{
					nextArray = p->next;
				}
				else
				{
					p = new (btAlignedAlloc(sizeof(PoolArray<T>), 16)) PoolArray<T>(arraySize);
					p->next = arrays;
					arrays = p;
				}
				o = p->init();
			}
			freeObjects = o->next;
			return new (o) T();
		};

		void freeObject(T* object)
		{
			object->~T();
			object->next = freeObjects;
			freeObjects = object;
		}
	};

	btVector3 scaling;
	btVector3 center;
	Pool<Vertex> vertexPool;
	Pool<Edge> edgePool;
	Pool<Face> facePool;
	btAlignedObjectArray<Vertex*> originalVertices;
	int mergeStamp;
	int minAxis;
	int medAxis;
	int maxAxis;
	int usedEdgePairs;
	int maxUsedEdgePairs;

	static Orientation getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t);
	Edge* findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot);
	void findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1);

	Edge* newEdgePair(Vertex* from, Vertex* to);

	void removeEdgePair(Edge* edge)
	{
		Edge* n = edge->next;
		Edge* r = edge->reverse;

		btAssert(edge->target && r->target);

		if (n != edge)
		{
			n->prev = edge->prev;
			edge->prev->next = n;
			r->target->edges = n;
		}
		else
		{
			r->target->edges = NULL;
		}

		n = r->next;

		if (n != r)
		{
			n->prev = r->prev;
			r->prev->next = n;
			edge->target->edges = n;
		}
		else
		{
			edge->target->edges = NULL;
		}

		edgePool.freeObject(edge);
		edgePool.freeObject(r);
		usedEdgePairs--;
	}

	void computeInternal(int start, int end, IntermediateHull& result);

	bool mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1);

	void merge(IntermediateHull& h0, IntermediateHull& h1);

	btVector3 toBtVector(const Point32& v);

	btVector3 getBtNormal(Face* face);

	bool shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack);

public:
	Vertex* vertexList;

	void compute(const void* coords, bool doubleCoords, int stride, int count);

	btVector3 getCoordinates(const Vertex* v);

	btScalar shrink(btScalar amount, btScalar clampAmount);
};

btConvexHullInternal::Int128 btConvexHullInternal::Int128::operator*(int64_t b) const
{
	bool negative = (int64_t)high < 0;
	Int128 a = negative ? -*this : *this;
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	Int128 result = mul(a.low, (uint64_t)b);
	result.high += a.high * (uint64_t)b;
	return negative ? -result : result;
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(int64_t a, int64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("imulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");
	return result;

#else
	bool negative = a < 0;
	if (negative)
	{
		a = -a;
	}
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	DMul<uint64_t, uint32_t>::mul((uint64_t)a, (uint64_t)b, result.low, result.high);
	return negative ? -result : result;
#endif
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(uint64_t a, uint64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("mulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");

#else
	DMul<uint64_t, uint32_t>::mul(a, b, result.low, result.high);
#endif

	return result;
}

int btConvexHullInternal::Rational64::compare(const Rational64& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}

	//	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;

#ifdef USE_X86_64_ASM

	int result;
	int64_t tmp;
	int64_t dummy;
	__asm__(
		"mulq %[bn]\n\t"
		"movq %%rax, %[tmp]\n\t"
		"movq %%rdx, %%rbx\n\t"
		"movq %[tn], %%rax\n\t"
		"mulq %[bd]\n\t"
		"subq %[tmp], %%rax\n\t"
		"sbbq %%rbx, %%rdx\n\t"  // rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
		"setnsb %%bh\n\t"        // bh=1 if difference is non-negative, bh=0 otherwise
		"orq %%rdx, %%rax\n\t"
		"setnzb %%bl\n\t"      // bl=1 if difference if non-zero, bl=0 if it is zero
		"decb %%bh\n\t"        // now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
		"shll $16, %%ebx\n\t"  // ebx has same sign as difference
		: "=&b"(result), [tmp] "=&r"(tmp), "=a"(dummy)
		: "a"(m_denominator), [bn] "g"(b.m_numerator), [tn] "g"(m_numerator), [bd] "g"(b.m_denominator)
		: "%rdx", "cc");
	return result ? result ^ sign  // if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
								   // if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
				  : 0;

#else

	return sign * Int128::mul(m_numerator, b.m_denominator).ucmp(Int128::mul(m_denominator, b.m_numerator));

#endif
}

int btConvexHullInternal::Rational128::compare(const Rational128& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}
	if (isInt64)
	{
		return -b.compare(sign * (int64_t)numerator.low);
	}

	Int128 nbdLow, nbdHigh, dbnLow, dbnHigh;
	DMul<Int128, uint64_t>::mul(numerator, b.denominator, nbdLow, nbdHigh);
	DMul<Int128, uint64_t>::mul(denominator, b.numerator, dbnLow, dbnHigh);

	int cmp = nbdHigh.ucmp(dbnHigh);
	if (cmp)
	{
		return cmp * sign;
	}
	return nbdLow.ucmp(dbnLow) * sign;
}

int btConvexHullInternal::Rational128::compare(int64_t b) const
{
	if (isInt64)
	{
		int64_t a = sign * (int64_t)numerator.low;
		return (a > b) ? 1 : (a < b) ? -1 : 0;
	}
	if (b > 0)
	{
		if (sign <= 0)
		{
			return -1;
		}
	}
	else if (b < 0)
	{
		if (sign >= 0)
		{
			return 1;
		}
		b = -b;
	}
	else
	{
		return sign;
	}

	return numerator.ucmp(denominator * b) * sign;
}

btConvexHullInternal::Edge* btConvexHullInternal::newEdgePair(Vertex* from, Vertex* to)
{
	btAssert(from && to);
	Edge* e = edgePool.newObject();
	Edge* r = edgePool.newObject();
	e->reverse = r;
	r->reverse = e;
	e->copy = mergeStamp;
	r->copy = mergeStamp;
	e->target = to;
	r->target = from;
	e->face = NULL;
	r->face = NULL;
	usedEdgePairs++;
	if (usedEdgePairs > maxUsedEdgePairs)
	{
		maxUsedEdgePairs = usedEdgePairs;
	}
	return e;
}

bool btConvexHullInternal::mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1)
{
	Vertex* v0 = h0.maxYx;
	Vertex* v1 = h1.minYx;
	if ((v0->point.x == v1->point.x) && (v0->point.y == v1->point.y))
	{
		btAssert(v0->point.z < v1->point.z);
		Vertex* v1p = v1->prev;
		if (v1p == v1)
		{
			c0 = v0;
			if (v1->edges)
			{
				btAssert(v1->edges->next == v1->edges);
				v1 = v1->edges->target;
				btAssert(v1->edges->next == v1->edges);
			}
			c1 = v1;
			return false;
		}
		Vertex* v1n = v1->next;
		v1p->next = v1n;
		v1n->prev = v1p;
		if (v1 == h1.minXy)
		{
			if ((v1n->point.x < v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y < v1p->point.y)))
			{
				h1.minXy = v1n;
			}
			else
			{
				h1.minXy = v1p;
			}
		}
		if (v1 == h1.maxXy)
		{
			if ((v1n->point.x > v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y > v1p->point.y)))
			{
				h1.maxXy = v1n;
			}
			else
			{
				h1.maxXy = v1p;
			}
		}
	}

	v0 = h0.maxXy;
	v1 = h1.maxXy;
	Vertex* v00 = NULL;
	Vertex* v10 = NULL;
	int32_t sign = 1;

	for (int side = 0; side <= 1; side++)
	{
		int32_t dx = (v1->point.x - v0->point.x) * sign;
		if (dx > 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w0 = side ? v0->next : v0->prev;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					if ((dy0 <= 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx <= dy * dx0))))
					{
						v0 = w0;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w1 = side ? v1->next : v1->prev;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					int32_t dxn = (w1->point.x - v0->point.x) * sign;
					if ((dxn > 0) && (dy1 < 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx < dy * dx1))))
					{
						v1 = w1;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else if (dx < 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w1 = side ? v1->prev : v1->next;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					if ((dy1 >= 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx <= dy * dx1))))
					{
						v1 = w1;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w0 = side ? v0->prev : v0->next;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					int32_t dxn = (v1->point.x - w0->point.x) * sign;
					if ((dxn < 0) && (dy0 > 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx < dy * dx0))))
					{
						v0 = w0;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else
		{
			int32_t x = v0->point.x;
			int32_t y0 = v0->point.y;
			Vertex* w0 = v0;
			Vertex* t;
			while (((t = side ? w0->next : w0->prev) != v0) && (t->point.x == x) && (t->point.y <= y0))
			{
				w0 = t;
				y0 = t->point.y;
			}
			v0 = w0;

			int32_t y1 = v1->point.y;
			Vertex* w1 = v1;
			while (((t = side ? w1->prev : w1->next) != v1) && (t->point.x == x) && (t->point.y >= y1))
			{
				w1 = t;
				y1 = t->point.y;
			}
			v1 = w1;
		}

		if (side == 0)
		{
			v00 = v0;
			v10 = v1;

			v0 = h0.minXy;
			v1 = h1.minXy;
			sign = -1;
		}
	}

	v0->prev = v1;
	v1->next = v0;

	v00->next = v10;
	v10->prev = v00;

	if (h1.minXy->point.x < h0.minXy->point.x)
	{
		h0.minXy = h1.minXy;
	}
	if (h1.maxXy->point.x >= h0.maxXy->point.x)
	{
		h0.maxXy = h1.maxXy;
	}

	h0.maxYx = h1.maxYx;

	c0 = v00;
	c1 = v10;

	return true;
}

void btConvexHullInternal::computeInternal(int start, int end, IntermediateHull& result)
{
	int n = end - start;
	switch (n)
	{
		case 0:
			result.minXy = NULL;
			result.maxXy = NULL;
			result.minYx = NULL;
			result.maxYx = NULL;
			return;
		case 2:
		{
			Vertex* v = originalVertices[start];
			Vertex* w = v + 1;
			if (v->point != w->point)
			{
				int32_t dx = v->point.x - w->point.x;
				int32_t dy = v->point.y - w->point.y;

				if ((dx == 0) && (dy == 0))
				{
					if (v->point.z > w->point.z)
					{
						Vertex* t = w;
						w = v;
						v = t;
					}
					btAssert(v->point.z < w->point.z);
					v->next = v;
					v->prev = v;
					result.minXy = v;
					result.maxXy = v;
					result.minYx = v;
					result.maxYx = v;
				}
				else
				{
					v->next = w;
					v->prev = w;
					w->next = v;
					w->prev = v;

					if ((dx < 0) || ((dx == 0) && (dy < 0)))
					{
						result.minXy = v;
						result.maxXy = w;
					}
					else
					{
						result.minXy = w;
						result.maxXy = v;
					}

					if ((dy < 0) || ((dy == 0) && (dx < 0)))
					{
						result.minYx = v;
						result.maxYx = w;
					}
					else
					{
						result.minYx = w;
						result.maxYx = v;
					}
				}

				Edge* e = newEdgePair(v, w);
				e->link(e);
				v->edges = e;

				e = e->reverse;
				e->link(e);
				w->edges = e;

				return;
			}
			{
				Vertex* v = originalVertices[start];
				v->edges = NULL;
				v->next = v;
				v->prev = v;

				result.minXy = v;
				result.maxXy = v;
				result.minYx = v;
				result.maxYx = v;
			}

			return;
		}

		case 1:
		{
			Vertex* v = originalVertices[start];
			v->edges = NULL;
			v->next = v;
			v->prev = v;

			result.minXy = v;
			result.maxXy = v;
			result.minYx = v;
			result.maxYx = v;

			return;
		}
	}

	int split0 = start + n / 2;
	Point32 p = originalVertices[split0 - 1]->point;
	int split1 = split0;
	while ((split1 < end) && (originalVertices[split1]->point == p))
	{
		split1++;
	}
	computeInternal(start, split0, result);
	IntermediateHull hull1;
	computeInternal(split1, end, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n\nMerge\n");
	result.print();
	hull1.print();
#endif
	merge(result, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n  Result\n");
	result.print();
#endif
}

#ifdef DEBUG_CONVEX_HULL
void btConvexHullInternal::IntermediateHull::print()
{
	printf("    Hull\n");
	for (Vertex* v = minXy; v;)
	{
		printf("      ");
		v->print();
		if (v == maxXy)
		{
			printf(" maxXy");
		}
		if (v == minYx)
		{
			printf(" minYx");
		}
		if (v == maxYx)
		{
			printf(" maxYx");
		}
		if (v->next->prev != v)
		{
			printf(" Inconsistency");
		}
		printf("\n");
		v = v->next;
		if (v == minXy)
		{
			break;
		}
	}
	if (minXy)
	{
		minXy->copy = (minXy->copy == -1) ? -2 : -1;
		minXy->printGraph();
	}
}

void btConvexHullInternal::Vertex::printGraph()
{
	print();
	printf("\nEdges\n");
	Edge* e = edges;
	if (e)
	{
		do
		{
			e->print();
			printf("\n");
			e = e->next;
		} while (e != edges);
		do
		{
			Vertex* v = e->target;
			if (v->copy != copy)
			{
				v->copy = copy;
				v->printGraph();
			}
			e = e->next;
		} while (e != edges);
	}
}
#endif

btConvexHullInternal::Orientation btConvexHullInternal::getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t)
{
	btAssert(prev->reverse->target == next->reverse->target);
	if (prev->next == next)
	{
		if (prev->prev == next)
		{
			Point64 n = t.cross(s);
			Point64 m = (*prev->target - *next->reverse->target).cross(*next->target - *next->reverse->target);
			btAssert(!m.isZero());
			int64_t dot = n.dot(m);
			btAssert(dot != 0);
			return (dot > 0) ? COUNTER_CLOCKWISE : CLOCKWISE;
		}
		return COUNTER_CLOCKWISE;
	}
	else if (prev->prev == next)
	{
		return CLOCKWISE;
	}
	else
	{
		return NONE;
	}
}

btConvexHullInternal::Edge* btConvexHullInternal::findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot)
{
	Edge* minEdge = NULL;

#ifdef DEBUG_CONVEX_HULL
	printf("find max edge for %d\n", start->point.index);
#endif
	Edge* e = start->edges;
	if (e)
	{
		do
		{
			if (e->copy > mergeStamp)
			{
				Point32 t = *e->target - *start;
				Rational64 cot(t.dot(sxrxs), t.dot(rxs));
#ifdef DEBUG_CONVEX_HULL
				printf("      Angle is %f (%d) for ", (float)btAtan(cot.toScalar()), (int)cot.isNaN());
				e->print();
#endif
				if (cot.isNaN())
				{
					btAssert(ccw ? (t.dot(s) < 0) : (t.dot(s) > 0));
				}
				else
				{
					int cmp;
					if (minEdge == NULL)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp = cot.compare(minCot)) < 0)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp == 0) && (ccw == (getOrientation(minEdge, e, s, t) == COUNTER_CLOCKWISE)))
					{
						minEdge = e;
					}
				}
#ifdef DEBUG_CONVEX_HULL
				printf("\n");
#endif
			}
			e = e->next;
		} while (e != start->edges);
	}
	return minEdge;
}

void btConvexHullInternal::findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1)
{
	Edge* start0 = e0;
	Edge* start1 = e1;
	Point32 et0 = start0 ? start0->target->point : c0->point;
	Point32 et1 = start1 ? start1->target->point : c1->point;
	Point32 s = c1->point - c0->point;
	Point64 normal = ((start0 ? start0 : start1)->target->point - c0->point).cross(s);
	int64_t dist = c0->point.dot(normal);
	btAssert(!start1 || (start1->target->point.dot(normal) == dist));
	Point64 perp = s.cross(normal);
	btAssert(!perp.isZero());

#ifdef DEBUG_CONVEX_HULL
	printf("   Advancing %d %d  (%p %p, %d %d)\n", c0->point.index, c1->point.index, start0, start1, start0 ? start0->target->point.index : -1, start1 ? start1->target->point.index : -1);
#endif

	int64_t maxDot0 = et0.dot(perp);
	if (e0)
	{
		while (e0->target != stop0)
		{
			Edge* e = e0->reverse->prev;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot0)
			{
				break;
			}
			maxDot0 = dot;
			e0 = e;
			et0 = e->target->point;
		}
	}

	int64_t maxDot1 = et1.dot(perp);
	if (e1)
	{
		while (e1->target != stop1)
		{
			Edge* e = e1->reverse->next;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot1)
			{
				break;
			}
			maxDot1 = dot;
			e1 = e;
			et1 = e->target->point;
		}
	}

#ifdef DEBUG_CONVEX_HULL
	printf("   Starting at %d %d\n", et0.index, et1.index);
#endif

	int64_t dx = maxDot1 - maxDot0;
	if (dx > 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->next->reverse;
				if (f0->copy > mergeStamp)
				{
					int64_t dx0 = (f0->target->point - et0).dot(perp);
					int64_t dy0 = (f0->target->point - et0).dot(s);
					if ((dx0 == 0) ? (dy0 < 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) >= 0)))
					{
						et0 = f0->target->point;
						dx = (et1 - et0).dot(perp);
						e0 = (e0 == start0) ? NULL : f0;
						continue;
					}
				}
			}

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->reverse->next;
				if (f1->copy > mergeStamp)
				{
					Point32 d1 = f1->target->point - et1;
					if (d1.dot(normal) == 0)
					{
						int64_t dx1 = d1.dot(perp);
						int64_t dy1 = d1.dot(s);
						int64_t dxn = (f1->target->point - et0).dot(perp);
						if ((dxn > 0) && ((dx1 == 0) ? (dy1 < 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) > 0))))
						{
							e1 = f1;
							et1 = e1->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e1 == start1) && (d1.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
	else if (dx < 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->prev->reverse;
				if (f1->copy > mergeStamp)
				{
					int64_t dx1 = (f1->target->point - et1).dot(perp);
					int64_t dy1 = (f1->target->point - et1).dot(s);
					if ((dx1 == 0) ? (dy1 > 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) <= 0)))
					{
						et1 = f1->target->point;
						dx = (et1 - et0).dot(perp);
						e1 = (e1 == start1) ? NULL : f1;
						continue;
					}
				}
			}

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->reverse->prev;
				if (f0->copy > mergeStamp)
				{
					Point32 d0 = f0->target->point - et0;
					if (d0.dot(normal) == 0)
					{
						int64_t dx0 = d0.dot(perp);
						int64_t dy0 = d0.dot(s);
						int64_t dxn = (et1 - f0->target->point).dot(perp);
						if ((dxn < 0) && ((dx0 == 0) ? (dy0 > 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) < 0))))
						{
							e0 = f0;
							et0 = e0->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e0 == start0) && (d0.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
#ifdef DEBUG_CONVEX_HULL
	printf("   Advanced edges to %d %d\n", et0.index, et1.index);
#endif
}

void btConvexHullInternal::merge(IntermediateHull& h0, IntermediateHull& h1)
{
	if (!h1.maxXy)
	{
		return;
	}
	if (!h0.maxXy)
	{
		h0 = h1;
		return;
	}

	mergeStamp--;

	Vertex* c0 = NULL;
	Edge* toPrev0 = NULL;
	Edge* firstNew0 = NULL;
	Edge* pendingHead0 = NULL;
	Edge* pendingTail0 = NULL;
	Vertex* c1 = NULL;
	Edge* toPrev1 = NULL;
	Edge* firstNew1 = NULL;
	Edge* pendingHead1 = NULL;
	Edge* pendingTail1 = NULL;
	Point32 prevPoint;

	if (mergeProjection(h0, h1, c0, c1))
	{
		Point32 s = *c1 - *c0;
		Point64 normal = Point32(0, 0, -1).cross(s);
		Point64 t = s.cross(normal);
		btAssert(!t.isZero());

		Edge* e = c0->edges;
		Edge* start0 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c0).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c0).dot(t) > 0))
				{
					if (!start0 || (getOrientation(start0, e, s, Point32(0, 0, -1)) == CLOCKWISE))
					{
						start0 = e;
					}
				}
				e = e->next;
			} while (e != c0->edges);
		}

		e = c1->edges;
		Edge* start1 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c1).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c1).dot(t) > 0))
				{
					if (!start1 || (getOrientation(start1, e, s, Point32(0, 0, -1)) == COUNTER_CLOCKWISE))
					{
						start1 = e;
					}
				}
				e = e->next;
			} while (e != c1->edges);
		}

		if (start0 || start1)
		{
			findEdgeForCoplanarFaces(c0, c1, start0, start1, NULL, NULL);
			if (start0)
			{
				c0 = start0->target;
			}
			if (start1)
			{
				c1 = start1->target;
			}
		}

		prevPoint = c1->point;
		prevPoint.z++;
	}
	else
	{
		prevPoint = c1->point;
		prevPoint.x++;
	}

	Vertex* first0 = c0;
	Vertex* first1 = c1;
	bool firstRun = true;

	while (true)
	{
		Point32 s = *c1 - *c0;
		Point32 r = prevPoint - c0->point;
		Point64 rxs = r.cross(s);
		Point64 sxrxs = s.cross(rxs);

#ifdef DEBUG_CONVEX_HULL
		printf("\n  Checking %d %d\n", c0->point.index, c1->point.index);
#endif
		Rational64 minCot0(0, 0);
		Edge* min0 = findMaxAngle(false, c0, s, rxs, sxrxs, minCot0);
		Rational64 minCot1(0, 0);
		Edge* min1 = findMaxAngle(true, c1, s, rxs, sxrxs, minCot1);
		if (!min0 && !min1)
		{
			Edge* e = newEdgePair(c0, c1);
			e->link(e);
			c0->edges = e;

			e = e->reverse;
			e->link(e);
			c1->edges = e;
			return;
		}
		else
		{
			int cmp = !min0 ? 1 : !min1 ? -1 : minCot0.compare(minCot1);
#ifdef DEBUG_CONVEX_HULL
			printf("    -> Result %d\n", cmp);
#endif
			if (firstRun || ((cmp >= 0) ? !minCot1.isNegativeInfinity() : !minCot0.isNegativeInfinity()))
			{
				Edge* e = newEdgePair(c0, c1);
				if (pendingTail0)
				{
					pendingTail0->prev = e;
				}
				else
				{
					pendingHead0 = e;
				}
				e->next = pendingTail0;
				pendingTail0 = e;

				e = e->reverse;
				if (pendingTail1)
				{
					pendingTail1->next = e;
				}
				else
				{
					pendingHead1 = e;
				}
				e->prev = pendingTail1;
				pendingTail1 = e;
			}

			Edge* e0 = min0;
			Edge* e1 = min1;

#ifdef DEBUG_CONVEX_HULL
			printf("   Found min edges to %d %d\n", e0 ? e0->target->point.index : -1, e1 ? e1->target->point.index : -1);
#endif

			if (cmp == 0)
			{
				findEdgeForCoplanarFaces(c0, c1, e0, e1, NULL, NULL);
			}

			if ((cmp >= 0) && e1)
			{
				if (toPrev1)
				{
					for (Edge *e = toPrev1->next, *n = NULL; e != min1; e = n)
					{
						n = e->next;
						removeEdgePair(e);
					}
				}

				if (pendingTail1)
				{
					if (toPrev1)
					{
						toPrev1->link(pendingHead1);
					}
					else
					{
						min1->prev->link(pendingHead1);
						firstNew1 = pendingHead1;
					}
					pendingTail1->link(min1);
					pendingHead1 = NULL;
					pendingTail1 = NULL;
				}
				else if (!toPrev1)
				{
					firstNew1 = min1;
				}

				prevPoint = c1->point;
				c1 = e1->target;
				toPrev1 = e1->reverse;
			}

			if ((cmp <= 0) && e0)
			{
				if (toPrev0)
				{
					for (Edge *e = toPrev0->prev, *n = NULL; e != min0; e = n)
					{
						n = e->prev;
						removeEdgePair(e);
					}
				}

				if (pendingTail0)
				{
					if (toPrev0)
					{
						pendingHead0->link(toPrev0);
					}
					else
					{
						pendingHead0->link(min0->next);
						firstNew0 = pendingHead0;
					}
					min0->link(pendingTail0);
					pendingHead0 = NULL;
					pendingTail0 = NULL;
				}
				else if (!toPrev0)
				{
					firstNew0 = min0;
				}

				prevPoint = c0->point;
				c0 = e0->target;
				toPrev0 = e0->reverse;
			}
		}

		if ((c0 == first0) && (c1 == first1))
		{
			if (toPrev0 == NULL)
			{
				pendingHead0->link(pendingTail0);
				c0->edges = pendingTail0;
			}
			else
			{
				for (Edge *e = toPrev0->prev, *n = NULL; e != firstNew0; e = n)
				{
					n = e->prev;
					removeEdgePair(e);
				}
				if (pendingTail0)
				{
					pendingHead0->link(toPrev0);
					firstNew0->link(pendingTail0);
				}
			}

			if (toPrev1 == NULL)
			{
				pendingTail1->link(pendingHead1);
				c1->edges = pendingTail1;
			}
			else
			{
				for (Edge *e = toPrev1->next, *n = NULL; e != firstNew1; e = n)
				{
					n = e->next;
					removeEdgePair(e);
				}
				if (pendingTail1)
				{
					toPrev1->link(pendingHead1);
					pendingTail1->link(firstNew1);
				}
			}

			return;
		}

		firstRun = false;
	}
}

class pointCmp
{
public:
	bool operator()(const btConvexHullInternal::Point32& p, const btConvexHullInternal::Point32& q) const
	{
		return (p.y < q.y) || ((p.y == q.y) && ((p.x < q.x) || ((p.x == q.x) && (p.z < q.z))));
	}
};

void btConvexHullInternal::compute(const void* coords, bool doubleCoords, int stride, int count)
{
	btVector3 min(btScalar(1e30), btScalar(1e30), btScalar(1e30)), max(btScalar(-1e30), btScalar(-1e30), btScalar(-1e30));
	const char* ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}

	btVector3 s = max - min;
	maxAxis = s.maxAxis();
	minAxis = s.minAxis();
	if (minAxis == maxAxis)
	{
		minAxis = (maxAxis + 1) % 3;
	}
	medAxis = 3 - maxAxis - minAxis;

	s /= btScalar(10216);
	if (((medAxis + 1) % 3) != maxAxis)
	{
		s *= -1;
	}
	scaling = s;

	if (s[0] != 0)
	{
		s[0] = btScalar(1) / s[0];
	}
	if (s[1] != 0)
	{
		s[1] = btScalar(1) / s[1];
	}
	if (s[2] != 0)
	{
		s[2] = btScalar(1) / s[2];
	}

	center = (min + max) * btScalar(0.5);

	btAlignedObjectArray<Point32> points;
	points.resize(count);
	ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	points.quickSort(pointCmp());

	vertexPool.reset();
	vertexPool.setArraySize(count);
	originalVertices.resize(count);
	for (int i = 0; i < count; i++)
	{
		Vertex* v = vertexPool.newObject();
		v->edges = NULL;
		v->point = points[i];
		v->copy = -1;
		originalVertices[i] = v;
	}

	points.clear();

	edgePool.reset();
	edgePool.setArraySize(6 * count);

	usedEdgePairs = 0;
	maxUsedEdgePairs = 0;

	mergeStamp = -3;

	IntermediateHull hull;
	computeInternal(0, count, hull);
	vertexList = hull.minXy;
#ifdef DEBUG_CONVEX_HULL
	printf("max. edges %d (3v = %d)", maxUsedEdgePairs, 3 * count);
#endif
}

btVector3 btConvexHullInternal::toBtVector(const Point32& v)
{
	btVector3 p;
	p[medAxis] = btScalar(v.x);
	p[maxAxis] = btScalar(v.y);
	p[minAxis] = btScalar(v.z);
	return p * scaling;
}

btVector3 btConvexHullInternal::getBtNormal(Face* face)
{
	return toBtVector(face->dir0).cross(toBtVector(face->dir1)).normalized();
}

btVector3 btConvexHullInternal::getCoordinates(const Vertex* v)
{
	btVector3 p;
	p[medAxis] = v->xvalue();
	p[maxAxis] = v->yvalue();
	p[minAxis] = v->zvalue();
	return p * scaling + center;
}

btScalar btConvexHullInternal::shrink(btScalar amount, btScalar clampAmount)
{
	if (!vertexList)
	{
		return 0;
	}
	int stamp = --mergeStamp;
	btAlignedObjectArray<Vertex*> stack;
	vertexList->copy = stamp;
	stack.push_back(vertexList);
	btAlignedObjectArray<Face*> faces;

	Point32 ref = vertexList->point;
	Int128 hullCenterX(0, 0);
	Int128 hullCenterY(0, 0);
	Int128 hullCenterZ(0, 0);
	Int128 volume(0, 0);

	while (stack.size() > 0)
	{
		Vertex* v = stack[stack.size() - 1];
		stack.pop_back();
		Edge* e = v->edges;
		if (e)
		{
			do
			{
				if (e->target->copy != stamp)
				{
					e->target->copy = stamp;
					stack.push_back(e->target);
				}
				if (e->copy != stamp)
				{
					Face* face = facePool.newObject();
					face->init(e->target, e->reverse->prev->target, v);
					faces.push_back(face);
					Edge* f = e;

					Vertex* a = NULL;
					Vertex* b = NULL;
					do
					{
						if (a && b)
						{
							int64_t vol = (v->point - ref).dot((a->point - ref).cross(b->point - ref));
							btAssert(vol >= 0);
							Point32 c = v->point + a->point + b->point + ref;
							hullCenterX += vol * c.x;
							hullCenterY += vol * c.y;
							hullCenterZ += vol * c.z;
							volume += vol;
						}

						btAssert(f->copy != stamp);
						f->copy = stamp;
						f->face = face;

						a = b;
						b = f->target;

						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != v->edges);
		}
	}

	if (volume.getSign() <= 0)
	{
		return 0;
	}

	btVector3 hullCenter;
	hullCenter[medAxis] = hullCenterX.toScalar();
	hullCenter[maxAxis] = hullCenterY.toScalar();
	hullCenter[minAxis] = hullCenterZ.toScalar();
	hullCenter /= 4 * volume.toScalar();
	hullCenter *= scaling;

	int faceCount = faces.size();

	if (clampAmount > 0)
	{
		btScalar minDist = SIMD_INFINITY;
		for (int i = 0; i < faceCount; i++)
		{
			btVector3 normal = getBtNormal(faces[i]);
			btScalar dist = normal.dot(toBtVector(faces[i]->origin) - hullCenter);
			if (dist < minDist)
			{
				minDist = dist;
			}
		}

		if (minDist <= 0)
		{
			return 0;
		}

		amount = btMin(amount, minDist * clampAmount);
	}

	unsigned int seed = 243703;
	for (int i = 0; i < faceCount; i++, seed = 1664525 * seed + 1013904223)
	{
		btSwap(faces[i], faces[seed % faceCount]);
	}

	for (int i = 0; i < faceCount; i++)
	{
		if (!shiftFace(faces[i], amount, stack))
		{
			return -amount;
		}
	}

	return amount;
}

bool btConvexHullInternal::shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack)
{
	btVector3 origShift = getBtNormal(face) * -amount;
	if (scaling[0] != 0)
	{
		origShift[0] /= scaling[0];
	}
	if (scaling[1] != 0)
	{
		origShift[1] /= scaling[1];
	}
	if (scaling[2] != 0)
	{
		origShift[2] /= scaling[2];
	}
	Point32 shift((int32_t)origShift[medAxis], (int32_t)origShift[maxAxis], (int32_t)origShift[minAxis]);
	if (shift.isZero())
	{
		return true;
	}
	Point64 normal = face->getNormal();
#ifdef DEBUG_CONVEX_HULL
	printf("\nShrinking face (%d %d %d) (%d %d %d) (%d %d %d) by (%d %d %d)\n",
		   face->origin.x, face->origin.y, face->origin.z, face->dir0.x, face->dir0.y, face->dir0.z, face->dir1.x, face->dir1.y, face->dir1.z, shift.x, shift.y, shift.z);
#endif
	int64_t origDot = face->origin.dot(normal);
	Point32 shiftedOrigin = face->origin + shift;
	int64_t shiftedDot = shiftedOrigin.dot(normal);
	btAssert(shiftedDot <= origDot);
	if (shiftedDot >= origDot)
	{
		return false;
	}

	Edge* intersection = NULL;

	Edge* startEdge = face->nearbyVertex->edges;
#ifdef DEBUG_CONVEX_HULL
	printf("Start edge is ");
	startEdge->print();
	printf(", normal is (%lld %lld %lld), shifted dot is %lld\n", normal.x, normal.y, normal.z, shiftedDot);
#endif
	Rational128 optDot = face->nearbyVertex->dot(normal);
	int cmp = optDot.compare(shiftedDot);
#ifdef SHOW_ITERATIONS
	int n = 0;
#endif
	if (cmp >= 0)
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving downwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) < 0)
			{
				int c = dot.compare(shiftedDot);
				optDot = dot;
				e = e->reverse;
				startEdge = e;
				if (c < 0)
				{
					intersection = e;
					break;
				}
				cmp = c;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return false;
		}
	}
	else
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving upwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) > 0)
			{
				cmp = dot.compare(shiftedDot);
				if (cmp >= 0)
				{
					intersection = e;
					break;
				}
				optDot = dot;
				e = e->reverse;
				startEdge = e;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return true;
		}
	}

#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to find initial intersection\n", n);
#endif

	if (cmp == 0)
	{
		Edge* e = intersection->reverse->next;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (e->target->dot(normal).compare(shiftedDot) <= 0)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->next;
			if (e == intersection->reverse)
			{
				return true;
			}
#ifdef DEBUG_CONVEX_HULL
			printf("Checking for outwards edge, current edge is ");
			e->print();
			printf("\n");
#endif
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to check for complete containment\n", n);
#endif
	}

	Edge* firstIntersection = NULL;
	Edge* faceEdge = NULL;
	Edge* firstFaceEdge = NULL;

#ifdef SHOW_ITERATIONS
	int m = 0;
#endif
	while (true)
	{
#ifdef SHOW_ITERATIONS
		m++;
#endif
#ifdef DEBUG_CONVEX_HULL
		printf("Intersecting edge is ");
		intersection->print();
		printf("\n");
#endif
		if (cmp == 0)
		{
			Edge* e = intersection->reverse->next;
			startEdge = e;
#ifdef SHOW_ITERATIONS
			n = 0;
#endif
			while (true)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				if (e->target->dot(normal).compare(shiftedDot) >= 0)
				{
					break;
				}
				intersection = e->reverse;
				e = e->next;
				if (e == startEdge)
				{
					return true;
				}
			}
#ifdef SHOW_ITERATIONS
			printf("Needed %d iterations to advance intersection\n", n);
#endif
		}

#ifdef DEBUG_CONVEX_HULL
		printf("Advanced intersecting edge to ");
		intersection->print();
		printf(", cmp = %d\n", cmp);
#endif

		if (!firstIntersection)
		{
			firstIntersection = intersection;
		}
		else if (intersection == firstIntersection)
		{
			break;
		}

		int prevCmp = cmp;
		Edge* prevIntersection = intersection;
		Edge* prevFaceEdge = faceEdge;

		Edge* e = intersection->reverse;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (true)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->reverse->prev;
			btAssert(e != intersection->reverse);
			cmp = e->target->dot(normal).compare(shiftedDot);
#ifdef DEBUG_CONVEX_HULL
			printf("Testing edge ");
			e->print();
			printf(" -> cmp = %d\n", cmp);
#endif
			if (cmp >= 0)
			{
				intersection = e;
				break;
			}
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to find other intersection of face\n", n);
#endif

		if (cmp > 0)
		{
			Vertex* removed = intersection->target;
			e = intersection->reverse;
			if (e->prev == e)
			{
				removed->edges = NULL;
			}
			else
			{
				removed->edges = e->prev;
				e->prev->link(e->next);
				e->link(e);
			}
#ifdef DEBUG_CONVEX_HULL
			printf("1: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif

			Point64 n0 = intersection->face->getNormal();
			Point64 n1 = intersection->reverse->face->getNormal();
			int64_t m00 = face->dir0.dot(n0);
			int64_t m01 = face->dir1.dot(n0);
			int64_t m10 = face->dir0.dot(n1);
			int64_t m11 = face->dir1.dot(n1);
			int64_t r0 = (intersection->face->origin - shiftedOrigin).dot(n0);
			int64_t r1 = (intersection->reverse->face->origin - shiftedOrigin).dot(n1);
			Int128 det = Int128::mul(m00, m11) - Int128::mul(m01, m10);
			btAssert(det.getSign() != 0);
			Vertex* v = vertexPool.newObject();
			v->point.index = -1;
			v->copy = -1;
			v->point128 = PointR128(Int128::mul(face->dir0.x * r0, m11) - Int128::mul(face->dir0.x * r1, m01) + Int128::mul(face->dir1.x * r1, m00) - Int128::mul(face->dir1.x * r0, m10) + det * shiftedOrigin.x,
									Int128::mul(face->dir0.y * r0, m11) - Int128::mul(face->dir0.y * r1, m01) + Int128::mul(face->dir1.y * r1, m00) - Int128::mul(face->dir1.y * r0, m10) + det * shiftedOrigin.y,
									Int128::mul(face->dir0.z * r0, m11) - Int128::mul(face->dir0.z * r1, m01) + Int128::mul(face->dir1.z * r1, m00) - Int128::mul(face->dir1.z * r0, m10) + det * shiftedOrigin.z,
									det);
			v->point.x = (int32_t)v->point128.xvalue();
			v->point.y = (int32_t)v->point128.yvalue();
			v->point.z = (int32_t)v->point128.zvalue();
			intersection->target = v;
			v->edges = e;

			stack.push_back(v);
			stack.push_back(removed);
			stack.push_back(NULL);
		}

		if (cmp || prevCmp || (prevIntersection->reverse->next->target != intersection->target))
		{
			faceEdge = newEdgePair(prevIntersection->target, intersection->target);
			if (prevCmp == 0)
			{
				faceEdge->link(prevIntersection->reverse->next);
			}
			if ((prevCmp == 0) || prevFaceEdge)
			{
				prevIntersection->reverse->link(faceEdge);
			}
			if (cmp == 0)
			{
				intersection->reverse->prev->link(faceEdge->reverse);
			}
			faceEdge->reverse->link(intersection->reverse);
		}
		else
		{
			faceEdge = prevIntersection->reverse->next;
		}

		if (prevFaceEdge)
		{
			if (prevCmp > 0)
			{
				faceEdge->link(prevFaceEdge->reverse);
			}
			else if (faceEdge != prevFaceEdge->reverse)
			{
				stack.push_back(prevFaceEdge->target);
				while (faceEdge->next != prevFaceEdge->reverse)
				{
					Vertex* removed = faceEdge->next->target;
					removeEdgePair(faceEdge->next);
					stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
					printf("2: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
				}
				stack.push_back(NULL);
			}
		}
		faceEdge->face = face;
		faceEdge->reverse->face = intersection->face;

		if (!firstFaceEdge)
		{
			firstFaceEdge = faceEdge;
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to process all intersections\n", m);
#endif

	if (cmp > 0)
	{
		firstFaceEdge->reverse->target = faceEdge->target;
		firstIntersection->reverse->link(firstFaceEdge);
		firstFaceEdge->link(faceEdge->reverse);
	}
	else if (firstFaceEdge != faceEdge->reverse)
	{
		stack.push_back(faceEdge->target);
		while (firstFaceEdge->next != faceEdge->reverse)
		{
			Vertex* removed = firstFaceEdge->next->target;
			removeEdgePair(firstFaceEdge->next);
			stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
			printf("3: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
		}
		stack.push_back(NULL);
	}

	btAssert(stack.size() > 0);
	vertexList = stack[0];

#ifdef DEBUG_CONVEX_HULL
	printf("Removing part\n");
#endif
#ifdef SHOW_ITERATIONS
	n = 0;
#endif
	int pos = 0;
	while (pos < stack.size())
	{
		int end = stack.size();
		while (pos < end)
		{
			Vertex* kept = stack[pos++];
#ifdef DEBUG_CONVEX_HULL
			kept->print();
#endif
			bool deeper = false;
			Vertex* removed;
			while ((removed = stack[pos++]) != NULL)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				kept->receiveNearbyFaces(removed);
				while (removed->edges)
				{
					if (!deeper)
					{
						deeper = true;
						stack.push_back(kept);
					}
					stack.push_back(removed->edges->target);
					removeEdgePair(removed->edges);
				}
			}
			if (deeper)
			{
				stack.push_back(NULL);
			}
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to remove part\n", n);
#endif

	stack.resize(0);
	face->origin = shiftedOrigin;

	return true;
}

static int getVertexCopy(btConvexHullInternal::Vertex* vertex, btAlignedObjectArray<btConvexHullInternal::Vertex*>& vertices)
{
	int index = vertex->copy;
	if (index < 0)
	{
		index = vertices.size();
		vertex->copy = index;
		vertices.push_back(vertex);
#ifdef DEBUG_CONVEX_HULL
		printf("Vertex %d gets index *%d\n", vertex->point.index, index);
#endif
	}
	return index;
}

btScalar btConvexHullComputer::compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
{
	if (count <= 0)
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return 0;
	}

	btConvexHullInternal hull;
	hull.compute(coords, doubleCoords, stride, count);

	btScalar shift = 0;
	if ((shrink > 0) && ((shift = hull.shrink(shrink, shrinkClamp)) < 0))
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return shift;
	}

	vertices.resize(0);
	original_vertex_index.resize(0);
	edges.resize(0);
	faces.resize(0);

	btAlignedObjectArray<btConvexHullInternal::Vertex*> oldVertices;
	getVertexCopy(hull.vertexList, oldVertices);
	int copied = 0;
	while (copied < oldVertices.size())
	{
		btConvexHullInternal::Vertex* v = oldVertices[copied];
		vertices.push_back(hull.getCoordinates(v));
		original_vertex_index.push_back(v->point.index);
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			int firstCopy = -1;
			int prevCopy = -1;
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy < 0)
				{
					int s = edges.size();
					edges.push_back(Edge());
					edges.push_back(Edge());
					Edge* c = &edges[s];
					Edge* r = &edges[s + 1];
					e->copy = s;
					e->reverse->copy = s + 1;
					c->reverse = 1;
					r->reverse = -1;
					c->targetVertex = getVertexCopy(e->target, oldVertices);
					r->targetVertex = copied;
#ifdef DEBUG_CONVEX_HULL
					printf("      CREATE: Vertex *%d has edge to *%d\n", copied, c->getTargetVertex());
#endif
				}
				if (prevCopy >= 0)
				{
					edges[e->copy].next = prevCopy - e->copy;
				}
				else
				{
					firstCopy = e->copy;
				}
				prevCopy = e->copy;
				e = e->next;
			} while (e != firstEdge);
			edges[firstCopy].next = prevCopy - firstCopy;
		}
		copied++;
	}

	for (int i = 0; i < copied; i++)
	{
		btConvexHullInternal::Vertex* v = oldVertices[i];
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy >= 0)
				{
#ifdef DEBUG_CONVEX_HULL
					printf("Vertex *%d has edge to *%d\n", i, edges[e->copy].getTargetVertex());
#endif
					faces.push_back(e->copy);
					btConvexHullInternal::Edge* f = e;
					do
					{
#ifdef DEBUG_CONVEX_HULL
						printf("   Face *%d\n", edges[f->copy].getTargetVertex());
#endif
						f->copy = -1;
						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != firstEdge);
		}
	}

	return shift;
}





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_HULL_COMPUTER_H
#define BT_CONVEX_HULL_COMPUTER_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullComputer
{
private:
	btScalar compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp);

public:
	class Edge
	{
	private:
		int next;
		int reverse;
		int targetVertex;

		friend class btConvexHullComputer;

	public:
		int getSourceVertex() const
		{
			return (this + reverse)->targetVertex;
		}

		int getTargetVertex() const
		{
			return targetVertex;
		}

		const Edge* getNextEdgeOfVertex() const  // clockwise list of all edges of a vertex
		{
			return this + next;
		}

		const Edge* getNextEdgeOfFace() const  // counter-clockwise list of all edges of a face
		{
			return (this + reverse)->getNextEdgeOfVertex();
		}

		const Edge* getReverseEdge() const
		{
			return this + reverse;
		}
	};

	// Vertices of the output hull
	btAlignedObjectArray<btVector3> vertices;

	// The original vertex index in the input coords array
	btAlignedObjectArray<int> original_vertex_index;

	// Edges of the output hull
	btAlignedObjectArray<Edge> edges;

	// Faces of the convex hull. Each entry is an index into the "edges" array pointing to an edge of the face. Faces are planar n-gons
	btAlignedObjectArray<int> faces;

	/*
		Compute convex hull of "count" vertices stored in "coords". "stride" is the difference in bytes
		between the addresses of consecutive vertices. If "shrink" is positive, the convex hull is shrunken
		by that amount (each face is moved by "shrink" length units towards the center along its normal).
		If "shrinkClamp" is positive, "shrink" is clamped to not exceed "shrinkClamp * innerRadius", where "innerRadius"
		is the minimum distance of a face to the center of the convex hull.

		The returned value is the amount by which the hull has been shrunken. If it is negative, the amount was so large
		that the resulting convex hull is empty.

		The output convex hull can be found in the member variables "vertices", "edges", "faces".
		*/
	btScalar compute(const float* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, false, stride, count, shrink, shrinkClamp);
	}

	// same as above, but double precision
	btScalar compute(const double* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, true, stride, count, shrink, shrinkClamp);
	}
};

#endif  //BT_CONVEX_HULL_COMPUTER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_HASH_MAP_H
#define BT_HASH_MAP_H

#include "LinearMath/btAlignedObjectArray.h"

///very basic hashable string implementation, compatible with btHashMap
struct btHashString
{
	std::string m_string1;
	unsigned int m_hash;

	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		return m_hash;
	}

	btHashString()
	{
		m_string1 = "";
		m_hash = 0;
	}
	btHashString(const char* name)
		: m_string1(name)
	{
		/* magic numbers from http://www.isthe.com/chongo/tech/comp/fnv/ */
		static const unsigned int InitialFNV = 2166136261u;
		static const unsigned int FNVMultiple = 16777619u;

		/* Fowler / Noll / Vo (FNV) Hash */
		unsigned int hash = InitialFNV;

		for (int i = 0; m_string1.c_str()[i]; i++)
		{
			hash = hash ^ (m_string1.c_str()[i]); /* xor  the low 8 bits */
			hash = hash * FNVMultiple;            /* multiply by the magic number */
		}
		m_hash = hash;
	}

	bool equals(const btHashString& other) const
	{
		return (m_string1 == other.m_string1);
	}
};

const int BT_HASH_NULL = 0xffffffff;

class btHashInt
{
	int m_uid;

public:
	btHashInt()
	{
	}

	btHashInt(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	void setUid1(int uid)
	{
		m_uid = uid;
	}

	bool equals(const btHashInt& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);

		return key;
	}
};

class btHashPtr
{
	union {
		const void* m_pointer;
		unsigned int m_hashValues[2];
	};

public:
	btHashPtr()
	{
	}

	btHashPtr(const void* ptr)
		: m_pointer(ptr)
	{
	}

	const void* getPointer() const
	{
		return m_pointer;
	}

	bool equals(const btHashPtr& other) const
	{
		return getPointer() == other.getPointer();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));

		unsigned int key = VOID_IS_8 ? m_hashValues[0] + m_hashValues[1] : m_hashValues[0];
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKeyPtr
{
	int m_uid;

public:
	btHashKeyPtr(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKeyPtr<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKey
{
	int m_uid;

public:
	btHashKey(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKey<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

///The btHashMap template class implements a generic and lightweight hashmap.
///A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
template <class Key, class Value>
class btHashMap
{
protected:
	btAlignedObjectArray<int> m_hashTable;
	btAlignedObjectArray<int> m_next;

	btAlignedObjectArray<Value> m_valueArray;
	btAlignedObjectArray<Key> m_keyArray;

	void growTables(const Key& /*key*/)
	{
		int newCapacity = m_valueArray.capacity();

		if (m_hashTable.size() < newCapacity)
		{
			//grow hashtable and next table
			int curHashtableSize = m_hashTable.size();

			m_hashTable.resize(newCapacity);
			m_next.resize(newCapacity);

			int i;

			for (i = 0; i < newCapacity; ++i)
			{
				m_hashTable[i] = BT_HASH_NULL;
			}
			for (i = 0; i < newCapacity; ++i)
			{
				m_next[i] = BT_HASH_NULL;
			}

			for (i = 0; i < curHashtableSize; i++)
			{
				//const Value& value = m_valueArray[i];
				//const Key& key = m_keyArray[i];

				int hashValue = m_keyArray[i].getHash() & (m_valueArray.capacity() - 1);  // New hash value with new mask
				m_next[i] = m_hashTable[hashValue];
				m_hashTable[hashValue] = i;
			}
		}
	}

public:
	void insert(const Key& key, const Value& value)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		//replace value if the key is already there
		int index = findIndex(key);
		if (index != BT_HASH_NULL)
		{
			m_valueArray[index] = value;
			return;
		}

		int count = m_valueArray.size();
		int oldCapacity = m_valueArray.capacity();
		m_valueArray.push_back(value);
		m_keyArray.push_back(key);

		int newCapacity = m_valueArray.capacity();
		if (oldCapacity < newCapacity)
		{
			growTables(key);
			//hash with new capacity
			hash = key.getHash() & (m_valueArray.capacity() - 1);
		}
		m_next[count] = m_hashTable[hash];
		m_hashTable[hash] = count;
	}

	void remove(const Key& key)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		int pairIndex = findIndex(key);

		if (pairIndex == BT_HASH_NULL)
		{
			return;
		}

		// Remove the pair from the hash table.
		int index = m_hashTable[hash];
		btAssert(index != BT_HASH_NULL);

		int previous = BT_HASH_NULL;
		while (index != pairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == pairIndex);
			m_next[previous] = m_next[pairIndex];
		}
		else
		{
			m_hashTable[hash] = m_next[pairIndex];
		}

		// We now move the last pair into spot of the
		// pair being removed. We need to fix the hash
		// table indices to support the move.

		int lastPairIndex = m_valueArray.size() - 1;

		// If the removed pair is the last pair, we are done.
		if (lastPairIndex == pairIndex)
		{
			m_valueArray.pop_back();
			m_keyArray.pop_back();
			return;
		}

		// Remove the last pair from the hash table.
		int lastHash = m_keyArray[lastPairIndex].getHash() & (m_valueArray.capacity() - 1);

		index = m_hashTable[lastHash];
		btAssert(index != BT_HASH_NULL);

		previous = BT_HASH_NULL;
		while (index != lastPairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == lastPairIndex);
			m_next[previous] = m_next[lastPairIndex];
		}
		else
		{
			m_hashTable[lastHash] = m_next[lastPairIndex];
		}

		// Copy the last pair into the remove pair's spot.
		m_valueArray[pairIndex] = m_valueArray[lastPairIndex];
		m_keyArray[pairIndex] = m_keyArray[lastPairIndex];

		// Insert the last pair into the hash table
		m_next[pairIndex] = m_hashTable[lastHash];
		m_hashTable[lastHash] = pairIndex;

		m_valueArray.pop_back();
		m_keyArray.pop_back();
	}

	int size() const
	{
		return m_valueArray.size();
	}

	const Value* getAtIndex(int index) const
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Value* getAtIndex(int index)
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Key getKeyAtIndex(int index)
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	const Key getKeyAtIndex(int index) const
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	Value* operator[](const Key& key)
	{
		return find(key);
	}

	const Value* operator[](const Key& key) const
	{
		return find(key);
	}

	const Value* find(const Key& key) const
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	Value* find(const Key& key)
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	int findIndex(const Key& key) const
	{
		unsigned int hash = key.getHash() & (m_valueArray.capacity() - 1);

		if (hash >= (unsigned int)m_hashTable.size())
		{
			return BT_HASH_NULL;
		}

		int index = m_hashTable[hash];
		while ((index != BT_HASH_NULL) && key.equals(m_keyArray[index]) == false)
		{
			index = m_next[index];
		}
		return index;
	}

	void clear()
	{
		m_hashTable.clear();
		m_next.clear();
		m_valueArray.clear();
		m_keyArray.clear();
	}
};

#endif  //BT_HASH_MAP_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btCapsuleShape.h"

#include "LinearMath/btQuaternion.h"

btCapsuleShape::btCapsuleShape(btScalar radius, btScalar height) : btConvexInternalShape()
{
	m_collisionMargin = radius;
	m_shapeType = CAPSULE_SHAPE_PROXYTYPE;
	m_upAxis = 1;
	m_implicitShapeDimensions.setValue(radius, 0.5f * height, radius);
}

btVector3 btCapsuleShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);

	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}
	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = -getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}

	return supVec;
}

void btCapsuleShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	for (int j = 0; j < numVectors; j++)
	{
		btScalar maxDot(btScalar(-BT_LARGE_FLOAT));
		const btVector3& vec = vectors[j];

		btVector3 vtx;
		btScalar newDot;
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = -getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
	}
}

void btCapsuleShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//as an approximation, take the inertia of the box that bounds the spheres

	btTransform ident;
	ident.setIdentity();

	btScalar radius = getRadius();

	btVector3 halfExtents(radius, radius, radius);
	halfExtents[getUpAxis()] += getHalfHeight();

	btScalar lx = btScalar(2.) * (halfExtents[0]);
	btScalar ly = btScalar(2.) * (halfExtents[1]);
	btScalar lz = btScalar(2.) * (halfExtents[2]);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(.08333333);

	inertia[0] = scaledmass * (y2 + z2);
	inertia[1] = scaledmass * (x2 + z2);
	inertia[2] = scaledmass * (x2 + y2);
}

btCapsuleShapeX::btCapsuleShapeX(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 0;
	m_implicitShapeDimensions.setValue(0.5f * height, radius, radius);
}

btCapsuleShapeZ::btCapsuleShapeZ(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 2;
	m_implicitShapeDimensions.setValue(radius, radius, 0.5f * height);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CAPSULE_SHAPE_H
#define BT_CAPSULE_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
///The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
///The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
ATTRIBUTE_ALIGNED16(class)
btCapsuleShape : public btConvexInternalShape
{
protected:
	int m_upAxis;

protected:
	///only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.
	btCapsuleShape() : btConvexInternalShape() { m_shapeType = CAPSULE_SHAPE_PROXYTYPE; };

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCapsuleShape(btScalar radius, btScalar height);

	///CollisionShape Interface
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	/// btConvexShape Interface
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void setMargin(btScalar collisionMargin)
	{
		//don't override the margin for capsules, their entire radius == margin
		(void)collisionMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		btVector3 halfExtents(getRadius(), getRadius(), getRadius());
		halfExtents[m_upAxis] = getRadius() + getHalfHeight();
		btMatrix3x3 abs_b = t.getBasis().absolute();
		btVector3 center = t.getOrigin();
		btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

		aabbMin = center - extent;
		aabbMax = center + extent;
	}

	virtual const char* getName() const
	{
		return "CapsuleShape";
	}

	int getUpAxis() const
	{
		return m_upAxis;
	}

	btScalar getRadius() const
	{
		int radiusAxis = (m_upAxis + 2) % 3;
		return m_implicitShapeDimensions[radiusAxis];
	}

	btScalar getHalfHeight() const
	{
		return m_implicitShapeDimensions[m_upAxis];
	}

	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 unScaledImplicitShapeDimensions = m_implicitShapeDimensions / m_localScaling;
		btConvexInternalShape::setLocalScaling(scaling);
		m_implicitShapeDimensions = (unScaledImplicitShapeDimensions * scaling);
		//update m_collisionMargin, since entire radius==margin
		int radiusAxis = (m_upAxis + 2) % 3;
		m_collisionMargin = m_implicitShapeDimensions[radiusAxis];
	}

	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		btVector3 aniDir(0, 0, 0);
		aniDir[getUpAxis()] = 1;
		return aniDir;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	SIMD_FORCE_INLINE void deSerializeFloat(struct btCapsuleShapeData * dataBuffer);
};

///btCapsuleShapeX represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeX : public btCapsuleShape
{
public:
	btCapsuleShapeX(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleX";
	}
};

///btCapsuleShapeZ represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeZ : public btCapsuleShape
{
public:
	btCapsuleShapeZ(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleZ";
	}
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btCapsuleShapeData
{
	btConvexInternalShapeData m_convexInternalShapeData;

	int m_upAxis;

	char m_padding[4];
};

SIMD_FORCE_INLINE int btCapsuleShape::calculateSerializeBufferSize() const
{
	return sizeof(btCapsuleShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btCapsuleShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCapsuleShapeData* shapeData = (btCapsuleShapeData*)dataBuffer;

	btConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serializer);

	shapeData->m_upAxis = m_upAxis;

	// Fill padding with zeros to appease msan.
	shapeData->m_padding[0] = 0;
	shapeData->m_padding[1] = 0;
	shapeData->m_padding[2] = 0;
	shapeData->m_padding[3] = 0;

	return "btCapsuleShapeData";
}

SIMD_FORCE_INLINE void btCapsuleShape::deSerializeFloat(btCapsuleShapeData* dataBuffer)
{
	m_implicitShapeDimensions.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_implicitShapeDimensions);
	m_collisionMargin = dataBuffer->m_convexInternalShapeData.m_collisionMargin;
	m_localScaling.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_localScaling);
	//it is best to already pre-allocate the matching btCapsuleShape*(X/Z) version to match m_upAxis
	m_upAxis = dataBuffer->m_upAxis;
}

#endif  //BT_CAPSULE_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

btCollisionObject::btCollisionObject()
	: m_interpolationLinearVelocity(0.f, 0.f, 0.f),
	  m_interpolationAngularVelocity(0.f, 0.f, 0.f),
	  m_anisotropicFriction(1.f, 1.f, 1.f),
	  m_hasAnisotropicFriction(false),
	  m_contactProcessingThreshold(BT_LARGE_FLOAT),
	  m_broadphaseHandle(0),
	  m_collisionShape(0),
	  m_extensionPointer(0),
	  m_rootCollisionShape(0),
	  m_collisionFlags(btCollisionObject::CF_STATIC_OBJECT),
	  m_islandTag1(-1),
	  m_companionId(-1),
	  m_worldArrayIndex(-1),
	  m_activationState1(1),
	  m_deactivationTime(btScalar(0.)),
	  m_friction(btScalar(0.5)),
	  m_restitution(btScalar(0.)),
	  m_rollingFriction(0.0f),
	  m_spinningFriction(0.f),
	  m_contactDamping(.1),
	  m_contactStiffness(BT_LARGE_FLOAT),
	  m_internalType(CO_COLLISION_OBJECT),
	  m_userObjectPointer(0),
	  m_userIndex2(-1),
	  m_userIndex(-1),
	  m_userIndex3(-1),
	  m_hitFraction(btScalar(1.)),
	  m_ccdSweptSphereRadius(btScalar(0.)),
	  m_ccdMotionThreshold(btScalar(0.)),
	  m_checkCollideWith(false),
	  m_updateRevision(0)
{
	m_worldTransform.setIdentity();
	m_interpolationWorldTransform.setIdentity();
}

btCollisionObject::~btCollisionObject()
{
}

void btCollisionObject::setActivationState(int newState) const
{
	if ((m_activationState1 != DISABLE_DEACTIVATION) && (m_activationState1 != DISABLE_SIMULATION))
		m_activationState1 = newState;
}

void btCollisionObject::forceActivationState(int newState) const
{
	m_activationState1 = newState;
}

void btCollisionObject::activate(bool forceActivation) const
{
	if (forceActivation || !(m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT)))
	{
		setActivationState(ACTIVE_TAG);
		m_deactivationTime = btScalar(0.);
	}
}

const char* btCollisionObject::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionObjectData* dataOut = (btCollisionObjectData*)dataBuffer;

	m_worldTransform.serialize(dataOut->m_worldTransform);
	m_interpolationWorldTransform.serialize(dataOut->m_interpolationWorldTransform);
	m_interpolationLinearVelocity.serialize(dataOut->m_interpolationLinearVelocity);
	m_interpolationAngularVelocity.serialize(dataOut->m_interpolationAngularVelocity);
	m_anisotropicFriction.serialize(dataOut->m_anisotropicFriction);
	dataOut->m_hasAnisotropicFriction = m_hasAnisotropicFriction;
	dataOut->m_contactProcessingThreshold = m_contactProcessingThreshold;
	dataOut->m_broadphaseHandle = 0;
	dataOut->m_collisionShape = serializer->getUniquePointer(m_collisionShape);
	dataOut->m_rootCollisionShape = 0;  //@todo
	dataOut->m_collisionFlags = m_collisionFlags;
	dataOut->m_islandTag1 = m_islandTag1;
	dataOut->m_companionId = m_companionId;
	dataOut->m_activationState1 = m_activationState1;
	dataOut->m_deactivationTime = m_deactivationTime;
	dataOut->m_friction = m_friction;
	dataOut->m_rollingFriction = m_rollingFriction;
	dataOut->m_contactDamping = m_contactDamping;
	dataOut->m_contactStiffness = m_contactStiffness;
	dataOut->m_restitution = m_restitution;
	dataOut->m_internalType = m_internalType;

	char* name = (char*)serializer->findNameForPointer(this);
	dataOut->m_name = (char*)serializer->getUniquePointer(name);
	if (dataOut->m_name)
	{
		serializer->serializeName(name);
	}
	dataOut->m_hitFraction = m_hitFraction;
	dataOut->m_ccdSweptSphereRadius = m_ccdSweptSphereRadius;
	dataOut->m_ccdMotionThreshold = m_ccdMotionThreshold;
	dataOut->m_checkCollideWith = m_checkCollideWith;
	if (m_broadphaseHandle)
	{
		dataOut->m_collisionFilterGroup = m_broadphaseHandle->m_collisionFilterGroup;
		dataOut->m_collisionFilterMask = m_broadphaseHandle->m_collisionFilterMask;
		dataOut->m_uniqueId = m_broadphaseHandle->m_uniqueId;
	}
	else
	{
		dataOut->m_collisionFilterGroup = 0;
		dataOut->m_collisionFilterMask = 0;
		dataOut->m_uniqueId = -1;
	}
	return btCollisionObjectDataName;
}

void btCollisionObject::serializeSingleObject(class btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_COLLISIONOBJECT_CODE, (void*)this);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_OBJECT_H
#define BT_COLLISION_OBJECT_H

#include "LinearMath/btTransform.h"

//island management, m_activationState1
#define ACTIVE_TAG 1
#define ISLAND_SLEEPING 2
#define WANTS_DEACTIVATION 3
#define DISABLE_DEACTIVATION 4
#define DISABLE_SIMULATION 5
#define FIXED_BASE_MULTI_BODY 6

struct btBroadphaseProxy;
class btCollisionShape;
struct btCollisionShapeData;
#include "LinearMath/btMotionState.h"
#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btAlignedObjectArray.h"

typedef btAlignedObjectArray<class btCollisionObject*> btCollisionObjectArray;

#ifdef BT_USE_DOUBLE_PRECISION
#define btCollisionObjectData btCollisionObjectDoubleData
#define btCollisionObjectDataName "btCollisionObjectDoubleData"
#else
#define btCollisionObjectData btCollisionObjectFloatData
#define btCollisionObjectDataName "btCollisionObjectFloatData"
#endif

/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
ATTRIBUTE_ALIGNED16(class)
btCollisionObject
{
protected:
	btTransform m_worldTransform;

	///m_interpolationWorldTransform is used for CCD and interpolation
	///it can be either previous or future (predicted) transform
	btTransform m_interpolationWorldTransform;
	//those two are experimental: just added for bullet time effect, so you can still apply impulses (directly modifying velocities)
	//without destroying the continuous interpolated motion (which uses this interpolation velocities)
	btVector3 m_interpolationLinearVelocity;
	btVector3 m_interpolationAngularVelocity;

	btVector3 m_anisotropicFriction;
	int m_hasAnisotropicFriction;
	btScalar m_contactProcessingThreshold;

	btBroadphaseProxy* m_broadphaseHandle;
	btCollisionShape* m_collisionShape;
	///m_extensionPointer is used by some internal low-level Bullet extensions.
	void* m_extensionPointer;

	///m_rootCollisionShape is temporarily used to store the original collision shape
	///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
	///If it is NULL, the m_collisionShape is not temporarily replaced.
	btCollisionShape* m_rootCollisionShape;

	int m_collisionFlags;

	int m_islandTag1;
	int m_companionId;
	int m_worldArrayIndex;  // index of object in world's collisionObjects array

	mutable int m_activationState1;
	mutable btScalar m_deactivationTime;

	btScalar m_friction;
	btScalar m_restitution;
	btScalar m_rollingFriction;   //torsional friction orthogonal to contact normal (useful to stop spheres rolling forever)
	btScalar m_spinningFriction;  // torsional friction around the contact normal (useful for grasping)
	btScalar m_contactDamping;
	btScalar m_contactStiffness;

	///m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
	///do not assign your own m_internalType unless you write a new dynamics object class.
	int m_internalType;

	///users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer

	void* m_userObjectPointer;

	int m_userIndex2;

	int m_userIndex;

	int m_userIndex3;

	///time of impact calculation
	btScalar m_hitFraction;

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar m_ccdSweptSphereRadius;

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	btScalar m_ccdMotionThreshold;

	/// If some object should have elaborate collision filtering by sub-classes
	int m_checkCollideWith;

	btAlignedObjectArray<const btCollisionObject*> m_objectsWithoutCollisionCheck;

	///internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
	int m_updateRevision;

	btVector3 m_customDebugColorRGB;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	enum CollisionFlags
	{
		CF_DYNAMIC_OBJECT = 0,
		CF_STATIC_OBJECT = 1,
		CF_KINEMATIC_OBJECT = 2,
		CF_NO_CONTACT_RESPONSE = 4,
		CF_CUSTOM_MATERIAL_CALLBACK = 8,  //this allows per-triangle material (friction/restitution)
		CF_CHARACTER_OBJECT = 16,
		CF_DISABLE_VISUALIZE_OBJECT = 32,          //disable debug drawing
		CF_DISABLE_SPU_COLLISION_PROCESSING = 64,  //disable parallel/SPU processing
		CF_HAS_CONTACT_STIFFNESS_DAMPING = 128,
		CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR = 256,
		CF_HAS_FRICTION_ANCHOR = 512,
		CF_HAS_COLLISION_SOUND_TRIGGER = 1024
	};

	enum CollisionObjectTypes
	{
		CO_COLLISION_OBJECT = 1,
		CO_RIGID_BODY = 2,
		///CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
		///It is useful for collision sensors, explosion objects, character controller etc.
		CO_GHOST_OBJECT = 4,
		CO_SOFT_BODY = 8,
		CO_HF_FLUID = 16,
		CO_USER_TYPE = 32,
		CO_FEATHERSTONE_LINK = 64
	};

	enum AnisotropicFrictionFlags
	{
		CF_ANISOTROPIC_FRICTION_DISABLED = 0,
		CF_ANISOTROPIC_FRICTION = 1,
		CF_ANISOTROPIC_ROLLING_FRICTION = 2
	};

	SIMD_FORCE_INLINE bool mergesSimulationIslands() const
	{
		///static objects, kinematic and object without contact response don't merge islands
		return ((m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT | CF_NO_CONTACT_RESPONSE)) == 0);
	}

	const btVector3& getAnisotropicFriction() const
	{
		return m_anisotropicFriction;
	}
	void setAnisotropicFriction(const btVector3& anisotropicFriction, int frictionMode = CF_ANISOTROPIC_FRICTION)
	{
		m_anisotropicFriction = anisotropicFriction;
		bool isUnity = (anisotropicFriction[0] != 1.f) || (anisotropicFriction[1] != 1.f) || (anisotropicFriction[2] != 1.f);
		m_hasAnisotropicFriction = isUnity ? frictionMode : 0;
	}
	bool hasAnisotropicFriction(int frictionMode = CF_ANISOTROPIC_FRICTION) const
	{
		return (m_hasAnisotropicFriction & frictionMode) != 0;
	}

	///the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
	///Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges
	void setContactProcessingThreshold(btScalar contactProcessingThreshold)
	{
		m_contactProcessingThreshold = contactProcessingThreshold;
	}
	btScalar getContactProcessingThreshold() const
	{
		return m_contactProcessingThreshold;
	}

	SIMD_FORCE_INLINE bool isStaticObject() const
	{
		return (m_collisionFlags & CF_STATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isKinematicObject() const
	{
		return (m_collisionFlags & CF_KINEMATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isStaticOrKinematicObject() const
	{
		return (m_collisionFlags & (CF_KINEMATIC_OBJECT | CF_STATIC_OBJECT)) != 0;
	}

	SIMD_FORCE_INLINE bool hasContactResponse() const
	{
		return (m_collisionFlags & CF_NO_CONTACT_RESPONSE) == 0;
	}

	btCollisionObject();

	virtual ~btCollisionObject();

	virtual void setCollisionShape(btCollisionShape * collisionShape)
	{
		m_updateRevision++;
		m_collisionShape = collisionShape;
		m_rootCollisionShape = collisionShape;
	}

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setIgnoreCollisionCheck(const btCollisionObject* co, bool ignoreCollisionCheck)
	{
		if (ignoreCollisionCheck)
		{
			//We don't check for duplicates. Is it ok to leave that up to the user of this API?
			//int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
			//if (index == m_objectsWithoutCollisionCheck.size())
			//{
			m_objectsWithoutCollisionCheck.push_back(co);
			//}
		}
		else
		{
			m_objectsWithoutCollisionCheck.remove(co);
		}
		m_checkCollideWith = m_objectsWithoutCollisionCheck.size() > 0;
	}

        int getNumObjectsWithoutCollision() const
	{
		return m_objectsWithoutCollisionCheck.size();
	}

	const btCollisionObject* getObjectWithoutCollision(int index)
	{
		return m_objectsWithoutCollisionCheck[index];
	}

	virtual bool checkCollideWithOverride(const btCollisionObject* co) const
	{
		int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
		if (index < m_objectsWithoutCollisionCheck.size())
		{
			return false;
		}
		return true;
	}

	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void* internalGetExtensionPointer() const
	{
		return m_extensionPointer;
	}
	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void internalSetExtensionPointer(void* pointer)
	{
		m_extensionPointer = pointer;
	}

	SIMD_FORCE_INLINE int getActivationState() const { return m_activationState1; }

	void setActivationState(int newState) const;

	void setDeactivationTime(btScalar time)
	{
		m_deactivationTime = time;
	}
	btScalar getDeactivationTime() const
	{
		return m_deactivationTime;
	}

	void forceActivationState(int newState) const;

	void activate(bool forceActivation = false) const;

	SIMD_FORCE_INLINE bool isActive() const
	{
		return ((getActivationState() != FIXED_BASE_MULTI_BODY) && (getActivationState() != ISLAND_SLEEPING) && (getActivationState() != DISABLE_SIMULATION));
	}

	void setRestitution(btScalar rest)
	{
		m_updateRevision++;
		m_restitution = rest;
	}
	btScalar getRestitution() const
	{
		return m_restitution;
	}
	void setFriction(btScalar frict)
	{
		m_updateRevision++;
		m_friction = frict;
	}
	btScalar getFriction() const
	{
		return m_friction;
	}

	void setRollingFriction(btScalar frict)
	{
		m_updateRevision++;
		m_rollingFriction = frict;
	}
	btScalar getRollingFriction() const
	{
		return m_rollingFriction;
	}
	void setSpinningFriction(btScalar frict)
	{
		m_updateRevision++;
		m_spinningFriction = frict;
	}
	btScalar getSpinningFriction() const
	{
		return m_spinningFriction;
	}
	void setContactStiffnessAndDamping(btScalar stiffness, btScalar damping)
	{
		m_updateRevision++;
		m_contactStiffness = stiffness;
		m_contactDamping = damping;

		m_collisionFlags |= CF_HAS_CONTACT_STIFFNESS_DAMPING;

		//avoid divisions by zero...
		if (m_contactStiffness < SIMD_EPSILON)
		{
			m_contactStiffness = SIMD_EPSILON;
		}
	}

	btScalar getContactStiffness() const
	{
		return m_contactStiffness;
	}

	btScalar getContactDamping() const
	{
		return m_contactDamping;
	}

	///reserved for Bullet internal usage
	int getInternalType() const
	{
		return m_internalType;
	}

	btTransform& getWorldTransform()
	{
		return m_worldTransform;
	}

	const btTransform& getWorldTransform() const
	{
		return m_worldTransform;
	}

	void setWorldTransform(const btTransform& worldTrans)
	{
		m_updateRevision++;
		m_worldTransform = worldTrans;
	}

	SIMD_FORCE_INLINE btBroadphaseProxy* getBroadphaseHandle()
	{
		return m_broadphaseHandle;
	}

	SIMD_FORCE_INLINE const btBroadphaseProxy* getBroadphaseHandle() const
	{
		return m_broadphaseHandle;
	}

	void setBroadphaseHandle(btBroadphaseProxy * handle)
	{
		m_broadphaseHandle = handle;
	}

	const btTransform& getInterpolationWorldTransform() const
	{
		return m_interpolationWorldTransform;
	}

	btTransform& getInterpolationWorldTransform()
	{
		return m_interpolationWorldTransform;
	}

	void setInterpolationWorldTransform(const btTransform& trans)
	{
		m_updateRevision++;
		m_interpolationWorldTransform = trans;
	}

	void setInterpolationLinearVelocity(const btVector3& linvel)
	{
		m_updateRevision++;
		m_interpolationLinearVelocity = linvel;
	}

	void setInterpolationAngularVelocity(const btVector3& angvel)
	{
		m_updateRevision++;
		m_interpolationAngularVelocity = angvel;
	}

	const btVector3& getInterpolationLinearVelocity() const
	{
		return m_interpolationLinearVelocity;
	}

	const btVector3& getInterpolationAngularVelocity() const
	{
		return m_interpolationAngularVelocity;
	}

	SIMD_FORCE_INLINE int getIslandTag() const
	{
		return m_islandTag1;
	}

	void setIslandTag(int tag)
	{
		m_islandTag1 = tag;
	}

	SIMD_FORCE_INLINE int getCompanionId() const
	{
		return m_companionId;
	}

	void setCompanionId(int id)
	{
		m_companionId = id;
	}

	SIMD_FORCE_INLINE int getWorldArrayIndex() const
	{
		return m_worldArrayIndex;
	}

	// only should be called by CollisionWorld
	void setWorldArrayIndex(int ix)
	{
		m_worldArrayIndex = ix;
	}

	SIMD_FORCE_INLINE btScalar getHitFraction() const
	{
		return m_hitFraction;
	}

	void setHitFraction(btScalar hitFraction)
	{
		m_hitFraction = hitFraction;
	}

	SIMD_FORCE_INLINE int getCollisionFlags() const
	{
		return m_collisionFlags;
	}

	void setCollisionFlags(int flags)
	{
		m_collisionFlags = flags;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar getCcdSweptSphereRadius() const
	{
		return m_ccdSweptSphereRadius;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	void setCcdSweptSphereRadius(btScalar radius)
	{
		m_ccdSweptSphereRadius = radius;
	}

	btScalar getCcdMotionThreshold() const
	{
		return m_ccdMotionThreshold;
	}

	btScalar getCcdSquareMotionThreshold() const
	{
		return m_ccdMotionThreshold * m_ccdMotionThreshold;
	}

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	void setCcdMotionThreshold(btScalar ccdMotionThreshold)
	{
		m_ccdMotionThreshold = ccdMotionThreshold;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void* getUserPointer() const
	{
		return m_userObjectPointer;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	int getUserIndex3() const
	{
		return m_userIndex3;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserPointer(void* userPointer)
	{
		m_userObjectPointer = userPointer;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	void setUserIndex3(int index)
	{
		m_userIndex3 = index;
	}

	int getUpdateRevisionInternal() const
	{
		return m_updateRevision;
	}

	void setCustomDebugColor(const btVector3& colorRGB)
	{
		m_customDebugColorRGB = colorRGB;
		m_collisionFlags |= CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	void removeCustomDebugColor()
	{
		m_collisionFlags &= ~CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	bool getCustomDebugColor(btVector3 & colorRGB) const
	{
		bool hasCustomColor = (0 != (m_collisionFlags & CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR));
		if (hasCustomColor)
		{
			colorRGB = m_customDebugColorRGB;
		}
		return hasCustomColor;
	}

	inline bool checkCollideWith(const btCollisionObject* co) const
	{
		if (m_checkCollideWith)
			return checkCollideWithOverride(co);

		return true;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer * serializer) const;
};

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectDoubleData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformDoubleData	m_worldTransform;
	btTransformDoubleData	m_interpolationWorldTransform;
	btVector3DoubleData		m_interpolationLinearVelocity;
	btVector3DoubleData		m_interpolationAngularVelocity;
	btVector3DoubleData		m_anisotropicFriction;
	double					m_contactProcessingThreshold;	
	double					m_deactivationTime;
	double					m_friction;
	double					m_rollingFriction;
	double                  m_contactDamping;
	double                  m_contactStiffness;
	double					m_restitution;
	double					m_hitFraction; 
	double					m_ccdSweptSphereRadius;
	double					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;//m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectFloatData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformFloatData	m_worldTransform;
	btTransformFloatData	m_interpolationWorldTransform;
	btVector3FloatData		m_interpolationLinearVelocity;
	btVector3FloatData		m_interpolationAngularVelocity;
	btVector3FloatData		m_anisotropicFriction;
	float					m_contactProcessingThreshold;	
	float					m_deactivationTime;
	float					m_friction;
	float					m_rollingFriction;
	float                   m_contactDamping;
    float                   m_contactStiffness;
	float					m_restitution;
	float					m_hitFraction; 
	float					m_ccdSweptSphereRadius;
	float					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;
};
// clang-format on

SIMD_FORCE_INLINE int btCollisionObject::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionObjectData);
}

#endif  //BT_COLLISION_OBJECT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMotionState.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "LinearMath/btSerializer.h"

//'temporarily' global variables
btScalar gDeactivationTime = btScalar(2.);
bool gDisableDeactivation = false;
static int uniqueId = 0;

btRigidBody::btRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	setupRigidBody(constructionInfo);
}

btRigidBody::btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia)
{
	btRigidBodyConstructionInfo cinfo(mass, motionState, collisionShape, localInertia);
	setupRigidBody(cinfo);
}

void btRigidBody::setupRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	m_internalType = CO_RIGID_BODY;

	m_linearVelocity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	m_angularFactor.setValue(1, 1, 1);
	m_linearFactor.setValue(1, 1, 1);
	m_gravity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_gravity_acceleration.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0)),
		setDamping(constructionInfo.m_linearDamping, constructionInfo.m_angularDamping);

	m_linearSleepingThreshold = constructionInfo.m_linearSleepingThreshold;
	m_angularSleepingThreshold = constructionInfo.m_angularSleepingThreshold;
	m_optionalMotionState = constructionInfo.m_motionState;
	m_contactSolverType = 0;
	m_frictionSolverType = 0;
	m_additionalDamping = constructionInfo.m_additionalDamping;
	m_additionalDampingFactor = constructionInfo.m_additionalDampingFactor;
	m_additionalLinearDampingThresholdSqr = constructionInfo.m_additionalLinearDampingThresholdSqr;
	m_additionalAngularDampingThresholdSqr = constructionInfo.m_additionalAngularDampingThresholdSqr;
	m_additionalAngularDampingFactor = constructionInfo.m_additionalAngularDampingFactor;

	if (m_optionalMotionState)
	{
		m_optionalMotionState->getWorldTransform(m_worldTransform);
	}
	else
	{
		m_worldTransform = constructionInfo.m_startWorldTransform;
	}

	m_interpolationWorldTransform = m_worldTransform;
	m_interpolationLinearVelocity.setValue(0, 0, 0);
	m_interpolationAngularVelocity.setValue(0, 0, 0);

	//moved to btCollisionObject
	m_friction = constructionInfo.m_friction;
	m_rollingFriction = constructionInfo.m_rollingFriction;
	m_spinningFriction = constructionInfo.m_spinningFriction;

	m_restitution = constructionInfo.m_restitution;

	setCollisionShape(constructionInfo.m_collisionShape);
	m_debugBodyId = uniqueId++;

	setMassProps(constructionInfo.m_mass, constructionInfo.m_localInertia);
	updateInertiaTensor();

	m_rigidbodyFlags = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;

	m_deltaLinearVelocity.setZero();
	m_deltaAngularVelocity.setZero();
	m_invMass = m_inverseMass * m_linearFactor;
	m_pushVelocity.setZero();
	m_turnVelocity.setZero();
}

void btRigidBody::predictIntegratedTransform(btScalar timeStep, btTransform& predictedTransform)
{
	btTransformUtil::integrateTransform(m_worldTransform, m_linearVelocity, m_angularVelocity, timeStep, predictedTransform);
}

void btRigidBody::saveKinematicState(btScalar timeStep)
{
	//todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities
	if (timeStep != btScalar(0.))
	{
		//if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform
		if (getMotionState())
			getMotionState()->getWorldTransform(m_worldTransform);
		btVector3 linVel, angVel;

		btTransformUtil::calculateVelocity(m_interpolationWorldTransform, m_worldTransform, timeStep, m_linearVelocity, m_angularVelocity);
		m_interpolationLinearVelocity = m_linearVelocity;
		m_interpolationAngularVelocity = m_angularVelocity;
		m_interpolationWorldTransform = m_worldTransform;
		//printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());
	}
}

void btRigidBody::getAabb(btVector3& aabbMin, btVector3& aabbMax) const
{
	getCollisionShape()->getAabb(m_worldTransform, aabbMin, aabbMax);
}

void btRigidBody::setGravity(const btVector3& acceleration)
{
	if (m_inverseMass != btScalar(0.0))
	{
		m_gravity = acceleration * (btScalar(1.0) / m_inverseMass);
	}
	m_gravity_acceleration = acceleration;
}

void btRigidBody::setDamping(btScalar lin_damping, btScalar ang_damping)
{
#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearDamping = btMax(lin_damping, btScalar(0.0));
	m_angularDamping = btMax(ang_damping, btScalar(0.0));
#else
	m_linearDamping = btClamped(lin_damping, btScalar(0.0), btScalar(1.0));
	m_angularDamping = btClamped(ang_damping, btScalar(0.0), btScalar(1.0));
#endif
}

///applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping
void btRigidBody::applyDamping(btScalar timeStep)
{
	//On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74
	//todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway

#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearVelocity *= btMax((btScalar(1.0) - timeStep * m_linearDamping), btScalar(0.0));
	m_angularVelocity *= btMax((btScalar(1.0) - timeStep * m_angularDamping), btScalar(0.0));
#else
	m_linearVelocity *= btPow(btScalar(1) - m_linearDamping, timeStep);
	m_angularVelocity *= btPow(btScalar(1) - m_angularDamping, timeStep);
#endif

	if (m_additionalDamping)
	{
		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		if ((m_angularVelocity.length2() < m_additionalAngularDampingThresholdSqr) &&
			(m_linearVelocity.length2() < m_additionalLinearDampingThresholdSqr))
		{
			m_angularVelocity *= m_additionalDampingFactor;
			m_linearVelocity *= m_additionalDampingFactor;
		}

		btScalar speed = m_linearVelocity.length();
		if (speed < m_linearDamping)
		{
			btScalar dampVel = btScalar(0.005);
			if (speed > dampVel)
			{
				btVector3 dir = m_linearVelocity.normalized();
				m_linearVelocity -= dir * dampVel;
			}
			else
			{
				m_linearVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}

		btScalar angSpeed = m_angularVelocity.length();
		if (angSpeed < m_angularDamping)
		{
			btScalar angDampVel = btScalar(0.005);
			if (angSpeed > angDampVel)
			{
				btVector3 dir = m_angularVelocity.normalized();
				m_angularVelocity -= dir * angDampVel;
			}
			else
			{
				m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}
	}
}

void btRigidBody::applyGravity()
{
	if (isStaticOrKinematicObject())
		return;

	applyCentralForce(m_gravity);
}

void btRigidBody::clearGravity()
{
    if (isStaticOrKinematicObject())
        return;
    
    applyCentralForce(-m_gravity);
}

void btRigidBody::proceedToTransform(const btTransform& newTrans)
{
	setCenterOfMassTransform(newTrans);
}

void btRigidBody::setMassProps(btScalar mass, const btVector3& inertia)
{
	if (mass == btScalar(0.))
	{
		m_collisionFlags |= btCollisionObject::CF_STATIC_OBJECT;
		m_inverseMass = btScalar(0.);
	}
	else
	{
		m_collisionFlags &= (~btCollisionObject::CF_STATIC_OBJECT);
		m_inverseMass = btScalar(1.0) / mass;
	}

	//Fg = m * a
	m_gravity = mass * m_gravity_acceleration;

	m_invInertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
							   inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
							   inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));

	m_invMass = m_linearFactor * m_inverseMass;
}

void btRigidBody::updateInertiaTensor()
{
	m_invInertiaTensorWorld = m_worldTransform.getBasis().scaled(m_invInertiaLocal) * m_worldTransform.getBasis().transpose();
}

btVector3 btRigidBody::getLocalInertia() const
{
	btVector3 inertiaLocal;
	const btVector3 inertia = m_invInertiaLocal;
	inertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
						  inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
						  inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));
	return inertiaLocal;
}

inline btVector3 evalEulerEqn(const btVector3& w1, const btVector3& w0, const btVector3& T, const btScalar dt,
							  const btMatrix3x3& I)
{
	const btVector3 w2 = I * w1 + w1.cross(I * w1) * dt - (T * dt + I * w0);
	return w2;
}

inline btMatrix3x3 evalEulerEqnDeriv(const btVector3& w1, const btVector3& w0, const btScalar dt,
									 const btMatrix3x3& I)
{
	btMatrix3x3 w1x, Iw1x;
	const btVector3 Iwi = (I * w1);
	w1.getSkewSymmetricMatrix(&w1x[0], &w1x[1], &w1x[2]);
	Iwi.getSkewSymmetricMatrix(&Iw1x[0], &Iw1x[1], &Iw1x[2]);

	const btMatrix3x3 dfw1 = I + (w1x * I - Iw1x) * dt;
	return dfw1;
}

btVector3 btRigidBody::computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const
{
	btVector3 inertiaLocal = getLocalInertia();
	btMatrix3x3 inertiaTensorWorld = getWorldTransform().getBasis().scaled(inertiaLocal) * getWorldTransform().getBasis().transpose();
	btVector3 tmp = inertiaTensorWorld * getAngularVelocity();
	btVector3 gf = getAngularVelocity().cross(tmp);
	btScalar l2 = gf.length2();
	if (l2 > maxGyroscopicForce * maxGyroscopicForce)
	{
		gf *= btScalar(1.) / btSqrt(l2) * maxGyroscopicForce;
	}
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_Body(btScalar step) const
{
	btVector3 idl = getLocalInertia();
	btVector3 omega1 = getAngularVelocity();
	btQuaternion q = getWorldTransform().getRotation();

	// Convert to body coordinates
	btVector3 omegab = quatRotate(q.inverse(), omega1);
	btMatrix3x3 Ib;
	Ib.setValue(idl.x(), 0, 0,
				0, idl.y(), 0,
				0, 0, idl.z());

	btVector3 ibo = Ib * omegab;

	// Residual vector
	btVector3 f = step * omegab.cross(ibo);

	btMatrix3x3 skew0;
	omegab.getSkewSymmetricMatrix(&skew0[0], &skew0[1], &skew0[2]);
	btVector3 om = Ib * omegab;
	btMatrix3x3 skew1;
	om.getSkewSymmetricMatrix(&skew1[0], &skew1[1], &skew1[2]);

	// Jacobian
	btMatrix3x3 J = Ib + (skew0 * Ib - skew1) * step;

	//	btMatrix3x3 Jinv = J.inverse();
	//	btVector3 omega_div = Jinv*f;
	btVector3 omega_div = J.solve33(f);

	// Single Newton-Raphson update
	omegab = omegab - omega_div;  //Solve33(J, f);
	// Back to world coordinates
	btVector3 omega2 = quatRotate(q, omegab);
	btVector3 gf = omega2 - omega1;
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_World(btScalar step) const
{
	// use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.
	// calculate using implicit euler step so it's stable.

	const btVector3 inertiaLocal = getLocalInertia();
	const btVector3 w0 = getAngularVelocity();

	btMatrix3x3 I;

	I = m_worldTransform.getBasis().scaled(inertiaLocal) *
		m_worldTransform.getBasis().transpose();

	// use newtons method to find implicit solution for new angular velocity (w')
	// f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0
	// df/dw' = I + 1xIw'*step + w'xI*step

	btVector3 w1 = w0;

	// one step of newton's method
	{
		const btVector3 fw = evalEulerEqn(w1, w0, btVector3(0, 0, 0), step, I);
		const btMatrix3x3 dfw = evalEulerEqnDeriv(w1, w0, step, I);

		btVector3 dw;
		dw = dfw.solve33(fw);
		//const btMatrix3x3 dfw_inv = dfw.inverse();
		//dw = dfw_inv*fw;

		w1 -= dw;
	}

	btVector3 gf = (w1 - w0);
	return gf;
}

void btRigidBody::integrateVelocities(btScalar step)
{
	if (isStaticOrKinematicObject())
		return;

	m_linearVelocity += m_totalForce * (m_inverseMass * step);
	m_angularVelocity += m_invInertiaTensorWorld * m_totalTorque * step;

#define MAX_ANGVEL SIMD_HALF_PI
	/// clamp angular velocity. collision calculations will fail on higher angular velocities
	btScalar angvel = m_angularVelocity.length();
	if (angvel * step > MAX_ANGVEL)
	{
		m_angularVelocity *= (MAX_ANGVEL / step) / angvel;
	}
	#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
	clampVelocity(m_angularVelocity);
	#endif
}

btQuaternion btRigidBody::getOrientation() const
{
	btQuaternion orn;
	m_worldTransform.getBasis().getRotation(orn);
	return orn;
}

void btRigidBody::setCenterOfMassTransform(const btTransform& xform)
{
	if (isKinematicObject())
	{
		m_interpolationWorldTransform = m_worldTransform;
	}
	else
	{
		m_interpolationWorldTransform = xform;
	}
	m_interpolationLinearVelocity = getLinearVelocity();
	m_interpolationAngularVelocity = getAngularVelocity();
	m_worldTransform = xform;
	updateInertiaTensor();
}

void btRigidBody::addConstraintRef(btTypedConstraint* c)
{
	///disable collision with the 'other' body

	int index = m_constraintRefs.findLinearSearch(c);
	//don't add constraints that are already referenced
	//btAssert(index == m_constraintRefs.size());
	if (index == m_constraintRefs.size())
	{
		m_constraintRefs.push_back(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, true);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, true);
		}
	}
}

void btRigidBody::removeConstraintRef(btTypedConstraint* c)
{
	int index = m_constraintRefs.findLinearSearch(c);
	//don't remove constraints that are not referenced
	if (index < m_constraintRefs.size())
	{
		m_constraintRefs.remove(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, false);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, false);
		}
	}
}

int btRigidBody::calculateSerializeBufferSize() const
{
	int sz = sizeof(btRigidBodyData);
	return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btRigidBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
	btRigidBodyData* rbd = (btRigidBodyData*)dataBuffer;

	btCollisionObject::serialize(&rbd->m_collisionObjectData, serializer);

	m_invInertiaTensorWorld.serialize(rbd->m_invInertiaTensorWorld);
	m_linearVelocity.serialize(rbd->m_linearVelocity);
	m_angularVelocity.serialize(rbd->m_angularVelocity);
	rbd->m_inverseMass = m_inverseMass;
	m_angularFactor.serialize(rbd->m_angularFactor);
	m_linearFactor.serialize(rbd->m_linearFactor);
	m_gravity.serialize(rbd->m_gravity);
	m_gravity_acceleration.serialize(rbd->m_gravity_acceleration);
	m_invInertiaLocal.serialize(rbd->m_invInertiaLocal);
	m_totalForce.serialize(rbd->m_totalForce);
	m_totalTorque.serialize(rbd->m_totalTorque);
	rbd->m_linearDamping = m_linearDamping;
	rbd->m_angularDamping = m_angularDamping;
	rbd->m_additionalDamping = m_additionalDamping;
	rbd->m_additionalDampingFactor = m_additionalDampingFactor;
	rbd->m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;
	rbd->m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;
	rbd->m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;
	rbd->m_linearSleepingThreshold = m_linearSleepingThreshold;
	rbd->m_angularSleepingThreshold = m_angularSleepingThreshold;

	// Fill padding with zeros to appease msan.
#ifdef BT_USE_DOUBLE_PRECISION
	memset(rbd->m_padding, 0, sizeof(rbd->m_padding));
#endif

	return btRigidBodyDataName;
}

void btRigidBody::serializeSingleObject(class btSerializer* serializer) const
{
	btChunk* chunk = serializer->allocate(calculateSerializeBufferSize(), 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, (void*)this);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_RIGIDBODY_H
#define BT_RIGIDBODY_H

#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

class btCollisionShape;
class btMotionState;
class btTypedConstraint;

extern btScalar gDeactivationTime;
extern bool gDisableDeactivation;

#ifdef BT_USE_DOUBLE_PRECISION
#define btRigidBodyData btRigidBodyDoubleData
#define btRigidBodyDataName "btRigidBodyDoubleData"
#else
#define btRigidBodyData btRigidBodyFloatData
#define btRigidBodyDataName "btRigidBodyFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

enum btRigidBodyFlags
{
	BT_DISABLE_WORLD_GRAVITY = 1,
	///BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
	///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
	///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
	BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT = 2,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD = 4,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY = 8,
	BT_ENABLE_GYROPSCOPIC_FORCE = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY,
};

///The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
///It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
///There are 3 types of rigid bodies:
///- A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
///- B) Fixed objects with zero mass. They are not moving (basically collision objects)
///- C) Kinematic objects, which are objects without mass, but the user can move them. There is one-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
///Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
///Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
class btRigidBody : public btCollisionObject
{
	btMatrix3x3 m_invInertiaTensorWorld;
	btVector3 m_linearVelocity;
	btVector3 m_angularVelocity;
	btScalar m_inverseMass;
	btVector3 m_linearFactor;

	btVector3 m_gravity;
	btVector3 m_gravity_acceleration;
	btVector3 m_invInertiaLocal;
	btVector3 m_totalForce;
	btVector3 m_totalTorque;

	btScalar m_linearDamping;
	btScalar m_angularDamping;

	bool m_additionalDamping;
	btScalar m_additionalDampingFactor;
	btScalar m_additionalLinearDampingThresholdSqr;
	btScalar m_additionalAngularDampingThresholdSqr;
	btScalar m_additionalAngularDampingFactor;

	btScalar m_linearSleepingThreshold;
	btScalar m_angularSleepingThreshold;

	//m_optionalMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* m_optionalMotionState;

	//keep track of typed constraints referencing this rigid body, to disable collision between linked bodies
	btAlignedObjectArray<btTypedConstraint*> m_constraintRefs;

	int m_rigidbodyFlags;

	int m_debugBodyId;

protected:
	ATTRIBUTE_ALIGNED16(btVector3 m_deltaLinearVelocity);
	btVector3 m_deltaAngularVelocity;
	btVector3 m_angularFactor;
	btVector3 m_invMass;
	btVector3 m_pushVelocity;
	btVector3 m_turnVelocity;

public:
	///The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
	///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
	///You can use the motion state to synchronize the world transform between physics and graphics objects.
	///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
	///m_startWorldTransform is only used when you don't provide a motion state.
	struct btRigidBodyConstructionInfo
	{
		btScalar m_mass;

		///When a motionState is provided, the rigid body will initialize its world transform from the motion state
		///In this case, m_startWorldTransform is ignored.
		btMotionState* m_motionState;
		btTransform m_startWorldTransform;

		btCollisionShape* m_collisionShape;
		btVector3 m_localInertia;
		btScalar m_linearDamping;
		btScalar m_angularDamping;

		///best simulation results when friction is non-zero
		btScalar m_friction;
		///the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
		///See Bullet/Demos/RollingFrictionDemo for usage
		btScalar m_rollingFriction;
		btScalar m_spinningFriction;  //torsional friction around contact normal

		///best simulation results using zero restitution.
		btScalar m_restitution;

		btScalar m_linearSleepingThreshold;
		btScalar m_angularSleepingThreshold;

		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		bool m_additionalDamping;
		btScalar m_additionalDampingFactor;
		btScalar m_additionalLinearDampingThresholdSqr;
		btScalar m_additionalAngularDampingThresholdSqr;
		btScalar m_additionalAngularDampingFactor;

		btRigidBodyConstructionInfo(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0)) : m_mass(mass),
																																									   m_motionState(motionState),
																																									   m_collisionShape(collisionShape),
																																									   m_localInertia(localInertia),
																																									   m_linearDamping(btScalar(0.)),
																																									   m_angularDamping(btScalar(0.)),
																																									   m_friction(btScalar(0.5)),
																																									   m_rollingFriction(btScalar(0)),
																																									   m_spinningFriction(btScalar(0)),
																																									   m_restitution(btScalar(0.)),
																																									   m_linearSleepingThreshold(btScalar(0.8)),
																																									   m_angularSleepingThreshold(btScalar(1.f)),
																																									   m_additionalDamping(false),
																																									   m_additionalDampingFactor(btScalar(0.005)),
																																									   m_additionalLinearDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingFactor(btScalar(0.01))
		{
			m_startWorldTransform.setIdentity();
		}
	};

	///btRigidBody constructor using construction info
	btRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

	///btRigidBody constructor for backwards compatibility.
	///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
	btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0));

	virtual ~btRigidBody()
	{
		//No constraints should point to this rigidbody
		//Remove constraints from the dynamics world before you delete the related rigidbodies.
		btAssert(m_constraintRefs.size() == 0);
	}

protected:
	///setupRigidBody is only used internally by the constructor
	void setupRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

public:
	void proceedToTransform(const btTransform& newTrans);

	///to keep collision detection and dynamics separate we don't store a rigidbody pointer
	///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
	static const btRigidBody* upcast(const btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (const btRigidBody*)colObj;
		return 0;
	}
	static btRigidBody* upcast(btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (btRigidBody*)colObj;
		return 0;
	}

	/// continuous collision detection needs prediction
	void predictIntegratedTransform(btScalar step, btTransform& predictedTransform);

	void saveKinematicState(btScalar step);

	void applyGravity();
    
    void clearGravity();

	void setGravity(const btVector3& acceleration);

	const btVector3& getGravity() const
	{
		return m_gravity_acceleration;
	}

	void setDamping(btScalar lin_damping, btScalar ang_damping);

	btScalar getLinearDamping() const
	{
		return m_linearDamping;
	}

	btScalar getAngularDamping() const
	{
		return m_angularDamping;
	}

	btScalar getLinearSleepingThreshold() const
	{
		return m_linearSleepingThreshold;
	}

	btScalar getAngularSleepingThreshold() const
	{
		return m_angularSleepingThreshold;
	}

	void applyDamping(btScalar timeStep);

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setMassProps(btScalar mass, const btVector3& inertia);

	const btVector3& getLinearFactor() const
	{
		return m_linearFactor;
	}
	void setLinearFactor(const btVector3& linearFactor)
	{
		m_linearFactor = linearFactor;
		m_invMass = m_linearFactor * m_inverseMass;
	}
	btScalar getInvMass() const { return m_inverseMass; }
	btScalar getMass() const { return m_inverseMass == btScalar(0.) ? btScalar(0.) : btScalar(1.0) / m_inverseMass; }
	const btMatrix3x3& getInvInertiaTensorWorld() const
	{
		return m_invInertiaTensorWorld;
	}

	void integrateVelocities(btScalar step);

	void setCenterOfMassTransform(const btTransform& xform);

	void applyCentralForce(const btVector3& force)
	{
		m_totalForce += force * m_linearFactor;
	}

	const btVector3& getTotalForce() const
	{
		return m_totalForce;
	};

	const btVector3& getTotalTorque() const
	{
		return m_totalTorque;
	};

	const btVector3& getInvInertiaDiagLocal() const
	{
		return m_invInertiaLocal;
	};

	void setInvInertiaDiagLocal(const btVector3& diagInvInertia)
	{
		m_invInertiaLocal = diagInvInertia;
	}

	void setSleepingThresholds(btScalar linear, btScalar angular)
	{
		m_linearSleepingThreshold = linear;
		m_angularSleepingThreshold = angular;
	}

	void applyTorque(const btVector3& torque)
	{
		m_totalTorque += torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_totalTorque);
		#endif
	}

	void applyForce(const btVector3& force, const btVector3& rel_pos)
	{
		applyCentralForce(force);
		applyTorque(rel_pos.cross(force * m_linearFactor));
	}

	void applyCentralImpulse(const btVector3& impulse)
	{
		m_linearVelocity += impulse * m_linearFactor * m_inverseMass;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	void applyTorqueImpulse(const btVector3& torque)
	{
		m_angularVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	void applyImpulse(const btVector3& impulse, const btVector3& rel_pos)
	{
		if (m_inverseMass != btScalar(0.))
		{
			applyCentralImpulse(impulse);
			if (m_angularFactor)
			{
				applyTorqueImpulse(rel_pos.cross(impulse * m_linearFactor));
			}
		}
	}
    
    void applyPushImpulse(const btVector3& impulse, const btVector3& rel_pos)
    {
        if (m_inverseMass != btScalar(0.))
        {
            applyCentralPushImpulse(impulse);
            if (m_angularFactor)
            {
                applyTorqueTurnImpulse(rel_pos.cross(impulse * m_linearFactor));
            }
        }
    }
    
    btVector3 getPushVelocity() const
    {
        return m_pushVelocity;
    }
    
    btVector3 getTurnVelocity() const
    {
        return m_turnVelocity;
    }
    
    void setPushVelocity(const btVector3& v)
    {
        m_pushVelocity = v;
    }

    #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
    void clampVelocity(btVector3& v) const {
        v.setX(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getX()))
        );
        v.setY(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getY()))
        );
        v.setZ(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getZ()))
        );
    }
    #endif

    void setTurnVelocity(const btVector3& v)
    {
        m_turnVelocity = v;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }
    
    void applyCentralPushImpulse(const btVector3& impulse)
    {
        m_pushVelocity += impulse * m_linearFactor * m_inverseMass;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_pushVelocity);
        #endif
    }
    
    void applyTorqueTurnImpulse(const btVector3& torque)
    {
        m_turnVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }

	void clearForces()
	{
		m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
		m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	void updateInertiaTensor();

	const btVector3& getCenterOfMassPosition() const
	{
		return m_worldTransform.getOrigin();
	}
	btQuaternion getOrientation() const;

	const btTransform& getCenterOfMassTransform() const
	{
		return m_worldTransform;
	}
	const btVector3& getLinearVelocity() const
	{
		return m_linearVelocity;
	}
	const btVector3& getAngularVelocity() const
	{
		return m_angularVelocity;
	}

	inline void setLinearVelocity(const btVector3& lin_vel)
	{
		m_updateRevision++;
		m_linearVelocity = lin_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	inline void setAngularVelocity(const btVector3& ang_vel)
	{
		m_updateRevision++;
		m_angularVelocity = ang_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	btVector3 getVelocityInLocalPoint(const btVector3& rel_pos) const
	{
		//we also calculate lin/ang velocity for kinematic objects
		return m_linearVelocity + m_angularVelocity.cross(rel_pos);

		//for kinematic objects, we could also use use:
		//		return 	(m_worldTransform(rel_pos) - m_interpolationWorldTransform(rel_pos)) / m_kinematicTimeStep;
	}
    
    btVector3 getPushVelocityInLocalPoint(const btVector3& rel_pos) const
    {
        //we also calculate lin/ang velocity for kinematic objects
        return m_pushVelocity + m_turnVelocity.cross(rel_pos);
    }

	void translate(const btVector3& v)
	{
		m_worldTransform.getOrigin() += v;
	}

	void getAabb(btVector3& aabbMin, btVector3& aabbMax) const;

	SIMD_FORCE_INLINE btScalar computeImpulseDenominator(const btVector3& pos, const btVector3& normal) const
	{
		btVector3 r0 = pos - getCenterOfMassPosition();

		btVector3 c0 = (r0).cross(normal);

		btVector3 vec = (c0 * getInvInertiaTensorWorld()).cross(r0);

		return m_inverseMass + normal.dot(vec);
	}

	SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis) const
	{
		btVector3 vec = axis * getInvInertiaTensorWorld();
		return axis.dot(vec);
	}

	SIMD_FORCE_INLINE void updateDeactivation(btScalar timeStep)
	{
		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == DISABLE_DEACTIVATION))
			return;

		if ((getLinearVelocity().length2() < m_linearSleepingThreshold * m_linearSleepingThreshold) &&
			(getAngularVelocity().length2() < m_angularSleepingThreshold * m_angularSleepingThreshold))
		{
			m_deactivationTime += timeStep;
		}
		else
		{
			m_deactivationTime = btScalar(0.);
			setActivationState(0);
		}
	}

	SIMD_FORCE_INLINE bool wantsSleeping()
	{
		if (getActivationState() == DISABLE_DEACTIVATION)
			return false;

		//disable deactivation
		if (gDisableDeactivation || (gDeactivationTime == btScalar(0.)))
			return false;

		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == WANTS_DEACTIVATION))
			return true;

		if (m_deactivationTime > gDeactivationTime)
		{
			return true;
		}
		return false;
	}

	const btBroadphaseProxy* getBroadphaseProxy() const
	{
		return m_broadphaseHandle;
	}
	btBroadphaseProxy* getBroadphaseProxy()
	{
		return m_broadphaseHandle;
	}
	void setNewBroadphaseProxy(btBroadphaseProxy* broadphaseProxy)
	{
		m_broadphaseHandle = broadphaseProxy;
	}

	//btMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* getMotionState()
	{
		return m_optionalMotionState;
	}
	const btMotionState* getMotionState() const
	{
		return m_optionalMotionState;
	}
	void setMotionState(btMotionState* motionState)
	{
		m_optionalMotionState = motionState;
		if (m_optionalMotionState)
			motionState->getWorldTransform(m_worldTransform);
	}

	//for experimental overriding of friction/contact solver func
	int m_contactSolverType;
	int m_frictionSolverType;

	void setAngularFactor(const btVector3& angFac)
	{
		m_updateRevision++;
		m_angularFactor = angFac;
	}

	void setAngularFactor(btScalar angFac)
	{
		m_updateRevision++;
		m_angularFactor.setValue(angFac, angFac, angFac);
	}
	const btVector3& getAngularFactor() const
	{
		return m_angularFactor;
	}

	//is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
	bool isInWorld() const
	{
		return (getBroadphaseProxy() != 0);
	}

	void addConstraintRef(btTypedConstraint* c);
	void removeConstraintRef(btTypedConstraint* c);

	btTypedConstraint* getConstraintRef(int index)
	{
		return m_constraintRefs[index];
	}

	int getNumConstraintRefs() const
	{
		return m_constraintRefs.size();
	}

	void setFlags(int flags)
	{
		m_rigidbodyFlags = flags;
	}

	int getFlags() const
	{
		return m_rigidbodyFlags;
	}

	///perform implicit force computation in world space
	btVector3 computeGyroscopicImpulseImplicit_World(btScalar dt) const;

	///perform implicit force computation in body space (inertial frame)
	btVector3 computeGyroscopicImpulseImplicit_Body(btScalar step) const;

	///explicit version is best avoided, it gains energy
	btVector3 computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const;
	btVector3 getLocalInertia() const;

	///////////////////////////////////////////////

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer* serializer) const;
};

//@todo add m_optionalMotionState and m_constraintRefs to btRigidBodyData
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyFloatData
{
	btCollisionObjectFloatData m_collisionObjectData;
	btMatrix3x3FloatData m_invInertiaTensorWorld;
	btVector3FloatData m_linearVelocity;
	btVector3FloatData m_angularVelocity;
	btVector3FloatData m_angularFactor;
	btVector3FloatData m_linearFactor;
	btVector3FloatData m_gravity;
	btVector3FloatData m_gravity_acceleration;
	btVector3FloatData m_invInertiaLocal;
	btVector3FloatData m_totalForce;
	btVector3FloatData m_totalTorque;
	float m_inverseMass;
	float m_linearDamping;
	float m_angularDamping;
	float m_additionalDampingFactor;
	float m_additionalLinearDampingThresholdSqr;
	float m_additionalAngularDampingThresholdSqr;
	float m_additionalAngularDampingFactor;
	float m_linearSleepingThreshold;
	float m_angularSleepingThreshold;
	int m_additionalDamping;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyDoubleData
{
	btCollisionObjectDoubleData m_collisionObjectData;
	btMatrix3x3DoubleData m_invInertiaTensorWorld;
	btVector3DoubleData m_linearVelocity;
	btVector3DoubleData m_angularVelocity;
	btVector3DoubleData m_angularFactor;
	btVector3DoubleData m_linearFactor;
	btVector3DoubleData m_gravity;
	btVector3DoubleData m_gravity_acceleration;
	btVector3DoubleData m_invInertiaLocal;
	btVector3DoubleData m_totalForce;
	btVector3DoubleData m_totalTorque;
	double m_inverseMass;
	double m_linearDamping;
	double m_angularDamping;
	double m_additionalDampingFactor;
	double m_additionalLinearDampingThresholdSqr;
	double m_additionalAngularDampingThresholdSqr;
	double m_additionalAngularDampingFactor;
	double m_linearSleepingThreshold;
	double m_angularSleepingThreshold;
	int m_additionalDamping;
	char m_padding[4];
};

#endif  //BT_RIGIDBODY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_JACOBIAN_ENTRY_H
#define BT_JACOBIAN_ENTRY_H

#include "LinearMath/btMatrix3x3.h"

//notes:
// Another memory optimization would be to store m_1MinvJt in the remaining 3 w components
// which makes the btJacobianEntry memory layout 16 bytes
// if you only are interested in angular part, just feed massInvA and massInvB zero

/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
ATTRIBUTE_ALIGNED16(class)
btJacobianEntry
{
public:
	btJacobianEntry(){};
	//constraint between two different rigidbodies
	btJacobianEntry(
		const btMatrix3x3& world2A,
		const btMatrix3x3& world2B,
		const btVector3& rel_pos1, const btVector3& rel_pos2,
		const btVector3& jointAxis,
		const btVector3& inertiaInvA,
		const btScalar massInvA,
		const btVector3& inertiaInvB,
		const btScalar massInvB)
		: m_linearJointAxis(jointAxis)
	{
		m_aJ = world2A * (rel_pos1.cross(m_linearJointAxis));
		m_bJ = world2B * (rel_pos2.cross(-m_linearJointAxis));
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = massInvA + m_0MinvJt.dot(m_aJ) + massInvB + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//angular constraint between two different rigidbodies
	btJacobianEntry(const btVector3& jointAxis,
					const btMatrix3x3& world2A,
					const btMatrix3x3& world2B,
					const btVector3& inertiaInvA,
					const btVector3& inertiaInvB)
		: m_linearJointAxis(btVector3(btScalar(0.), btScalar(0.), btScalar(0.)))
	{
		m_aJ = world2A * jointAxis;
		m_bJ = world2B * -jointAxis;
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = m_0MinvJt.dot(m_aJ) + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//angular constraint between two different rigidbodies
	btJacobianEntry(const btVector3& axisInA,
					const btVector3& axisInB,
					const btVector3& inertiaInvA,
					const btVector3& inertiaInvB)
		: m_linearJointAxis(btVector3(btScalar(0.), btScalar(0.), btScalar(0.))), m_aJ(axisInA), m_bJ(-axisInB)
	{
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = inertiaInvB * m_bJ;
		m_Adiag = m_0MinvJt.dot(m_aJ) + m_1MinvJt.dot(m_bJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	//constraint on one rigidbody
	btJacobianEntry(
		const btMatrix3x3& world2A,
		const btVector3& rel_pos1, const btVector3& rel_pos2,
		const btVector3& jointAxis,
		const btVector3& inertiaInvA,
		const btScalar massInvA)
		: m_linearJointAxis(jointAxis)
	{
		m_aJ = world2A * (rel_pos1.cross(jointAxis));
		m_bJ = world2A * (rel_pos2.cross(-jointAxis));
		m_0MinvJt = inertiaInvA * m_aJ;
		m_1MinvJt = btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
		m_Adiag = massInvA + m_0MinvJt.dot(m_aJ);

		btAssert(m_Adiag > btScalar(0.0));
	}

	btScalar getDiagonal() const { return m_Adiag; }

	// for two constraints on the same rigidbody (for example vehicle friction)
	btScalar getNonDiagonal(const btJacobianEntry& jacB, const btScalar massInvA) const
	{
		const btJacobianEntry& jacA = *this;
		btScalar lin = massInvA * jacA.m_linearJointAxis.dot(jacB.m_linearJointAxis);
		btScalar ang = jacA.m_0MinvJt.dot(jacB.m_aJ);
		return lin + ang;
	}

	// for two constraints on sharing two same rigidbodies (for example two contact points between two rigidbodies)
	btScalar getNonDiagonal(const btJacobianEntry& jacB, const btScalar massInvA, const btScalar massInvB) const
	{
		const btJacobianEntry& jacA = *this;
		btVector3 lin = jacA.m_linearJointAxis * jacB.m_linearJointAxis;
		btVector3 ang0 = jacA.m_0MinvJt * jacB.m_aJ;
		btVector3 ang1 = jacA.m_1MinvJt * jacB.m_bJ;
		btVector3 lin0 = massInvA * lin;
		btVector3 lin1 = massInvB * lin;
		btVector3 sum = ang0 + ang1 + lin0 + lin1;
		return sum[0] + sum[1] + sum[2];
	}

	btScalar getRelativeVelocity(const btVector3& linvelA, const btVector3& angvelA, const btVector3& linvelB, const btVector3& angvelB)
	{
		btVector3 linrel = linvelA - linvelB;
		btVector3 angvela = angvelA * m_aJ;
		btVector3 angvelb = angvelB * m_bJ;
		linrel *= m_linearJointAxis;
		angvela += angvelb;
		angvela += linrel;
		btScalar rel_vel2 = angvela[0] + angvela[1] + angvela[2];
		return rel_vel2 + SIMD_EPSILON;
	}
	//private:

	btVector3 m_linearJointAxis;
	btVector3 m_aJ;
	btVector3 m_bJ;
	btVector3 m_0MinvJt;
	btVector3 m_1MinvJt;
	//Optimization: can be stored in the w/last component of one of the vectors
	btScalar m_Adiag;
};

#endif  //BT_JACOBIAN_ENTRY_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRANSFORM_UTIL_H
#define BT_TRANSFORM_UTIL_H

#include "LinearMath/btTransform.h"
#define ANGULAR_MOTION_THRESHOLD btScalar(0.5) * SIMD_HALF_PI

SIMD_FORCE_INLINE btVector3 btAabbSupport(const btVector3& halfExtents, const btVector3& supportDir)
{
	return btVector3(supportDir.x() < btScalar(0.0) ? -halfExtents.x() : halfExtents.x(),
					 supportDir.y() < btScalar(0.0) ? -halfExtents.y() : halfExtents.y(),
					 supportDir.z() < btScalar(0.0) ? -halfExtents.z() : halfExtents.z());
}

/// Utils related to temporal transforms
class btTransformUtil
{
public:
	static void integrateTransform(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btTransform& predictedTransform)
	{
		predictedTransform.setOrigin(curTrans.getOrigin() + linvel * timeStep);
		//	#define QUATERNION_DERIVATIVE
#ifdef QUATERNION_DERIVATIVE
		btQuaternion predictedOrn = curTrans.getRotation();
		predictedOrn += (angvel * predictedOrn) * (timeStep * btScalar(0.5));
		predictedOrn.safeNormalize();
#else
		//Exponential map
		//google for "Practical Parameterization of Rotations Using the Exponential Map", F. Sebastian Grassia

		btVector3 axis;
		btScalar fAngle2 = angvel.length2();
		btScalar fAngle = 0;
		if (fAngle2 > SIMD_EPSILON)
		{
			fAngle = btSqrt(fAngle2);
		}

		//limit the angular motion
		if (fAngle * timeStep > ANGULAR_MOTION_THRESHOLD)
		{
			fAngle = ANGULAR_MOTION_THRESHOLD / timeStep;
		}

		if (fAngle < btScalar(0.001))
		{
			// use Taylor's expansions of sync function
			axis = angvel * (btScalar(0.5) * timeStep - (timeStep * timeStep * timeStep) * (btScalar(0.020833333333)) * fAngle * fAngle);
		}
		else
		{
			// sync(fAngle) = sin(c*fAngle)/t
			axis = angvel * (btSin(btScalar(0.5) * fAngle * timeStep) / fAngle);
		}
		btQuaternion dorn(axis.x(), axis.y(), axis.z(), btCos(fAngle * timeStep * btScalar(0.5)));
		btQuaternion orn0 = curTrans.getRotation();

		btQuaternion predictedOrn = dorn * orn0;
		predictedOrn.safeNormalize();
#endif
		if (predictedOrn.length2() > SIMD_EPSILON)
		{
			predictedTransform.setRotation(predictedOrn);
		}
		else
		{
			predictedTransform.setBasis(curTrans.getBasis());
		}
	}

	static void calculateVelocityQuaternion(const btVector3& pos0, const btVector3& pos1, const btQuaternion& orn0, const btQuaternion& orn1, btScalar timeStep, btVector3& linVel, btVector3& angVel)
	{
		linVel = (pos1 - pos0) / timeStep;
		btVector3 axis;
		btScalar angle;
		if (orn0 != orn1)
		{
			calculateDiffAxisAngleQuaternion(orn0, orn1, axis, angle);
			angVel = axis * angle / timeStep;
		}
		else
		{
			angVel.setValue(0, 0, 0);
		}
	}

	static void calculateDiffAxisAngleQuaternion(const btQuaternion& orn0, const btQuaternion& orn1a, btVector3& axis, btScalar& angle)
	{
		btQuaternion orn1 = orn0.nearest(orn1a);
		btQuaternion dorn = orn1 * orn0.inverse();
		angle = dorn.getAngle();
		axis = btVector3(dorn.x(), dorn.y(), dorn.z());
		axis[3] = btScalar(0.);
		//check for axis length
		btScalar len = axis.length2();
		if (len < SIMD_EPSILON * SIMD_EPSILON)
			axis = btVector3(btScalar(1.), btScalar(0.), btScalar(0.));
		else
			axis /= btSqrt(len);
	}

	static void calculateVelocity(const btTransform& transform0, const btTransform& transform1, btScalar timeStep, btVector3& linVel, btVector3& angVel)
	{
		linVel = (transform1.getOrigin() - transform0.getOrigin()) / timeStep;
		btVector3 axis;
		btScalar angle;
		calculateDiffAxisAngle(transform0, transform1, axis, angle);
		angVel = axis * angle / timeStep;
	}

	static void calculateDiffAxisAngle(const btTransform& transform0, const btTransform& transform1, btVector3& axis, btScalar& angle)
	{
		btMatrix3x3 dmat = transform1.getBasis() * transform0.getBasis().inverse();
		btQuaternion dorn;
		dmat.getRotation(dorn);

		///floating point inaccuracy can lead to w component > 1..., which breaks
		dorn.normalize();

		angle = dorn.getAngle();
		axis = btVector3(dorn.x(), dorn.y(), dorn.z());
		axis[3] = btScalar(0.);
		//check for axis length
		btScalar len = axis.length2();
		if (len < SIMD_EPSILON * SIMD_EPSILON)
			axis = btVector3(btScalar(1.), btScalar(0.), btScalar(0.));
		else
			axis /= btSqrt(len);
	}
};

///The btConvexSeparatingDistanceUtil can help speed up convex collision detection
///by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
class btConvexSeparatingDistanceUtil
{
	btQuaternion m_ornA;
	btQuaternion m_ornB;
	btVector3 m_posA;
	btVector3 m_posB;

	btVector3 m_separatingNormal;

	btScalar m_boundingRadiusA;
	btScalar m_boundingRadiusB;
	btScalar m_separatingDistance;

public:
	btConvexSeparatingDistanceUtil(btScalar boundingRadiusA, btScalar boundingRadiusB)
		: m_boundingRadiusA(boundingRadiusA),
		  m_boundingRadiusB(boundingRadiusB),
		  m_separatingDistance(0.f)
	{
	}

	btScalar getConservativeSeparatingDistance()
	{
		return m_separatingDistance;
	}

	void updateSeparatingDistance(const btTransform& transA, const btTransform& transB)
	{
		const btVector3& toPosA = transA.getOrigin();
		const btVector3& toPosB = transB.getOrigin();
		btQuaternion toOrnA = transA.getRotation();
		btQuaternion toOrnB = transB.getRotation();

		if (m_separatingDistance > 0.f)
		{
			btVector3 linVelA, angVelA, linVelB, angVelB;
			btTransformUtil::calculateVelocityQuaternion(m_posA, toPosA, m_ornA, toOrnA, btScalar(1.), linVelA, angVelA);
			btTransformUtil::calculateVelocityQuaternion(m_posB, toPosB, m_ornB, toOrnB, btScalar(1.), linVelB, angVelB);
			btScalar maxAngularProjectedVelocity = angVelA.length() * m_boundingRadiusA + angVelB.length() * m_boundingRadiusB;
			btVector3 relLinVel = (linVelB - linVelA);
			btScalar relLinVelocLength = relLinVel.dot(m_separatingNormal);
			if (relLinVelocLength < 0.f)
			{
				relLinVelocLength = 0.f;
			}

			btScalar projectedMotion = maxAngularProjectedVelocity + relLinVelocLength;
			m_separatingDistance -= projectedMotion;
		}

		m_posA = toPosA;
		m_posB = toPosB;
		m_ornA = toOrnA;
		m_ornB = toOrnB;
	}

	void initSeparatingDistance(const btVector3& separatingVector, btScalar separatingDistance, const btTransform& transA, const btTransform& transB)
	{
		m_separatingDistance = separatingDistance;

		if (m_separatingDistance > 0.f)
		{
			m_separatingNormal = separatingVector;

			const btVector3& toPosA = transA.getOrigin();
			const btVector3& toPosB = transB.getOrigin();
			btQuaternion toOrnA = transA.getRotation();
			btQuaternion toOrnB = transB.getRotation();
			m_posA = toPosA;
			m_posB = toPosB;
			m_ornA = toOrnA;
			m_ornB = toOrnB;
		}
	}
};

#endif  //BT_TRANSFORM_UTIL_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SOLVER_BODY_H
#define BT_SOLVER_BODY_H

class btRigidBody;
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"

#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btTransformUtil.h"

///Until we get other contributions, only use SIMD on Windows, when using Visual Studio 2008 or later, and not double precision
#ifdef BT_USE_SSE
#define USE_SIMD 1
#endif  //

#ifdef USE_SIMD

struct btSimdScalar
{
	SIMD_FORCE_INLINE btSimdScalar()
	{
	}

	SIMD_FORCE_INLINE btSimdScalar(float fl)
		: m_vec128(_mm_set1_ps(fl))
	{
	}

	SIMD_FORCE_INLINE btSimdScalar(__m128 v128)
		: m_vec128(v128)
	{
	}
	union {
		__m128 m_vec128;
		float m_floats[4];
		int m_ints[4];
		btScalar m_unusedPadding;
	};
	SIMD_FORCE_INLINE __m128 get128()
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE const __m128 get128() const
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE void set128(__m128 v128)
	{
		m_vec128 = v128;
	}

	SIMD_FORCE_INLINE operator __m128()
	{
		return m_vec128;
	}
	SIMD_FORCE_INLINE operator const __m128() const
	{
		return m_vec128;
	}

	SIMD_FORCE_INLINE operator float() const
	{
		return m_floats[0];
	}
};

///@brief Return the elementwise product of two btSimdScalar
SIMD_FORCE_INLINE btSimdScalar
operator*(const btSimdScalar& v1, const btSimdScalar& v2)
{
	return btSimdScalar(_mm_mul_ps(v1.get128(), v2.get128()));
}

///@brief Return the elementwise product of two btSimdScalar
SIMD_FORCE_INLINE btSimdScalar
operator+(const btSimdScalar& v1, const btSimdScalar& v2)
{
	return btSimdScalar(_mm_add_ps(v1.get128(), v2.get128()));
}

#else
#define btSimdScalar btScalar
#endif

///The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
ATTRIBUTE_ALIGNED16(struct)
btSolverBody
{
	BT_DECLARE_ALIGNED_ALLOCATOR();
	btTransform m_worldTransform;
	btVector3 m_deltaLinearVelocity;
	btVector3 m_deltaAngularVelocity;
	btVector3 m_angularFactor;
	btVector3 m_linearFactor;
	btVector3 m_invMass;
	btVector3 m_pushVelocity;
	btVector3 m_turnVelocity;
	btVector3 m_linearVelocity;
	btVector3 m_angularVelocity;
	btVector3 m_externalForceImpulse;
	btVector3 m_externalTorqueImpulse;

	btRigidBody* m_originalBody;
	void setWorldTransform(const btTransform& worldTransform)
	{
		m_worldTransform = worldTransform;
	}

	const btTransform& getWorldTransform() const
	{
		return m_worldTransform;
	}

	SIMD_FORCE_INLINE void getVelocityInLocalPointNoDelta(const btVector3& rel_pos, btVector3& velocity) const
	{
		if (m_originalBody)
			velocity = m_linearVelocity + m_externalForceImpulse + (m_angularVelocity + m_externalTorqueImpulse).cross(rel_pos);
		else
			velocity.setValue(0, 0, 0);
	}

	SIMD_FORCE_INLINE void getVelocityInLocalPointObsolete(const btVector3& rel_pos, btVector3& velocity) const
	{
		if (m_originalBody)
			velocity = m_linearVelocity + m_deltaLinearVelocity + (m_angularVelocity + m_deltaAngularVelocity).cross(rel_pos);
		else
			velocity.setValue(0, 0, 0);
	}

	SIMD_FORCE_INLINE void getAngularVelocity(btVector3 & angVel) const
	{
		if (m_originalBody)
			angVel = m_angularVelocity + m_deltaAngularVelocity;
		else
			angVel.setValue(0, 0, 0);
	}

	//Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
	SIMD_FORCE_INLINE void applyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_deltaLinearVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_deltaAngularVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	SIMD_FORCE_INLINE void internalApplyPushImpulse(const btVector3& linearComponent, const btVector3& angularComponent, btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_pushVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_turnVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	const btVector3& getDeltaLinearVelocity() const
	{
		return m_deltaLinearVelocity;
	}

	const btVector3& getDeltaAngularVelocity() const
	{
		return m_deltaAngularVelocity;
	}

	const btVector3& getPushVelocity() const
	{
		return m_pushVelocity;
	}

	const btVector3& getTurnVelocity() const
	{
		return m_turnVelocity;
	}

	////////////////////////////////////////////////
	///some internal methods, don't use them

	btVector3& internalGetDeltaLinearVelocity()
	{
		return m_deltaLinearVelocity;
	}

	btVector3& internalGetDeltaAngularVelocity()
	{
		return m_deltaAngularVelocity;
	}

	const btVector3& internalGetAngularFactor() const
	{
		return m_angularFactor;
	}

	const btVector3& internalGetInvMass() const
	{
		return m_invMass;
	}

	void internalSetInvMass(const btVector3& invMass)
	{
		m_invMass = invMass;
	}

	btVector3& internalGetPushVelocity()
	{
		return m_pushVelocity;
	}

	btVector3& internalGetTurnVelocity()
	{
		return m_turnVelocity;
	}

	SIMD_FORCE_INLINE void internalGetVelocityInLocalPointObsolete(const btVector3& rel_pos, btVector3& velocity) const
	{
		velocity = m_linearVelocity + m_deltaLinearVelocity + (m_angularVelocity + m_deltaAngularVelocity).cross(rel_pos);
	}

	SIMD_FORCE_INLINE void internalGetAngularVelocity(btVector3 & angVel) const
	{
		angVel = m_angularVelocity + m_deltaAngularVelocity;
	}

	//Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
	SIMD_FORCE_INLINE void internalApplyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)
	{
		if (m_originalBody)
		{
			m_deltaLinearVelocity += linearComponent * impulseMagnitude * m_linearFactor;
			m_deltaAngularVelocity += angularComponent * (impulseMagnitude * m_angularFactor);
		}
	}

	void writebackVelocity()
	{
		if (m_originalBody)
		{
			m_linearVelocity += m_deltaLinearVelocity;
			m_angularVelocity += m_deltaAngularVelocity;

			//m_originalBody->setCompanionId(-1);
		}
	}

	void writebackVelocityAndTransform(btScalar timeStep, btScalar splitImpulseTurnErp)
	{
		(void)timeStep;
		if (m_originalBody)
		{
			m_linearVelocity += m_deltaLinearVelocity;
			m_angularVelocity += m_deltaAngularVelocity;

			//correct the position/orientation based on push/turn recovery
			btTransform newTransform;
			if (m_pushVelocity[0] != 0.f || m_pushVelocity[1] != 0 || m_pushVelocity[2] != 0 || m_turnVelocity[0] != 0.f || m_turnVelocity[1] != 0 || m_turnVelocity[2] != 0)
			{
				//	btQuaternion orn = m_worldTransform.getRotation();
				btTransformUtil::integrateTransform(m_worldTransform, m_pushVelocity, m_turnVelocity * splitImpulseTurnErp, timeStep, newTransform);
				m_worldTransform = newTransform;
			}
			//m_worldTransform.setRotation(orn);
			//m_originalBody->setCompanionId(-1);
		}
	}
};

#endif  //BT_SOLVER_BODY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SOLVER_CONSTRAINT_H
#define BT_SOLVER_CONSTRAINT_H

class btRigidBody;
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "LinearMath/btAlignedObjectArray.h"

//#define NO_FRICTION_TANGENTIALS 1
#include "BulletDynamics/ConstraintSolver/btSolverBody.h"

///1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
ATTRIBUTE_ALIGNED16(struct)
btSolverConstraint
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btVector3 m_relpos1CrossNormal;
	btVector3 m_contactNormal1;

	btVector3 m_relpos2CrossNormal;
	btVector3 m_contactNormal2;  //usually m_contactNormal2 == -m_contactNormal1, but not always

	btVector3 m_angularComponentA;
	btVector3 m_angularComponentB;

	mutable btSimdScalar m_appliedPushImpulse;
	mutable btSimdScalar m_appliedImpulse;

	btScalar m_friction;
	btScalar m_jacDiagABInv;
	btScalar m_rhs;
	btScalar m_cfm;

	btScalar m_lowerLimit;
	btScalar m_upperLimit;
	btScalar m_rhsPenetration;
	union {
		void* m_originalContactPoint;
		btScalar m_unusedPadding4;
		int m_numRowsForNonContactConstraint;
	};

	int m_overrideNumSolverIterations;
	int m_frictionIndex;
	int m_solverBodyIdA;
	int m_solverBodyIdB;

	enum btSolverConstraintType
	{
		BT_SOLVER_CONTACT_1D = 0,
		BT_SOLVER_FRICTION_1D
	};
};

typedef btAlignedObjectArray<btSolverConstraint> btConstraintArray;

#endif  //BT_SOLVER_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btSerializer.h"

#define DEFAULT_DEBUGDRAW_SIZE btScalar(0.05f)

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(getFixedBody()),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA, btRigidBody& rbB)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(rbB),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btScalar btTypedConstraint::getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact)
{
	if (lowLim > uppLim)
	{
		return btScalar(1.0f);
	}
	else if (lowLim == uppLim)
	{
		return btScalar(0.0f);
	}
	btScalar lim_fact = btScalar(1.0f);
	btScalar delta_max = vel / timeFact;
	if (delta_max < btScalar(0.0f))
	{
		if ((pos >= lowLim) && (pos < (lowLim - delta_max)))
		{
			lim_fact = (lowLim - pos) / delta_max;
		}
		else if (pos < lowLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else if (delta_max > btScalar(0.0f))
	{
		if ((pos <= uppLim) && (pos > (uppLim - delta_max)))
		{
			lim_fact = (uppLim - pos) / delta_max;
		}
		else if (pos > uppLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else
	{
		lim_fact = btScalar(0.0f);
	}
	return lim_fact;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btTypedConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btTypedConstraintData2* tcd = (btTypedConstraintData2*)dataBuffer;

	tcd->m_rbA = (btRigidBodyData*)serializer->getUniquePointer(&m_rbA);
	tcd->m_rbB = (btRigidBodyData*)serializer->getUniquePointer(&m_rbB);
	char* name = (char*)serializer->findNameForPointer(this);
	tcd->m_name = (char*)serializer->getUniquePointer(name);
	if (tcd->m_name)
	{
		serializer->serializeName(name);
	}

	tcd->m_objectType = m_objectType;
	tcd->m_needsFeedback = m_needsFeedback;
	tcd->m_overrideNumSolverIterations = m_overrideNumSolverIterations;
	tcd->m_breakingImpulseThreshold = m_breakingImpulseThreshold;
	tcd->m_isEnabled = m_isEnabled ? 1 : 0;

	tcd->m_userConstraintId = m_userConstraintId;
	tcd->m_userConstraintType = m_userConstraintType;

	tcd->m_appliedImpulse = m_appliedImpulse;
	tcd->m_dbgDrawSize = m_dbgDrawSize;

	tcd->m_disableCollisionsBetweenLinkedBodies = false;

	int i;
	for (i = 0; i < m_rbA.getNumConstraintRefs(); i++)
		if (m_rbA.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;
	for (i = 0; i < m_rbB.getNumConstraintRefs(); i++)
		if (m_rbB.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;

	return btTypedConstraintDataName;
}

btRigidBody& btTypedConstraint::getFixedBody()
{
	static btRigidBody s_fixed(0, 0, 0);
	s_fixed.setMassProps(btScalar(0.), btVector3(btScalar(0.), btScalar(0.), btScalar(0.)));
	return s_fixed;
}

void btAngularLimit::set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor)
{
	m_halfRange = (high - low) / 2.0f;
	m_center = btNormalizeAngle(low + m_halfRange);
	m_softness = _softness;
	m_biasFactor = _biasFactor;
	m_relaxationFactor = _relaxationFactor;
}

void btAngularLimit::test(const btScalar angle)
{
	m_correction = 0.0f;
	m_sign = 0.0f;
	m_solveLimit = false;

	if (m_halfRange >= 0.0f)
	{
		btScalar deviation = btNormalizeAngle(angle - m_center);
		if (deviation < -m_halfRange)
		{
			m_solveLimit = true;
			m_correction = -(deviation + m_halfRange);
			m_sign = +1.0f;
		}
		else if (deviation > m_halfRange)
		{
			m_solveLimit = true;
			m_correction = m_halfRange - deviation;
			m_sign = -1.0f;
		}
	}
}

btScalar btAngularLimit::getError() const
{
	return m_correction * m_sign;
}

void btAngularLimit::fit(btScalar& angle) const
{
	if (m_halfRange > 0.0f)
	{
		btScalar relativeAngle = btNormalizeAngle(angle - m_center);
		if (!btEqual(relativeAngle, m_halfRange))
		{
			if (relativeAngle > 0.0f)
			{
				angle = getHigh();
			}
			else
			{
				angle = getLow();
			}
		}
	}
}

btScalar btAngularLimit::getLow() const
{
	return btNormalizeAngle(m_center - m_halfRange);
}

btScalar btAngularLimit::getHigh() const
{
	return btNormalizeAngle(m_center + m_halfRange);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2010 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TYPED_CONSTRAINT_H
#define BT_TYPED_CONSTRAINT_H

#include "LinearMath/btScalar.h"
#include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTypedConstraintData2 btTypedConstraintDoubleData
#define btTypedConstraintDataName "btTypedConstraintDoubleData"
#else
#define btTypedConstraintData2 btTypedConstraintFloatData
#define btTypedConstraintDataName "btTypedConstraintFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

class btSerializer;

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
enum btTypedConstraintType
{
	POINT2POINT_CONSTRAINT_TYPE = 3,
	HINGE_CONSTRAINT_TYPE,
	CONETWIST_CONSTRAINT_TYPE,
	D6_CONSTRAINT_TYPE,
	SLIDER_CONSTRAINT_TYPE,
	CONTACT_CONSTRAINT_TYPE,
	D6_SPRING_CONSTRAINT_TYPE,
	GEAR_CONSTRAINT_TYPE,
	FIXED_CONSTRAINT_TYPE,
	D6_SPRING_2_CONSTRAINT_TYPE,
	MAX_CONSTRAINT_TYPE
};

enum btConstraintParams
{
	BT_CONSTRAINT_ERP = 1,
	BT_CONSTRAINT_STOP_ERP,
	BT_CONSTRAINT_CFM,
	BT_CONSTRAINT_STOP_CFM
};

#if 1
#define btAssertConstrParams(_par) btAssert(_par)
#else
#define btAssertConstrParams(_par)
#endif

ATTRIBUTE_ALIGNED16(struct)
btJointFeedback
{
	BT_DECLARE_ALIGNED_ALLOCATOR();
	btVector3 m_appliedForceBodyA;
	btVector3 m_appliedTorqueBodyA;
	btVector3 m_appliedForceBodyB;
	btVector3 m_appliedTorqueBodyB;
};

///TypedConstraint is the baseclass for Bullet constraints and vehicles
ATTRIBUTE_ALIGNED16(class)
btTypedConstraint : public btTypedObject
{
	int m_userConstraintType;

	union {
		int m_userConstraintId;
		void* m_userConstraintPtr;
	};

	btScalar m_breakingImpulseThreshold;
	bool m_isEnabled;
	bool m_needsFeedback;
	int m_overrideNumSolverIterations;

	btTypedConstraint& operator=(btTypedConstraint& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

protected:
	btRigidBody& m_rbA;
	btRigidBody& m_rbB;
	btScalar m_appliedImpulse;
	btScalar m_dbgDrawSize;
	btJointFeedback* m_jointFeedback;

	///internal method used by the constraint solver, don't use them directly
	btScalar getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btTypedConstraint(){};
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA);
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA, btRigidBody & rbB);

	struct btConstraintInfo1
	{
		int m_numConstraintRows, nub;
	};

	static btRigidBody& getFixedBody();

	struct btConstraintInfo2
	{
		// integrator parameters: frames per second (1/stepsize), default error
		// reduction parameter (0..1).
		btScalar fps, erp;

		// for the first and second body, pointers to two (linear and angular)
		// n*3 jacobian sub matrices, stored by rows. these matrices will have
		// been initialized to 0 on entry. if the second body is zero then the
		// J2xx pointers may be 0.
		btScalar *m_J1linearAxis, *m_J1angularAxis, *m_J2linearAxis, *m_J2angularAxis;

		// elements to jump from one row to the next in J's
		int rowskip;

		// right hand sides of the equation J*v = c + cfm * lambda. cfm is the
		// "constraint force mixing" vector. c is set to zero on entry, cfm is
		// set to a constant value (typically very small or zero) value on entry.
		btScalar *m_constraintError, *cfm;

		// lo and hi limits for variables (set to -/+ infinity on entry).
		btScalar *m_lowerLimit, *m_upperLimit;

		// number of solver iterations
		int m_numIterations;

		//damping of the velocity
		btScalar m_damping;
	};

	int getOverrideNumSolverIterations() const
	{
		return m_overrideNumSolverIterations;
	}

	///override the number of constraint solver iterations used to solve this constraint
	///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
	void setOverrideNumSolverIterations(int overideNumIterations)
	{
		m_overrideNumSolverIterations = overideNumIterations;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void buildJacobian(){};

	///internal method used by the constraint solver, don't use them directly
	virtual void setupSolverConstraint(btConstraintArray & ca, int solverBodyA, int solverBodyB, btScalar timeStep)
	{
		(void)ca;
		(void)solverBodyA;
		(void)solverBodyB;
		(void)timeStep;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo1(btConstraintInfo1 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo2(btConstraintInfo2 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	void internalSetAppliedImpulse(btScalar appliedImpulse)
	{
		m_appliedImpulse = appliedImpulse;
	}
	///internal method used by the constraint solver, don't use them directly
	btScalar internalGetAppliedImpulse()
	{
		return m_appliedImpulse;
	}

	btScalar getBreakingImpulseThreshold() const
	{
		return m_breakingImpulseThreshold;
	}

	void setBreakingImpulseThreshold(btScalar threshold)
	{
		m_breakingImpulseThreshold = threshold;
	}

	bool isEnabled() const
	{
		return m_isEnabled;
	}

	void setEnabled(bool enabled)
	{
		m_isEnabled = enabled;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void solveConstraintObsolete(btSolverBody& /*bodyA*/, btSolverBody& /*bodyB*/, btScalar /*timeStep*/){};

	const btRigidBody& getRigidBodyA() const
	{
		return m_rbA;
	}
	const btRigidBody& getRigidBodyB() const
	{
		return m_rbB;
	}

	btRigidBody& getRigidBodyA()
	{
		return m_rbA;
	}
	btRigidBody& getRigidBodyB()
	{
		return m_rbB;
	}

	int getUserConstraintType() const
	{
		return m_userConstraintType;
	}

	void setUserConstraintType(int userConstraintType)
	{
		m_userConstraintType = userConstraintType;
	};

	void setUserConstraintId(int uid)
	{
		m_userConstraintId = uid;
	}

	int getUserConstraintId() const
	{
		return m_userConstraintId;
	}

	void setUserConstraintPtr(void* ptr)
	{
		m_userConstraintPtr = ptr;
	}

	void* getUserConstraintPtr()
	{
		return m_userConstraintPtr;
	}

	void setJointFeedback(btJointFeedback * jointFeedback)
	{
		m_jointFeedback = jointFeedback;
	}

	const btJointFeedback* getJointFeedback() const
	{
		return m_jointFeedback;
	}

	btJointFeedback* getJointFeedback()
	{
		return m_jointFeedback;
	}

	int getUid() const
	{
		return m_userConstraintId;
	}

	bool needsFeedback() const
	{
		return m_needsFeedback;
	}

	///enableFeedback will allow to read the applied linear and angular impulse
	///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
	void enableFeedback(bool needsFeedback)
	{
		m_needsFeedback = needsFeedback;
	}

	///getAppliedImpulse is an estimated total applied impulse.
	///This feedback could be used to determine breaking constraints or playing sounds.
	btScalar getAppliedImpulse() const
	{
		btAssert(m_needsFeedback);
		return m_appliedImpulse;
	}

	btTypedConstraintType getConstraintType() const
	{
		return btTypedConstraintType(m_objectType);
	}

	void setDbgDrawSize(btScalar dbgDrawSize)
	{
		m_dbgDrawSize = dbgDrawSize;
	}
	btScalar getDbgDrawSize()
	{
		return m_dbgDrawSize;
	}

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1) = 0;

	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const = 0;

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

// returns angle in range [-SIMD_2_PI, SIMD_2_PI], closest to one of the limits
// all arguments should be normalized angles (i.e. in range [-SIMD_PI, SIMD_PI])
SIMD_FORCE_INLINE btScalar btAdjustAngleToLimits(btScalar angleInRadians, btScalar angleLowerLimitInRadians, btScalar angleUpperLimitInRadians)
{
	if (angleLowerLimitInRadians >= angleUpperLimitInRadians)
	{
		return angleInRadians;
	}
	else if (angleInRadians < angleLowerLimitInRadians)
	{
		btScalar diffLo = btFabs(btNormalizeAngle(angleLowerLimitInRadians - angleInRadians));
		btScalar diffHi = btFabs(btNormalizeAngle(angleUpperLimitInRadians - angleInRadians));
		return (diffLo < diffHi) ? angleInRadians : (angleInRadians + SIMD_2_PI);
	}
	else if (angleInRadians > angleUpperLimitInRadians)
	{
		btScalar diffHi = btFabs(btNormalizeAngle(angleInRadians - angleUpperLimitInRadians));
		btScalar diffLo = btFabs(btNormalizeAngle(angleInRadians - angleLowerLimitInRadians));
		return (diffLo < diffHi) ? (angleInRadians - SIMD_2_PI) : angleInRadians;
	}
	else
	{
		return angleInRadians;
	}
}

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btTypedConstraintFloatData
{
	btRigidBodyFloatData		*m_rbA;
	btRigidBodyFloatData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64

#define BT_BACKWARDS_COMPATIBLE_SERIALIZATION
#ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
///this structure is not used, except for loading pre-2.82 .bullet files
struct	btTypedConstraintData
{
	btRigidBodyData		*m_rbA;
	btRigidBodyData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};
#endif //BACKWARDS_COMPATIBLE

struct	btTypedConstraintDoubleData
{
	btRigidBodyDoubleData		*m_rbA;
	btRigidBodyDoubleData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	double	m_appliedImpulse;
	double	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	double	m_breakingImpulseThreshold;
	int		m_isEnabled;
	char	padding[4];
	
};

// clang-format on

SIMD_FORCE_INLINE int btTypedConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btTypedConstraintData2);
}

class btAngularLimit
{
private:
	btScalar
		m_center,
		m_halfRange,
		m_softness,
		m_biasFactor,
		m_relaxationFactor,
		m_correction,
		m_sign;

	bool
		m_solveLimit;

public:
	/// Default constructor initializes limit as inactive, allowing free constraint movement
	btAngularLimit()
		: m_center(0.0f),
		  m_halfRange(-1.0f),
		  m_softness(0.9f),
		  m_biasFactor(0.3f),
		  m_relaxationFactor(1.0f),
		  m_correction(0.0f),
		  m_sign(0.0f),
		  m_solveLimit(false)
	{
	}

	/// Sets all limit's parameters.
	/// When low > high limit becomes inactive.
	/// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
	void set(btScalar low, btScalar high, btScalar _softness = 0.9f, btScalar _biasFactor = 0.3f, btScalar _relaxationFactor = 1.0f);

	/// Checks conastaint angle against limit. If limit is active and the angle violates the limit
	/// correction is calculated.
	void test(const btScalar angle);

	/// Returns limit's softness
	inline btScalar getSoftness() const
	{
		return m_softness;
	}

	/// Returns limit's bias factor
	inline btScalar getBiasFactor() const
	{
		return m_biasFactor;
	}

	/// Returns limit's relaxation factor
	inline btScalar getRelaxationFactor() const
	{
		return m_relaxationFactor;
	}

	/// Returns correction value evaluated when test() was invoked
	inline btScalar getCorrection() const
	{
		return m_correction;
	}

	/// Returns sign value evaluated when test() was invoked
	inline btScalar getSign() const
	{
		return m_sign;
	}

	/// Gives half of the distance between min and max limit angle
	inline btScalar getHalfRange() const
	{
		return m_halfRange;
	}

	/// Returns true when the last test() invocation recognized limit violation
	inline bool isLimit() const
	{
		return m_solveLimit;
	}

	/// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
	/// returned is modified so it equals to the limit closest to given angle.
	void fit(btScalar& angle) const;

	/// Returns correction value multiplied by sign value
	btScalar getError() const;

	btScalar getLow() const;

	btScalar getHigh() const;
};

#endif  //BT_TYPED_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btDispatcher.h"

btDispatcher::~btDispatcher()
{
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_DISPATCHER_H
#define BT_DISPATCHER_H
#include "LinearMath/btScalar.h"

class btCollisionAlgorithm;
struct btBroadphaseProxy;
class btRigidBody;
class btCollisionObject;
class btOverlappingPairCache;
struct btCollisionObjectWrapper;

class btPersistentManifold;
class btPoolAllocator;

struct btDispatcherInfo
{
	enum DispatchFunc
	{
		DISPATCH_DISCRETE = 1,
		DISPATCH_CONTINUOUS
	};
	btDispatcherInfo()
		: m_timeStep(btScalar(0.)),
		  m_stepCount(0),
		  m_dispatchFunc(DISPATCH_DISCRETE),
		  m_timeOfImpact(btScalar(1.)),
		  m_useContinuous(true),
		  m_debugDraw(0),
		  m_enableSatConvex(false),
		  m_enableSPU(true),
		  m_useEpa(true),
		  m_allowedCcdPenetration(btScalar(0.04)),
		  m_useConvexConservativeDistanceUtil(false),
		  m_convexConservativeDistanceThreshold(0.0f),
		  m_deterministicOverlappingPairs(false)
	{
	}
	btScalar m_timeStep;
	int m_stepCount;
	int m_dispatchFunc;
	mutable btScalar m_timeOfImpact;
	bool m_useContinuous;
	class btIDebugDraw* m_debugDraw;
	bool m_enableSatConvex;
	bool m_enableSPU;
	bool m_useEpa;
	btScalar m_allowedCcdPenetration;
	bool m_useConvexConservativeDistanceUtil;
	btScalar m_convexConservativeDistanceThreshold;
	bool m_deterministicOverlappingPairs;
};

enum ebtDispatcherQueryType
{
	BT_CONTACT_POINT_ALGORITHMS = 1,
	BT_CLOSEST_POINT_ALGORITHMS = 2
};

///The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
///For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
class btDispatcher
{
public:
	virtual ~btDispatcher();

	virtual btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btPersistentManifold* sharedManifold, ebtDispatcherQueryType queryType) = 0;

	virtual btPersistentManifold* getNewManifold(const btCollisionObject* b0, const btCollisionObject* b1) = 0;

	virtual void releaseManifold(btPersistentManifold* manifold) = 0;

	virtual void clearManifold(btPersistentManifold* manifold) = 0;

	virtual bool needsCollision(const btCollisionObject* body0, const btCollisionObject* body1) = 0;

	virtual bool needsResponse(const btCollisionObject* body0, const btCollisionObject* body1) = 0;

	virtual void dispatchAllCollisionPairs(btOverlappingPairCache* pairCache, const btDispatcherInfo& dispatchInfo, btDispatcher* dispatcher) = 0;

	virtual int getNumManifolds() const = 0;

	virtual btPersistentManifold* getManifoldByIndexInternal(int index) = 0;

	virtual btPersistentManifold** getInternalManifoldPointer() = 0;

	virtual btPoolAllocator* getInternalManifoldPool() = 0;

	virtual const btPoolAllocator* getInternalManifoldPool() const = 0;

	virtual void* allocateCollisionAlgorithm(int size) = 0;

	virtual void freeCollisionAlgorithm(void* ptr) = 0;
};

#endif  //BT_DISPATCHER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MANIFOLD_CONTACT_POINT_H
#define BT_MANIFOLD_CONTACT_POINT_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransformUtil.h"

#ifdef PFX_USE_FREE_VECTORMATH
#include "physics_effects/base_level/solver/pfx_constraint_row.h"
typedef sce::PhysicsEffects::PfxConstraintRow btConstraintRow;
#else
// Don't change following order of parameters
ATTRIBUTE_ALIGNED16(struct)
btConstraintRow
{
	btScalar m_normal[3];
	btScalar m_rhs;
	btScalar m_jacDiagInv;
	btScalar m_lowerLimit;
	btScalar m_upperLimit;
	btScalar m_accumImpulse;
};
typedef btConstraintRow PfxConstraintRow;
#endif  //PFX_USE_FREE_VECTORMATH

enum btContactPointFlags
{
	BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED = 1,
	BT_CONTACT_FLAG_HAS_CONTACT_CFM = 2,
	BT_CONTACT_FLAG_HAS_CONTACT_ERP = 4,
	BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING = 8,
	BT_CONTACT_FLAG_FRICTION_ANCHOR = 16,
};

/// ManifoldContactPoint collects and maintains persistent contactpoints.
/// used to improve stability and performance of rigidbody dynamics response.
class btManifoldPoint
{
public:
	btManifoldPoint()
		: m_userPersistentData(0),
		  m_contactPointFlags(0),
		  m_appliedImpulse(0.f),
		  m_prevRHS(0.f),
		  m_appliedImpulseLateral1(0.f),
		  m_appliedImpulseLateral2(0.f),
		  m_contactMotion1(0.f),
		  m_contactMotion2(0.f),
		  m_contactCFM(0.f),
		  m_contactERP(0.f),
		  m_frictionCFM(0.f),
		  m_lifeTime(0)
	{
	}

	btManifoldPoint(const btVector3& pointA, const btVector3& pointB,
					const btVector3& normal,
					btScalar distance) : m_localPointA(pointA),
										 m_localPointB(pointB),
										 m_positionWorldOnB(0,0,0),
										 m_positionWorldOnA(0,0,0),
										 m_normalWorldOnB(normal),
										 m_distance1(distance),
										 m_combinedFriction(btScalar(0.)),
										 m_combinedRollingFriction(btScalar(0.)),
										 m_combinedSpinningFriction(btScalar(0.)),
										 m_combinedRestitution(btScalar(0.)),
										 m_partId0(-1),
										 m_partId1(-1),
										 m_index0(-1),
										 m_index1(-1),
										 m_userPersistentData(0),
										 m_contactPointFlags(0),
										 m_appliedImpulse(0.f),
										 m_prevRHS(0.f),
										 m_appliedImpulseLateral1(0.f),
										 m_appliedImpulseLateral2(0.f),
										 m_contactMotion1(0.f),
										 m_contactMotion2(0.f),
										 m_contactCFM(0.f),
										 m_contactERP(0.f),
										 m_frictionCFM(0.f),
										 m_lifeTime(0),
										 m_lateralFrictionDir1(0,0,0),
										 m_lateralFrictionDir2(0,0,0)
	{
	}

	btVector3 m_localPointA;
	btVector3 m_localPointB;
	btVector3 m_positionWorldOnB;
	///m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
	btVector3 m_positionWorldOnA;
	btVector3 m_normalWorldOnB;

	btScalar m_distance1;
	btScalar m_combinedFriction;
	btScalar m_combinedRollingFriction;   //torsional friction orthogonal to contact normal, useful to make spheres stop rolling forever
	btScalar m_combinedSpinningFriction;  //torsional friction around contact normal, useful for grasping objects
	btScalar m_combinedRestitution;

	//BP mod, store contact triangles.
	int m_partId0;
	int m_partId1;
	int m_index0;
	int m_index1;

	mutable void* m_userPersistentData;
	//bool			m_lateralFrictionInitialized;
	int m_contactPointFlags;

	btScalar m_appliedImpulse;
	btScalar m_prevRHS;
	btScalar m_appliedImpulseLateral1;
	btScalar m_appliedImpulseLateral2;
	btScalar m_contactMotion1;
	btScalar m_contactMotion2;

	union {
		btScalar m_contactCFM;
		btScalar m_combinedContactStiffness1;
	};

	union {
		btScalar m_contactERP;
		btScalar m_combinedContactDamping1;
	};

	btScalar m_frictionCFM;

	int m_lifeTime;  //lifetime of the contactpoint in frames

	btVector3 m_lateralFrictionDir1;
	btVector3 m_lateralFrictionDir2;

	btScalar getDistance() const
	{
		return m_distance1;
	}
	int getLifeTime() const
	{
		return m_lifeTime;
	}

	const btVector3& getPositionWorldOnA() const
	{
		return m_positionWorldOnA;
		//				return m_positionWorldOnB + m_normalWorldOnB * m_distance1;
	}

	const btVector3& getPositionWorldOnB() const
	{
		return m_positionWorldOnB;
	}

	void setDistance(btScalar dist)
	{
		m_distance1 = dist;
	}

	///this returns the most recent applied impulse, to satisfy contact constraints by the constraint solver
	btScalar getAppliedImpulse() const
	{
		return m_appliedImpulse;
	}
};

#endif  //BT_MANIFOLD_CONTACT_POINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btSerializer.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btCollisionObjectData btCollisionObjectDoubleData
#else
#define btCollisionObjectData btCollisionObjectFloatData
#endif

btScalar gContactBreakingThreshold = btScalar(0.02);
ContactDestroyedCallback gContactDestroyedCallback = 0;
ContactProcessedCallback gContactProcessedCallback = 0;
ContactStartedCallback gContactStartedCallback = 0;
ContactEndedCallback gContactEndedCallback = 0;
///gContactCalcArea3Points will approximate the convex hull area using 3 points
///when setting it to false, it will use 4 points to compute the area: it is more accurate but slower
bool gContactCalcArea3Points = true;

btPersistentManifold::btPersistentManifold()
	: btTypedObject(BT_PERSISTENT_MANIFOLD_TYPE),
	  m_body0(0),
	  m_body1(0),
	  m_cachedPoints(0),
	  m_companionIdA(0),
	  m_companionIdB(0),
	  m_index1a(0)
{
}

#ifdef DEBUG_PERSISTENCY
void btPersistentManifold::DebugPersistency()
{
	int i;
	printf("DebugPersistency : numPoints %d\n", m_cachedPoints);
	for (i = 0; i < m_cachedPoints; i++)
	{
		printf("m_pointCache[%d].m_userPersistentData = %x\n", i, m_pointCache[i].m_userPersistentData);
	}
}
#endif  //DEBUG_PERSISTENCY

void btPersistentManifold::clearUserCache(btManifoldPoint& pt)
{
	void* oldPtr = pt.m_userPersistentData;
	if (oldPtr)
	{
#ifdef DEBUG_PERSISTENCY
		int i;
		int occurance = 0;
		for (i = 0; i < m_cachedPoints; i++)
		{
			if (m_pointCache[i].m_userPersistentData == oldPtr)
			{
				occurance++;
				if (occurance > 1)
					printf("error in clearUserCache\n");
			}
		}
		btAssert(occurance <= 0);
#endif  //DEBUG_PERSISTENCY

		if (pt.m_userPersistentData && gContactDestroyedCallback)
		{
			(*gContactDestroyedCallback)(pt.m_userPersistentData);
			pt.m_userPersistentData = 0;
		}

#ifdef DEBUG_PERSISTENCY
		DebugPersistency();
#endif
	}
}

static inline btScalar calcArea4Points(const btVector3& p0, const btVector3& p1, const btVector3& p2, const btVector3& p3)
{
	// It calculates possible 3 area constructed from random 4 points and returns the biggest one.

	btVector3 a[3], b[3];
	a[0] = p0 - p1;
	a[1] = p0 - p2;
	a[2] = p0 - p3;
	b[0] = p2 - p3;
	b[1] = p1 - p3;
	b[2] = p1 - p2;

	//todo: Following 3 cross production can be easily optimized by SIMD.
	btVector3 tmp0 = a[0].cross(b[0]);
	btVector3 tmp1 = a[1].cross(b[1]);
	btVector3 tmp2 = a[2].cross(b[2]);

	return btMax(btMax(tmp0.length2(), tmp1.length2()), tmp2.length2());
}

int btPersistentManifold::sortCachedPoints(const btManifoldPoint& pt)
{
	//calculate 4 possible cases areas, and take biggest area
	//also need to keep 'deepest'

	int maxPenetrationIndex = -1;
#define KEEP_DEEPEST_POINT 1
#ifdef KEEP_DEEPEST_POINT
	btScalar maxPenetration = pt.getDistance();
	for (int i = 0; i < 4; i++)
	{
		if (m_pointCache[i].getDistance() < maxPenetration)
		{
			maxPenetrationIndex = i;
			maxPenetration = m_pointCache[i].getDistance();
		}
	}
#endif  //KEEP_DEEPEST_POINT

	btScalar res0(btScalar(0.)), res1(btScalar(0.)), res2(btScalar(0.)), res3(btScalar(0.));

	if (gContactCalcArea3Points)
	{
		if (maxPenetrationIndex != 0)
		{
			btVector3 a0 = pt.m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 b0 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
			btVector3 cross = a0.cross(b0);
			res0 = cross.length2();
		}
		if (maxPenetrationIndex != 1)
		{
			btVector3 a1 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b1 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
			btVector3 cross = a1.cross(b1);
			res1 = cross.length2();
		}

		if (maxPenetrationIndex != 2)
		{
			btVector3 a2 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b2 = m_pointCache[3].m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 cross = a2.cross(b2);
			res2 = cross.length2();
		}

		if (maxPenetrationIndex != 3)
		{
			btVector3 a3 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b3 = m_pointCache[2].m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 cross = a3.cross(b3);
			res3 = cross.length2();
		}
	}
	else
	{
		if (maxPenetrationIndex != 0)
		{
			res0 = calcArea4Points(pt.m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 1)
		{
			res1 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 2)
		{
			res2 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 3)
		{
			res3 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA);
		}
	}
	btVector4 maxvec(res0, res1, res2, res3);
	int biggestarea = maxvec.closestAxis4();
	return biggestarea;
}

int btPersistentManifold::getCacheEntry(const btManifoldPoint& newPoint) const
{
	btScalar shortestDist = getContactBreakingThreshold() * getContactBreakingThreshold();
	int size = getNumContacts();
	int nearestPoint = -1;
	for (int i = 0; i < size; i++)
	{
		const btManifoldPoint& mp = m_pointCache[i];

		btVector3 diffA = mp.m_localPointA - newPoint.m_localPointA;
		const btScalar distToManiPoint = diffA.dot(diffA);
		if (distToManiPoint < shortestDist)
		{
			shortestDist = distToManiPoint;
			nearestPoint = i;
		}
	}
	return nearestPoint;
}

int btPersistentManifold::addManifoldPoint(const btManifoldPoint& newPoint, bool isPredictive)
{
	if (!isPredictive)
	{
		btAssert(validContactDistance(newPoint));
	}

	int insertIndex = getNumContacts();
	if (insertIndex == MANIFOLD_CACHE_SIZE)
	{
#if MANIFOLD_CACHE_SIZE >= 4
		//sort cache so best points come first, based on area
		insertIndex = sortCachedPoints(newPoint);
#else
		insertIndex = 0;
#endif
		clearUserCache(m_pointCache[insertIndex]);
	}
	else
	{
		m_cachedPoints++;
	}
	if (insertIndex < 0)
		insertIndex = 0;

	btAssert(m_pointCache[insertIndex].m_userPersistentData == 0);
	m_pointCache[insertIndex] = newPoint;
	return insertIndex;
}

btScalar btPersistentManifold::getContactBreakingThreshold() const
{
	return m_contactBreakingThreshold;
}

void btPersistentManifold::refreshContactPoints(const btTransform& trA, const btTransform& trB)
{
	int i;
#ifdef DEBUG_PERSISTENCY
	printf("refreshContactPoints posA = (%f,%f,%f) posB = (%f,%f,%f)\n",
		   trA.getOrigin().getX(),
		   trA.getOrigin().getY(),
		   trA.getOrigin().getZ(),
		   trB.getOrigin().getX(),
		   trB.getOrigin().getY(),
		   trB.getOrigin().getZ());
#endif  //DEBUG_PERSISTENCY
	/// first refresh worldspace positions and distance
	for (i = getNumContacts() - 1; i >= 0; i--)
	{
		btManifoldPoint& manifoldPoint = m_pointCache[i];
		manifoldPoint.m_positionWorldOnA = trA(manifoldPoint.m_localPointA);
		manifoldPoint.m_positionWorldOnB = trB(manifoldPoint.m_localPointB);
		manifoldPoint.m_distance1 = (manifoldPoint.m_positionWorldOnA - manifoldPoint.m_positionWorldOnB).dot(manifoldPoint.m_normalWorldOnB);
		manifoldPoint.m_lifeTime++;
	}

	/// then
	btScalar distance2d;
	btVector3 projectedDifference, projectedPoint;
	for (i = getNumContacts() - 1; i >= 0; i--)
	{
		btManifoldPoint& manifoldPoint = m_pointCache[i];
		//contact becomes invalid when signed distance exceeds margin (projected on contactnormal direction)
		if (!validContactDistance(manifoldPoint))
		{
			removeContactPoint(i);
		}
		else
		{
			//todo: friction anchor may require the contact to be around a bit longer
			//contact also becomes invalid when relative movement orthogonal to normal exceeds margin
			projectedPoint = manifoldPoint.m_positionWorldOnA - manifoldPoint.m_normalWorldOnB * manifoldPoint.m_distance1;
			projectedDifference = manifoldPoint.m_positionWorldOnB - projectedPoint;
			distance2d = projectedDifference.dot(projectedDifference);
			if (distance2d > getContactBreakingThreshold() * getContactBreakingThreshold())
			{
				removeContactPoint(i);
			}
			else
			{
				//contact point processed callback
				if (gContactProcessedCallback)
					(*gContactProcessedCallback)(manifoldPoint, (void*)m_body0, (void*)m_body1);
			}
		}
	}
#ifdef DEBUG_PERSISTENCY
	DebugPersistency();
#endif  //
}

int btPersistentManifold::calculateSerializeBufferSize() const
{
	return sizeof(btPersistentManifoldData);
}

const char* btPersistentManifold::serialize(const class btPersistentManifold* manifold, void* dataBuffer, class btSerializer* serializer) const
{
	btPersistentManifoldData* dataOut = (btPersistentManifoldData*)dataBuffer;
	memset(dataOut, 0, sizeof(btPersistentManifoldData));

	dataOut->m_body0 = (btCollisionObjectData*)serializer->getUniquePointer((void*)manifold->getBody0());
	dataOut->m_body1 = (btCollisionObjectData*)serializer->getUniquePointer((void*)manifold->getBody1());
	dataOut->m_contactBreakingThreshold = manifold->getContactBreakingThreshold();
	dataOut->m_contactProcessingThreshold = manifold->getContactProcessingThreshold();
	dataOut->m_numCachedPoints = manifold->getNumContacts();
	dataOut->m_companionIdA = manifold->m_companionIdA;
	dataOut->m_companionIdB = manifold->m_companionIdB;
	dataOut->m_index1a = manifold->m_index1a;
	dataOut->m_objectType = manifold->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		const btManifoldPoint& pt = manifold->getContactPoint(i);
		dataOut->m_pointCacheAppliedImpulse[i] = pt.m_appliedImpulse;
		dataOut->m_pointCachePrevRHS[i] = pt.m_prevRHS;
		dataOut->m_pointCacheAppliedImpulseLateral1[i] = pt.m_appliedImpulseLateral1;
		dataOut->m_pointCacheAppliedImpulseLateral2[i] = pt.m_appliedImpulseLateral2;
		pt.m_localPointA.serialize(dataOut->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.serialize(dataOut->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.serialize(dataOut->m_pointCacheNormalWorldOnB[i]);
		dataOut->m_pointCacheDistance[i] = pt.m_distance1;
		dataOut->m_pointCacheCombinedContactDamping1[i] = pt.m_combinedContactDamping1;
		dataOut->m_pointCacheCombinedContactStiffness1[i] = pt.m_combinedContactStiffness1;
		dataOut->m_pointCacheLifeTime[i] = pt.m_lifeTime;
		dataOut->m_pointCacheFrictionCFM[i] = pt.m_frictionCFM;
		dataOut->m_pointCacheContactERP[i] = pt.m_contactERP;
		dataOut->m_pointCacheContactCFM[i] = pt.m_contactCFM;
		dataOut->m_pointCacheContactPointFlags[i] = pt.m_contactPointFlags;
		dataOut->m_pointCacheIndex0[i] = pt.m_index0;
		dataOut->m_pointCacheIndex1[i] = pt.m_index1;
		dataOut->m_pointCachePartId0[i] = pt.m_partId0;
		dataOut->m_pointCachePartId1[i] = pt.m_partId1;
		pt.m_positionWorldOnA.serialize(dataOut->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.serialize(dataOut->m_pointCachePositionWorldOnB[i]);
		dataOut->m_pointCacheCombinedFriction[i] = pt.m_combinedFriction;
		pt.m_lateralFrictionDir1.serialize(dataOut->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.serialize(dataOut->m_pointCacheLateralFrictionDir2[i]);
		dataOut->m_pointCacheCombinedRollingFriction[i] = pt.m_combinedRollingFriction;
		dataOut->m_pointCacheCombinedSpinningFriction[i] = pt.m_combinedSpinningFriction;
		dataOut->m_pointCacheCombinedRestitution[i] = pt.m_combinedRestitution;
		dataOut->m_pointCacheContactMotion1[i] = pt.m_contactMotion1;
		dataOut->m_pointCacheContactMotion2[i] = pt.m_contactMotion2;
	}
	return btPersistentManifoldDataName;
}

void btPersistentManifold::deSerialize(const struct btPersistentManifoldDoubleData* manifoldDataPtr)
{
	m_contactBreakingThreshold = manifoldDataPtr->m_contactBreakingThreshold;
	m_contactProcessingThreshold = manifoldDataPtr->m_contactProcessingThreshold;
	m_cachedPoints = manifoldDataPtr->m_numCachedPoints;
	m_companionIdA = manifoldDataPtr->m_companionIdA;
	m_companionIdB = manifoldDataPtr->m_companionIdB;
	//m_index1a = manifoldDataPtr->m_index1a;
	m_objectType = manifoldDataPtr->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		btManifoldPoint& pt = m_pointCache[i];

		pt.m_appliedImpulse = manifoldDataPtr->m_pointCacheAppliedImpulse[i];
		pt.m_prevRHS = manifoldDataPtr->m_pointCachePrevRHS[i];
		pt.m_appliedImpulseLateral1 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral1[i];
		pt.m_appliedImpulseLateral2 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral2[i];
		pt.m_localPointA.deSerializeDouble(manifoldDataPtr->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.deSerializeDouble(manifoldDataPtr->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.deSerializeDouble(manifoldDataPtr->m_pointCacheNormalWorldOnB[i]);
		pt.m_distance1 = manifoldDataPtr->m_pointCacheDistance[i];
		pt.m_combinedContactDamping1 = manifoldDataPtr->m_pointCacheCombinedContactDamping1[i];
		pt.m_combinedContactStiffness1 = manifoldDataPtr->m_pointCacheCombinedContactStiffness1[i];
		pt.m_lifeTime = manifoldDataPtr->m_pointCacheLifeTime[i];
		pt.m_frictionCFM = manifoldDataPtr->m_pointCacheFrictionCFM[i];
		pt.m_contactERP = manifoldDataPtr->m_pointCacheContactERP[i];
		pt.m_contactCFM = manifoldDataPtr->m_pointCacheContactCFM[i];
		pt.m_contactPointFlags = manifoldDataPtr->m_pointCacheContactPointFlags[i];
		pt.m_index0 = manifoldDataPtr->m_pointCacheIndex0[i];
		pt.m_index1 = manifoldDataPtr->m_pointCacheIndex1[i];
		pt.m_partId0 = manifoldDataPtr->m_pointCachePartId0[i];
		pt.m_partId1 = manifoldDataPtr->m_pointCachePartId1[i];
		pt.m_positionWorldOnA.deSerializeDouble(manifoldDataPtr->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.deSerializeDouble(manifoldDataPtr->m_pointCachePositionWorldOnB[i]);
		pt.m_combinedFriction = manifoldDataPtr->m_pointCacheCombinedFriction[i];
		pt.m_lateralFrictionDir1.deSerializeDouble(manifoldDataPtr->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.deSerializeDouble(manifoldDataPtr->m_pointCacheLateralFrictionDir2[i]);
		pt.m_combinedRollingFriction = manifoldDataPtr->m_pointCacheCombinedRollingFriction[i];
		pt.m_combinedSpinningFriction = manifoldDataPtr->m_pointCacheCombinedSpinningFriction[i];
		pt.m_combinedRestitution = manifoldDataPtr->m_pointCacheCombinedRestitution[i];
		pt.m_contactMotion1 = manifoldDataPtr->m_pointCacheContactMotion1[i];
		pt.m_contactMotion2 = manifoldDataPtr->m_pointCacheContactMotion2[i];
	}
}

void btPersistentManifold::deSerialize(const struct btPersistentManifoldFloatData* manifoldDataPtr)
{
	m_contactBreakingThreshold = manifoldDataPtr->m_contactBreakingThreshold;
	m_contactProcessingThreshold = manifoldDataPtr->m_contactProcessingThreshold;
	m_cachedPoints = manifoldDataPtr->m_numCachedPoints;
	m_companionIdA = manifoldDataPtr->m_companionIdA;
	m_companionIdB = manifoldDataPtr->m_companionIdB;
	//m_index1a = manifoldDataPtr->m_index1a;
	m_objectType = manifoldDataPtr->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		btManifoldPoint& pt = m_pointCache[i];

		pt.m_appliedImpulse = manifoldDataPtr->m_pointCacheAppliedImpulse[i];
		pt.m_prevRHS = manifoldDataPtr->m_pointCachePrevRHS[i];
		pt.m_appliedImpulseLateral1 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral1[i];
		pt.m_appliedImpulseLateral2 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral2[i];
		pt.m_localPointA.deSerialize(manifoldDataPtr->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.deSerialize(manifoldDataPtr->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.deSerialize(manifoldDataPtr->m_pointCacheNormalWorldOnB[i]);
		pt.m_distance1 = manifoldDataPtr->m_pointCacheDistance[i];
		pt.m_combinedContactDamping1 = manifoldDataPtr->m_pointCacheCombinedContactDamping1[i];
		pt.m_combinedContactStiffness1 = manifoldDataPtr->m_pointCacheCombinedContactStiffness1[i];
		pt.m_lifeTime = manifoldDataPtr->m_pointCacheLifeTime[i];
		pt.m_frictionCFM = manifoldDataPtr->m_pointCacheFrictionCFM[i];
		pt.m_contactERP = manifoldDataPtr->m_pointCacheContactERP[i];
		pt.m_contactCFM = manifoldDataPtr->m_pointCacheContactCFM[i];
		pt.m_contactPointFlags = manifoldDataPtr->m_pointCacheContactPointFlags[i];
		pt.m_index0 = manifoldDataPtr->m_pointCacheIndex0[i];
		pt.m_index1 = manifoldDataPtr->m_pointCacheIndex1[i];
		pt.m_partId0 = manifoldDataPtr->m_pointCachePartId0[i];
		pt.m_partId1 = manifoldDataPtr->m_pointCachePartId1[i];
		pt.m_positionWorldOnA.deSerialize(manifoldDataPtr->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.deSerialize(manifoldDataPtr->m_pointCachePositionWorldOnB[i]);
		pt.m_combinedFriction = manifoldDataPtr->m_pointCacheCombinedFriction[i];
		pt.m_lateralFrictionDir1.deSerialize(manifoldDataPtr->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.deSerialize(manifoldDataPtr->m_pointCacheLateralFrictionDir2[i]);
		pt.m_combinedRollingFriction = manifoldDataPtr->m_pointCacheCombinedRollingFriction[i];
		pt.m_combinedSpinningFriction = manifoldDataPtr->m_pointCacheCombinedSpinningFriction[i];
		pt.m_combinedRestitution = manifoldDataPtr->m_pointCacheCombinedRestitution[i];
		pt.m_contactMotion1 = manifoldDataPtr->m_pointCacheContactMotion1[i];
		pt.m_contactMotion2 = manifoldDataPtr->m_pointCacheContactMotion2[i];
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_PERSISTENT_MANIFOLD_H
#define BT_PERSISTENT_MANIFOLD_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
class btCollisionObject;
#include "LinearMath/btAlignedAllocator.h"

struct btCollisionResult;
struct btCollisionObjectDoubleData;
struct btCollisionObjectFloatData;

///maximum contact breaking and merging threshold
extern btScalar gContactBreakingThreshold;

#ifndef SWIG
class btPersistentManifold;

typedef bool (*ContactDestroyedCallback)(void* userPersistentData);
typedef bool (*ContactProcessedCallback)(btManifoldPoint& cp, void* body0, void* body1);
typedef void (*ContactStartedCallback)(btPersistentManifold* const& manifold);
typedef void (*ContactEndedCallback)(btPersistentManifold* const& manifold);
extern ContactDestroyedCallback gContactDestroyedCallback;
extern ContactProcessedCallback gContactProcessedCallback;
extern ContactStartedCallback gContactStartedCallback;
extern ContactEndedCallback gContactEndedCallback;
#endif  //SWIG

//the enum starts at 1024 to avoid type conflicts with btTypedConstraint
enum btContactManifoldTypes
{
	MIN_CONTACT_MANIFOLD_TYPE = 1024,
	BT_PERSISTENT_MANIFOLD_TYPE
};

#define MANIFOLD_CACHE_SIZE 4

///btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
///Those contact points are created by the collision narrow phase.
///The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
///updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
///reduces the cache to 4 points, when more then 4 points are added, using following rules:
///the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
///note that some pairs of objects might have more then one contact manifold.

//ATTRIBUTE_ALIGNED128( class) btPersistentManifold : public btTypedObject
ATTRIBUTE_ALIGNED16(class)
btPersistentManifold : public btTypedObject
{
	btManifoldPoint m_pointCache[MANIFOLD_CACHE_SIZE];

	/// this two body pointers can point to the physics rigidbody class.
	const btCollisionObject* m_body0;
	const btCollisionObject* m_body1;

	int m_cachedPoints;

	btScalar m_contactBreakingThreshold;
	btScalar m_contactProcessingThreshold;

	/// sort cached points so most isolated points come first
	int sortCachedPoints(const btManifoldPoint& pt);

	int findContactPoint(const btManifoldPoint* unUsed, int numUnused, const btManifoldPoint& pt);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	int m_companionIdA;
	int m_companionIdB;

	int m_index1a;

	btPersistentManifold();

	btPersistentManifold(const btCollisionObject* body0, const btCollisionObject* body1, int, btScalar contactBreakingThreshold, btScalar contactProcessingThreshold)
		: btTypedObject(BT_PERSISTENT_MANIFOLD_TYPE),
		  m_body0(body0),
		  m_body1(body1),
		  m_cachedPoints(0),
		  m_contactBreakingThreshold(contactBreakingThreshold),
		  m_contactProcessingThreshold(contactProcessingThreshold),
		  m_companionIdA(0),
		  m_companionIdB(0),
		  m_index1a(0)
	{
	}

	SIMD_FORCE_INLINE const btCollisionObject* getBody0() const { return m_body0; }
	SIMD_FORCE_INLINE const btCollisionObject* getBody1() const { return m_body1; }

	void setBodies(const btCollisionObject* body0, const btCollisionObject* body1)
	{
		m_body0 = body0;
		m_body1 = body1;
	}

	void clearUserCache(btManifoldPoint & pt);

#ifdef DEBUG_PERSISTENCY
	void DebugPersistency();
#endif  //

	SIMD_FORCE_INLINE int getNumContacts() const
	{
		return m_cachedPoints;
	}
	/// the setNumContacts API is usually not used, except when you gather/fill all contacts manually
	void setNumContacts(int cachedPoints)
	{
		m_cachedPoints = cachedPoints;
	}

	SIMD_FORCE_INLINE const btManifoldPoint& getContactPoint(int index) const
	{
		btAssert(index < m_cachedPoints);
		return m_pointCache[index];
	}

	SIMD_FORCE_INLINE btManifoldPoint& getContactPoint(int index)
	{
		btAssert(index < m_cachedPoints);
		return m_pointCache[index];
	}

	///@todo: get this margin from the current physics / collision environment
	btScalar getContactBreakingThreshold() const;

	btScalar getContactProcessingThreshold() const
	{
		return m_contactProcessingThreshold;
	}

	void setContactBreakingThreshold(btScalar contactBreakingThreshold)
	{
		m_contactBreakingThreshold = contactBreakingThreshold;
	}

	void setContactProcessingThreshold(btScalar contactProcessingThreshold)
	{
		m_contactProcessingThreshold = contactProcessingThreshold;
	}

	int getCacheEntry(const btManifoldPoint& newPoint) const;

	int addManifoldPoint(const btManifoldPoint& newPoint, bool isPredictive = false);

	void removeContactPoint(int index)
	{
		clearUserCache(m_pointCache[index]);

		int lastUsedIndex = getNumContacts() - 1;
		//		m_pointCache[index] = m_pointCache[lastUsedIndex];
		if (index != lastUsedIndex)
		{
			m_pointCache[index] = m_pointCache[lastUsedIndex];
			//get rid of duplicated userPersistentData pointer
			m_pointCache[lastUsedIndex].m_userPersistentData = 0;
			m_pointCache[lastUsedIndex].m_appliedImpulse = 0.f;
			m_pointCache[lastUsedIndex].m_prevRHS = 0.f;
			m_pointCache[lastUsedIndex].m_contactPointFlags = 0;
			m_pointCache[lastUsedIndex].m_appliedImpulseLateral1 = 0.f;
			m_pointCache[lastUsedIndex].m_appliedImpulseLateral2 = 0.f;
			m_pointCache[lastUsedIndex].m_lifeTime = 0;
		}

		btAssert(m_pointCache[lastUsedIndex].m_userPersistentData == 0);
		m_cachedPoints--;

		if (gContactEndedCallback && m_cachedPoints == 0)
		{
			gContactEndedCallback(this);
		}
	}
	void replaceContactPoint(const btManifoldPoint& newPoint, int insertIndex)
	{
		btAssert(validContactDistance(newPoint));

#define MAINTAIN_PERSISTENCY 1
#ifdef MAINTAIN_PERSISTENCY
		int lifeTime = m_pointCache[insertIndex].getLifeTime();
		btScalar appliedImpulse = m_pointCache[insertIndex].m_appliedImpulse;
		btScalar prevRHS = m_pointCache[insertIndex].m_prevRHS;
		btScalar appliedLateralImpulse1 = m_pointCache[insertIndex].m_appliedImpulseLateral1;
		btScalar appliedLateralImpulse2 = m_pointCache[insertIndex].m_appliedImpulseLateral2;

		bool replacePoint = true;
		///we keep existing contact points for friction anchors
		///if the friction force is within the Coulomb friction cone
		if (newPoint.m_contactPointFlags & BT_CONTACT_FLAG_FRICTION_ANCHOR)
		{
			//   printf("appliedImpulse=%f\n", appliedImpulse);
			//   printf("appliedLateralImpulse1=%f\n", appliedLateralImpulse1);
			//   printf("appliedLateralImpulse2=%f\n", appliedLateralImpulse2);
			//   printf("mu = %f\n", m_pointCache[insertIndex].m_combinedFriction);
			btScalar mu = m_pointCache[insertIndex].m_combinedFriction;
			btScalar eps = 0;  //we could allow to enlarge or shrink the tolerance to check against the friction cone a bit, say 1e-7
			btScalar a = appliedLateralImpulse1 * appliedLateralImpulse1 + appliedLateralImpulse2 * appliedLateralImpulse2;
			btScalar b = eps + mu * appliedImpulse;
			b = b * b;
			replacePoint = (a) > (b);
		}

		if (replacePoint)
		{
			btAssert(lifeTime >= 0);
			void* cache = m_pointCache[insertIndex].m_userPersistentData;

			m_pointCache[insertIndex] = newPoint;
			m_pointCache[insertIndex].m_userPersistentData = cache;
			m_pointCache[insertIndex].m_appliedImpulse = appliedImpulse;
			m_pointCache[insertIndex].m_prevRHS = prevRHS;
			m_pointCache[insertIndex].m_appliedImpulseLateral1 = appliedLateralImpulse1;
			m_pointCache[insertIndex].m_appliedImpulseLateral2 = appliedLateralImpulse2;
		}

		m_pointCache[insertIndex].m_lifeTime = lifeTime;
#else
		clearUserCache(m_pointCache[insertIndex]);
		m_pointCache[insertIndex] = newPoint;

#endif
	}

	bool validContactDistance(const btManifoldPoint& pt) const
	{
		return pt.m_distance1 <= getContactBreakingThreshold();
	}
	/// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
	void refreshContactPoints(const btTransform& trA, const btTransform& trB);

	SIMD_FORCE_INLINE void clearManifold()
	{
		int i;
		for (i = 0; i < m_cachedPoints; i++)
		{
			clearUserCache(m_pointCache[i]);
		}

		if (gContactEndedCallback && m_cachedPoints)
		{
			gContactEndedCallback(this);
		}
		m_cachedPoints = 0;
	}

	int calculateSerializeBufferSize() const;
	const char* serialize(const class btPersistentManifold* manifold, void* dataBuffer, class btSerializer* serializer) const;
	void deSerialize(const struct btPersistentManifoldDoubleData* manifoldDataPtr);
	void deSerialize(const struct btPersistentManifoldFloatData* manifoldDataPtr);
};

// clang-format off

struct btPersistentManifoldDoubleData
{
	btVector3DoubleData m_pointCacheLocalPointA[4];
	btVector3DoubleData m_pointCacheLocalPointB[4];
	btVector3DoubleData m_pointCachePositionWorldOnA[4];
	btVector3DoubleData m_pointCachePositionWorldOnB[4];
	btVector3DoubleData m_pointCacheNormalWorldOnB[4];
	btVector3DoubleData	m_pointCacheLateralFrictionDir1[4];
	btVector3DoubleData	m_pointCacheLateralFrictionDir2[4];
	double m_pointCacheDistance[4];
	double m_pointCacheAppliedImpulse[4];
	double m_pointCachePrevRHS[4];
	 double m_pointCacheCombinedFriction[4];
	double m_pointCacheCombinedRollingFriction[4];
	double m_pointCacheCombinedSpinningFriction[4];
	double m_pointCacheCombinedRestitution[4];
	int	m_pointCachePartId0[4];
	int	m_pointCachePartId1[4];
	int	m_pointCacheIndex0[4];
	int	m_pointCacheIndex1[4];
	int m_pointCacheContactPointFlags[4];
	double m_pointCacheAppliedImpulseLateral1[4];
	double m_pointCacheAppliedImpulseLateral2[4];
	double m_pointCacheContactMotion1[4];
	double m_pointCacheContactMotion2[4];
	double m_pointCacheContactCFM[4];
	double m_pointCacheCombinedContactStiffness1[4];
	double m_pointCacheContactERP[4];
	double m_pointCacheCombinedContactDamping1[4];
	double m_pointCacheFrictionCFM[4];
	int m_pointCacheLifeTime[4];

	int m_numCachedPoints;
	int m_companionIdA;
	int m_companionIdB;
	int m_index1a;

	int m_objectType;
	double	m_contactBreakingThreshold;
	double	m_contactProcessingThreshold;
	int m_padding;

	btCollisionObjectDoubleData *m_body0;
	btCollisionObjectDoubleData *m_body1;
};


struct btPersistentManifoldFloatData
{
	btVector3FloatData m_pointCacheLocalPointA[4];
	btVector3FloatData m_pointCacheLocalPointB[4];
	btVector3FloatData m_pointCachePositionWorldOnA[4];
	btVector3FloatData m_pointCachePositionWorldOnB[4];
	btVector3FloatData m_pointCacheNormalWorldOnB[4];
	btVector3FloatData	m_pointCacheLateralFrictionDir1[4];
	btVector3FloatData	m_pointCacheLateralFrictionDir2[4];
	float m_pointCacheDistance[4];
	float m_pointCacheAppliedImpulse[4];
	float m_pointCachePrevRHS[4];
	float m_pointCacheCombinedFriction[4];
	float m_pointCacheCombinedRollingFriction[4];
	float m_pointCacheCombinedSpinningFriction[4];
	float m_pointCacheCombinedRestitution[4];
	int	m_pointCachePartId0[4];
	int	m_pointCachePartId1[4];
	int	m_pointCacheIndex0[4];
	int	m_pointCacheIndex1[4];
	int m_pointCacheContactPointFlags[4];
	float m_pointCacheAppliedImpulseLateral1[4];
	float m_pointCacheAppliedImpulseLateral2[4];
	float m_pointCacheContactMotion1[4];
	float m_pointCacheContactMotion2[4];
	float m_pointCacheContactCFM[4];
	float m_pointCacheCombinedContactStiffness1[4];
	float m_pointCacheContactERP[4];
	float m_pointCacheCombinedContactDamping1[4];
	float m_pointCacheFrictionCFM[4];
	int m_pointCacheLifeTime[4];

	int m_numCachedPoints;
	int m_companionIdA;
	int m_companionIdB;
	int m_index1a;

	int m_objectType;
	float	m_contactBreakingThreshold;
	float	m_contactProcessingThreshold;
	int m_padding;

	btCollisionObjectFloatData *m_body0;
	btCollisionObjectFloatData *m_body1;
};

// clang-format on

#ifdef BT_USE_DOUBLE_PRECISION
#define btPersistentManifoldData btPersistentManifoldDoubleData
#define btPersistentManifoldDataName "btPersistentManifoldDoubleData"
#else
#define btPersistentManifoldData btPersistentManifoldFloatData
#define btPersistentManifoldDataName "btPersistentManifoldFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#endif  //BT_PERSISTENT_MANIFOLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H
#define BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"

/// This interface is made to be used by an iterative approach to do TimeOfImpact calculations
/// This interface allows to query for closest points and penetration depth between two (convex) objects
/// the closest point is on the second object (B), and the normal points from the surface on B towards A.
/// distance is between closest points on B and closest point on A. So you can calculate closest point on A
/// by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
struct btDiscreteCollisionDetectorInterface
{
	struct Result
	{
		virtual ~Result() {}

		///setShapeIdentifiersA/B provides experimental support for per-triangle material / custom material combiner
		virtual void setShapeIdentifiersA(int partId0, int index0) = 0;
		virtual void setShapeIdentifiersB(int partId1, int index1) = 0;
		virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth) = 0;
	};

	struct ClosestPointInput
	{
		ClosestPointInput()
			: m_maximumDistanceSquared(btScalar(BT_LARGE_FLOAT))
		{
		}

		btTransform m_transformA;
		btTransform m_transformB;
		btScalar m_maximumDistanceSquared;
	};

	virtual ~btDiscreteCollisionDetectorInterface(){};

	//
	// give either closest points (distance > 0) or penetration (distance)
	// the normal always points from B towards A
	//
	virtual void getClosestPoints(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw, bool swapResults = false) = 0;
};

struct btStorageResult : public btDiscreteCollisionDetectorInterface::Result
{
	btVector3 m_normalOnSurfaceB;
	btVector3 m_closestPointInB;
	btScalar m_distance;  //negative means penetration !

protected:
	btStorageResult() : m_distance(btScalar(BT_LARGE_FLOAT))
	{
	}

public:
	virtual ~btStorageResult(){};

	virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
	{
		if (depth < m_distance)
		{
			m_normalOnSurfaceB = normalOnBInWorld;
			m_closestPointInB = pointInWorld;
			m_distance = depth;
		}
	}
};

#endif  //BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H





#ifndef BT_COLLISION_OBJECT_WRAPPER_H
#define BT_COLLISION_OBJECT_WRAPPER_H

///btCollisionObjectWrapperis an internal data structure.
///Most users can ignore this and use btCollisionObject and btCollisionShape instead
class btCollisionShape;
class btCollisionObject;
class btTransform;
#include "LinearMath/btScalar.h"

#define BT_DECLARE_STACK_ONLY_OBJECT \
public:                            \
	void operator delete(void*);	\
private:                             \
	void* operator new(size_t size); \

struct btCollisionObjectWrapper;
struct btCollisionObjectWrapper
{
	BT_DECLARE_STACK_ONLY_OBJECT

private:
	btCollisionObjectWrapper(const btCollisionObjectWrapper&);  // not implemented. Not allowed.
	btCollisionObjectWrapper* operator=(const btCollisionObjectWrapper&);

public:
	const btCollisionObjectWrapper* m_parent;
	const btCollisionShape* m_shape;
	const btCollisionObject* m_collisionObject;
	const btTransform& m_worldTransform;
    const btTransform* m_preTransform;
	int m_partId;
	int m_index;

	btCollisionObjectWrapper(const btCollisionObjectWrapper* parent, const btCollisionShape* shape, const btCollisionObject* collisionObject, const btTransform& worldTransform, int partId, int index)
		: m_parent(parent), m_shape(shape), m_collisionObject(collisionObject), m_worldTransform(worldTransform), m_preTransform(NULL), m_partId(partId), m_index(index)
	{
	}
    
    btCollisionObjectWrapper(const btCollisionObjectWrapper* parent, const btCollisionShape* shape, const btCollisionObject* collisionObject, const btTransform& worldTransform, const btTransform& preTransform, int partId, int index)
    : m_parent(parent), m_shape(shape), m_collisionObject(collisionObject), m_worldTransform(worldTransform), m_preTransform(&preTransform), m_partId(partId), m_index(index)
    {
    }

	SIMD_FORCE_INLINE const btTransform& getWorldTransform() const { return m_worldTransform; }
	SIMD_FORCE_INLINE const btCollisionObject* getCollisionObject() const { return m_collisionObject; }
	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const { return m_shape; }
};

#endif  //BT_COLLISION_OBJECT_WRAPPER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btManifoldResult.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

///This is to allow MaterialCombiner/Custom Friction/Restitution values
ContactAddedCallback gContactAddedCallback = 0;

CalculateCombinedCallback gCalculateCombinedRestitutionCallback = &btManifoldResult::calculateCombinedRestitution;
CalculateCombinedCallback gCalculateCombinedFrictionCallback = &btManifoldResult::calculateCombinedFriction;
CalculateCombinedCallback gCalculateCombinedRollingFrictionCallback = &btManifoldResult::calculateCombinedRollingFriction;
CalculateCombinedCallback gCalculateCombinedSpinningFrictionCallback = &btManifoldResult::calculateCombinedSpinningFriction;
CalculateCombinedCallback gCalculateCombinedContactDampingCallback = &btManifoldResult::calculateCombinedContactDamping;
CalculateCombinedCallback gCalculateCombinedContactStiffnessCallback = &btManifoldResult::calculateCombinedContactStiffness;

btScalar btManifoldResult::calculateCombinedRollingFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
	btScalar friction = body0->getRollingFriction() * body1->getFriction() + body1->getRollingFriction() * body0->getFriction();

	const btScalar MAX_FRICTION = btScalar(10.);
	if (friction < -MAX_FRICTION)
		friction = -MAX_FRICTION;
	if (friction > MAX_FRICTION)
		friction = MAX_FRICTION;
	return friction;
}

btScalar btManifoldResult::calculateCombinedSpinningFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
	btScalar friction = body0->getSpinningFriction() * body1->getFriction() + body1->getSpinningFriction() * body0->getFriction();

	const btScalar MAX_FRICTION = btScalar(10.);
	if (friction < -MAX_FRICTION)
		friction = -MAX_FRICTION;
	if (friction > MAX_FRICTION)
		friction = MAX_FRICTION;
	return friction;
}

///User can override this material combiner by implementing gContactAddedCallback and setting body0->m_collisionFlags |= btCollisionObject::customMaterialCallback;
btScalar btManifoldResult::calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1)
{
	btScalar friction = body0->getFriction() * body1->getFriction();

	const btScalar MAX_FRICTION = btScalar(10.);
	if (friction < -MAX_FRICTION)
		friction = -MAX_FRICTION;
	if (friction > MAX_FRICTION)
		friction = MAX_FRICTION;
	return friction;
}

btScalar btManifoldResult::calculateCombinedRestitution(const btCollisionObject* body0, const btCollisionObject* body1)
{
	return body0->getRestitution() * body1->getRestitution();
}

btScalar btManifoldResult::calculateCombinedContactDamping(const btCollisionObject* body0, const btCollisionObject* body1)
{
	return body0->getContactDamping() + body1->getContactDamping();
}

btScalar btManifoldResult::calculateCombinedContactStiffness(const btCollisionObject* body0, const btCollisionObject* body1)
{
	btScalar s0 = body0->getContactStiffness();
	btScalar s1 = body1->getContactStiffness();

	btScalar tmp0 = btScalar(1) / s0;
	btScalar tmp1 = btScalar(1) / s1;
	btScalar combinedStiffness = btScalar(1) / (tmp0 + tmp1);
	return combinedStiffness;
}

btManifoldResult::btManifoldResult(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
	: m_manifoldPtr(0),
	  m_body0Wrap(body0Wrap),
	  m_body1Wrap(body1Wrap)
	  ,
	  m_partId0(-1),
	  m_partId1(-1),
	  m_index0(-1),
	  m_index1(-1)
	  ,
	  m_closestPointDistanceThreshold(0)
{
}

void btManifoldResult::addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
{
	btAssert(m_manifoldPtr);
	//order in manifold needs to match

	if (depth > m_manifoldPtr->getContactBreakingThreshold())
		//	if (depth > m_manifoldPtr->getContactProcessingThreshold())
		return;

	bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
	bool isNewCollision = m_manifoldPtr->getNumContacts() == 0;

	btVector3 pointA = pointInWorld + normalOnBInWorld * depth;

	btVector3 localA;
	btVector3 localB;

	if (isSwapped)
	{
		localA = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
		localB = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
	}
	else
	{
		localA = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
		localB = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
	}

	btManifoldPoint newPt(localA, localB, normalOnBInWorld, depth);
	newPt.m_positionWorldOnA = pointA;
	newPt.m_positionWorldOnB = pointInWorld;

	int insertIndex = m_manifoldPtr->getCacheEntry(newPt);

	newPt.m_combinedFriction = gCalculateCombinedFrictionCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
	newPt.m_combinedRestitution = gCalculateCombinedRestitutionCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
	newPt.m_combinedRollingFriction = gCalculateCombinedRollingFrictionCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
	newPt.m_combinedSpinningFriction = gCalculateCombinedSpinningFrictionCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());

	if ((m_body0Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING) ||
		(m_body1Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING))
	{
		newPt.m_combinedContactDamping1 = gCalculateCombinedContactDampingCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
		newPt.m_combinedContactStiffness1 = gCalculateCombinedContactStiffnessCallback(m_body0Wrap->getCollisionObject(), m_body1Wrap->getCollisionObject());
		newPt.m_contactPointFlags |= BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING;
	}

	if ((m_body0Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_HAS_FRICTION_ANCHOR) ||
		(m_body1Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_HAS_FRICTION_ANCHOR))
	{
		newPt.m_contactPointFlags |= BT_CONTACT_FLAG_FRICTION_ANCHOR;
	}

	btPlaneSpace1(newPt.m_normalWorldOnB, newPt.m_lateralFrictionDir1, newPt.m_lateralFrictionDir2);

	//BP mod, store contact triangles.
	if (isSwapped)
	{
		newPt.m_partId0 = m_partId1;
		newPt.m_partId1 = m_partId0;
		newPt.m_index0 = m_index1;
		newPt.m_index1 = m_index0;
	}
	else
	{
		newPt.m_partId0 = m_partId0;
		newPt.m_partId1 = m_partId1;
		newPt.m_index0 = m_index0;
		newPt.m_index1 = m_index1;
	}
	//printf("depth=%f\n",depth);
	///@todo, check this for any side effects
	if (insertIndex >= 0)
	{
		//const btManifoldPoint& oldPoint = m_manifoldPtr->getContactPoint(insertIndex);
		m_manifoldPtr->replaceContactPoint(newPt, insertIndex);
	}
	else
	{
		insertIndex = m_manifoldPtr->addManifoldPoint(newPt);
	}

	//User can override friction and/or restitution
	if (gContactAddedCallback &&
		//and if either of the two bodies requires custom material
		((m_body0Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK) ||
		 (m_body1Wrap->getCollisionObject()->getCollisionFlags() & btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK)))
	{
		//experimental feature info, for per-triangle material etc.
		const btCollisionObjectWrapper* obj0Wrap = isSwapped ? m_body1Wrap : m_body0Wrap;
		const btCollisionObjectWrapper* obj1Wrap = isSwapped ? m_body0Wrap : m_body1Wrap;
		(*gContactAddedCallback)(m_manifoldPtr->getContactPoint(insertIndex), obj0Wrap, newPt.m_partId0, newPt.m_index0, obj1Wrap, newPt.m_partId1, newPt.m_index1);
	}

	if (gContactStartedCallback && isNewCollision)
	{
		gContactStartedCallback(m_manifoldPtr);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MANIFOLD_RESULT_H
#define BT_MANIFOLD_RESULT_H

class btCollisionObject;
struct btCollisionObjectWrapper;

#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
class btManifoldPoint;

#include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"

#include "LinearMath/btTransform.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

typedef bool (*ContactAddedCallback)(btManifoldPoint& cp, const btCollisionObjectWrapper* colObj0Wrap, int partId0, int index0, const btCollisionObjectWrapper* colObj1Wrap, int partId1, int index1);
extern ContactAddedCallback gContactAddedCallback;

//#define DEBUG_PART_INDEX 1

/// These callbacks are used to customize the algorith that combine restitution, friction, damping, Stiffness
typedef btScalar (*CalculateCombinedCallback)(const btCollisionObject* body0, const btCollisionObject* body1);

extern CalculateCombinedCallback gCalculateCombinedRestitutionCallback;
extern CalculateCombinedCallback gCalculateCombinedFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedRollingFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedSpinningFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedContactDampingCallback;
extern CalculateCombinedCallback gCalculateCombinedContactStiffnessCallback;

///btManifoldResult is a helper class to manage  contact results.
class btManifoldResult : public btDiscreteCollisionDetectorInterface::Result
{
protected:
	btPersistentManifold* m_manifoldPtr;

	const btCollisionObjectWrapper* m_body0Wrap;
	const btCollisionObjectWrapper* m_body1Wrap;
	int m_partId0;
	int m_partId1;
	int m_index0;
	int m_index1;

public:
	btManifoldResult()
		:
#ifdef DEBUG_PART_INDEX

		  m_partId0(-1),
		  m_partId1(-1),
		  m_index0(-1),
		  m_index1(-1)
#endif  //DEBUG_PART_INDEX
			  m_closestPointDistanceThreshold(0)
	{
	}

	btManifoldResult(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);

	virtual ~btManifoldResult(){};

	void setPersistentManifold(btPersistentManifold* manifoldPtr)
	{
		m_manifoldPtr = manifoldPtr;
	}

	const btPersistentManifold* getPersistentManifold() const
	{
		return m_manifoldPtr;
	}
	btPersistentManifold* getPersistentManifold()
	{
		return m_manifoldPtr;
	}

	virtual void setShapeIdentifiersA(int partId0, int index0)
	{
		m_partId0 = partId0;
		m_index0 = index0;
	}

	virtual void setShapeIdentifiersB(int partId1, int index1)
	{
		m_partId1 = partId1;
		m_index1 = index1;
	}

	virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth);

	SIMD_FORCE_INLINE void refreshContactPoints()
	{
		btAssert(m_manifoldPtr);
		if (!m_manifoldPtr->getNumContacts())
			return;

		bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();

		if (isSwapped)
		{
			m_manifoldPtr->refreshContactPoints(m_body1Wrap->getCollisionObject()->getWorldTransform(), m_body0Wrap->getCollisionObject()->getWorldTransform());
		}
		else
		{
			m_manifoldPtr->refreshContactPoints(m_body0Wrap->getCollisionObject()->getWorldTransform(), m_body1Wrap->getCollisionObject()->getWorldTransform());
		}
	}

	const btCollisionObjectWrapper* getBody0Wrap() const
	{
		return m_body0Wrap;
	}
	const btCollisionObjectWrapper* getBody1Wrap() const
	{
		return m_body1Wrap;
	}

	void setBody0Wrap(const btCollisionObjectWrapper* obj0Wrap)
	{
		m_body0Wrap = obj0Wrap;
	}

	void setBody1Wrap(const btCollisionObjectWrapper* obj1Wrap)
	{
		m_body1Wrap = obj1Wrap;
	}

	const btCollisionObject* getBody0Internal() const
	{
		return m_body0Wrap->getCollisionObject();
	}

	const btCollisionObject* getBody1Internal() const
	{
		return m_body1Wrap->getCollisionObject();
	}

	btScalar m_closestPointDistanceThreshold;

	/// in the future we can let the user override the methods to combine restitution and friction
	static btScalar calculateCombinedRestitution(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedRollingFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedSpinningFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedContactDamping(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedContactStiffness(const btCollisionObject* body0, const btCollisionObject* body1);
};

#endif  //BT_MANIFOLD_RESULT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_CREATE_FUNC
#define BT_COLLISION_CREATE_FUNC

#include "LinearMath/btAlignedObjectArray.h"
class btCollisionAlgorithm;
class btCollisionObject;
struct btCollisionObjectWrapper;
struct btCollisionAlgorithmConstructionInfo;

///Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
struct btCollisionAlgorithmCreateFunc
{
	bool m_swapped;

	btCollisionAlgorithmCreateFunc()
		: m_swapped(false)
	{
	}
	virtual ~btCollisionAlgorithmCreateFunc(){};

	virtual btCollisionAlgorithm* CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo&, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap)
	{
		(void)body0Wrap;
		(void)body1Wrap;
		return 0;
	}
};
#endif  //BT_COLLISION_CREATE_FUNC





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "LinearMath/btQuickprof.h"

#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"

#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btPoolAllocator.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

#ifdef BT_DEBUG
#endif

btCollisionDispatcher::btCollisionDispatcher(btCollisionConfiguration* collisionConfiguration) : m_dispatcherFlags(btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD),
																								 m_collisionConfiguration(collisionConfiguration)
{
	int i;

	setNearCallback(defaultNearCallback);

	m_collisionAlgorithmPoolAllocator = collisionConfiguration->getCollisionAlgorithmPool();

	m_persistentManifoldPoolAllocator = collisionConfiguration->getPersistentManifoldPool();

	for (i = 0; i < MAX_BROADPHASE_COLLISION_TYPES; i++)
	{
		for (int j = 0; j < MAX_BROADPHASE_COLLISION_TYPES; j++)
		{
			m_doubleDispatchContactPoints[i][j] = m_collisionConfiguration->getCollisionAlgorithmCreateFunc(i, j);
			btAssert(m_doubleDispatchContactPoints[i][j]);
			m_doubleDispatchClosestPoints[i][j] = m_collisionConfiguration->getClosestPointsAlgorithmCreateFunc(i, j);
		}
	}
}

void btCollisionDispatcher::registerCollisionCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc* createFunc)
{
	m_doubleDispatchContactPoints[proxyType0][proxyType1] = createFunc;
}

void btCollisionDispatcher::registerClosestPointsCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc* createFunc)
{
	m_doubleDispatchClosestPoints[proxyType0][proxyType1] = createFunc;
}

btCollisionDispatcher::~btCollisionDispatcher()
{
}

btPersistentManifold* btCollisionDispatcher::getNewManifold(const btCollisionObject* body0, const btCollisionObject* body1)
{
	//btAssert(gNumManifold < 65535);

	//optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)

	btScalar contactBreakingThreshold = (m_dispatcherFlags & btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD) ? btMin(body0->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold), body1->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold))
																																: gContactBreakingThreshold;

	btScalar contactProcessingThreshold = btMin(body0->getContactProcessingThreshold(), body1->getContactProcessingThreshold());

	void* mem = m_persistentManifoldPoolAllocator->allocate(sizeof(btPersistentManifold));
	if (NULL == mem)
	{
		//we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
		if ((m_dispatcherFlags & CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION) == 0)
		{
			mem = btAlignedAlloc(sizeof(btPersistentManifold), 16);
		}
		else
		{
			btAssert(0);
			//make sure to increase the m_defaultMaxPersistentManifoldPoolSize in the btDefaultCollisionConstructionInfo/btDefaultCollisionConfiguration
			return 0;
		}
	}
	btPersistentManifold* manifold = new (mem) btPersistentManifold(body0, body1, 0, contactBreakingThreshold, contactProcessingThreshold);
	manifold->m_index1a = m_manifoldsPtr.size();
	m_manifoldsPtr.push_back(manifold);

	return manifold;
}

void btCollisionDispatcher::clearManifold(btPersistentManifold* manifold)
{
	manifold->clearManifold();
}

void btCollisionDispatcher::releaseManifold(btPersistentManifold* manifold)
{
	//printf("releaseManifold: gNumManifold %d\n",gNumManifold);
	clearManifold(manifold);

	int findIndex = manifold->m_index1a;
	btAssert(findIndex < m_manifoldsPtr.size());
	m_manifoldsPtr.swap(findIndex, m_manifoldsPtr.size() - 1);
	m_manifoldsPtr[findIndex]->m_index1a = findIndex;
	m_manifoldsPtr.pop_back();

	manifold->~btPersistentManifold();
	if (m_persistentManifoldPoolAllocator->validPtr(manifold))
	{
		m_persistentManifoldPoolAllocator->freeMemory(manifold);
	}
	else
	{
		btAlignedFree(manifold);
	}
}

btCollisionAlgorithm* btCollisionDispatcher::findAlgorithm(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btPersistentManifold* sharedManifold, ebtDispatcherQueryType algoType)
{
	btCollisionAlgorithmConstructionInfo ci;

	ci.m_dispatcher1 = this;
	ci.m_manifold = sharedManifold;
	btCollisionAlgorithm* algo = 0;
	if (algoType == BT_CONTACT_POINT_ALGORITHMS)
	{
		algo = m_doubleDispatchContactPoints[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci, body0Wrap, body1Wrap);
	}
	else
	{
		algo = m_doubleDispatchClosestPoints[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci, body0Wrap, body1Wrap);
	}

	return algo;
}

bool btCollisionDispatcher::needsResponse(const btCollisionObject* body0, const btCollisionObject* body1)
{
	//here you can do filtering
	bool hasResponse =
		(body0->hasContactResponse() && body1->hasContactResponse());
	//no response between two static/kinematic bodies:
	hasResponse = hasResponse &&
				  ((!body0->isStaticOrKinematicObject()) || (!body1->isStaticOrKinematicObject()));
	return hasResponse;
}

bool btCollisionDispatcher::needsCollision(const btCollisionObject* body0, const btCollisionObject* body1)
{
	btAssert(body0);
	btAssert(body1);

	bool needsCollision = true;

#ifdef BT_DEBUG
	if (!(m_dispatcherFlags & btCollisionDispatcher::CD_STATIC_STATIC_REPORTED))
	{
		//broadphase filtering already deals with this
		if (body0->isStaticOrKinematicObject() && body1->isStaticOrKinematicObject())
		{
			m_dispatcherFlags |= btCollisionDispatcher::CD_STATIC_STATIC_REPORTED;
			printf("warning btCollisionDispatcher::needsCollision: static-static collision!\n");
		}
	}
#endif  //BT_DEBUG

	if ((!body0->isActive()) && (!body1->isActive()))
		needsCollision = false;
	else if ((!body0->checkCollideWith(body1)) || (!body1->checkCollideWith(body0)))
		needsCollision = false;

	return needsCollision;
}

///interface for iterating all overlapping collision pairs, no matter how those pairs are stored (array, set, map etc)
///this is useful for the collision dispatcher.
class btCollisionPairCallback : public btOverlapCallback
{
	const btDispatcherInfo& m_dispatchInfo;
	btCollisionDispatcher* m_dispatcher;

public:
	btCollisionPairCallback(const btDispatcherInfo& dispatchInfo, btCollisionDispatcher* dispatcher)
		: m_dispatchInfo(dispatchInfo),
		  m_dispatcher(dispatcher)
	{
	}

	/*btCollisionPairCallback& operator=(btCollisionPairCallback& other)
	{
		m_dispatchInfo = other.m_dispatchInfo;
		m_dispatcher = other.m_dispatcher;
		return *this;
	}
	*/

	virtual ~btCollisionPairCallback() {}

	virtual bool processOverlap(btBroadphasePair& pair)
	{
		(*m_dispatcher->getNearCallback())(pair, *m_dispatcher, m_dispatchInfo);
		return false;
	}
};

void btCollisionDispatcher::dispatchAllCollisionPairs(btOverlappingPairCache* pairCache, const btDispatcherInfo& dispatchInfo, btDispatcher* dispatcher)
{
	//m_blockedForChanges = true;

	btCollisionPairCallback collisionCallback(dispatchInfo, this);

	{
		BT_PROFILE("processAllOverlappingPairs");
		pairCache->processAllOverlappingPairs(&collisionCallback, dispatcher, dispatchInfo);
	}

	//m_blockedForChanges = false;
}

//by default, Bullet will use this near callback
void btCollisionDispatcher::defaultNearCallback(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo)
{
	btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
	btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;

	if (dispatcher.needsCollision(colObj0, colObj1))
	{
		btCollisionObjectWrapper obj0Wrap(0, colObj0->getCollisionShape(), colObj0, colObj0->getWorldTransform(), -1, -1);
		btCollisionObjectWrapper obj1Wrap(0, colObj1->getCollisionShape(), colObj1, colObj1->getWorldTransform(), -1, -1);

		//dispatcher will keep algorithms persistent in the collision pair
		if (!collisionPair.m_algorithm)
		{
			collisionPair.m_algorithm = dispatcher.findAlgorithm(&obj0Wrap, &obj1Wrap, 0, BT_CONTACT_POINT_ALGORITHMS);
		}

		if (collisionPair.m_algorithm)
		{
			btManifoldResult contactPointResult(&obj0Wrap, &obj1Wrap);

			if (dispatchInfo.m_dispatchFunc == btDispatcherInfo::DISPATCH_DISCRETE)
			{
				//discrete collision detection query

				collisionPair.m_algorithm->processCollision(&obj0Wrap, &obj1Wrap, dispatchInfo, &contactPointResult);
			}
			else
			{
				//continuous collision detection query, time of impact (toi)
				btScalar toi = collisionPair.m_algorithm->calculateTimeOfImpact(colObj0, colObj1, dispatchInfo, &contactPointResult);
				if (dispatchInfo.m_timeOfImpact > toi)
					dispatchInfo.m_timeOfImpact = toi;
			}
		}
	}
}

void* btCollisionDispatcher::allocateCollisionAlgorithm(int size)
{
	void* mem = m_collisionAlgorithmPoolAllocator->allocate(size);
	if (NULL == mem)
	{
		//warn user for overflow?
		return btAlignedAlloc(static_cast<size_t>(size), 16);
	}
	return mem;
}

void btCollisionDispatcher::freeCollisionAlgorithm(void* ptr)
{
	if (m_collisionAlgorithmPoolAllocator->validPtr(ptr))
	{
		m_collisionAlgorithmPoolAllocator->freeMemory(ptr);
	}
	else
	{
		btAlignedFree(ptr);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION__DISPATCHER_H
#define BT_COLLISION__DISPATCHER_H

#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"

#include "BulletCollision/CollisionDispatch/btManifoldResult.h"

#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "LinearMath/btAlignedObjectArray.h"

class btIDebugDraw;
class btOverlappingPairCache;
class btPoolAllocator;
class btCollisionConfiguration;

#include "BulletCollision/CollisionDispatch/btCollisionCreateFunc.h"

#define USE_DISPATCH_REGISTRY_ARRAY 1

class btCollisionDispatcher;
///user can override this nearcallback for collision filtering and more finegrained control over collision detection
typedef void (*btNearCallback)(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo);

///btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
///Time of Impact, Closest Points and Penetration Depth.
class btCollisionDispatcher : public btDispatcher
{
protected:
	int m_dispatcherFlags;

	btAlignedObjectArray<btPersistentManifold*> m_manifoldsPtr;

	btNearCallback m_nearCallback;

	btPoolAllocator* m_collisionAlgorithmPoolAllocator;

	btPoolAllocator* m_persistentManifoldPoolAllocator;

	btCollisionAlgorithmCreateFunc* m_doubleDispatchContactPoints[MAX_BROADPHASE_COLLISION_TYPES][MAX_BROADPHASE_COLLISION_TYPES];

	btCollisionAlgorithmCreateFunc* m_doubleDispatchClosestPoints[MAX_BROADPHASE_COLLISION_TYPES][MAX_BROADPHASE_COLLISION_TYPES];

	btCollisionConfiguration* m_collisionConfiguration;

public:
	enum DispatcherFlags
	{
		CD_STATIC_STATIC_REPORTED = 1,
		CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD = 2,
		CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION = 4
	};

	int getDispatcherFlags() const
	{
		return m_dispatcherFlags;
	}

	void setDispatcherFlags(int flags)
	{
		m_dispatcherFlags = flags;
	}

	///registerCollisionCreateFunc allows registration of custom/alternative collision create functions
	void registerCollisionCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc* createFunc);

	void registerClosestPointsCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc* createFunc);

	int getNumManifolds() const
	{
		return int(m_manifoldsPtr.size());
	}

	btPersistentManifold** getInternalManifoldPointer()
	{
		return m_manifoldsPtr.size() ? &m_manifoldsPtr[0] : 0;
	}

	btPersistentManifold* getManifoldByIndexInternal(int index)
	{
		btAssert(index>=0);
		btAssert(index<m_manifoldsPtr.size());
		return m_manifoldsPtr[index];
	}

	const btPersistentManifold* getManifoldByIndexInternal(int index) const
	{
		btAssert(index>=0);
		btAssert(index<m_manifoldsPtr.size());
		return m_manifoldsPtr[index];
	}

	btCollisionDispatcher(btCollisionConfiguration* collisionConfiguration);

	virtual ~btCollisionDispatcher();

	virtual btPersistentManifold* getNewManifold(const btCollisionObject* b0, const btCollisionObject* b1);

	virtual void releaseManifold(btPersistentManifold* manifold);

	virtual void clearManifold(btPersistentManifold* manifold);

	btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btPersistentManifold* sharedManifold, ebtDispatcherQueryType queryType);

	virtual bool needsCollision(const btCollisionObject* body0, const btCollisionObject* body1);

	virtual bool needsResponse(const btCollisionObject* body0, const btCollisionObject* body1);

	virtual void dispatchAllCollisionPairs(btOverlappingPairCache* pairCache, const btDispatcherInfo& dispatchInfo, btDispatcher* dispatcher);

	void setNearCallback(btNearCallback nearCallback)
	{
		m_nearCallback = nearCallback;
	}

	btNearCallback getNearCallback() const
	{
		return m_nearCallback;
	}

	//by default, Bullet will use this near callback
	static void defaultNearCallback(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo);

	virtual void* allocateCollisionAlgorithm(int size);

	virtual void freeCollisionAlgorithm(void* ptr);

	btCollisionConfiguration* getCollisionConfiguration()
	{
		return m_collisionConfiguration;
	}

	const btCollisionConfiguration* getCollisionConfiguration() const
	{
		return m_collisionConfiguration;
	}

	void setCollisionConfiguration(btCollisionConfiguration* config)
	{
		m_collisionConfiguration = config;
	}

	virtual btPoolAllocator* getInternalManifoldPool()
	{
		return m_persistentManifoldPoolAllocator;
	}

	virtual const btPoolAllocator* getInternalManifoldPool() const
	{
		return m_persistentManifoldPoolAllocator;
	}
};

#endif  //BT_COLLISION__DISPATCHER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_BROADPHASE_INTERFACE_H
#define BT_BROADPHASE_INTERFACE_H

struct btDispatcherInfo;
class btDispatcher;
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

class btOverlappingPairCache;

struct btBroadphaseAabbCallback
{
	virtual ~btBroadphaseAabbCallback() {}
	virtual bool process(const btBroadphaseProxy* proxy) = 0;
};

struct btBroadphaseRayCallback : public btBroadphaseAabbCallback
{
	///added some cached data to accelerate ray-AABB tests
	btVector3 m_rayDirectionInverse;
	unsigned int m_signs[3];
	btScalar m_lambda_max;

	virtual ~btBroadphaseRayCallback() {}

protected:
	btBroadphaseRayCallback() {}
};

#include "LinearMath/btVector3.h"

///The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
///Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
///The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class.
class btBroadphaseInterface
{
public:
	virtual ~btBroadphaseInterface() {}

	virtual btBroadphaseProxy* createProxy(const btVector3& aabbMin, const btVector3& aabbMax, int shapeType, void* userPtr, int collisionFilterGroup, int collisionFilterMask, btDispatcher* dispatcher) = 0;
	virtual void destroyProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher) = 0;
	virtual void setAabb(btBroadphaseProxy* proxy, const btVector3& aabbMin, const btVector3& aabbMax, btDispatcher* dispatcher) = 0;
	virtual void getAabb(btBroadphaseProxy* proxy, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void rayTest(const btVector3& rayFrom, const btVector3& rayTo, btBroadphaseRayCallback& rayCallback, const btVector3& aabbMin = btVector3(0, 0, 0), const btVector3& aabbMax = btVector3(0, 0, 0)) = 0;

	virtual void aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback) = 0;

	///calculateOverlappingPairs is optional: incremental algorithms (sweep and prune) might do it during the set aabb
	virtual void calculateOverlappingPairs(btDispatcher* dispatcher) = 0;

	virtual btOverlappingPairCache* getOverlappingPairCache() = 0;
	virtual const btOverlappingPairCache* getOverlappingPairCache() const = 0;

	///getAabb returns the axis aligned bounding box in the 'global' coordinate frame
	///will add some transform later
	virtual void getBroadphaseAabb(btVector3& aabbMin, btVector3& aabbMax) const = 0;

	///reset broadphase internal structures, to ensure determinism/reproducability
	virtual void resetPool(btDispatcher* dispatcher) { (void)dispatcher; };

	virtual void printStats() = 0;
};

#endif  //BT_BROADPHASE_INTERFACE_H






/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef OVERLAPPING_PAIR_CALLBACK_H
#define OVERLAPPING_PAIR_CALLBACK_H

class btDispatcher;
struct btBroadphasePair;

///The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
class btOverlappingPairCallback
{
protected:
	btOverlappingPairCallback() {}

public:
	virtual ~btOverlappingPairCallback()
	{
	}

	virtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1) = 0;

	virtual void* removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher) = 0;

	virtual void removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy0, btDispatcher* dispatcher) = 0;
};

#endif  //OVERLAPPING_PAIR_CALLBACK_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"

#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "LinearMath/btAabbUtil2.h"


btHashedOverlappingPairCache::btHashedOverlappingPairCache() : m_overlapFilterCallback(0),
															   m_ghostPairCallback(0)
{
	int initialAllocatedSize = 2;
	m_overlappingPairArray.reserve(initialAllocatedSize);
	growTables();
}

btHashedOverlappingPairCache::~btHashedOverlappingPairCache()
{
}

void btHashedOverlappingPairCache::cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher)
{
	if (pair.m_algorithm && dispatcher)
	{
		{
			pair.m_algorithm->~btCollisionAlgorithm();
			dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
			pair.m_algorithm = 0;
		}
	}
}

void btHashedOverlappingPairCache::cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{
	class CleanPairCallback : public btOverlapCallback
	{
		btBroadphaseProxy* m_cleanProxy;
		btOverlappingPairCache* m_pairCache;
		btDispatcher* m_dispatcher;

	public:
		CleanPairCallback(btBroadphaseProxy* cleanProxy, btOverlappingPairCache* pairCache, btDispatcher* dispatcher)
			: m_cleanProxy(cleanProxy),
			  m_pairCache(pairCache),
			  m_dispatcher(dispatcher)
		{
		}
		virtual bool processOverlap(btBroadphasePair& pair)
		{
			if ((pair.m_pProxy0 == m_cleanProxy) ||
				(pair.m_pProxy1 == m_cleanProxy))
			{
				m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
			}
			return false;
		}
	};

	CleanPairCallback cleanPairs(proxy, this, dispatcher);

	processAllOverlappingPairs(&cleanPairs, dispatcher);
}

void btHashedOverlappingPairCache::removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{
	class RemovePairCallback : public btOverlapCallback
	{
		btBroadphaseProxy* m_obsoleteProxy;

	public:
		RemovePairCallback(btBroadphaseProxy* obsoleteProxy)
			: m_obsoleteProxy(obsoleteProxy)
		{
		}
		virtual bool processOverlap(btBroadphasePair& pair)
		{
			return ((pair.m_pProxy0 == m_obsoleteProxy) ||
					(pair.m_pProxy1 == m_obsoleteProxy));
		}
	};

	RemovePairCallback removeCallback(proxy);

	processAllOverlappingPairs(&removeCallback, dispatcher);
}

btBroadphasePair* btHashedOverlappingPairCache::findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
	if (proxy0->m_uniqueId > proxy1->m_uniqueId)
		btSwap(proxy0, proxy1);
	int proxyId1 = proxy0->getUid();
	int proxyId2 = proxy1->getUid();

	/*if (proxyId1 > proxyId2)
		btSwap(proxyId1, proxyId2);*/

	int hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

	if (hash >= m_hashTable.size())
	{
		return NULL;
	}

	int index = m_hashTable[hash];
	while (index != BT_NULL_PAIR && equalsPair(m_overlappingPairArray[index], proxyId1, proxyId2) == false)
	{
		index = m_next[index];
	}

	if (index == BT_NULL_PAIR)
	{
		return NULL;
	}

	btAssert(index < m_overlappingPairArray.size());

	return &m_overlappingPairArray[index];
}


void btHashedOverlappingPairCache::growTables()
{
	int newCapacity = m_overlappingPairArray.capacity();

	if (m_hashTable.size() < newCapacity)
	{
		//grow hashtable and next table
		int curHashtableSize = m_hashTable.size();

		m_hashTable.resize(newCapacity);
		m_next.resize(newCapacity);

		int i;

		for (i = 0; i < newCapacity; ++i)
		{
			m_hashTable[i] = BT_NULL_PAIR;
		}
		for (i = 0; i < newCapacity; ++i)
		{
			m_next[i] = BT_NULL_PAIR;
		}

		for (i = 0; i < curHashtableSize; i++)
		{
			const btBroadphasePair& pair = m_overlappingPairArray[i];
			int proxyId1 = pair.m_pProxy0->getUid();
			int proxyId2 = pair.m_pProxy1->getUid();
			/*if (proxyId1 > proxyId2) 
				btSwap(proxyId1, proxyId2);*/
			int hashValue = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));  // New hash value with new mask
			m_next[i] = m_hashTable[hashValue];
			m_hashTable[hashValue] = i;
		}
	}
}

btBroadphasePair* btHashedOverlappingPairCache::internalAddPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
	if (proxy0->m_uniqueId > proxy1->m_uniqueId)
		btSwap(proxy0, proxy1);
	int proxyId1 = proxy0->getUid();
	int proxyId2 = proxy1->getUid();

	/*if (proxyId1 > proxyId2) 
		btSwap(proxyId1, proxyId2);*/

	int hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));  // New hash value with new mask

	btBroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
	if (pair != NULL)
	{
		return pair;
	}
	/*for(int i=0;i<m_overlappingPairArray.size();++i)
		{
		if(	(m_overlappingPairArray[i].m_pProxy0==proxy0)&&
			(m_overlappingPairArray[i].m_pProxy1==proxy1))
			{
			printf("Adding duplicated %u<>%u\r\n",proxyId1,proxyId2);
			internalFindPair(proxy0, proxy1, hash);
			}
		}*/
	int count = m_overlappingPairArray.size();
	int oldCapacity = m_overlappingPairArray.capacity();
	void* mem = &m_overlappingPairArray.expandNonInitializing();

	//this is where we add an actual pair, so also call the 'ghost'
	if (m_ghostPairCallback)
		m_ghostPairCallback->addOverlappingPair(proxy0, proxy1);

	int newCapacity = m_overlappingPairArray.capacity();

	if (oldCapacity < newCapacity)
	{
		growTables();
		//hash with new capacity
		hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));
	}

	pair = new (mem) btBroadphasePair(*proxy0, *proxy1);
	//	pair->m_pProxy0 = proxy0;
	//	pair->m_pProxy1 = proxy1;
	pair->m_algorithm = 0;
	pair->m_internalTmpValue = 0;

	m_next[count] = m_hashTable[hash];
	m_hashTable[hash] = count;

	return pair;
}

void* btHashedOverlappingPairCache::removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher)
{
	if (proxy0->m_uniqueId > proxy1->m_uniqueId)
		btSwap(proxy0, proxy1);
	int proxyId1 = proxy0->getUid();
	int proxyId2 = proxy1->getUid();

	/*if (proxyId1 > proxyId2)
		btSwap(proxyId1, proxyId2);*/

	int hash = static_cast<int>(getHash(static_cast<unsigned int>(proxyId1), static_cast<unsigned int>(proxyId2)) & (m_overlappingPairArray.capacity() - 1));

	btBroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
	if (pair == NULL)
	{
		return 0;
	}

	cleanOverlappingPair(*pair, dispatcher);

	void* userData = pair->m_internalInfo1;

	btAssert(pair->m_pProxy0->getUid() == proxyId1);
	btAssert(pair->m_pProxy1->getUid() == proxyId2);

	int pairIndex = int(pair - &m_overlappingPairArray[0]);
	btAssert(pairIndex < m_overlappingPairArray.size());

	// Remove the pair from the hash table.
	int index = m_hashTable[hash];
	btAssert(index != BT_NULL_PAIR);

	int previous = BT_NULL_PAIR;
	while (index != pairIndex)
	{
		previous = index;
		index = m_next[index];
	}

	if (previous != BT_NULL_PAIR)
	{
		btAssert(m_next[previous] == pairIndex);
		m_next[previous] = m_next[pairIndex];
	}
	else
	{
		m_hashTable[hash] = m_next[pairIndex];
	}

	// We now move the last pair into spot of the
	// pair being removed. We need to fix the hash
	// table indices to support the move.

	int lastPairIndex = m_overlappingPairArray.size() - 1;

	if (m_ghostPairCallback)
		m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1, dispatcher);

	// If the removed pair is the last pair, we are done.
	if (lastPairIndex == pairIndex)
	{
		m_overlappingPairArray.pop_back();
		return userData;
	}

	// Remove the last pair from the hash table.
	const btBroadphasePair* last = &m_overlappingPairArray[lastPairIndex];
	/* missing swap here too, Nat. */
	int lastHash = static_cast<int>(getHash(static_cast<unsigned int>(last->m_pProxy0->getUid()), static_cast<unsigned int>(last->m_pProxy1->getUid())) & (m_overlappingPairArray.capacity() - 1));

	index = m_hashTable[lastHash];
	btAssert(index != BT_NULL_PAIR);

	previous = BT_NULL_PAIR;
	while (index != lastPairIndex)
	{
		previous = index;
		index = m_next[index];
	}

	if (previous != BT_NULL_PAIR)
	{
		btAssert(m_next[previous] == lastPairIndex);
		m_next[previous] = m_next[lastPairIndex];
	}
	else
	{
		m_hashTable[lastHash] = m_next[lastPairIndex];
	}

	// Copy the last pair into the remove pair's spot.
	m_overlappingPairArray[pairIndex] = m_overlappingPairArray[lastPairIndex];

	// Insert the last pair into the hash table
	m_next[pairIndex] = m_hashTable[lastHash];
	m_hashTable[lastHash] = pairIndex;

	m_overlappingPairArray.pop_back();

	return userData;
}
#include "LinearMath/btQuickprof.h"
void btHashedOverlappingPairCache::processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher)
{
	BT_PROFILE("btHashedOverlappingPairCache::processAllOverlappingPairs");
	int i;

	//	printf("m_overlappingPairArray.size()=%d\n",m_overlappingPairArray.size());
	for (i = 0; i < m_overlappingPairArray.size();)
	{
		btBroadphasePair* pair = &m_overlappingPairArray[i];
		if (callback->processOverlap(*pair))
		{
			removeOverlappingPair(pair->m_pProxy0, pair->m_pProxy1, dispatcher);
		}
		else
		{
			i++;
		}
	}
}

struct MyPairIndex
{
	int m_orgIndex;
	int m_uidA0;
	int m_uidA1;
};

class MyPairIndeSortPredicate
{
public:
	bool operator()(const MyPairIndex& a, const MyPairIndex& b) const
	{
		const int uidA0 = a.m_uidA0;
		const int uidB0 = b.m_uidA0;
		const int uidA1 = a.m_uidA1;
		const int uidB1 = b.m_uidA1;
		return uidA0 > uidB0 || (uidA0 == uidB0 && uidA1 > uidB1);
	}
};

void btHashedOverlappingPairCache::processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher, const struct btDispatcherInfo& dispatchInfo)
{
	if (dispatchInfo.m_deterministicOverlappingPairs)
	{
		btBroadphasePairArray& pa = getOverlappingPairArray();
		btAlignedObjectArray<MyPairIndex> indices;
		{
			BT_PROFILE("sortOverlappingPairs");
			indices.resize(pa.size());
			for (int i = 0; i < indices.size(); i++)
			{
				const btBroadphasePair& p = pa[i];
				const int uidA0 = p.m_pProxy0 ? p.m_pProxy0->m_uniqueId : -1;
				const int uidA1 = p.m_pProxy1 ? p.m_pProxy1->m_uniqueId : -1;

				indices[i].m_uidA0 = uidA0;
				indices[i].m_uidA1 = uidA1;
				indices[i].m_orgIndex = i;
			}
			indices.quickSort(MyPairIndeSortPredicate());
		}
		{
			BT_PROFILE("btHashedOverlappingPairCache::processAllOverlappingPairs");
			int i;
			for (i = 0; i < indices.size();)
			{
				btBroadphasePair* pair = &pa[indices[i].m_orgIndex];
				if (callback->processOverlap(*pair))
				{
					removeOverlappingPair(pair->m_pProxy0, pair->m_pProxy1, dispatcher);
				}
				else
				{
					i++;
				}
			}
		}
	}
	else
	{
		processAllOverlappingPairs(callback, dispatcher);
	}
}

void btHashedOverlappingPairCache::sortOverlappingPairs(btDispatcher* dispatcher)
{
	///need to keep hashmap in sync with pair address, so rebuild all
	btBroadphasePairArray tmpPairs;
	int i;
	for (i = 0; i < m_overlappingPairArray.size(); i++)
	{
		tmpPairs.push_back(m_overlappingPairArray[i]);
	}

	for (i = 0; i < tmpPairs.size(); i++)
	{
		removeOverlappingPair(tmpPairs[i].m_pProxy0, tmpPairs[i].m_pProxy1, dispatcher);
	}

	for (i = 0; i < m_next.size(); i++)
	{
		m_next[i] = BT_NULL_PAIR;
	}

	tmpPairs.quickSort(btBroadphasePairSortPredicate());

	for (i = 0; i < tmpPairs.size(); i++)
	{
		addOverlappingPair(tmpPairs[i].m_pProxy0, tmpPairs[i].m_pProxy1);
	}
}

void* btSortedOverlappingPairCache::removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher)
{
	if (!hasDeferredRemoval())
	{
		btBroadphasePair findPair(*proxy0, *proxy1);

		int findIndex = m_overlappingPairArray.findLinearSearch(findPair);
		if (findIndex < m_overlappingPairArray.size())
		{
			btBroadphasePair& pair = m_overlappingPairArray[findIndex];
			void* userData = pair.m_internalInfo1;
			cleanOverlappingPair(pair, dispatcher);
			if (m_ghostPairCallback)
				m_ghostPairCallback->removeOverlappingPair(proxy0, proxy1, dispatcher);

			m_overlappingPairArray.swap(findIndex, m_overlappingPairArray.capacity() - 1);
			m_overlappingPairArray.pop_back();
			return userData;
		}
	}

	return 0;
}

btBroadphasePair* btSortedOverlappingPairCache::addOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
	//don't add overlap with own
	btAssert(proxy0 != proxy1);

	if (!needsBroadphaseCollision(proxy0, proxy1))
		return 0;

	void* mem = &m_overlappingPairArray.expandNonInitializing();
	btBroadphasePair* pair = new (mem) btBroadphasePair(*proxy0, *proxy1);

	if (m_ghostPairCallback)
		m_ghostPairCallback->addOverlappingPair(proxy0, proxy1);
	return pair;
}

///this findPair becomes really slow. Either sort the list to speedup the query, or
///use a different solution. It is mainly used for Removing overlapping pairs. Removal could be delayed.
///we could keep a linked list in each proxy, and store pair in one of the proxies (with lowest memory address)
///Also we can use a 2D bitmap, which can be useful for a future GPU implementation
btBroadphasePair* btSortedOverlappingPairCache::findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1)
{
	if (!needsBroadphaseCollision(proxy0, proxy1))
		return 0;

	btBroadphasePair tmpPair(*proxy0, *proxy1);
	int findIndex = m_overlappingPairArray.findLinearSearch(tmpPair);

	if (findIndex < m_overlappingPairArray.size())
	{
		//btAssert(it != m_overlappingPairSet.end());
		btBroadphasePair* pair = &m_overlappingPairArray[findIndex];
		return pair;
	}
	return 0;
}


void btSortedOverlappingPairCache::processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher)
{
	int i;

	for (i = 0; i < m_overlappingPairArray.size();)
	{
		btBroadphasePair* pair = &m_overlappingPairArray[i];
		if (callback->processOverlap(*pair))
		{
			cleanOverlappingPair(*pair, dispatcher);
			pair->m_pProxy0 = 0;
			pair->m_pProxy1 = 0;
			m_overlappingPairArray.swap(i, m_overlappingPairArray.size() - 1);
			m_overlappingPairArray.pop_back();
		}
		else
		{
			i++;
		}
	}
}

btSortedOverlappingPairCache::btSortedOverlappingPairCache() : m_blockedForChanges(false),
															   m_hasDeferredRemoval(true),
															   m_overlapFilterCallback(0),
															   m_ghostPairCallback(0)
{
	int initialAllocatedSize = 2;
	m_overlappingPairArray.reserve(initialAllocatedSize);
}

btSortedOverlappingPairCache::~btSortedOverlappingPairCache()
{
}

void btSortedOverlappingPairCache::cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher)
{
	if (pair.m_algorithm)
	{
		{
			pair.m_algorithm->~btCollisionAlgorithm();
			dispatcher->freeCollisionAlgorithm(pair.m_algorithm);
			pair.m_algorithm = 0;
		}
	}
}

void btSortedOverlappingPairCache::cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{
	class CleanPairCallback : public btOverlapCallback
	{
		btBroadphaseProxy* m_cleanProxy;
		btOverlappingPairCache* m_pairCache;
		btDispatcher* m_dispatcher;

	public:
		CleanPairCallback(btBroadphaseProxy* cleanProxy, btOverlappingPairCache* pairCache, btDispatcher* dispatcher)
			: m_cleanProxy(cleanProxy),
			  m_pairCache(pairCache),
			  m_dispatcher(dispatcher)
		{
		}
		virtual bool processOverlap(btBroadphasePair& pair)
		{
			if ((pair.m_pProxy0 == m_cleanProxy) ||
				(pair.m_pProxy1 == m_cleanProxy))
			{
				m_pairCache->cleanOverlappingPair(pair, m_dispatcher);
			}
			return false;
		}
	};

	CleanPairCallback cleanPairs(proxy, this, dispatcher);

	processAllOverlappingPairs(&cleanPairs, dispatcher);
}

void btSortedOverlappingPairCache::removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher)
{
	class RemovePairCallback : public btOverlapCallback
	{
		btBroadphaseProxy* m_obsoleteProxy;

	public:
		RemovePairCallback(btBroadphaseProxy* obsoleteProxy)
			: m_obsoleteProxy(obsoleteProxy)
		{
		}
		virtual bool processOverlap(btBroadphasePair& pair)
		{
			return ((pair.m_pProxy0 == m_obsoleteProxy) ||
					(pair.m_pProxy1 == m_obsoleteProxy));
		}
	};

	RemovePairCallback removeCallback(proxy);

	processAllOverlappingPairs(&removeCallback, dispatcher);
}

void btSortedOverlappingPairCache::sortOverlappingPairs(btDispatcher* dispatcher)
{
	//should already be sorted
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OVERLAPPING_PAIR_CACHE_H
#define BT_OVERLAPPING_PAIR_CACHE_H

#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h"

#include "LinearMath/btAlignedObjectArray.h"
class btDispatcher;

typedef btAlignedObjectArray<btBroadphasePair> btBroadphasePairArray;

struct btOverlapCallback
{
	virtual ~btOverlapCallback()
	{
	}
	//return true for deletion of the pair
	virtual bool processOverlap(btBroadphasePair& pair) = 0;
};

struct btOverlapFilterCallback
{
	virtual ~btOverlapFilterCallback()
	{
	}
	// return true when pairs need collision
	virtual bool needBroadphaseCollision(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1) const = 0;
};

const int BT_NULL_PAIR = 0xffffffff;

///The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
///The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
class btOverlappingPairCache : public btOverlappingPairCallback
{
public:
	virtual ~btOverlappingPairCache() {}  // this is needed so we can get to the derived class destructor

	virtual btBroadphasePair* getOverlappingPairArrayPtr() = 0;

	virtual const btBroadphasePair* getOverlappingPairArrayPtr() const = 0;

	virtual btBroadphasePairArray& getOverlappingPairArray() = 0;

	virtual void cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher) = 0;

	virtual int getNumOverlappingPairs() const = 0;
	virtual bool needsBroadphaseCollision(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1) const = 0;
	virtual btOverlapFilterCallback* getOverlapFilterCallback() = 0;
	virtual void cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher) = 0;

	virtual void setOverlapFilterCallback(btOverlapFilterCallback* callback) = 0;

	virtual void processAllOverlappingPairs(btOverlapCallback*, btDispatcher* dispatcher) = 0;

	virtual void processAllOverlappingPairs(btOverlapCallback* callback, btDispatcher* dispatcher, const struct btDispatcherInfo& /*dispatchInfo*/)
	{
		processAllOverlappingPairs(callback, dispatcher);
	}
	virtual btBroadphasePair* findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1) = 0;

	virtual bool hasDeferredRemoval() = 0;

	virtual void setInternalGhostPairCallback(btOverlappingPairCallback* ghostPairCallback) = 0;

	virtual void sortOverlappingPairs(btDispatcher* dispatcher) = 0;
};

/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com

ATTRIBUTE_ALIGNED16(class)
btHashedOverlappingPairCache : public btOverlappingPairCache
{
	btBroadphasePairArray m_overlappingPairArray;
	btOverlapFilterCallback* m_overlapFilterCallback;

protected:
	btAlignedObjectArray<int> m_hashTable;
	btAlignedObjectArray<int> m_next;
	btOverlappingPairCallback* m_ghostPairCallback;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btHashedOverlappingPairCache();
	virtual ~btHashedOverlappingPairCache();

	void removeOverlappingPairsContainingProxy(btBroadphaseProxy * proxy, btDispatcher * dispatcher);

	virtual void* removeOverlappingPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1, btDispatcher * dispatcher);

	SIMD_FORCE_INLINE bool needsBroadphaseCollision(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1) const
	{
		if (m_overlapFilterCallback)
			return m_overlapFilterCallback->needBroadphaseCollision(proxy0, proxy1);

		bool collides = (proxy0->m_collisionFilterGroup & proxy1->m_collisionFilterMask) != 0;
		collides = collides && (proxy1->m_collisionFilterGroup & proxy0->m_collisionFilterMask);

		return collides;
	}

	// Add a pair and return the new pair. If the pair already exists,
	// no new pair is created and the old one is returned.
	virtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1)
	{
		if (!needsBroadphaseCollision(proxy0, proxy1))
			return 0;

		return internalAddPair(proxy0, proxy1);
	}

	void cleanProxyFromPairs(btBroadphaseProxy * proxy, btDispatcher * dispatcher);

	virtual void processAllOverlappingPairs(btOverlapCallback*, btDispatcher * dispatcher);

	virtual void processAllOverlappingPairs(btOverlapCallback * callback, btDispatcher * dispatcher, const struct btDispatcherInfo& dispatchInfo);

	virtual btBroadphasePair* getOverlappingPairArrayPtr()
	{
		return &m_overlappingPairArray[0];
	}

	const btBroadphasePair* getOverlappingPairArrayPtr() const
	{
		return &m_overlappingPairArray[0];
	}

	btBroadphasePairArray& getOverlappingPairArray()
	{
		return m_overlappingPairArray;
	}

	const btBroadphasePairArray& getOverlappingPairArray() const
	{
		return m_overlappingPairArray;
	}

	void cleanOverlappingPair(btBroadphasePair & pair, btDispatcher * dispatcher);

	btBroadphasePair* findPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1);

	int GetCount() const { return m_overlappingPairArray.size(); }
	//	btBroadphasePair* GetPairs() { return m_pairs; }

	btOverlapFilterCallback* getOverlapFilterCallback()
	{
		return m_overlapFilterCallback;
	}

	void setOverlapFilterCallback(btOverlapFilterCallback * callback)
	{
		m_overlapFilterCallback = callback;
	}

	int getNumOverlappingPairs() const
	{
		return m_overlappingPairArray.size();
	}

private:
	btBroadphasePair* internalAddPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1);

	void growTables();

	SIMD_FORCE_INLINE bool equalsPair(const btBroadphasePair& pair, int proxyId1, int proxyId2)
	{
		return pair.m_pProxy0->getUid() == proxyId1 && pair.m_pProxy1->getUid() == proxyId2;
	}

	/*
	// Thomas Wang's hash, see: http://www.concentric.net/~Ttwang/tech/inthash.htm
	// This assumes proxyId1 and proxyId2 are 16-bit.
	SIMD_FORCE_INLINE int getHash(int proxyId1, int proxyId2)
	{
		int key = (proxyId2 << 16) | proxyId1;
		key = ~key + (key << 15);
		key = key ^ (key >> 12);
		key = key + (key << 2);
		key = key ^ (key >> 4);
		key = key * 2057;
		key = key ^ (key >> 16);
		return key;
	}
	*/

	SIMD_FORCE_INLINE unsigned int getHash(unsigned int proxyId1, unsigned int proxyId2)
	{
		unsigned int key = proxyId1 | (proxyId2 << 16);
		// Thomas Wang's hash

		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}

	SIMD_FORCE_INLINE btBroadphasePair* internalFindPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1, int hash)
	{
		int proxyId1 = proxy0->getUid();
		int proxyId2 = proxy1->getUid();
#if 0  // wrong, 'equalsPair' use unsorted uids, copy-past devil striked again. Nat.
		if (proxyId1 > proxyId2) 
			btSwap(proxyId1, proxyId2);
#endif

		int index = m_hashTable[hash];

		while (index != BT_NULL_PAIR && equalsPair(m_overlappingPairArray[index], proxyId1, proxyId2) == false)
		{
			index = m_next[index];
		}

		if (index == BT_NULL_PAIR)
		{
			return NULL;
		}

		btAssert(index < m_overlappingPairArray.size());

		return &m_overlappingPairArray[index];
	}

	virtual bool hasDeferredRemoval()
	{
		return false;
	}

	virtual void setInternalGhostPairCallback(btOverlappingPairCallback * ghostPairCallback)
	{
		m_ghostPairCallback = ghostPairCallback;
	}

	virtual void sortOverlappingPairs(btDispatcher * dispatcher);
};

///btSortedOverlappingPairCache maintains the objects with overlapping AABB
///Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
class btSortedOverlappingPairCache : public btOverlappingPairCache
{
protected:
	//avoid brute-force finding all the time
	btBroadphasePairArray m_overlappingPairArray;

	//during the dispatch, check that user doesn't destroy/create proxy
	bool m_blockedForChanges;

	///by default, do the removal during the pair traversal
	bool m_hasDeferredRemoval;

	//if set, use the callback instead of the built in filter in needBroadphaseCollision
	btOverlapFilterCallback* m_overlapFilterCallback;

	btOverlappingPairCallback* m_ghostPairCallback;

public:
	btSortedOverlappingPairCache();
	virtual ~btSortedOverlappingPairCache();

	virtual void processAllOverlappingPairs(btOverlapCallback*, btDispatcher* dispatcher);

	void* removeOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher);

	void cleanOverlappingPair(btBroadphasePair& pair, btDispatcher* dispatcher);

	btBroadphasePair* addOverlappingPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);

	btBroadphasePair* findPair(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);

	void cleanProxyFromPairs(btBroadphaseProxy* proxy, btDispatcher* dispatcher);

	void removeOverlappingPairsContainingProxy(btBroadphaseProxy* proxy, btDispatcher* dispatcher);

	inline bool needsBroadphaseCollision(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1) const
	{
		if (m_overlapFilterCallback)
			return m_overlapFilterCallback->needBroadphaseCollision(proxy0, proxy1);

		bool collides = (proxy0->m_collisionFilterGroup & proxy1->m_collisionFilterMask) != 0;
		collides = collides && (proxy1->m_collisionFilterGroup & proxy0->m_collisionFilterMask);

		return collides;
	}

	btBroadphasePairArray& getOverlappingPairArray()
	{
		return m_overlappingPairArray;
	}

	const btBroadphasePairArray& getOverlappingPairArray() const
	{
		return m_overlappingPairArray;
	}

	btBroadphasePair* getOverlappingPairArrayPtr()
	{
		return &m_overlappingPairArray[0];
	}

	const btBroadphasePair* getOverlappingPairArrayPtr() const
	{
		return &m_overlappingPairArray[0];
	}

	int getNumOverlappingPairs() const
	{
		return m_overlappingPairArray.size();
	}

	btOverlapFilterCallback* getOverlapFilterCallback()
	{
		return m_overlapFilterCallback;
	}

	void setOverlapFilterCallback(btOverlapFilterCallback* callback)
	{
		m_overlapFilterCallback = callback;
	}

	virtual bool hasDeferredRemoval()
	{
		return m_hasDeferredRemoval;
	}

	virtual void setInternalGhostPairCallback(btOverlappingPairCallback* ghostPairCallback)
	{
		m_ghostPairCallback = ghostPairCallback;
	}

	virtual void sortOverlappingPairs(btDispatcher* dispatcher);
};

///btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
class btNullPairCache : public btOverlappingPairCache
{
	btBroadphasePairArray m_overlappingPairArray;

public:
	virtual btBroadphasePair* getOverlappingPairArrayPtr()
	{
		return &m_overlappingPairArray[0];
	}
	const btBroadphasePair* getOverlappingPairArrayPtr() const
	{
		return &m_overlappingPairArray[0];
	}
	btBroadphasePairArray& getOverlappingPairArray()
	{
		return m_overlappingPairArray;
	}

	virtual void cleanOverlappingPair(btBroadphasePair& /*pair*/, btDispatcher* /*dispatcher*/)
	{
	}

	virtual int getNumOverlappingPairs() const
	{
		return 0;
	}

	virtual void cleanProxyFromPairs(btBroadphaseProxy* /*proxy*/, btDispatcher* /*dispatcher*/)
	{
	}

	bool needsBroadphaseCollision(btBroadphaseProxy*, btBroadphaseProxy*) const
	{
		return true;
	}
	btOverlapFilterCallback* getOverlapFilterCallback()
	{
		return 0;
	}
	virtual void setOverlapFilterCallback(btOverlapFilterCallback* /*callback*/)
	{
	}

	virtual void processAllOverlappingPairs(btOverlapCallback*, btDispatcher* /*dispatcher*/)
	{
	}

	virtual btBroadphasePair* findPair(btBroadphaseProxy* /*proxy0*/, btBroadphaseProxy* /*proxy1*/)
	{
		return 0;
	}

	virtual bool hasDeferredRemoval()
	{
		return true;
	}

	virtual void setInternalGhostPairCallback(btOverlappingPairCallback* /* ghostPairCallback */)
	{
	}

	virtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy* /*proxy0*/, btBroadphaseProxy* /*proxy1*/)
	{
		return 0;
	}

	virtual void* removeOverlappingPair(btBroadphaseProxy* /*proxy0*/, btBroadphaseProxy* /*proxy1*/, btDispatcher* /*dispatcher*/)
	{
		return 0;
	}

	virtual void removeOverlappingPairsContainingProxy(btBroadphaseProxy* /*proxy0*/, btDispatcher* /*dispatcher*/)
	{
	}

	virtual void sortOverlappingPairs(btDispatcher* dispatcher)
	{
		(void)dispatcher;
	}
};

#endif  //BT_OVERLAPPING_PAIR_CACHE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//#define DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION

//#define USE_BRUTEFORCE_RAYBROADPHASE 1
//RECALCULATE_AABB is slower, but benefit is that you don't need to call 'stepSimulation'  or 'updateAabbs' before using a rayTest
//#define RECALCULATE_AABB_RAYCAST 1

//When the user doesn't provide dispatcher or broadphase, create basic versions (and delete them in destructor)
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"

///for debug drawing

//for debug rendering
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btTriangleCallback.h"
#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"

btCollisionWorld::btCollisionWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btCollisionConfiguration* collisionConfiguration)
	: m_dispatcher1(dispatcher),
	  m_broadphasePairCache(pairCache),
	  m_debugDrawer(0),
	  m_forceUpdateAllAabbs(true)
{
}

btCollisionWorld::~btCollisionWorld()
{
	//clean up remaining objects
	int i;
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* collisionObject = m_collisionObjects[i];

		btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
		if (bp)
		{
			//
			// only clear the cached algorithms
			//
			getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
			getBroadphase()->destroyProxy(bp, m_dispatcher1);
			collisionObject->setBroadphaseHandle(0);
		}
	}
}

void btCollisionWorld::refreshBroadphaseProxy(btCollisionObject* collisionObject)
{
	if (collisionObject->getBroadphaseHandle())
	{
		int collisionFilterGroup = collisionObject->getBroadphaseHandle()->m_collisionFilterGroup;
		int collisionFilterMask = collisionObject->getBroadphaseHandle()->m_collisionFilterMask;

		getBroadphase()->destroyProxy(collisionObject->getBroadphaseHandle(), getDispatcher());

		//calculate new AABB
		btTransform trans = collisionObject->getWorldTransform();

		btVector3 minAabb;
		btVector3 maxAabb;
		collisionObject->getCollisionShape()->getAabb(trans, minAabb, maxAabb);

		int type = collisionObject->getCollisionShape()->getShapeType();
		collisionObject->setBroadphaseHandle(getBroadphase()->createProxy(
			minAabb,
			maxAabb,
			type,
			collisionObject,
			collisionFilterGroup,
			collisionFilterMask,
			m_dispatcher1));
	}
}

void btCollisionWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{
	btAssert(collisionObject);

	//check that the object isn't already added
	btAssert(m_collisionObjects.findLinearSearch(collisionObject) == m_collisionObjects.size());
	btAssert(collisionObject->getWorldArrayIndex() == -1);  // do not add the same object to more than one collision world

	collisionObject->setWorldArrayIndex(m_collisionObjects.size());
	m_collisionObjects.push_back(collisionObject);

	//calculate new AABB
	btTransform trans = collisionObject->getWorldTransform();

	btVector3 minAabb;
	btVector3 maxAabb;
	collisionObject->getCollisionShape()->getAabb(trans, minAabb, maxAabb);

	int type = collisionObject->getCollisionShape()->getShapeType();
	collisionObject->setBroadphaseHandle(getBroadphase()->createProxy(
		minAabb,
		maxAabb,
		type,
		collisionObject,
		collisionFilterGroup,
		collisionFilterMask,
		m_dispatcher1));
}

void btCollisionWorld::updateSingleAabb(btCollisionObject* colObj)
{
	btVector3 minAabb, maxAabb;
	colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
	//need to increase the aabb for contact thresholds
	btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
	minAabb -= contactThreshold;
	maxAabb += contactThreshold;

	if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
	{
		btVector3 minAabb2, maxAabb2;
		colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
		minAabb2 -= contactThreshold;
		maxAabb2 += contactThreshold;
		minAabb.setMin(minAabb2);
		maxAabb.setMax(maxAabb2);
	}

	btBroadphaseInterface* bp = (btBroadphaseInterface*)m_broadphasePairCache;

	//moving objects should be moderately sized, probably something wrong if not
	if (colObj->isStaticObject() || ((maxAabb - minAabb).length2() < btScalar(1e12)))
	{
		bp->setAabb(colObj->getBroadphaseHandle(), minAabb, maxAabb, m_dispatcher1);
	}
	else
	{
		//something went wrong, investigate
		//this assert is unwanted in 3D modelers (danger of loosing work)
		colObj->setActivationState(DISABLE_SIMULATION);

		static bool reportMe = true;
		if (reportMe && m_debugDrawer)
		{
			reportMe = false;
			m_debugDrawer->reportErrorWarning("Overflow in AABB, object removed from simulation");
			m_debugDrawer->reportErrorWarning("If you can reproduce this, please email bugs@continuousphysics.com\n");
			m_debugDrawer->reportErrorWarning("Please include above information, your Platform, version of OS.\n");
			m_debugDrawer->reportErrorWarning("Thanks.\n");
		}
	}
}

void btCollisionWorld::updateAabbs()
{
	BT_PROFILE("updateAabbs");

	for (int i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btAssert(colObj->getWorldArrayIndex() == i);

		//only update aabb of active objects
		if (m_forceUpdateAllAabbs || colObj->isActive())
		{
			updateSingleAabb(colObj);
		}
	}
}

void btCollisionWorld::computeOverlappingPairs()
{
	BT_PROFILE("calculateOverlappingPairs");
	m_broadphasePairCache->calculateOverlappingPairs(m_dispatcher1);
}

void btCollisionWorld::performDiscreteCollisionDetection()
{
	BT_PROFILE("performDiscreteCollisionDetection");

	btDispatcherInfo& dispatchInfo = getDispatchInfo();

	updateAabbs();

	computeOverlappingPairs();

	btDispatcher* dispatcher = getDispatcher();
	{
		BT_PROFILE("dispatchAllCollisionPairs");
		if (dispatcher)
			dispatcher->dispatchAllCollisionPairs(m_broadphasePairCache->getOverlappingPairCache(), dispatchInfo, m_dispatcher1);
	}
}

void btCollisionWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
	//bool removeFromBroadphase = false;

	{
		btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
		if (bp)
		{
			//
			// only clear the cached algorithms
			//
			getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
			getBroadphase()->destroyProxy(bp, m_dispatcher1);
			collisionObject->setBroadphaseHandle(0);
		}
	}

	int iObj = collisionObject->getWorldArrayIndex();
	//    btAssert(iObj >= 0 && iObj < m_collisionObjects.size()); // trying to remove an object that was never added or already removed previously?
	if (iObj >= 0 && iObj < m_collisionObjects.size())
	{
		btAssert(collisionObject == m_collisionObjects[iObj]);
		m_collisionObjects.swap(iObj, m_collisionObjects.size() - 1);
		m_collisionObjects.pop_back();
		if (iObj < m_collisionObjects.size())
		{
			m_collisionObjects[iObj]->setWorldArrayIndex(iObj);
		}
	}
	else
	{
		// slow linear search
		//swapremove
		m_collisionObjects.remove(collisionObject);
	}
	collisionObject->setWorldArrayIndex(-1);
}

void btCollisionWorld::rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
									 btCollisionObject* collisionObject,
									 const btCollisionShape* collisionShape,
									 const btTransform& colObjWorldTransform,
									 RayResultCallback& resultCallback)
{
	btCollisionObjectWrapper colObWrap(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
	btCollisionWorld::rayTestSingleInternal(rayFromTrans, rayToTrans, &colObWrap, resultCallback);
}

void btCollisionWorld::rayTestSingleInternal(const btTransform& rayFromTrans, const btTransform& rayToTrans,
											 const btCollisionObjectWrapper* collisionObjectWrap,
											 RayResultCallback& resultCallback)
{
	btSphereShape pointShape(btScalar(0.0));
	pointShape.setMargin(0.f);
	const btConvexShape* castShape = &pointShape;
	const btCollisionShape* collisionShape = collisionObjectWrap->getCollisionShape();
	const btTransform& colObjWorldTransform = collisionObjectWrap->getWorldTransform();

	if (collisionShape->isConvex())
	{
		//		BT_PROFILE("rayTestConvex");
		btConvexCast::CastResult castResult;
		castResult.m_fraction = resultCallback.m_closestHitFraction;

		btConvexShape* convexShape = (btConvexShape*)collisionShape;
		btVoronoiSimplexSolver simplexSolver;
		btSubsimplexConvexCast subSimplexConvexCaster(castShape, convexShape, &simplexSolver);

		btGjkConvexCast gjkConvexCaster(castShape, convexShape, &simplexSolver);

		//btContinuousConvexCollision convexCaster(castShape,convexShape,&simplexSolver,0);

		btConvexCast* convexCasterPtr = 0;
		//use kF_UseSubSimplexConvexCastRaytest by default
		if (resultCallback.m_flags & btTriangleRaycastCallback::kF_UseGjkConvexCastRaytest)
			convexCasterPtr = &gjkConvexCaster;
		else
			convexCasterPtr = &subSimplexConvexCaster;

		btConvexCast& convexCaster = *convexCasterPtr;

		if (convexCaster.calcTimeOfImpact(rayFromTrans, rayToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
		{
			//add hit
			if (castResult.m_normal.length2() > btScalar(0.0001))
			{
				if (castResult.m_fraction < resultCallback.m_closestHitFraction)
				{
					//todo: figure out what this is about. When is rayFromTest.getBasis() not identity?
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
					//rotate normal into worldspace
					castResult.m_normal = rayFromTrans.getBasis() * castResult.m_normal;
#endif  //USE_SUBSIMPLEX_CONVEX_CAST

					castResult.m_normal.normalize();
					btCollisionWorld::LocalRayResult localRayResult(
						collisionObjectWrap->getCollisionObject(),
						0,
						castResult.m_normal,
						castResult.m_fraction);

					bool normalInWorldSpace = true;
					resultCallback.addSingleResult(localRayResult, normalInWorldSpace);
				}
			}
		}
	}
	else
	{
		if (collisionShape->isConcave())
		{
			//ConvexCast::CastResult
			struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
			{
				btCollisionWorld::RayResultCallback* m_resultCallback;
				const btCollisionObject* m_collisionObject;
				const btConcaveShape* m_triangleMesh;

				btTransform m_colObjWorldTransform;

				BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
											  btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, const btConcaveShape* triangleMesh, const btTransform& colObjWorldTransform) :  //@BP Mod
																																																							btTriangleRaycastCallback(from, to, resultCallback->m_flags),
																																																							m_resultCallback(resultCallback),
																																																							m_collisionObject(collisionObject),
																																																							m_triangleMesh(triangleMesh),
																																																							m_colObjWorldTransform(colObjWorldTransform)
				{
				}

				virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
				{
					btCollisionWorld::LocalShapeInfo shapeInfo;
					shapeInfo.m_shapePart = partId;
					shapeInfo.m_triangleIndex = triangleIndex;

					btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

					btCollisionWorld::LocalRayResult rayResult(m_collisionObject,
															   &shapeInfo,
															   hitNormalWorld,
															   hitFraction);

					bool normalInWorldSpace = true;
					return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
				}
			};

			btTransform worldTocollisionObject = colObjWorldTransform.inverse();
			btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
			btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

			//			BT_PROFILE("rayTestConcave");
			if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				///optimized version for btBvhTriangleMeshShape
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				triangleMesh->performRaycast(&rcb, rayFromLocal, rayToLocal);
			}
			else if (collisionShape->getShapeType() == SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				///optimized version for btScaledBvhTriangleMeshShape
				btScaledBvhTriangleMeshShape* scaledTriangleMesh = (btScaledBvhTriangleMeshShape*)collisionShape;
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)scaledTriangleMesh->getChildShape();

				//scale the ray positions
				btVector3 scale = scaledTriangleMesh->getLocalScaling();
				btVector3 rayFromLocalScaled = rayFromLocal / scale;
				btVector3 rayToLocalScaled = rayToLocal / scale;

				//perform raycast in the underlying btBvhTriangleMeshShape
				BridgeTriangleRaycastCallback rcb(rayFromLocalScaled, rayToLocalScaled, &resultCallback, collisionObjectWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				triangleMesh->performRaycast(&rcb, rayFromLocalScaled, rayToLocalScaled);
			}
			else if (((resultCallback.m_flags&btTriangleRaycastCallback::kF_DisableHeightfieldAccelerator)==0) 
				&& collisionShape->getShapeType() == TERRAIN_SHAPE_PROXYTYPE 
				)
			{
				///optimized version for btHeightfieldTerrainShape
				btHeightfieldTerrainShape* heightField = (btHeightfieldTerrainShape*)collisionShape;
				btTransform worldTocollisionObject = colObjWorldTransform.inverse();
				btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
				btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), heightField, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				heightField->performRaycast(&rcb, rayFromLocal, rayToLocal);
			}
			else
			{
				//generic (slower) case
				btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;

				btTransform worldTocollisionObject = colObjWorldTransform.inverse();

				btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
				btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

				//ConvexCast::CastResult

				struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
				{
					btCollisionWorld::RayResultCallback* m_resultCallback;
					const btCollisionObject* m_collisionObject;
					btConcaveShape* m_triangleMesh;

					btTransform m_colObjWorldTransform;

					BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
												  btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape* triangleMesh, const btTransform& colObjWorldTransform) :  //@BP Mod
																																																						  btTriangleRaycastCallback(from, to, resultCallback->m_flags),
																																																						  m_resultCallback(resultCallback),
																																																						  m_collisionObject(collisionObject),
																																																						  m_triangleMesh(triangleMesh),
																																																						  m_colObjWorldTransform(colObjWorldTransform)
					{
					}

					virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = partId;
						shapeInfo.m_triangleIndex = triangleIndex;

						btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

						btCollisionWorld::LocalRayResult rayResult(m_collisionObject,
																   &shapeInfo,
																   hitNormalWorld,
																   hitFraction);

						bool normalInWorldSpace = true;
						return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
					}
				};

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;

				btVector3 rayAabbMinLocal = rayFromLocal;
				rayAabbMinLocal.setMin(rayToLocal);
				btVector3 rayAabbMaxLocal = rayFromLocal;
				rayAabbMaxLocal.setMax(rayToLocal);

				concaveShape->processAllTriangles(&rcb, rayAabbMinLocal, rayAabbMaxLocal);
			}
		}
		else
		{
			//			BT_PROFILE("rayTestCompound");
			if (collisionShape->isCompound())
			{
				struct LocalInfoAdder2 : public RayResultCallback
				{
					RayResultCallback* m_userCallback;
					int m_i;

					LocalInfoAdder2(int i, RayResultCallback* user)
						: m_userCallback(user), m_i(i)
					{
						m_closestHitFraction = m_userCallback->m_closestHitFraction;
						m_flags = m_userCallback->m_flags;
					}
					virtual bool needsCollision(btBroadphaseProxy* p) const
					{
						return m_userCallback->needsCollision(p);
					}

					virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& r, bool b)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = -1;
						shapeInfo.m_triangleIndex = m_i;
						if (r.m_localShapeInfo == NULL)
							r.m_localShapeInfo = &shapeInfo;

						const btScalar result = m_userCallback->addSingleResult(r, b);
						m_closestHitFraction = m_userCallback->m_closestHitFraction;
						return result;
					}
				};

				struct RayTester : btDbvt::ICollide
				{
					const btCollisionObject* m_collisionObject;
					const btCompoundShape* m_compoundShape;
					const btTransform& m_colObjWorldTransform;
					const btTransform& m_rayFromTrans;
					const btTransform& m_rayToTrans;
					RayResultCallback& m_resultCallback;

					RayTester(const btCollisionObject* collisionObject,
							  const btCompoundShape* compoundShape,
							  const btTransform& colObjWorldTransform,
							  const btTransform& rayFromTrans,
							  const btTransform& rayToTrans,
							  RayResultCallback& resultCallback) : m_collisionObject(collisionObject),
																   m_compoundShape(compoundShape),
																   m_colObjWorldTransform(colObjWorldTransform),
																   m_rayFromTrans(rayFromTrans),
																   m_rayToTrans(rayToTrans),
																   m_resultCallback(resultCallback)
					{
					}

					void ProcessLeaf(int i)
					{
						const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(i);
						const btTransform& childTrans = m_compoundShape->getChildTransform(i);
						btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

						btCollisionObjectWrapper tmpOb(0, childCollisionShape, m_collisionObject, childWorldTrans, -1, i);
						// replace collision shape so that callback can determine the triangle

						LocalInfoAdder2 my_cb(i, &m_resultCallback);

						rayTestSingleInternal(
							m_rayFromTrans,
							m_rayToTrans,
							&tmpOb,
							my_cb);
					}

					void Process(const btDbvtNode* leaf)
					{
						ProcessLeaf(leaf->dataAsInt);
					}
				};

				const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);
				const btDbvt* dbvt = compoundShape->getDynamicAabbTree();

				RayTester rayCB(
					collisionObjectWrap->getCollisionObject(),
					compoundShape,
					colObjWorldTransform,
					rayFromTrans,
					rayToTrans,
					resultCallback);
#ifndef DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
				if (dbvt)
				{
					btVector3 localRayFrom = colObjWorldTransform.inverseTimes(rayFromTrans).getOrigin();
					btVector3 localRayTo = colObjWorldTransform.inverseTimes(rayToTrans).getOrigin();
					btDbvt::rayTest(dbvt->m_root, localRayFrom, localRayTo, rayCB);
				}
				else
#endif  //DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
				{
					for (int i = 0, n = compoundShape->getNumChildShapes(); i < n; ++i)
					{
						rayCB.ProcessLeaf(i);
					}
				}
			}
		}
	}
}

void btCollisionWorld::objectQuerySingle(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
										 btCollisionObject* collisionObject,
										 const btCollisionShape* collisionShape,
										 const btTransform& colObjWorldTransform,
										 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
	btCollisionObjectWrapper tmpOb(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
	btCollisionWorld::objectQuerySingleInternal(castShape, convexFromTrans, convexToTrans, &tmpOb, resultCallback, allowedPenetration);
}

void btCollisionWorld::objectQuerySingleInternal(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
												 const btCollisionObjectWrapper* colObjWrap,
												 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
	const btCollisionShape* collisionShape = colObjWrap->getCollisionShape();
	const btTransform& colObjWorldTransform = colObjWrap->getWorldTransform();

	if (collisionShape->isConvex())
	{
		//BT_PROFILE("convexSweepConvex");
		btConvexCast::CastResult castResult;
		castResult.m_allowedPenetration = allowedPenetration;
		castResult.m_fraction = resultCallback.m_closestHitFraction;  //btScalar(1.);//??

		btConvexShape* convexShape = (btConvexShape*)collisionShape;
		btVoronoiSimplexSolver simplexSolver;
		btGjkEpaPenetrationDepthSolver gjkEpaPenetrationSolver;

		btContinuousConvexCollision convexCaster1(castShape, convexShape, &simplexSolver, &gjkEpaPenetrationSolver);
		//btGjkConvexCast convexCaster2(castShape,convexShape,&simplexSolver);
		//btSubsimplexConvexCast convexCaster3(castShape,convexShape,&simplexSolver);

		btConvexCast* castPtr = &convexCaster1;

		if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
		{
			//add hit
			if (castResult.m_normal.length2() > btScalar(0.0001))
			{
				if (castResult.m_fraction < resultCallback.m_closestHitFraction)
				{
					castResult.m_normal.normalize();
					btCollisionWorld::LocalConvexResult localConvexResult(
						colObjWrap->getCollisionObject(),
						0,
						castResult.m_normal,
						castResult.m_hitPoint,
						castResult.m_fraction);

					bool normalInWorldSpace = true;
					resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);
				}
			}
		}
	}
	else
	{
		if (collisionShape->isConcave())
		{
			if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				//BT_PROFILE("convexSweepbtBvhTriangleMesh");
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;
				btTransform worldTocollisionObject = colObjWorldTransform.inverse();
				btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
				btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
				// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
				btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

				//ConvexCast::CastResult
				struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
				{
					btCollisionWorld::ConvexResultCallback* m_resultCallback;
					const btCollisionObject* m_collisionObject;
					btTriangleMeshShape* m_triangleMesh;

					BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
													 btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btTriangleMeshShape* triangleMesh, const btTransform& triangleToWorld) : btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
																																																								m_resultCallback(resultCallback),
																																																								m_collisionObject(collisionObject),
																																																								m_triangleMesh(triangleMesh)
					{
					}

					virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = partId;
						shapeInfo.m_triangleIndex = triangleIndex;
						if (hitFraction <= m_resultCallback->m_closestHitFraction)
						{
							btCollisionWorld::LocalConvexResult convexResult(m_collisionObject,
																			 &shapeInfo,
																			 hitNormalLocal,
																			 hitPointLocal,
																			 hitFraction);

							bool normalInWorldSpace = true;

							return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
						}
						return hitFraction;
					}
				};

				BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				tccb.m_hitFraction = resultCallback.m_closestHitFraction;
				tccb.m_allowedPenetration = allowedPenetration;
				btVector3 boxMinLocal, boxMaxLocal;
				castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);
				triangleMesh->performConvexcast(&tccb, convexFromLocal, convexToLocal, boxMinLocal, boxMaxLocal);
			}
			else
			{
				if (collisionShape->getShapeType() == STATIC_PLANE_PROXYTYPE)
				{
					btConvexCast::CastResult castResult;
					castResult.m_allowedPenetration = allowedPenetration;
					castResult.m_fraction = resultCallback.m_closestHitFraction;
					btStaticPlaneShape* planeShape = (btStaticPlaneShape*)collisionShape;
					btContinuousConvexCollision convexCaster1(castShape, planeShape);
					btConvexCast* castPtr = &convexCaster1;

					if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
					{
						//add hit
						if (castResult.m_normal.length2() > btScalar(0.0001))
						{
							if (castResult.m_fraction < resultCallback.m_closestHitFraction)
							{
								castResult.m_normal.normalize();
								btCollisionWorld::LocalConvexResult localConvexResult(
									colObjWrap->getCollisionObject(),
									0,
									castResult.m_normal,
									castResult.m_hitPoint,
									castResult.m_fraction);

								bool normalInWorldSpace = true;
								resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);
							}
						}
					}
				}
				else
				{
					//BT_PROFILE("convexSweepConcave");
					btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;
					btTransform worldTocollisionObject = colObjWorldTransform.inverse();
					btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
					btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
					// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
					btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

					//ConvexCast::CastResult
					struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
					{
						btCollisionWorld::ConvexResultCallback* m_resultCallback;
						const btCollisionObject* m_collisionObject;
						btConcaveShape* m_triangleMesh;

						BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
														 btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape* triangleMesh, const btTransform& triangleToWorld) : btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
																																																							   m_resultCallback(resultCallback),
																																																							   m_collisionObject(collisionObject),
																																																							   m_triangleMesh(triangleMesh)
						{
						}

						virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
						{
							btCollisionWorld::LocalShapeInfo shapeInfo;
							shapeInfo.m_shapePart = partId;
							shapeInfo.m_triangleIndex = triangleIndex;
							if (hitFraction <= m_resultCallback->m_closestHitFraction)
							{
								btCollisionWorld::LocalConvexResult convexResult(m_collisionObject,
																				 &shapeInfo,
																				 hitNormalLocal,
																				 hitPointLocal,
																				 hitFraction);

								bool normalInWorldSpace = true;

								return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
							}
							return hitFraction;
						}
					};

					BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
					tccb.m_hitFraction = resultCallback.m_closestHitFraction;
					tccb.m_allowedPenetration = allowedPenetration;
					btVector3 boxMinLocal, boxMaxLocal;
					castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);

					btVector3 rayAabbMinLocal = convexFromLocal;
					rayAabbMinLocal.setMin(convexToLocal);
					btVector3 rayAabbMaxLocal = convexFromLocal;
					rayAabbMaxLocal.setMax(convexToLocal);
					rayAabbMinLocal += boxMinLocal;
					rayAabbMaxLocal += boxMaxLocal;
					concaveShape->processAllTriangles(&tccb, rayAabbMinLocal, rayAabbMaxLocal);
				}
			}
		}
		else
		{
			if (collisionShape->isCompound())
			{
				struct btCompoundLeafCallback : btDbvt::ICollide
				{
					btCompoundLeafCallback(
						const btCollisionObjectWrapper* colObjWrap,
						const btConvexShape* castShape,
						const btTransform& convexFromTrans,
						const btTransform& convexToTrans,
						btScalar allowedPenetration,
						const btCompoundShape* compoundShape,
						const btTransform& colObjWorldTransform,
						ConvexResultCallback& resultCallback)
						: m_colObjWrap(colObjWrap),
						  m_castShape(castShape),
						  m_convexFromTrans(convexFromTrans),
						  m_convexToTrans(convexToTrans),
						  m_allowedPenetration(allowedPenetration),
						  m_compoundShape(compoundShape),
						  m_colObjWorldTransform(colObjWorldTransform),
						  m_resultCallback(resultCallback)
					{
					}

					const btCollisionObjectWrapper* m_colObjWrap;
					const btConvexShape* m_castShape;
					const btTransform& m_convexFromTrans;
					const btTransform& m_convexToTrans;
					btScalar m_allowedPenetration;
					const btCompoundShape* m_compoundShape;
					const btTransform& m_colObjWorldTransform;
					ConvexResultCallback& m_resultCallback;

				public:
					void ProcessChild(int index, const btTransform& childTrans, const btCollisionShape* childCollisionShape)
					{
						btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

						struct LocalInfoAdder : public ConvexResultCallback
						{
							ConvexResultCallback* m_userCallback;
							int m_i;

							LocalInfoAdder(int i, ConvexResultCallback* user)
								: m_userCallback(user), m_i(i)
							{
								m_closestHitFraction = m_userCallback->m_closestHitFraction;
							}
							virtual bool needsCollision(btBroadphaseProxy* p) const
							{
								return m_userCallback->needsCollision(p);
							}
							virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& r, bool b)
							{
								btCollisionWorld::LocalShapeInfo shapeInfo;
								shapeInfo.m_shapePart = -1;
								shapeInfo.m_triangleIndex = m_i;
								if (r.m_localShapeInfo == NULL)
									r.m_localShapeInfo = &shapeInfo;
								const btScalar result = m_userCallback->addSingleResult(r, b);
								m_closestHitFraction = m_userCallback->m_closestHitFraction;
								return result;
							}
						};

						LocalInfoAdder my_cb(index, &m_resultCallback);

						btCollisionObjectWrapper tmpObj(m_colObjWrap, childCollisionShape, m_colObjWrap->getCollisionObject(), childWorldTrans, -1, index);

						objectQuerySingleInternal(m_castShape, m_convexFromTrans, m_convexToTrans, &tmpObj, my_cb, m_allowedPenetration);
					}

					void Process(const btDbvtNode* leaf)
					{
						// Processing leaf node
						int index = leaf->dataAsInt;

						btTransform childTrans = m_compoundShape->getChildTransform(index);
						const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(index);

						ProcessChild(index, childTrans, childCollisionShape);
					}
				};

				BT_PROFILE("convexSweepCompound");
				const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);

				btVector3 fromLocalAabbMin, fromLocalAabbMax;
				btVector3 toLocalAabbMin, toLocalAabbMax;

				castShape->getAabb(colObjWorldTransform.inverse() * convexFromTrans, fromLocalAabbMin, fromLocalAabbMax);
				castShape->getAabb(colObjWorldTransform.inverse() * convexToTrans, toLocalAabbMin, toLocalAabbMax);

				fromLocalAabbMin.setMin(toLocalAabbMin);
				fromLocalAabbMax.setMax(toLocalAabbMax);

				btCompoundLeafCallback callback(colObjWrap, castShape, convexFromTrans, convexToTrans,
												allowedPenetration, compoundShape, colObjWorldTransform, resultCallback);

				const btDbvt* tree = compoundShape->getDynamicAabbTree();
				if (tree)
				{
					const ATTRIBUTE_ALIGNED16(btDbvtVolume) bounds = btDbvtVolume::FromMM(fromLocalAabbMin, fromLocalAabbMax);
					tree->collideTV(tree->m_root, bounds, callback);
				}
				else
				{
					int i;
					for (i = 0; i < compoundShape->getNumChildShapes(); i++)
					{
						const btCollisionShape* childCollisionShape = compoundShape->getChildShape(i);
						btTransform childTrans = compoundShape->getChildTransform(i);
						callback.ProcessChild(i, childTrans, childCollisionShape);
					}
				}
			}
		}
	}
}

struct btSingleRayCallback : public btBroadphaseRayCallback
{
	btVector3 m_rayFromWorld;
	btVector3 m_rayToWorld;
	btTransform m_rayFromTrans;
	btTransform m_rayToTrans;
	btVector3 m_hitNormal;

	const btCollisionWorld* m_world;
	btCollisionWorld::RayResultCallback& m_resultCallback;

	btSingleRayCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld, const btCollisionWorld* world, btCollisionWorld::RayResultCallback& resultCallback)
		: m_rayFromWorld(rayFromWorld),
		  m_rayToWorld(rayToWorld),
		  m_world(world),
		  m_resultCallback(resultCallback)
	{
		m_rayFromTrans.setIdentity();
		m_rayFromTrans.setOrigin(m_rayFromWorld);
		m_rayToTrans.setIdentity();
		m_rayToTrans.setOrigin(m_rayToWorld);

		btVector3 rayDir = (rayToWorld - rayFromWorld);

		rayDir.normalize();
		///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
		m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
		m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
		m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
		m_signs[0] = m_rayDirectionInverse[0] < 0.0;
		m_signs[1] = m_rayDirectionInverse[1] < 0.0;
		m_signs[2] = m_rayDirectionInverse[2] < 0.0;

		m_lambda_max = rayDir.dot(m_rayToWorld - m_rayFromWorld);
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		///terminate further ray tests, once the closestHitFraction reached zero
		if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
			return false;

		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			//btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
#if 0
#ifdef RECALCULATE_AABB
			btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
			collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(),collisionObjectAabbMin,collisionObjectAabbMax);
#else
			//getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
			const btVector3& collisionObjectAabbMin = collisionObject->getBroadphaseHandle()->m_aabbMin;
			const btVector3& collisionObjectAabbMax = collisionObject->getBroadphaseHandle()->m_aabbMax;
#endif
#endif
			//btScalar hitLambda = m_resultCallback.m_closestHitFraction;
			//culling already done by broadphase
			//if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
			{
				m_world->rayTestSingle(m_rayFromTrans, m_rayToTrans,
									   collisionObject,
									   collisionObject->getCollisionShape(),
									   collisionObject->getWorldTransform(),
									   m_resultCallback);
			}
		}
		return true;
	}
};

void btCollisionWorld::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const
{
	//BT_PROFILE("rayTest");
	/// use the broadphase to accelerate the search for objects, based on their aabb
	/// and for each object with ray-aabb overlap, perform an exact ray test
	btSingleRayCallback rayCB(rayFromWorld, rayToWorld, this, resultCallback);

#ifndef USE_BRUTEFORCE_RAYBROADPHASE
	m_broadphasePairCache->rayTest(rayFromWorld, rayToWorld, rayCB);
#else
	for (int i = 0; i < this->getNumCollisionObjects(); i++)
	{
		rayCB.process(m_collisionObjects[i]->getBroadphaseHandle());
	}
#endif  //USE_BRUTEFORCE_RAYBROADPHASE
}

struct btSingleSweepCallback : public btBroadphaseRayCallback
{
	btTransform m_convexFromTrans;
	btTransform m_convexToTrans;
	btVector3 m_hitNormal;
	const btCollisionWorld* m_world;
	btCollisionWorld::ConvexResultCallback& m_resultCallback;
	btScalar m_allowedCcdPenetration;
	const btConvexShape* m_castShape;

	btSingleSweepCallback(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans, const btCollisionWorld* world, btCollisionWorld::ConvexResultCallback& resultCallback, btScalar allowedPenetration)
		: m_convexFromTrans(convexFromTrans),
		  m_convexToTrans(convexToTrans),
		  m_world(world),
		  m_resultCallback(resultCallback),
		  m_allowedCcdPenetration(allowedPenetration),
		  m_castShape(castShape)
	{
		btVector3 unnormalizedRayDir = (m_convexToTrans.getOrigin() - m_convexFromTrans.getOrigin());
		btVector3 rayDir = unnormalizedRayDir.fuzzyZero() ? btVector3(btScalar(0.0), btScalar(0.0), btScalar(0.0)) : unnormalizedRayDir.normalized();
		///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
		m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
		m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
		m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
		m_signs[0] = m_rayDirectionInverse[0] < 0.0;
		m_signs[1] = m_rayDirectionInverse[1] < 0.0;
		m_signs[2] = m_rayDirectionInverse[2] < 0.0;

		m_lambda_max = rayDir.dot(unnormalizedRayDir);
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		///terminate further convex sweep tests, once the closestHitFraction reached zero
		if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
			return false;

		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			m_world->objectQuerySingle(m_castShape, m_convexFromTrans, m_convexToTrans,
									   collisionObject,
									   collisionObject->getCollisionShape(),
									   collisionObject->getWorldTransform(),
									   m_resultCallback,
									   m_allowedCcdPenetration);
		}

		return true;
	}
};

void btCollisionWorld::convexSweepTest(const btConvexShape* castShape, const btTransform& convexFromWorld, const btTransform& convexToWorld, ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration) const
{
	BT_PROFILE("convexSweepTest");
	/// use the broadphase to accelerate the search for objects, based on their aabb
	/// and for each object with ray-aabb overlap, perform an exact ray test
	/// unfortunately the implementation for rayTest and convexSweepTest duplicated, albeit practically identical

	btTransform convexFromTrans, convexToTrans;
	convexFromTrans = convexFromWorld;
	convexToTrans = convexToWorld;
	btVector3 castShapeAabbMin, castShapeAabbMax;
	/* Compute AABB that encompasses angular movement */
	{
		btVector3 linVel, angVel;
		btTransformUtil::calculateVelocity(convexFromTrans, convexToTrans, 1.0f, linVel, angVel);
		btVector3 zeroLinVel;
		zeroLinVel.setValue(0, 0, 0);
		btTransform R;
		R.setIdentity();
		R.setRotation(convexFromTrans.getRotation());
		castShape->calculateTemporalAabb(R, zeroLinVel, angVel, 1.0f, castShapeAabbMin, castShapeAabbMax);
	}

#ifndef USE_BRUTEFORCE_RAYBROADPHASE

	btSingleSweepCallback convexCB(castShape, convexFromWorld, convexToWorld, this, resultCallback, allowedCcdPenetration);

	m_broadphasePairCache->rayTest(convexFromTrans.getOrigin(), convexToTrans.getOrigin(), convexCB, castShapeAabbMin, castShapeAabbMax);

#else
	/// go over all objects, and if the ray intersects their aabb + cast shape aabb,
	// do a ray-shape query using convexCaster (CCD)
	int i;
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* collisionObject = m_collisionObjects[i];
		//only perform raycast if filterMask matches
		if (resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
			collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
			AabbExpand(collisionObjectAabbMin, collisionObjectAabbMax, castShapeAabbMin, castShapeAabbMax);
			btScalar hitLambda = btScalar(1.);  //could use resultCallback.m_closestHitFraction, but needs testing
			btVector3 hitNormal;
			if (btRayAabb(convexFromWorld.getOrigin(), convexToWorld.getOrigin(), collisionObjectAabbMin, collisionObjectAabbMax, hitLambda, hitNormal))
			{
				objectQuerySingle(castShape, convexFromTrans, convexToTrans,
								  collisionObject,
								  collisionObject->getCollisionShape(),
								  collisionObject->getWorldTransform(),
								  resultCallback,
								  allowedCcdPenetration);
			}
		}
	}
#endif  //USE_BRUTEFORCE_RAYBROADPHASE
}

struct btBridgedManifoldResult : public btManifoldResult
{
	btCollisionWorld::ContactResultCallback& m_resultCallback;

	btBridgedManifoldResult(const btCollisionObjectWrapper* obj0Wrap, const btCollisionObjectWrapper* obj1Wrap, btCollisionWorld::ContactResultCallback& resultCallback)
		: btManifoldResult(obj0Wrap, obj1Wrap),
		  m_resultCallback(resultCallback)
	{
	}

	virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
	{
		bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
		btVector3 pointA = pointInWorld + normalOnBInWorld * depth;
		btVector3 localA;
		btVector3 localB;
		if (isSwapped)
		{
			localA = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
			localB = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
		}
		else
		{
			localA = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
			localB = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
		}

		btManifoldPoint newPt(localA, localB, normalOnBInWorld, depth);
		newPt.m_positionWorldOnA = pointA;
		newPt.m_positionWorldOnB = pointInWorld;

		//BP mod, store contact triangles.
		if (isSwapped)
		{
			newPt.m_partId0 = m_partId1;
			newPt.m_partId1 = m_partId0;
			newPt.m_index0 = m_index1;
			newPt.m_index1 = m_index0;
		}
		else
		{
			newPt.m_partId0 = m_partId0;
			newPt.m_partId1 = m_partId1;
			newPt.m_index0 = m_index0;
			newPt.m_index1 = m_index1;
		}

		//experimental feature info, for per-triangle material etc.
		const btCollisionObjectWrapper* obj0Wrap = isSwapped ? m_body1Wrap : m_body0Wrap;
		const btCollisionObjectWrapper* obj1Wrap = isSwapped ? m_body0Wrap : m_body1Wrap;
		m_resultCallback.addSingleResult(newPt, obj0Wrap, newPt.m_partId0, newPt.m_index0, obj1Wrap, newPt.m_partId1, newPt.m_index1);
	}
};

struct btSingleContactCallback : public btBroadphaseAabbCallback
{
	btCollisionObject* m_collisionObject;
	btCollisionWorld* m_world;
	btCollisionWorld::ContactResultCallback& m_resultCallback;

	btSingleContactCallback(btCollisionObject* collisionObject, btCollisionWorld* world, btCollisionWorld::ContactResultCallback& resultCallback)
		: m_collisionObject(collisionObject),
		  m_world(world),
		  m_resultCallback(resultCallback)
	{
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;
		if (collisionObject == m_collisionObject)
			return true;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			btCollisionObjectWrapper ob0(0, m_collisionObject->getCollisionShape(), m_collisionObject, m_collisionObject->getWorldTransform(), -1, -1);
			btCollisionObjectWrapper ob1(0, collisionObject->getCollisionShape(), collisionObject, collisionObject->getWorldTransform(), -1, -1);

			btCollisionAlgorithm* algorithm = m_world->getDispatcher()->findAlgorithm(&ob0, &ob1, 0, BT_CLOSEST_POINT_ALGORITHMS);
			if (algorithm)
			{
				btBridgedManifoldResult contactPointResult(&ob0, &ob1, m_resultCallback);
				//discrete collision detection query

				algorithm->processCollision(&ob0, &ob1, m_world->getDispatchInfo(), &contactPointResult);

				algorithm->~btCollisionAlgorithm();
				m_world->getDispatcher()->freeCollisionAlgorithm(algorithm);
			}
		}
		return true;
	}
};

///contactTest performs a discrete collision test against all objects in the btCollisionWorld, and calls the resultCallback.
///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
void btCollisionWorld::contactTest(btCollisionObject* colObj, ContactResultCallback& resultCallback)
{
	btVector3 aabbMin, aabbMax;
	colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), aabbMin, aabbMax);
	btSingleContactCallback contactCB(colObj, this, resultCallback);

	m_broadphasePairCache->aabbTest(aabbMin, aabbMax, contactCB);
}

///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
///it reports one or more contact points (including the one with deepest penetration)
void btCollisionWorld::contactPairTest(btCollisionObject* colObjA, btCollisionObject* colObjB, ContactResultCallback& resultCallback)
{
	btCollisionObjectWrapper obA(0, colObjA->getCollisionShape(), colObjA, colObjA->getWorldTransform(), -1, -1);
	btCollisionObjectWrapper obB(0, colObjB->getCollisionShape(), colObjB, colObjB->getWorldTransform(), -1, -1);

	btCollisionAlgorithm* algorithm = getDispatcher()->findAlgorithm(&obA, &obB, 0, BT_CLOSEST_POINT_ALGORITHMS);
	if (algorithm)
	{
		btBridgedManifoldResult contactPointResult(&obA, &obB, resultCallback);
		contactPointResult.m_closestPointDistanceThreshold = resultCallback.m_closestDistanceThreshold;
		//discrete collision detection query
		algorithm->processCollision(&obA, &obB, getDispatchInfo(), &contactPointResult);

		algorithm->~btCollisionAlgorithm();
		getDispatcher()->freeCollisionAlgorithm(algorithm);
	}
}

class DebugDrawcallback : public btTriangleCallback, public btInternalTriangleIndexCallback
{
	btIDebugDraw* m_debugDrawer;
	btVector3 m_color;
	btTransform m_worldTrans;

public:
	DebugDrawcallback(btIDebugDraw* debugDrawer, const btTransform& worldTrans, const btVector3& color) : m_debugDrawer(debugDrawer),
																										  m_color(color),
																										  m_worldTrans(worldTrans)
	{
	}

	virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
	{
		processTriangle(triangle, partId, triangleIndex);
	}

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
	{
		(void)partId;
		(void)triangleIndex;

		btVector3 wv0, wv1, wv2;
		wv0 = m_worldTrans * triangle[0];
		wv1 = m_worldTrans * triangle[1];
		wv2 = m_worldTrans * triangle[2];
		btVector3 center = (wv0 + wv1 + wv2) * btScalar(1. / 3.);

		if (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
		{
			btVector3 normal = (wv1 - wv0).cross(wv2 - wv0);
			normal.normalize();
			btVector3 normalColor(1, 1, 0);
			m_debugDrawer->drawLine(center, center + normal, normalColor);
		}
		m_debugDrawer->drawTriangle(wv0, wv1, wv2, m_color, 1.0);
	}
};

void btCollisionWorld::debugDrawObject(const btTransform& worldTransform, const btCollisionShape* shape, const btVector3& color)
{
	// Draw a small simplex at the center of the object
	if (getDebugDrawer() && getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawFrames)
	{
		getDebugDrawer()->drawTransform(worldTransform, .1);
	}

	if (shape->getShapeType() == COMPOUND_SHAPE_PROXYTYPE)
	{
		const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(shape);
		for (int i = compoundShape->getNumChildShapes() - 1; i >= 0; i--)
		{
			btTransform childTrans = compoundShape->getChildTransform(i);
			const btCollisionShape* colShape = compoundShape->getChildShape(i);
			debugDrawObject(worldTransform * childTrans, colShape, color);
		}
	}
	else
	{
		switch (shape->getShapeType())
		{
			case BOX_SHAPE_PROXYTYPE:
			{
				const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
				btVector3 halfExtents = boxShape->getHalfExtentsWithMargin();
				getDebugDrawer()->drawBox(-halfExtents, halfExtents, worldTransform, color);
				break;
			}

			case SPHERE_SHAPE_PROXYTYPE:
			{
				const btSphereShape* sphereShape = static_cast<const btSphereShape*>(shape);
				btScalar radius = sphereShape->getMargin();  //radius doesn't include the margin, so draw with margin

				getDebugDrawer()->drawSphere(radius, worldTransform, color);
				break;
			}
			case MULTI_SPHERE_SHAPE_PROXYTYPE:
			{
				const btMultiSphereShape* multiSphereShape = static_cast<const btMultiSphereShape*>(shape);

				btTransform childTransform;
				childTransform.setIdentity();

				for (int i = multiSphereShape->getSphereCount() - 1; i >= 0; i--)
				{
					childTransform.setOrigin(multiSphereShape->getSpherePosition(i));
					getDebugDrawer()->drawSphere(multiSphereShape->getSphereRadius(i), worldTransform * childTransform, color);
				}

				break;
			}
			case CAPSULE_SHAPE_PROXYTYPE:
			{
				const btCapsuleShape* capsuleShape = static_cast<const btCapsuleShape*>(shape);

				btScalar radius = capsuleShape->getRadius();
				btScalar halfHeight = capsuleShape->getHalfHeight();

				int upAxis = capsuleShape->getUpAxis();
				getDebugDrawer()->drawCapsule(radius, halfHeight, upAxis, worldTransform, color);
				break;
			}
			case CONE_SHAPE_PROXYTYPE:
			{
				const btConeShape* coneShape = static_cast<const btConeShape*>(shape);
				btScalar radius = coneShape->getRadius();  //+coneShape->getMargin();
				btScalar height = coneShape->getHeight();  //+coneShape->getMargin();

				int upAxis = coneShape->getConeUpIndex();
				getDebugDrawer()->drawCone(radius, height, upAxis, worldTransform, color);
				break;
			}
			case CYLINDER_SHAPE_PROXYTYPE:
			{
				const btCylinderShape* cylinder = static_cast<const btCylinderShape*>(shape);
				int upAxis = cylinder->getUpAxis();
				btScalar radius = cylinder->getRadius();
				btScalar halfHeight = cylinder->getHalfExtentsWithMargin()[upAxis];
				getDebugDrawer()->drawCylinder(radius, halfHeight, upAxis, worldTransform, color);
				break;
			}

			case STATIC_PLANE_PROXYTYPE:
			{
				const btStaticPlaneShape* staticPlaneShape = static_cast<const btStaticPlaneShape*>(shape);
				btScalar planeConst = staticPlaneShape->getPlaneConstant();
				const btVector3& planeNormal = staticPlaneShape->getPlaneNormal();
				getDebugDrawer()->drawPlane(planeNormal, planeConst, worldTransform, color);
				break;
			}
			default:
			{
				/// for polyhedral shapes
				if (shape->isPolyhedral())
				{
					btPolyhedralConvexShape* polyshape = (btPolyhedralConvexShape*)shape;

					int i;
					if (polyshape->getConvexPolyhedron())
					{
						const btConvexPolyhedron* poly = polyshape->getConvexPolyhedron();
						for (i = 0; i < poly->m_faces.size(); i++)
						{
							btVector3 centroid(0, 0, 0);
							int numVerts = poly->m_faces[i].m_indices.size();
							if (numVerts)
							{
								int lastV = poly->m_faces[i].m_indices[numVerts - 1];
								for (int v = 0; v < poly->m_faces[i].m_indices.size(); v++)
								{
									int curVert = poly->m_faces[i].m_indices[v];
									centroid += poly->m_vertices[curVert];
									getDebugDrawer()->drawLine(worldTransform * poly->m_vertices[lastV], worldTransform * poly->m_vertices[curVert], color);
									lastV = curVert;
								}
							}
							centroid *= btScalar(1.f) / btScalar(numVerts);
							if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
							{
								btVector3 normalColor(1, 1, 0);
								btVector3 faceNormal(poly->m_faces[i].m_plane[0], poly->m_faces[i].m_plane[1], poly->m_faces[i].m_plane[2]);
								getDebugDrawer()->drawLine(worldTransform * centroid, worldTransform * (centroid + faceNormal), normalColor);
							}
						}
					}
					else
					{
						for (i = 0; i < polyshape->getNumEdges(); i++)
						{
							btVector3 a, b;
							polyshape->getEdge(i, a, b);
							btVector3 wa = worldTransform * a;
							btVector3 wb = worldTransform * b;
							getDebugDrawer()->drawLine(wa, wb, color);
						}
					}
				}

				if (shape->isConcave())
				{
					btConcaveShape* concaveMesh = (btConcaveShape*)shape;

					///@todo pass camera, for some culling? no -> we are not a graphics lib
					btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
					btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));

					DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
					concaveMesh->processAllTriangles(&drawCallback, aabbMin, aabbMax);
				}

				if (shape->getShapeType() == CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE)
				{
					btConvexTriangleMeshShape* convexMesh = (btConvexTriangleMeshShape*)shape;
					//todo: pass camera for some culling
					btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
					btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
					//DebugDrawcallback drawCallback;
					DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
					convexMesh->getMeshInterface()->InternalProcessAllTriangles(&drawCallback, aabbMin, aabbMax);
				}
			}
		}
	}
}

void btCollisionWorld::debugDrawWorld()
{
	if (getDebugDrawer())
	{
		getDebugDrawer()->clearLines();

		btIDebugDraw::DefaultColors defaultColors = getDebugDrawer()->getDefaultColors();

		if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawContactPoints)
		{
			if (getDispatcher())
			{
				int numManifolds = getDispatcher()->getNumManifolds();

				for (int i = 0; i < numManifolds; i++)
				{
					btPersistentManifold* contactManifold = getDispatcher()->getManifoldByIndexInternal(i);
					//btCollisionObject* obA = static_cast<btCollisionObject*>(contactManifold->getBody0());
					//btCollisionObject* obB = static_cast<btCollisionObject*>(contactManifold->getBody1());

					int numContacts = contactManifold->getNumContacts();
					for (int j = 0; j < numContacts; j++)
					{
						btManifoldPoint& cp = contactManifold->getContactPoint(j);
						getDebugDrawer()->drawContactPoint(cp.m_positionWorldOnB, cp.m_normalWorldOnB, cp.getDistance(), cp.getLifeTime(), defaultColors.m_contactPoint);
					}
				}
			}
		}

		if ((getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb)))
		{
			int i;

			for (i = 0; i < m_collisionObjects.size(); i++)
			{
				btCollisionObject* colObj = m_collisionObjects[i];
				if ((colObj->getCollisionFlags() & btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT) == 0)
				{
					if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawWireframe))
					{
						btVector3 color(btScalar(0.4), btScalar(0.4), btScalar(0.4));

						switch (colObj->getActivationState())
						{
							case ACTIVE_TAG:
								color = defaultColors.m_activeObject;
								break;
							case ISLAND_SLEEPING:
								color = defaultColors.m_deactivatedObject;
								break;
							case WANTS_DEACTIVATION:
								color = defaultColors.m_wantsDeactivationObject;
								break;
							case DISABLE_DEACTIVATION:
								color = defaultColors.m_disabledDeactivationObject;
								break;
							case DISABLE_SIMULATION:
								color = defaultColors.m_disabledSimulationObject;
								break;
							default:
							{
								color = btVector3(btScalar(.3), btScalar(0.3), btScalar(0.3));
							}
						};

						colObj->getCustomDebugColor(color);

						debugDrawObject(colObj->getWorldTransform(), colObj->getCollisionShape(), color);
					}
					if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
					{
						btVector3 minAabb, maxAabb;
						btVector3 colorvec = defaultColors.m_aabb;
						colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
						btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
						minAabb -= contactThreshold;
						maxAabb += contactThreshold;

						btVector3 minAabb2, maxAabb2;

						if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
						{
							colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
							minAabb2 -= contactThreshold;
							maxAabb2 += contactThreshold;
							minAabb.setMin(minAabb2);
							maxAabb.setMax(maxAabb2);
						}

						m_debugDrawer->drawAabb(minAabb, maxAabb, colorvec);
					}
				}
			}
		}
	}
}

void btCollisionWorld::serializeCollisionObjects(btSerializer* serializer)
{
	int i;

	///keep track of shapes already serialized
	btHashMap<btHashPtr, btCollisionShape*> serializedShapes;

	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btCollisionShape* shape = colObj->getCollisionShape();

		if (!serializedShapes.find(shape))
		{
			serializedShapes.insert(shape, shape);
			shape->serializeSingleShape(serializer);
		}
	}

	//serialize all collision objects
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		if (colObj->getInternalType() == btCollisionObject::CO_COLLISION_OBJECT)
		{
			colObj->serializeSingleObject(serializer);
		}
	}
}

void btCollisionWorld::serializeContactManifolds(btSerializer* serializer)
{
	if (serializer->getSerializationFlags() & BT_SERIALIZE_CONTACT_MANIFOLDS)
	{
		int numManifolds = getDispatcher()->getNumManifolds();
		for (int i = 0; i < numManifolds; i++)
		{
			const btPersistentManifold* manifold = getDispatcher()->getInternalManifoldPointer()[i];
			//don't serialize empty manifolds, they just take space
			//(may have to do it anyway if it destroys determinism)
			if (manifold->getNumContacts() == 0)
				continue;

			btChunk* chunk = serializer->allocate(manifold->calculateSerializeBufferSize(), 1);
			const char* structType = manifold->serialize(manifold, chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_CONTACTMANIFOLD_CODE, (void*)manifold);
		}
	}
}

void btCollisionWorld::serialize(btSerializer* serializer)
{
	serializer->startSerialization();

	serializeCollisionObjects(serializer);

	serializeContactManifolds(serializer);

	serializer->finishSerialization();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/**
 * @mainpage Bullet Documentation
 *
 * @section intro_sec Introduction
 * Bullet is a Collision Detection and Rigid Body Dynamics Library. The Library is Open Source and free for commercial use, under the ZLib license ( http://opensource.org/licenses/zlib-license.php ).
 *
 * The main documentation is Bullet_User_Manual.pdf, included in the source code distribution.
 * There is the Physics Forum for feedback and general Collision Detection and Physics discussions.
 * Please visit http://www.bulletphysics.org
 *
 * @section install_sec Installation
 *
 * @subsection step1 Step 1: Download
 * You can download the Bullet Physics Library from the github repository: https://github.com/bulletphysics/bullet3/releases 
 *
 * @subsection step2 Step 2: Building
 * Bullet has multiple build systems, including premake, cmake and autotools. Premake and cmake support all platforms.
 * Premake is included in the Bullet/build folder for Windows, Mac OSX and Linux. 
 * Under Windows you can click on Bullet/build/vs2010.bat to create Microsoft Visual Studio projects. 
 * On Mac OSX and Linux you can open a terminal and generate Makefile, codeblocks or Xcode4 projects:
 * cd Bullet/build
 * ./premake4_osx gmake or ./premake4_linux gmake or ./premake4_linux64 gmake or (for Mac) ./premake4_osx xcode4
 * cd Bullet/build/gmake
 * make
 * 
 * An alternative to premake is cmake. You can download cmake from http://www.cmake.org
 * cmake can autogenerate projectfiles for Microsoft Visual Studio, Apple Xcode, KDevelop and Unix Makefiles.
 * The easiest is to run the CMake cmake-gui graphical user interface and choose the options and generate projectfiles.
 * You can also use cmake in the command-line. Here are some examples for various platforms:
 * cmake . -G "Visual Studio 9 2008"
 * cmake . -G Xcode
 * cmake . -G "Unix Makefiles"
 * Although cmake is recommended, you can also use autotools for UNIX: ./autogen.sh ./configure to create a Makefile and then run make.
 * 
 * @subsection step3 Step 3: Testing demos
 * Try to run and experiment with BasicDemo executable as a starting point.
 * Bullet can be used in several ways, as Full Rigid Body simulation, as Collision Detector Library or Low Level / Snippets like the GJK Closest Point calculation.
 * The Dependencies can be seen in this documentation under Directories
 * 
 * @subsection step4 Step 4: Integrating in your application, full Rigid Body and Soft Body simulation
 * Check out BasicDemo how to create a btDynamicsWorld, btRigidBody and btCollisionShape, Stepping the simulation and synchronizing your graphics object transform.
 * Check out SoftDemo how to use soft body dynamics, using btSoftRigidDynamicsWorld.
 * @subsection step5 Step 5 : Integrate the Collision Detection Library (without Dynamics and other Extras)
 * Bullet Collision Detection can also be used without the Dynamics/Extras.
 * Check out btCollisionWorld and btCollisionObject, and the CollisionInterfaceDemo.
 * @subsection step6 Step 6 : Use Snippets like the GJK Closest Point calculation.
 * Bullet has been designed in a modular way keeping dependencies to a minimum. The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
 *
 * @section copyright Copyright
 * For up-to-data information and copyright and contributors list check out the Bullet_User_Manual.pdf
 * 
 */

#ifndef BT_COLLISION_WORLD_H
#define BT_COLLISION_WORLD_H

class btCollisionShape;
class btConvexShape;
class btBroadphaseInterface;
class btSerializer;

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btAlignedObjectArray.h"

///CollisionWorld is interface and container for the collision detection
class btCollisionWorld
{
protected:
	btAlignedObjectArray<btCollisionObject*> m_collisionObjects;

	btDispatcher* m_dispatcher1;

	btDispatcherInfo m_dispatchInfo;

	btBroadphaseInterface* m_broadphasePairCache;

	btIDebugDraw* m_debugDrawer;

	///m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
	///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
	bool m_forceUpdateAllAabbs;

	void serializeCollisionObjects(btSerializer* serializer);

	void serializeContactManifolds(btSerializer* serializer);

public:
	//this constructor doesn't own the dispatcher and paircache/broadphase
	btCollisionWorld(btDispatcher* dispatcher, btBroadphaseInterface* broadphasePairCache, btCollisionConfiguration* collisionConfiguration);

	virtual ~btCollisionWorld();

	void setBroadphase(btBroadphaseInterface* pairCache)
	{
		m_broadphasePairCache = pairCache;
	}

	const btBroadphaseInterface* getBroadphase() const
	{
		return m_broadphasePairCache;
	}

	btBroadphaseInterface* getBroadphase()
	{
		return m_broadphasePairCache;
	}

	btOverlappingPairCache* getPairCache()
	{
		return m_broadphasePairCache->getOverlappingPairCache();
	}

	btDispatcher* getDispatcher()
	{
		return m_dispatcher1;
	}

	const btDispatcher* getDispatcher() const
	{
		return m_dispatcher1;
	}

	void updateSingleAabb(btCollisionObject* colObj);

	virtual void updateAabbs();

	///the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
	///it can be useful to use if you perform ray tests without collision detection/simulation
	virtual void computeOverlappingPairs();

	virtual void setDebugDrawer(btIDebugDraw* debugDrawer)
	{
		m_debugDrawer = debugDrawer;
	}

	virtual btIDebugDraw* getDebugDrawer()
	{
		return m_debugDrawer;
	}

	virtual void debugDrawWorld();

	virtual void debugDrawObject(const btTransform& worldTransform, const btCollisionShape* shape, const btVector3& color);

	///LocalShapeInfo gives extra information for complex shapes
	///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
	struct LocalShapeInfo
	{
		int m_shapePart;
		int m_triangleIndex;

		//const btCollisionShape*	m_shapeTemp;
		//const btTransform*	m_shapeLocalTransform;
	};

	struct LocalRayResult
	{
		LocalRayResult(const btCollisionObject* collisionObject,
					   LocalShapeInfo* localShapeInfo,
					   const btVector3& hitNormalLocal,
					   btScalar hitFraction)
			: m_collisionObject(collisionObject),
			  m_localShapeInfo(localShapeInfo),
			  m_hitNormalLocal(hitNormalLocal),
			  m_hitFraction(hitFraction)
		{
		}

		const btCollisionObject* m_collisionObject;
		LocalShapeInfo* m_localShapeInfo;
		btVector3 m_hitNormalLocal;
		btScalar m_hitFraction;
	};

	///RayResultCallback is used to report new raycast results
	struct RayResultCallback
	{
		btScalar m_closestHitFraction;
		const btCollisionObject* m_collisionObject;
		int m_collisionFilterGroup;
		int m_collisionFilterMask;
		//@BP Mod - Custom flags, currently used to enable backface culling on tri-meshes, see btRaycastCallback.h. Apply any of the EFlags defined there on m_flags here to invoke.
		unsigned int m_flags;

		virtual ~RayResultCallback()
		{
		}
		bool hasHit() const
		{
			return (m_collisionObject != 0);
		}

		RayResultCallback()
			: m_closestHitFraction(btScalar(1.)),
			  m_collisionObject(0),
			  m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter),
			  //@BP Mod
			  m_flags(0)
		{
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace) = 0;
	};

	struct ClosestRayResultCallback : public RayResultCallback
	{
		ClosestRayResultCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld)
			: m_rayFromWorld(rayFromWorld),
			  m_rayToWorld(rayToWorld)
		{
		}

		btVector3 m_rayFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_rayToWorld;

		btVector3 m_hitNormalWorld;
		btVector3 m_hitPointWorld;

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace)
		{
			//caller already does the filter on the m_closestHitFraction
			btAssert(rayResult.m_hitFraction <= m_closestHitFraction);

			m_closestHitFraction = rayResult.m_hitFraction;
			m_collisionObject = rayResult.m_collisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = rayResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				m_hitNormalWorld = m_collisionObject->getWorldTransform().getBasis() * rayResult.m_hitNormalLocal;
			}
			m_hitPointWorld.setInterpolate3(m_rayFromWorld, m_rayToWorld, rayResult.m_hitFraction);
			return rayResult.m_hitFraction;
		}
	};

	struct AllHitsRayResultCallback : public RayResultCallback
	{
		AllHitsRayResultCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld)
			: m_rayFromWorld(rayFromWorld),
			  m_rayToWorld(rayToWorld)
		{
		}

		btAlignedObjectArray<const btCollisionObject*> m_collisionObjects;

		btVector3 m_rayFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_rayToWorld;

		btAlignedObjectArray<btVector3> m_hitNormalWorld;
		btAlignedObjectArray<btVector3> m_hitPointWorld;
		btAlignedObjectArray<btScalar> m_hitFractions;

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace)
		{
			m_collisionObject = rayResult.m_collisionObject;
			m_collisionObjects.push_back(rayResult.m_collisionObject);
			btVector3 hitNormalWorld;
			if (normalInWorldSpace)
			{
				hitNormalWorld = rayResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				hitNormalWorld = m_collisionObject->getWorldTransform().getBasis() * rayResult.m_hitNormalLocal;
			}
			m_hitNormalWorld.push_back(hitNormalWorld);
			btVector3 hitPointWorld;
			hitPointWorld.setInterpolate3(m_rayFromWorld, m_rayToWorld, rayResult.m_hitFraction);
			m_hitPointWorld.push_back(hitPointWorld);
			m_hitFractions.push_back(rayResult.m_hitFraction);
			return m_closestHitFraction;
		}
	};

	struct LocalConvexResult
	{
		LocalConvexResult(const btCollisionObject* hitCollisionObject,
						  LocalShapeInfo* localShapeInfo,
						  const btVector3& hitNormalLocal,
						  const btVector3& hitPointLocal,
						  btScalar hitFraction)
			: m_hitCollisionObject(hitCollisionObject),
			  m_localShapeInfo(localShapeInfo),
			  m_hitNormalLocal(hitNormalLocal),
			  m_hitPointLocal(hitPointLocal),
			  m_hitFraction(hitFraction)
		{
		}

		const btCollisionObject* m_hitCollisionObject;
		LocalShapeInfo* m_localShapeInfo;
		btVector3 m_hitNormalLocal;
		btVector3 m_hitPointLocal;
		btScalar m_hitFraction;
	};

	///RayResultCallback is used to report new raycast results
	struct ConvexResultCallback
	{
		btScalar m_closestHitFraction;
		int m_collisionFilterGroup;
		int m_collisionFilterMask;

		ConvexResultCallback()
			: m_closestHitFraction(btScalar(1.)),
			  m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter)
		{
		}

		virtual ~ConvexResultCallback()
		{
		}

		bool hasHit() const
		{
			return (m_closestHitFraction < btScalar(1.));
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(LocalConvexResult& convexResult, bool normalInWorldSpace) = 0;
	};

	struct ClosestConvexResultCallback : public ConvexResultCallback
	{
		ClosestConvexResultCallback(const btVector3& convexFromWorld, const btVector3& convexToWorld)
			: m_convexFromWorld(convexFromWorld),
			  m_convexToWorld(convexToWorld),
			  m_hitCollisionObject(0)
		{
		}

		btVector3 m_convexFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_convexToWorld;

		btVector3 m_hitNormalWorld;
		btVector3 m_hitPointWorld;
		const btCollisionObject* m_hitCollisionObject;

		virtual btScalar addSingleResult(LocalConvexResult& convexResult, bool normalInWorldSpace)
		{
			//caller already does the filter on the m_closestHitFraction
			btAssert(convexResult.m_hitFraction <= m_closestHitFraction);

			m_closestHitFraction = convexResult.m_hitFraction;
			m_hitCollisionObject = convexResult.m_hitCollisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = convexResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				m_hitNormalWorld = m_hitCollisionObject->getWorldTransform().getBasis() * convexResult.m_hitNormalLocal;
			}
			m_hitPointWorld = convexResult.m_hitPointLocal;
			return convexResult.m_hitFraction;
		}
	};

	///ContactResultCallback is used to report contact points
	struct ContactResultCallback
	{
		int m_collisionFilterGroup;
		int m_collisionFilterMask;
		btScalar m_closestDistanceThreshold;

		ContactResultCallback()
			: m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter),
			  m_closestDistanceThreshold(0)
		{
		}

		virtual ~ContactResultCallback()
		{
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(btManifoldPoint& cp, const btCollisionObjectWrapper* colObj0Wrap, int partId0, int index0, const btCollisionObjectWrapper* colObj1Wrap, int partId1, int index1) = 0;
	};

	int getNumCollisionObjects() const
	{
		return int(m_collisionObjects.size());
	}

	/// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
	/// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
	virtual void rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const;

	/// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
	/// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
	void convexSweepTest(const btConvexShape* castShape, const btTransform& from, const btTransform& to, ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration = btScalar(0.)) const;

	///contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
	///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
	void contactTest(btCollisionObject* colObj, ContactResultCallback& resultCallback);

	///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
	///it reports one or more contact points (including the one with deepest penetration)
	void contactPairTest(btCollisionObject* colObjA, btCollisionObject* colObjB, ContactResultCallback& resultCallback);

	/// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
	/// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
	/// This allows more customization.
	static void rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
							  btCollisionObject* collisionObject,
							  const btCollisionShape* collisionShape,
							  const btTransform& colObjWorldTransform,
							  RayResultCallback& resultCallback);

	static void rayTestSingleInternal(const btTransform& rayFromTrans, const btTransform& rayToTrans,
									  const btCollisionObjectWrapper* collisionObjectWrap,
									  RayResultCallback& resultCallback);

	/// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
	static void objectQuerySingle(const btConvexShape* castShape, const btTransform& rayFromTrans, const btTransform& rayToTrans,
								  btCollisionObject* collisionObject,
								  const btCollisionShape* collisionShape,
								  const btTransform& colObjWorldTransform,
								  ConvexResultCallback& resultCallback, btScalar allowedPenetration);

	static void objectQuerySingleInternal(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
										  const btCollisionObjectWrapper* colObjWrap,
										  ConvexResultCallback& resultCallback, btScalar allowedPenetration);

	virtual void addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup = btBroadphaseProxy::DefaultFilter, int collisionFilterMask = btBroadphaseProxy::AllFilter);

	virtual void refreshBroadphaseProxy(btCollisionObject* collisionObject);

	btCollisionObjectArray& getCollisionObjectArray()
	{
		return m_collisionObjects;
	}

	const btCollisionObjectArray& getCollisionObjectArray() const
	{
		return m_collisionObjects;
	}

	virtual void removeCollisionObject(btCollisionObject* collisionObject);

	virtual void performDiscreteCollisionDetection();

	btDispatcherInfo& getDispatchInfo()
	{
		return m_dispatchInfo;
	}

	const btDispatcherInfo& getDispatchInfo() const
	{
		return m_dispatchInfo;
	}

	bool getForceUpdateAllAabbs() const
	{
		return m_forceUpdateAllAabbs;
	}
	void setForceUpdateAllAabbs(bool forceUpdateAllAabbs)
	{
		m_forceUpdateAllAabbs = forceUpdateAllAabbs;
	}

	///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
	virtual void serialize(btSerializer* serializer);
};

#endif  //BT_COLLISION_WORLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONTACT_SOLVER_INFO
#define BT_CONTACT_SOLVER_INFO

#include "LinearMath/btScalar.h"

enum btSolverMode
{
	SOLVER_RANDMIZE_ORDER = 1,
	SOLVER_FRICTION_SEPARATE = 2,
	SOLVER_USE_WARMSTARTING = 4,
	SOLVER_USE_2_FRICTION_DIRECTIONS = 16,
	SOLVER_ENABLE_FRICTION_DIRECTION_CACHING = 32,
	SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64,
	SOLVER_CACHE_FRIENDLY = 128,
	SOLVER_SIMD = 256,
	SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
	SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024,
	SOLVER_DISABLE_IMPLICIT_CONE_FRICTION = 2048,
	SOLVER_USE_ARTICULATED_WARMSTARTING = 4096,
};

struct btContactSolverInfoData
{
	btScalar m_tau;
	btScalar m_damping;  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	btScalar m_friction;
	btScalar m_timeStep;
	btScalar m_restitution;
	int m_numIterations;
	btScalar m_maxErrorReduction;
	btScalar m_sor;          //successive over-relaxation term
	btScalar m_erp;          //error reduction for non-contact constraints
	btScalar m_erp2;         //error reduction for contact constraints
	btScalar m_deformable_erp;          //error reduction for deformable constraints
	btScalar m_deformable_cfm;          //constraint force mixing for deformable constraints
	btScalar m_deformable_maxErrorReduction; // maxErrorReduction for deformable contact
	btScalar m_globalCfm;    //constraint force mixing for contacts and non-contacts
	btScalar m_frictionERP;  //error reduction for friction constraints
	btScalar m_frictionCFM;  //constraint force mixing for friction constraints

	int m_splitImpulse;
	btScalar m_splitImpulsePenetrationThreshold;
	btScalar m_splitImpulseTurnErp;
	btScalar m_linearSlop;
	btScalar m_warmstartingFactor;
	btScalar m_articulatedWarmstartingFactor;
	int m_solverMode;
	int m_restingContactRestitutionThreshold;
	int m_minimumSolverBatchSize;
	btScalar m_maxGyroscopicForce;
	btScalar m_singleAxisRollingFrictionThreshold;
	btScalar m_leastSquaresResidualThreshold;
	btScalar m_restitutionVelocityThreshold;
	bool m_jointFeedbackInWorldSpace;
	bool m_jointFeedbackInJointFrame;
	int m_reportSolverAnalytics;
	int m_numNonContactInnerIterations;
};

struct btContactSolverInfo : public btContactSolverInfoData
{
	inline btContactSolverInfo()
	{
		m_tau = btScalar(0.6);
		m_damping = btScalar(1.0);
		m_friction = btScalar(0.3);
		m_timeStep = btScalar(1.f / 60.f);
		m_restitution = btScalar(0.);
		m_maxErrorReduction = btScalar(20.);
		m_numIterations = 10;
		m_erp = btScalar(0.2);
		m_erp2 = btScalar(0.2);
		m_deformable_erp = btScalar(0.06);
		m_deformable_cfm = btScalar(0.01);
		m_deformable_maxErrorReduction = btScalar(0.1);
		m_globalCfm = btScalar(0.);
		m_frictionERP = btScalar(0.2);  //positional friction 'anchors' are disabled by default
		m_frictionCFM = btScalar(0.);
		m_sor = btScalar(1.);
		m_splitImpulse = true;
		m_splitImpulsePenetrationThreshold = -.04f;
		m_splitImpulseTurnErp = 0.1f;
		m_linearSlop = btScalar(0.0);
		m_warmstartingFactor = btScalar(0.85);
		m_articulatedWarmstartingFactor = btScalar(0.85);
		//m_solverMode =  SOLVER_USE_WARMSTARTING |  SOLVER_SIMD | SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION|SOLVER_USE_2_FRICTION_DIRECTIONS|SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;// | SOLVER_RANDMIZE_ORDER;
		m_solverMode = SOLVER_USE_WARMSTARTING | SOLVER_SIMD;  // | SOLVER_RANDMIZE_ORDER;
		m_restingContactRestitutionThreshold = 2;              //unused as of 2.81
		m_minimumSolverBatchSize = 128;                        //try to combine islands until the amount of constraints reaches this limit
		m_maxGyroscopicForce = 100.f;                          ///it is only used for 'explicit' version of gyroscopic force
		m_singleAxisRollingFrictionThreshold = 1e30f;          ///if the velocity is above this threshold, it will use a single constraint row (axis), otherwise 3 rows.
		m_leastSquaresResidualThreshold = 0.f;
		m_restitutionVelocityThreshold = 0.2f;  //if the relative velocity is below this threshold, there is zero restitution
		m_jointFeedbackInWorldSpace = false;
		m_jointFeedbackInJointFrame = false;
		m_reportSolverAnalytics = 0;
		m_numNonContactInnerIterations = 1;   // the number of inner iterations for solving motor constraint in a single iteration of the constraint solve
	}
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btContactSolverInfoDoubleData
{
	double m_tau;
	double m_damping;  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	double m_friction;
	double m_timeStep;
	double m_restitution;
	double m_maxErrorReduction;
	double m_sor;
	double m_erp;        //used as Baumgarte factor
	double m_erp2;       //used in Split Impulse
	double m_globalCfm;  //constraint force mixing
	double m_splitImpulsePenetrationThreshold;
	double m_splitImpulseTurnErp;
	double m_linearSlop;
	double m_warmstartingFactor;
	double m_articulatedWarmstartingFactor;
	double m_maxGyroscopicForce;  ///it is only used for 'explicit' version of gyroscopic force
	double m_singleAxisRollingFrictionThreshold;

	int m_numIterations;
	int m_solverMode;
	int m_restingContactRestitutionThreshold;
	int m_minimumSolverBatchSize;
	int m_splitImpulse;
	char m_padding[4];
};
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btContactSolverInfoFloatData
{
	float m_tau;
	float m_damping;  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	float m_friction;
	float m_timeStep;

	float m_restitution;
	float m_maxErrorReduction;
	float m_sor;
	float m_erp;  //used as Baumgarte factor

	float m_erp2;       //used in Split Impulse
	float m_globalCfm;  //constraint force mixing
	float m_splitImpulsePenetrationThreshold;
	float m_splitImpulseTurnErp;

	float m_linearSlop;
	float m_warmstartingFactor;
	float m_articulatedWarmstartingFactor;
	float m_maxGyroscopicForce;

	float m_singleAxisRollingFrictionThreshold;
	int m_numIterations;
	int m_solverMode;
	int m_restingContactRestitutionThreshold;

	int m_minimumSolverBatchSize;
	int m_splitImpulse;
	
};

#endif  //BT_CONTACT_SOLVER_INFO





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_DYNAMICS_WORLD_H
#define BT_DYNAMICS_WORLD_H

#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"

class btTypedConstraint;
class btActionInterface;
class btConstraintSolver;
class btDynamicsWorld;

/// Type for the callback for each tick
typedef void (*btInternalTickCallback)(btDynamicsWorld* world, btScalar timeStep);

enum btDynamicsWorldType
{
	BT_SIMPLE_DYNAMICS_WORLD = 1,
	BT_DISCRETE_DYNAMICS_WORLD = 2,
	BT_CONTINUOUS_DYNAMICS_WORLD = 3,
	BT_SOFT_RIGID_DYNAMICS_WORLD = 4,
	BT_GPU_DYNAMICS_WORLD = 5,
	BT_SOFT_MULTIBODY_DYNAMICS_WORLD = 6,
    BT_DEFORMABLE_MULTIBODY_DYNAMICS_WORLD = 7
};

///The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
class btDynamicsWorld : public btCollisionWorld
{
protected:
	btInternalTickCallback m_internalTickCallback;
	btInternalTickCallback m_internalPreTickCallback;
	void* m_worldUserInfo;

	btContactSolverInfo m_solverInfo;

public:
	btDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* broadphase, btCollisionConfiguration* collisionConfiguration)
		: btCollisionWorld(dispatcher, broadphase, collisionConfiguration), m_internalTickCallback(0), m_internalPreTickCallback(0), m_worldUserInfo(0)
	{
	}

	virtual ~btDynamicsWorld()
	{
	}

	///stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
	///By default, Bullet will subdivide the timestep in constant substeps of each 'fixedTimeStep'.
	///in order to keep the simulation real-time, the maximum number of substeps can be clamped to 'maxSubSteps'.
	///You can disable subdividing the timestep/substepping by passing maxSubSteps=0 as second argument to stepSimulation, but in that case you have to keep the timeStep constant.
	virtual int stepSimulation(btScalar timeStep, int maxSubSteps = 1, btScalar fixedTimeStep = btScalar(1.) / btScalar(60.)) = 0;

	virtual void debugDrawWorld() = 0;

	virtual void addConstraint(btTypedConstraint* constraint, bool disableCollisionsBetweenLinkedBodies = false)
	{
		(void)constraint;
		(void)disableCollisionsBetweenLinkedBodies;
	}

	virtual void removeConstraint(btTypedConstraint* constraint) { (void)constraint; }

	virtual void addAction(btActionInterface* action) = 0;

	virtual void removeAction(btActionInterface* action) = 0;

	//once a rigidbody is added to the dynamics world, it will get this gravity assigned
	//existing rigidbodies in the world get gravity assigned too, during this method
	virtual void setGravity(const btVector3& gravity) = 0;
	virtual btVector3 getGravity() const = 0;

	virtual void synchronizeMotionStates() = 0;

	virtual void addRigidBody(btRigidBody* body) = 0;

	virtual void addRigidBody(btRigidBody* body, int group, int mask) = 0;

	virtual void removeRigidBody(btRigidBody* body) = 0;

	virtual void setConstraintSolver(btConstraintSolver* solver) = 0;

	virtual btConstraintSolver* getConstraintSolver() = 0;

	virtual int getNumConstraints() const { return 0; }

	virtual btTypedConstraint* getConstraint(int index)
	{
		(void)index;
		return 0;
	}

	virtual const btTypedConstraint* getConstraint(int index) const
	{
		(void)index;
		return 0;
	}

	virtual btDynamicsWorldType getWorldType() const = 0;

	virtual void clearForces() = 0;

	/// Set the callback for when an internal tick (simulation substep) happens, optional user info
	void setInternalTickCallback(btInternalTickCallback cb, void* worldUserInfo = 0, bool isPreTick = false)
	{
		if (isPreTick)
		{
			m_internalPreTickCallback = cb;
		}
		else
		{
			m_internalTickCallback = cb;
		}
		m_worldUserInfo = worldUserInfo;
	}

	void setWorldUserInfo(void* worldUserInfo)
	{
		m_worldUserInfo = worldUserInfo;
	}

	void* getWorldUserInfo() const
	{
		return m_worldUserInfo;
	}

	btContactSolverInfo& getSolverInfo()
	{
		return m_solverInfo;
	}

	const btContactSolverInfo& getSolverInfo() const
	{
		return m_solverInfo;
	}

	///obsolete, use addAction instead.
	virtual void addVehicle(btActionInterface* vehicle) { (void)vehicle; }
	///obsolete, use removeAction instead
	virtual void removeVehicle(btActionInterface* vehicle) { (void)vehicle; }
	///obsolete, use addAction instead.
	virtual void addCharacter(btActionInterface* character) { (void)character; }
	///obsolete, use removeAction instead
	virtual void removeCharacter(btActionInterface* character) { (void)character; }
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btDynamicsWorldDoubleData
{
	btContactSolverInfoDoubleData m_solverInfo;
	btVector3DoubleData m_gravity;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btDynamicsWorldFloatData
{
	btContactSolverInfoFloatData m_solverInfo;
	btVector3FloatData m_gravity;
};

#endif  //BT_DYNAMICS_WORLD_H





/*
Copyright (c) 2003-2014 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btThreads.h"
#include "LinearMath/btQuickprof.h"

#if BT_USE_OPENMP && BT_THREADSAFE


#endif  // #if BT_USE_OPENMP && BT_THREADSAFE

#if BT_USE_PPL && BT_THREADSAFE

// use Microsoft Parallel Patterns Library (installed with Visual Studio 2010 and later)
// Visual Studio 2010 and later should come with it

#endif  // #if BT_USE_PPL && BT_THREADSAFE

#if BT_USE_TBB && BT_THREADSAFE

// use Intel Threading Building Blocks for thread management
#define __TBB_NO_IMPLICIT_LINKAGE 1

#endif  // #if BT_USE_TBB && BT_THREADSAFE

#if BT_THREADSAFE
//
// Lightweight spin-mutex based on atomics
// Using ordinary system-provided mutexes like Windows critical sections was noticeably slower
// presumably because when it fails to lock at first it would sleep the thread and trigger costly
// context switching.
//

#if __cplusplus >= 201103L

// for anything claiming full C++11 compliance, use C++11 atomics
// on GCC or Clang you need to compile with -std=c++11
#define USE_CPP11_ATOMICS 1

#elif defined(_MSC_VER)

// on MSVC, use intrinsics instead
#define USE_MSVC_INTRINSICS 1

#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7))

// available since GCC 4.7 and some versions of clang
// todo: check for clang
#define USE_GCC_BUILTIN_ATOMICS 1

#elif defined(__GNUC__) && (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)

// available since GCC 4.1
#define USE_GCC_BUILTIN_ATOMICS_OLD 1

#endif

#if USE_CPP11_ATOMICS


#define THREAD_LOCAL_STATIC thread_local static

bool btSpinMutex::tryLock()
{
	std::atomic<int>* aDest = reinterpret_cast<std::atomic<int>*>(&mLock);
	int expected = 0;
	return std::atomic_compare_exchange_weak_explicit(aDest, &expected, int(1), std::memory_order_acq_rel, std::memory_order_acquire);
}

void btSpinMutex::lock()
{
	// note: this lock does not sleep the thread.
	while (!tryLock())
	{
		// spin
	}
}

void btSpinMutex::unlock()
{
	std::atomic<int>* aDest = reinterpret_cast<std::atomic<int>*>(&mLock);
	std::atomic_store_explicit(aDest, int(0), std::memory_order_release);
}

#elif USE_MSVC_INTRINSICS

#define WIN32_LEAN_AND_MEAN


#define THREAD_LOCAL_STATIC __declspec(thread) static

bool btSpinMutex::tryLock()
{
	volatile long* aDest = reinterpret_cast<long*>(&mLock);
	return (0 == _InterlockedCompareExchange(aDest, 1, 0));
}

void btSpinMutex::lock()
{
	// note: this lock does not sleep the thread
	while (!tryLock())
	{
		// spin
	}
}

void btSpinMutex::unlock()
{
	volatile long* aDest = reinterpret_cast<long*>(&mLock);
	_InterlockedExchange(aDest, 0);
}

#elif USE_GCC_BUILTIN_ATOMICS

#define THREAD_LOCAL_STATIC static __thread

bool btSpinMutex::tryLock()
{
	int expected = 0;
	bool weak = false;
	const int memOrderSuccess = __ATOMIC_ACQ_REL;
	const int memOrderFail = __ATOMIC_ACQUIRE;
	return __atomic_compare_exchange_n(&mLock, &expected, int(1), weak, memOrderSuccess, memOrderFail);
}

void btSpinMutex::lock()
{
	// note: this lock does not sleep the thread
	while (!tryLock())
	{
		// spin
	}
}

void btSpinMutex::unlock()
{
	__atomic_store_n(&mLock, int(0), __ATOMIC_RELEASE);
}

#elif USE_GCC_BUILTIN_ATOMICS_OLD

#define THREAD_LOCAL_STATIC static __thread

bool btSpinMutex::tryLock()
{
	return __sync_bool_compare_and_swap(&mLock, int(0), int(1));
}

void btSpinMutex::lock()
{
	// note: this lock does not sleep the thread
	while (!tryLock())
	{
		// spin
	}
}

void btSpinMutex::unlock()
{
	// write 0
	__sync_fetch_and_and(&mLock, int(0));
}

#else  //#elif USE_MSVC_INTRINSICS

#error "no threading primitives defined -- unknown platform"

#endif  //#else //#elif USE_MSVC_INTRINSICS

#else  //#if BT_THREADSAFE

// These should not be called ever
void btSpinMutex::lock()
{
	btAssert(!"unimplemented btSpinMutex::lock() called");
}

void btSpinMutex::unlock()
{
	btAssert(!"unimplemented btSpinMutex::unlock() called");
}

bool btSpinMutex::tryLock()
{
	btAssert(!"unimplemented btSpinMutex::tryLock() called");
	return true;
}

#define THREAD_LOCAL_STATIC static

#endif  // #else //#if BT_THREADSAFE

struct ThreadsafeCounter
{
	unsigned int mCounter;
	btSpinMutex mMutex;

	ThreadsafeCounter()
	{
		mCounter = 0;
		--mCounter;  // first count should come back 0
	}

	unsigned int getNext()
	{
		// no need to optimize this with atomics, it is only called ONCE per thread!
		mMutex.lock();
		mCounter++;
		if (mCounter >= BT_MAX_THREAD_COUNT)
		{
			btAssert(!"thread counter exceeded");
			// wrap back to the first worker index
			mCounter = 1;
		}
		unsigned int val = mCounter;
		mMutex.unlock();
		return val;
	}
};

static btITaskScheduler* gBtTaskScheduler=0;
static int gThreadsRunningCounter = 0;  // useful for detecting if we are trying to do nested parallel-for calls
static btSpinMutex gThreadsRunningCounterMutex;
static ThreadsafeCounter gThreadCounter;

//
// BT_DETECT_BAD_THREAD_INDEX tries to detect when there are multiple threads assigned the same thread index.
//
// BT_DETECT_BAD_THREAD_INDEX is a developer option to test if
// certain assumptions about how the task scheduler manages its threads
// holds true.
// The main assumption is:
//   - when the threadpool is resized, the task scheduler either
//      1. destroys all worker threads and creates all new ones in the correct number, OR
//      2. never destroys a worker thread
//
// We make that assumption because we can't easily enumerate the worker threads of a task scheduler
// to assign nice sequential thread-indexes. We also do not get notified if a worker thread is destroyed,
// so we can't tell when a thread-index is no longer being used.
// We allocate thread-indexes as needed with a sequential global thread counter.
//
// Our simple thread-counting scheme falls apart if the task scheduler destroys some threads but
// continues to re-use other threads and the application repeatedly resizes the thread pool of the
// task scheduler.
// In order to prevent the thread-counter from exceeding the global max (BT_MAX_THREAD_COUNT), we
// wrap the thread counter back to 1. This should only happen if the worker threads have all been
// destroyed and re-created.
//
// BT_DETECT_BAD_THREAD_INDEX only works for Win32 right now,
// but could be adapted to work with pthreads
#define BT_DETECT_BAD_THREAD_INDEX 0

#if BT_DETECT_BAD_THREAD_INDEX

typedef DWORD ThreadId_t;
const static ThreadId_t kInvalidThreadId = 0;
ThreadId_t gDebugThreadIds[BT_MAX_THREAD_COUNT];

static ThreadId_t getDebugThreadId()
{
	return GetCurrentThreadId();
}

#endif  // #if BT_DETECT_BAD_THREAD_INDEX

// return a unique index per thread, main thread is 0, worker threads are in [1, BT_MAX_THREAD_COUNT)
unsigned int btGetCurrentThreadIndex()
{
	const unsigned int kNullIndex = ~0U;
	THREAD_LOCAL_STATIC unsigned int sThreadIndex = kNullIndex;
	if (sThreadIndex == kNullIndex)
	{
		sThreadIndex = gThreadCounter.getNext();
		btAssert(sThreadIndex < BT_MAX_THREAD_COUNT);
	}
#if BT_DETECT_BAD_THREAD_INDEX
	if (gBtTaskScheduler && sThreadIndex > 0)
	{
		ThreadId_t tid = getDebugThreadId();
		// if not set
		if (gDebugThreadIds[sThreadIndex] == kInvalidThreadId)
		{
			// set it
			gDebugThreadIds[sThreadIndex] = tid;
		}
		else
		{
			if (gDebugThreadIds[sThreadIndex] != tid)
			{
				// this could indicate the task scheduler is breaking our assumptions about
				// how threads are managed when threadpool is resized
				btAssert(!"there are 2 or more threads with the same thread-index!");
				__debugbreak();
			}
		}
	}
#endif  // #if BT_DETECT_BAD_THREAD_INDEX
	return sThreadIndex;
}

bool btIsMainThread()
{
	return btGetCurrentThreadIndex() == 0;
}

void btResetThreadIndexCounter()
{
	// for when all current worker threads are destroyed
	btAssert(btIsMainThread());
	gThreadCounter.mCounter = 0;
}

btITaskScheduler::btITaskScheduler(const char* name)
{
	m_name = name;
	m_savedThreadCounter = 0;
	m_isActive = false;
}

void btITaskScheduler::activate()
{
	// gThreadCounter is used to assign a thread-index to each worker thread in a task scheduler.
	// The main thread is always thread-index 0, and worker threads are numbered from 1 to 63 (BT_MAX_THREAD_COUNT-1)
	// The thread-indexes need to be unique amongst the threads that can be running simultaneously.
	// Since only one task scheduler can be used at a time, it is OK for a pair of threads that belong to different
	// task schedulers to share the same thread index because they can't be running at the same time.
	// So each task scheduler needs to keep its own thread counter value
	if (!m_isActive)
	{
		gThreadCounter.mCounter = m_savedThreadCounter;  // restore saved thread counter
		m_isActive = true;
	}
}

void btITaskScheduler::deactivate()
{
	if (m_isActive)
	{
		m_savedThreadCounter = gThreadCounter.mCounter;  // save thread counter
		m_isActive = false;
	}
}

void btPushThreadsAreRunning()
{
	gThreadsRunningCounterMutex.lock();
	gThreadsRunningCounter++;
	gThreadsRunningCounterMutex.unlock();
}

void btPopThreadsAreRunning()
{
	gThreadsRunningCounterMutex.lock();
	gThreadsRunningCounter--;
	gThreadsRunningCounterMutex.unlock();
}

bool btThreadsAreRunning()
{
	return gThreadsRunningCounter != 0;
}

void btSetTaskScheduler(btITaskScheduler* ts)
{
	int threadId = btGetCurrentThreadIndex();  // make sure we call this on main thread at least once before any workers run
	if (threadId != 0)
	{
		btAssert(!"btSetTaskScheduler must be called from the main thread!");
		return;
	}
	if (gBtTaskScheduler)
	{
		// deactivate old task scheduler
		gBtTaskScheduler->deactivate();
	}
	gBtTaskScheduler = ts;
	if (ts)
	{
		// activate new task scheduler
		ts->activate();
	}
}

btITaskScheduler* btGetTaskScheduler()
{
	return gBtTaskScheduler;
}

void btParallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body)
{
#if BT_THREADSAFE

#if BT_DETECT_BAD_THREAD_INDEX
	if (!btThreadsAreRunning())
	{
		// clear out thread ids
		for (int i = 0; i < BT_MAX_THREAD_COUNT; ++i)
		{
			gDebugThreadIds[i] = kInvalidThreadId;
		}
	}
#endif  // #if BT_DETECT_BAD_THREAD_INDEX

	btAssert(gBtTaskScheduler != NULL);  // call btSetTaskScheduler() with a valid task scheduler first!
	gBtTaskScheduler->parallelFor(iBegin, iEnd, grainSize, body);

#else  // #if BT_THREADSAFE

	// non-parallel version of btParallelFor
	btAssert(!"called btParallelFor in non-threadsafe build. enable BT_THREADSAFE");
	body.forLoop(iBegin, iEnd);

#endif  // #if BT_THREADSAFE
}

btScalar btParallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body)
{
#if BT_THREADSAFE

#if BT_DETECT_BAD_THREAD_INDEX
	if (!btThreadsAreRunning())
	{
		// clear out thread ids
		for (int i = 0; i < BT_MAX_THREAD_COUNT; ++i)
		{
			gDebugThreadIds[i] = kInvalidThreadId;
		}
	}
#endif  // #if BT_DETECT_BAD_THREAD_INDEX

	btAssert(gBtTaskScheduler != NULL);  // call btSetTaskScheduler() with a valid task scheduler first!
	return gBtTaskScheduler->parallelSum(iBegin, iEnd, grainSize, body);

#else  // #if BT_THREADSAFE

	// non-parallel version of btParallelSum
	btAssert(!"called btParallelFor in non-threadsafe build. enable BT_THREADSAFE");
	return body.sumLoop(iBegin, iEnd);

#endif  //#else // #if BT_THREADSAFE
}

///
/// btTaskSchedulerSequential -- non-threaded implementation of task scheduler
///                              (really just useful for testing performance of single threaded vs multi)
///
class btTaskSchedulerSequential : public btITaskScheduler
{
public:
	btTaskSchedulerSequential() : btITaskScheduler("Sequential") {}
	virtual int getMaxNumThreads() const BT_OVERRIDE { return 1; }
	virtual int getNumThreads() const BT_OVERRIDE { return 1; }
	virtual void setNumThreads(int numThreads) BT_OVERRIDE {}
	virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelFor_sequential");
		body.forLoop(iBegin, iEnd);
	}
	virtual btScalar parallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelSum_sequential");
		return body.sumLoop(iBegin, iEnd);
	}
};

#if BT_USE_OPENMP && BT_THREADSAFE
///
/// btTaskSchedulerOpenMP -- wrapper around OpenMP task scheduler
///
class btTaskSchedulerOpenMP : public btITaskScheduler
{
	int m_numThreads;

public:
	btTaskSchedulerOpenMP() : btITaskScheduler("OpenMP")
	{
		m_numThreads = 0;
	}
	virtual int getMaxNumThreads() const BT_OVERRIDE
	{
		return omp_get_max_threads();
	}
	virtual int getNumThreads() const BT_OVERRIDE
	{
		return m_numThreads;
	}
	virtual void setNumThreads(int numThreads) BT_OVERRIDE
	{
		// With OpenMP, because it is a standard with various implementations, we can't
		// know for sure if every implementation has the same behavior of destroying all
		// previous threads when resizing the threadpool
		m_numThreads = (std::max)(1, (std::min)(int(BT_MAX_THREAD_COUNT), numThreads));
		omp_set_num_threads(1);  // hopefully, all previous threads get destroyed here
		omp_set_num_threads(m_numThreads);
		m_savedThreadCounter = 0;
		if (m_isActive)
		{
			btResetThreadIndexCounter();
		}
	}
	virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelFor_OpenMP");
		btPushThreadsAreRunning();
#pragma omp parallel for schedule(static, 1)
		for (int i = iBegin; i < iEnd; i += grainSize)
		{
			BT_PROFILE("OpenMP_forJob");
			body.forLoop(i, (std::min)(i + grainSize, iEnd));
		}
		btPopThreadsAreRunning();
	}
	virtual btScalar parallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelFor_OpenMP");
		btPushThreadsAreRunning();
		btScalar sum = btScalar(0);
#pragma omp parallel for schedule(static, 1) reduction(+ \
													   : sum)
		for (int i = iBegin; i < iEnd; i += grainSize)
		{
			BT_PROFILE("OpenMP_sumJob");
			sum += body.sumLoop(i, (std::min)(i + grainSize, iEnd));
		}
		btPopThreadsAreRunning();
		return sum;
	}
};
#endif  // #if BT_USE_OPENMP && BT_THREADSAFE

#if BT_USE_TBB && BT_THREADSAFE
///
/// btTaskSchedulerTBB -- wrapper around Intel Threaded Building Blocks task scheduler
///
class btTaskSchedulerTBB : public btITaskScheduler
{
	int m_numThreads;
	tbb::task_scheduler_init* m_tbbSchedulerInit;

public:
	btTaskSchedulerTBB() : btITaskScheduler("IntelTBB")
	{
		m_numThreads = 0;
		m_tbbSchedulerInit = NULL;
	}
	~btTaskSchedulerTBB()
	{
		if (m_tbbSchedulerInit)
		{
			delete m_tbbSchedulerInit;
			m_tbbSchedulerInit = NULL;
		}
	}

	virtual int getMaxNumThreads() const BT_OVERRIDE
	{
		return tbb::task_scheduler_init::default_num_threads();
	}
	virtual int getNumThreads() const BT_OVERRIDE
	{
		return m_numThreads;
	}
	virtual void setNumThreads(int numThreads) BT_OVERRIDE
	{
		m_numThreads = (std::max)(1, (std::min)(int(BT_MAX_THREAD_COUNT), numThreads));
		if (m_tbbSchedulerInit)
		{
			// destroys all previous threads
			delete m_tbbSchedulerInit;
			m_tbbSchedulerInit = NULL;
		}
		m_tbbSchedulerInit = new tbb::task_scheduler_init(m_numThreads);
		m_savedThreadCounter = 0;
		if (m_isActive)
		{
			btResetThreadIndexCounter();
		}
	}
	struct ForBodyAdapter
	{
		const btIParallelForBody* mBody;

		ForBodyAdapter(const btIParallelForBody* body) : mBody(body) {}
		void operator()(const tbb::blocked_range<int>& range) const
		{
			BT_PROFILE("TBB_forJob");
			mBody->forLoop(range.begin(), range.end());
		}
	};
	virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelFor_TBB");
		ForBodyAdapter tbbBody(&body);
		btPushThreadsAreRunning();
		tbb::parallel_for(tbb::blocked_range<int>(iBegin, iEnd, grainSize),
						  tbbBody,
						  tbb::simple_partitioner());
		btPopThreadsAreRunning();
	}
	struct SumBodyAdapter
	{
		const btIParallelSumBody* mBody;
		btScalar mSum;

		SumBodyAdapter(const btIParallelSumBody* body) : mBody(body), mSum(btScalar(0)) {}
		SumBodyAdapter(const SumBodyAdapter& src, tbb::split) : mBody(src.mBody), mSum(btScalar(0)) {}
		void join(const SumBodyAdapter& src) { mSum += src.mSum; }
		void operator()(const tbb::blocked_range<int>& range)
		{
			BT_PROFILE("TBB_sumJob");
			mSum += mBody->sumLoop(range.begin(), range.end());
		}
	};
	virtual btScalar parallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelSum_TBB");
		SumBodyAdapter tbbBody(&body);
		btPushThreadsAreRunning();
		tbb::parallel_deterministic_reduce(tbb::blocked_range<int>(iBegin, iEnd, grainSize), tbbBody);
		btPopThreadsAreRunning();
		return tbbBody.mSum;
	}
};
#endif  // #if BT_USE_TBB && BT_THREADSAFE

#if BT_USE_PPL && BT_THREADSAFE
///
/// btTaskSchedulerPPL -- wrapper around Microsoft Parallel Patterns Lib task scheduler
///
class btTaskSchedulerPPL : public btITaskScheduler
{
	int m_numThreads;
	concurrency::combinable<btScalar> m_sum;  // for parallelSum
public:
	btTaskSchedulerPPL() : btITaskScheduler("PPL")
	{
		m_numThreads = 0;
	}
	virtual int getMaxNumThreads() const BT_OVERRIDE
	{
		return concurrency::GetProcessorCount();
	}
	virtual int getNumThreads() const BT_OVERRIDE
	{
		return m_numThreads;
	}
	virtual void setNumThreads(int numThreads) BT_OVERRIDE
	{
		// capping the thread count for PPL due to a thread-index issue
		const int maxThreadCount = (std::min)(int(BT_MAX_THREAD_COUNT), 31);
		m_numThreads = (std::max)(1, (std::min)(maxThreadCount, numThreads));
		using namespace concurrency;
		if (CurrentScheduler::Id() != -1)
		{
			CurrentScheduler::Detach();
		}
		SchedulerPolicy policy;
		{
			// PPL seems to destroy threads when threadpool is shrunk, but keeps reusing old threads
			// force it to destroy old threads
			policy.SetConcurrencyLimits(1, 1);
			CurrentScheduler::Create(policy);
			CurrentScheduler::Detach();
		}
		policy.SetConcurrencyLimits(m_numThreads, m_numThreads);
		CurrentScheduler::Create(policy);
		m_savedThreadCounter = 0;
		if (m_isActive)
		{
			btResetThreadIndexCounter();
		}
	}
	struct ForBodyAdapter
	{
		const btIParallelForBody* mBody;
		int mGrainSize;
		int mIndexEnd;

		ForBodyAdapter(const btIParallelForBody* body, int grainSize, int end) : mBody(body), mGrainSize(grainSize), mIndexEnd(end) {}
		void operator()(int i) const
		{
			BT_PROFILE("PPL_forJob");
			mBody->forLoop(i, (std::min)(i + mGrainSize, mIndexEnd));
		}
	};
	virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelFor_PPL");
		// PPL dispatch
		ForBodyAdapter pplBody(&body, grainSize, iEnd);
		btPushThreadsAreRunning();
		// note: MSVC 2010 doesn't support partitioner args, so avoid them
		concurrency::parallel_for(iBegin,
								  iEnd,
								  grainSize,
								  pplBody);
		btPopThreadsAreRunning();
	}
	struct SumBodyAdapter
	{
		const btIParallelSumBody* mBody;
		concurrency::combinable<btScalar>* mSum;
		int mGrainSize;
		int mIndexEnd;

		SumBodyAdapter(const btIParallelSumBody* body, concurrency::combinable<btScalar>* sum, int grainSize, int end) : mBody(body), mSum(sum), mGrainSize(grainSize), mIndexEnd(end) {}
		void operator()(int i) const
		{
			BT_PROFILE("PPL_sumJob");
			mSum->local() += mBody->sumLoop(i, (std::min)(i + mGrainSize, mIndexEnd));
		}
	};
	static btScalar sumFunc(btScalar a, btScalar b) { return a + b; }
	virtual btScalar parallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body) BT_OVERRIDE
	{
		BT_PROFILE("parallelSum_PPL");
		m_sum.clear();
		SumBodyAdapter pplBody(&body, &m_sum, grainSize, iEnd);
		btPushThreadsAreRunning();
		// note: MSVC 2010 doesn't support partitioner args, so avoid them
		concurrency::parallel_for(iBegin,
								  iEnd,
								  grainSize,
								  pplBody);
		btPopThreadsAreRunning();
		return m_sum.combine(sumFunc);
	}
};
#endif  // #if BT_USE_PPL && BT_THREADSAFE

// create a non-threaded task scheduler (always available)
btITaskScheduler* btGetSequentialTaskScheduler()
{
	static btTaskSchedulerSequential sTaskScheduler;
	return &sTaskScheduler;
}

// create an OpenMP task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetOpenMPTaskScheduler()
{
#if BT_USE_OPENMP && BT_THREADSAFE
	static btTaskSchedulerOpenMP sTaskScheduler;
	return &sTaskScheduler;
#else
	return NULL;
#endif
}

// create an Intel TBB task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetTBBTaskScheduler()
{
#if BT_USE_TBB && BT_THREADSAFE
	static btTaskSchedulerTBB sTaskScheduler;
	return &sTaskScheduler;
#else
	return NULL;
#endif
}

// create a PPL task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetPPLTaskScheduler()
{
#if BT_USE_PPL && BT_THREADSAFE
	static btTaskSchedulerPPL sTaskScheduler;
	return &sTaskScheduler;
#else
	return NULL;
#endif
}





/*
Copyright (c) 2003-2014 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_THREADS_H
#define BT_THREADS_H

#include "LinearMath/btScalar.h"

#if defined(_MSC_VER) && _MSC_VER >= 1600
// give us a compile error if any signatures of overriden methods is changed
#define BT_OVERRIDE override
#endif

#ifndef BT_OVERRIDE
#define BT_OVERRIDE
#endif

// Don't set this to larger than 64, without modifying btThreadSupportPosix
// and btThreadSupportWin32. They use UINT64 bit-masks.
const unsigned int BT_MAX_THREAD_COUNT = 64;  // only if BT_THREADSAFE is 1

// for internal use only
bool btIsMainThread();
bool btThreadsAreRunning();
unsigned int btGetCurrentThreadIndex();
void btResetThreadIndexCounter();  // notify that all worker threads have been destroyed

///
/// btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
///               a thread to sleep because it is designed to be used with a task scheduler
///               which has one thread per core and the threads don't sleep until they
///               run out of tasks. Not good for general purpose use.
///
class btSpinMutex
{
	int mLock;

public:
	btSpinMutex()
	{
		mLock = 0;
	}
	void lock();
	void unlock();
	bool tryLock();
};

//
// NOTE: btMutex* is for internal Bullet use only
//
// If BT_THREADSAFE is undefined or 0, should optimize away to nothing.
// This is good because for the single-threaded build of Bullet, any calls
// to these functions will be optimized out.
//
// However, for users of the multi-threaded build of Bullet this is kind
// of bad because if you call any of these functions from external code
// (where BT_THREADSAFE is undefined) you will get unexpected race conditions.
//
SIMD_FORCE_INLINE void btMutexLock(btSpinMutex* mutex)
{
#if BT_THREADSAFE
	mutex->lock();
#else
	(void)mutex;
#endif  // #if BT_THREADSAFE
}

SIMD_FORCE_INLINE void btMutexUnlock(btSpinMutex* mutex)
{
#if BT_THREADSAFE
	mutex->unlock();
#else
	(void)mutex;
#endif  // #if BT_THREADSAFE
}

SIMD_FORCE_INLINE bool btMutexTryLock(btSpinMutex* mutex)
{
#if BT_THREADSAFE
	return mutex->tryLock();
#else
	(void)mutex;
	return true;
#endif  // #if BT_THREADSAFE
}

//
// btIParallelForBody -- subclass this to express work that can be done in parallel
//
class btIParallelForBody
{
public:
	virtual ~btIParallelForBody() {}
	virtual void forLoop(int iBegin, int iEnd) const = 0;
};

//
// btIParallelSumBody -- subclass this to express work that can be done in parallel
//                       and produces a sum over all loop elements
//
class btIParallelSumBody
{
public:
	virtual ~btIParallelSumBody() {}
	virtual btScalar sumLoop(int iBegin, int iEnd) const = 0;
};

//
// btITaskScheduler -- subclass this to implement a task scheduler that can dispatch work to
//                     worker threads
//
class btITaskScheduler
{
public:
	btITaskScheduler(const char* name);
	virtual ~btITaskScheduler() {}
	const char* getName() const { return m_name; }

	virtual int getMaxNumThreads() const = 0;
	virtual int getNumThreads() const = 0;
	virtual void setNumThreads(int numThreads) = 0;
	virtual void parallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body) = 0;
	virtual btScalar parallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body) = 0;
	virtual void sleepWorkerThreadsHint() {}  // hint the task scheduler that we may not be using these threads for a little while

	// internal use only
	virtual void activate();
	virtual void deactivate();

protected:
	const char* m_name;
	unsigned int m_savedThreadCounter;
	bool m_isActive;
};

// set the task scheduler to use for all calls to btParallelFor()
// NOTE: you must set this prior to using any of the multi-threaded "Mt" classes
void btSetTaskScheduler(btITaskScheduler* ts);

// get the current task scheduler
btITaskScheduler* btGetTaskScheduler();

// get non-threaded task scheduler (always available)
btITaskScheduler* btGetSequentialTaskScheduler();

// create a default task scheduler (Win32 or pthreads based)
btITaskScheduler* btCreateDefaultTaskScheduler();

// get OpenMP task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetOpenMPTaskScheduler();

// get Intel TBB task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetTBBTaskScheduler();

// get PPL task scheduler (if available, otherwise returns null)
btITaskScheduler* btGetPPLTaskScheduler();

// btParallelFor -- call this to dispatch work like a for-loop
//                 (iterations may be done out of order, so no dependencies are allowed)
void btParallelFor(int iBegin, int iEnd, int grainSize, const btIParallelForBody& body);

// btParallelSum -- call this to dispatch work like a for-loop, returns the sum of all iterations
//                 (iterations may be done out of order, so no dependencies are allowed)
btScalar btParallelSum(int iBegin, int iEnd, int grainSize, const btIParallelSumBody& body);

#endif





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h"

//collision detection
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btQuickprof.h"

//rigidbody & constraints
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
#include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h"
#include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"

#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletDynamics/Dynamics/btActionInterface.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btMotionState.h"

#include "LinearMath/btSerializer.h"

#if 0
btAlignedObjectArray<btVector3> debugContacts;
btAlignedObjectArray<btVector3> debugNormals;
int startHit=2;
int firstHit=startHit;
#endif

SIMD_FORCE_INLINE int btGetConstraintIslandId(const btTypedConstraint* lhs)
{
	int islandId;

	const btCollisionObject& rcolObj0 = lhs->getRigidBodyA();
	const btCollisionObject& rcolObj1 = lhs->getRigidBodyB();
	islandId = rcolObj0.getIslandTag() >= 0 ? rcolObj0.getIslandTag() : rcolObj1.getIslandTag();
	return islandId;
}

class btSortConstraintOnIslandPredicate
{
public:
	bool operator()(const btTypedConstraint* lhs, const btTypedConstraint* rhs) const
	{
		int rIslandId0, lIslandId0;
		rIslandId0 = btGetConstraintIslandId(rhs);
		lIslandId0 = btGetConstraintIslandId(lhs);
		return lIslandId0 < rIslandId0;
	}
};

struct InplaceSolverIslandCallback : public btSimulationIslandManager::IslandCallback
{
	btContactSolverInfo* m_solverInfo;
	btConstraintSolver* m_solver;
	btTypedConstraint** m_sortedConstraints;
	int m_numConstraints;
	btIDebugDraw* m_debugDrawer;
	btDispatcher* m_dispatcher;

	btAlignedObjectArray<btCollisionObject*> m_bodies;
	btAlignedObjectArray<btPersistentManifold*> m_manifolds;
	btAlignedObjectArray<btTypedConstraint*> m_constraints;

	InplaceSolverIslandCallback(
		btConstraintSolver* solver,
		btStackAlloc* stackAlloc,
		btDispatcher* dispatcher)
		: m_solverInfo(NULL),
		  m_solver(solver),
		  m_sortedConstraints(NULL),
		  m_numConstraints(0),
		  m_debugDrawer(NULL),
		  m_dispatcher(dispatcher)
	{
	}

	InplaceSolverIslandCallback& operator=(InplaceSolverIslandCallback& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

	SIMD_FORCE_INLINE void setup(btContactSolverInfo* solverInfo, btTypedConstraint** sortedConstraints, int numConstraints, btIDebugDraw* debugDrawer)
	{
		btAssert(solverInfo);
		m_solverInfo = solverInfo;
		m_sortedConstraints = sortedConstraints;
		m_numConstraints = numConstraints;
		m_debugDrawer = debugDrawer;
		m_bodies.resize(0);
		m_manifolds.resize(0);
		m_constraints.resize(0);
	}

	virtual void processIsland(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifolds, int numManifolds, int islandId)
	{
		if (islandId < 0)
		{
			///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
			m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, &m_sortedConstraints[0], m_numConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
		}
		else
		{
			//also add all non-contact constraints/joints for this island
			btTypedConstraint** startConstraint = 0;
			int numCurConstraints = 0;
			int i;

			//find the first constraint for this island
			for (i = 0; i < m_numConstraints; i++)
			{
				if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
				{
					startConstraint = &m_sortedConstraints[i];
					break;
				}
			}
			//count the number of constraints in this island
			for (; i < m_numConstraints; i++)
			{
				if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
				{
					numCurConstraints++;
				}
			}

			if (m_solverInfo->m_minimumSolverBatchSize <= 1)
			{
				m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, startConstraint, numCurConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
			}
			else
			{
				for (i = 0; i < numBodies; i++)
					m_bodies.push_back(bodies[i]);
				for (i = 0; i < numManifolds; i++)
					m_manifolds.push_back(manifolds[i]);
				for (i = 0; i < numCurConstraints; i++)
					m_constraints.push_back(startConstraint[i]);
				if ((m_constraints.size() + m_manifolds.size()) > m_solverInfo->m_minimumSolverBatchSize)
				{
					processConstraints();
				}
				else
				{
					//printf("deferred\n");
				}
			}
		}
	}
	void processConstraints()
	{
		btCollisionObject** bodies = m_bodies.size() ? &m_bodies[0] : 0;
		btPersistentManifold** manifold = m_manifolds.size() ? &m_manifolds[0] : 0;
		btTypedConstraint** constraints = m_constraints.size() ? &m_constraints[0] : 0;

		m_solver->solveGroup(bodies, m_bodies.size(), manifold, m_manifolds.size(), constraints, m_constraints.size(), *m_solverInfo, m_debugDrawer, m_dispatcher);
		m_bodies.resize(0);
		m_manifolds.resize(0);
		m_constraints.resize(0);
	}
};

btDiscreteDynamicsWorld::btDiscreteDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration)
	: btDynamicsWorld(dispatcher, pairCache, collisionConfiguration),
	  m_sortedConstraints(),
	  m_solverIslandCallback(NULL),
	  m_constraintSolver(constraintSolver),
	  m_gravity(0, -10, 0),
	  m_localTime(0),
	  m_fixedTimeStep(0),
	  m_synchronizeAllMotionStates(false),
	  m_applySpeculativeContactRestitution(false),
	  m_profileTimings(0),
	  m_latencyMotionStateInterpolation(true)

{
	if (!m_constraintSolver)
	{
		void* mem = btAlignedAlloc(sizeof(btSequentialImpulseConstraintSolver), 16);
		m_constraintSolver = new (mem) btSequentialImpulseConstraintSolver;
		m_ownsConstraintSolver = true;
	}
	else
	{
		m_ownsConstraintSolver = false;
	}

	{
		void* mem = btAlignedAlloc(sizeof(btSimulationIslandManager), 16);
		m_islandManager = new (mem) btSimulationIslandManager();
	}

	m_ownsIslandManager = true;

	{
		void* mem = btAlignedAlloc(sizeof(InplaceSolverIslandCallback), 16);
		m_solverIslandCallback = new (mem) InplaceSolverIslandCallback(m_constraintSolver, 0, dispatcher);
	}
}

btDiscreteDynamicsWorld::~btDiscreteDynamicsWorld()
{
	//only delete it when we created it
	if (m_ownsIslandManager)
	{
		m_islandManager->~btSimulationIslandManager();
		btAlignedFree(m_islandManager);
	}
	if (m_solverIslandCallback)
	{
		m_solverIslandCallback->~InplaceSolverIslandCallback();
		btAlignedFree(m_solverIslandCallback);
	}
	if (m_ownsConstraintSolver)
	{
		m_constraintSolver->~btConstraintSolver();
		btAlignedFree(m_constraintSolver);
	}
}

void btDiscreteDynamicsWorld::saveKinematicState(btScalar timeStep)
{
	///would like to iterate over m_nonStaticRigidBodies, but unfortunately old API allows
	///to switch status _after_ adding kinematic objects to the world
	///fix it for Bullet 3.x release
	for (int i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btRigidBody* body = btRigidBody::upcast(colObj);
		if (body && body->getActivationState() != ISLAND_SLEEPING)
		{
			if (body->isKinematicObject())
			{
				//to calculate velocities next frame
				body->saveKinematicState(timeStep);
			}
		}
	}
}

void btDiscreteDynamicsWorld::debugDrawWorld()
{
	BT_PROFILE("debugDrawWorld");

	btCollisionWorld::debugDrawWorld();

	bool drawConstraints = false;
	if (getDebugDrawer())
	{
		int mode = getDebugDrawer()->getDebugMode();
		if (mode & (btIDebugDraw::DBG_DrawConstraints | btIDebugDraw::DBG_DrawConstraintLimits))
		{
			drawConstraints = true;
		}
	}
	if (drawConstraints)
	{
		for (int i = getNumConstraints() - 1; i >= 0; i--)
		{
			btTypedConstraint* constraint = getConstraint(i);
			debugDrawConstraint(constraint);
		}
	}

	if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb | btIDebugDraw::DBG_DrawNormals)))
	{
		int i;

		if (getDebugDrawer() && getDebugDrawer()->getDebugMode())
		{
			for (i = 0; i < m_actions.size(); i++)
			{
				m_actions[i]->debugDraw(m_debugDrawer);
			}
		}
	}
	if (getDebugDrawer())
		getDebugDrawer()->flushLines();
}

void btDiscreteDynamicsWorld::clearForces()
{
	///@todo: iterate over awake simulation islands!
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		//need to check if next line is ok
		//it might break backward compatibility (people applying forces on sleeping objects get never cleared and accumulate on wake-up
		body->clearForces();
	}
}

///apply gravity, call this once per timestep
void btDiscreteDynamicsWorld::applyGravity()
{
	///@todo: iterate over awake simulation islands!
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body->isActive())
		{
			body->applyGravity();
		}
	}
}

void btDiscreteDynamicsWorld::synchronizeSingleMotionState(btRigidBody* body)
{
	btAssert(body);

	if (body->getMotionState() && !body->isStaticOrKinematicObject())
	{
		//we need to call the update at least once, even for sleeping objects
		//otherwise the 'graphics' transform never updates properly
		///@todo: add 'dirty' flag
		//if (body->getActivationState() != ISLAND_SLEEPING)
		{
			btTransform interpolatedTransform;
			btTransformUtil::integrateTransform(body->getInterpolationWorldTransform(),
												body->getInterpolationLinearVelocity(), body->getInterpolationAngularVelocity(),
												(m_latencyMotionStateInterpolation && m_fixedTimeStep) ? m_localTime - m_fixedTimeStep : m_localTime * body->getHitFraction(),
												interpolatedTransform);
			body->getMotionState()->setWorldTransform(interpolatedTransform);
		}
	}
}

void btDiscreteDynamicsWorld::synchronizeMotionStates()
{
	//	BT_PROFILE("synchronizeMotionStates");
	if (m_synchronizeAllMotionStates)
	{
		//iterate  over all collision objects
		for (int i = 0; i < m_collisionObjects.size(); i++)
		{
			btCollisionObject* colObj = m_collisionObjects[i];
			btRigidBody* body = btRigidBody::upcast(colObj);
			if (body)
				synchronizeSingleMotionState(body);
		}
	}
	else
	{
		//iterate over all active rigid bodies
		for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
		{
			btRigidBody* body = m_nonStaticRigidBodies[i];
			if (body->isActive())
				synchronizeSingleMotionState(body);
		}
	}
}

int btDiscreteDynamicsWorld::stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep)
{
	startProfiling(timeStep);

	int numSimulationSubSteps = 0;

	if (maxSubSteps)
	{
		//fixed timestep with interpolation
		m_fixedTimeStep = fixedTimeStep;
		m_localTime += timeStep;
		if (m_localTime >= fixedTimeStep)
		{
			numSimulationSubSteps = int(m_localTime / fixedTimeStep);
			m_localTime -= numSimulationSubSteps * fixedTimeStep;
		}
	}
	else
	{
		//variable timestep
		fixedTimeStep = timeStep;
		m_localTime = m_latencyMotionStateInterpolation ? 0 : timeStep;
		m_fixedTimeStep = 0;
		if (btFuzzyZero(timeStep))
		{
			numSimulationSubSteps = 0;
			maxSubSteps = 0;
		}
		else
		{
			numSimulationSubSteps = 1;
			maxSubSteps = 1;
		}
	}

	//process some debugging flags
	if (getDebugDrawer())
	{
		btIDebugDraw* debugDrawer = getDebugDrawer();
		gDisableDeactivation = (debugDrawer->getDebugMode() & btIDebugDraw::DBG_NoDeactivation) != 0;
	}
	if (numSimulationSubSteps)
	{
		//clamp the number of substeps, to prevent simulation grinding spiralling down to a halt
		int clampedSimulationSteps = (numSimulationSubSteps > maxSubSteps) ? maxSubSteps : numSimulationSubSteps;

		saveKinematicState(fixedTimeStep * clampedSimulationSteps);

		applyGravity();

		for (int i = 0; i < clampedSimulationSteps; i++)
		{
			internalSingleStepSimulation(fixedTimeStep);
			synchronizeMotionStates();
		}
	}
	else
	{
		synchronizeMotionStates();
	}

	clearForces();

#ifndef BT_NO_PROFILE
	CProfileManager::Increment_Frame_Counter();
#endif  //BT_NO_PROFILE

	return numSimulationSubSteps;
}

void btDiscreteDynamicsWorld::internalSingleStepSimulation(btScalar timeStep)
{
	BT_PROFILE("internalSingleStepSimulation");

	if (0 != m_internalPreTickCallback)
	{
		(*m_internalPreTickCallback)(this, timeStep);
	}

	///apply gravity, predict motion
	predictUnconstraintMotion(timeStep);

	btDispatcherInfo& dispatchInfo = getDispatchInfo();

	dispatchInfo.m_timeStep = timeStep;
	dispatchInfo.m_stepCount = 0;
	dispatchInfo.m_debugDraw = getDebugDrawer();

	createPredictiveContacts(timeStep);

	///perform collision detection
	performDiscreteCollisionDetection();

	calculateSimulationIslands();

	getSolverInfo().m_timeStep = timeStep;

	///solve contact and other joint constraints
	solveConstraints(getSolverInfo());

	///CallbackTriggers();

	///integrate transforms

	integrateTransforms(timeStep);

	///update vehicle simulation
	updateActions(timeStep);

	updateActivationState(timeStep);

	if (0 != m_internalTickCallback)
	{
		(*m_internalTickCallback)(this, timeStep);
	}
}

void btDiscreteDynamicsWorld::setGravity(const btVector3& gravity)
{
	m_gravity = gravity;
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body->isActive() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
		{
			body->setGravity(gravity);
		}
	}
}

btVector3 btDiscreteDynamicsWorld::getGravity() const
{
	return m_gravity;
}

void btDiscreteDynamicsWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{
	btCollisionWorld::addCollisionObject(collisionObject, collisionFilterGroup, collisionFilterMask);
}

void btDiscreteDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
	btRigidBody* body = btRigidBody::upcast(collisionObject);
	if (body)
		removeRigidBody(body);
	else
		btCollisionWorld::removeCollisionObject(collisionObject);
}

void btDiscreteDynamicsWorld::removeRigidBody(btRigidBody* body)
{
	m_nonStaticRigidBodies.remove(body);
	btCollisionWorld::removeCollisionObject(body);
}

void btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body)
{
	if (!body->isStaticOrKinematicObject() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
	{
		body->setGravity(m_gravity);
	}

	if (body->getCollisionShape())
	{
		if (!body->isStaticObject())
		{
			m_nonStaticRigidBodies.push_back(body);
		}
		else
		{
			body->setActivationState(ISLAND_SLEEPING);
		}

		bool isDynamic = !(body->isStaticObject() || body->isKinematicObject());
		int collisionFilterGroup = isDynamic ? int(btBroadphaseProxy::DefaultFilter) : int(btBroadphaseProxy::StaticFilter);
		int collisionFilterMask = isDynamic ? int(btBroadphaseProxy::AllFilter) : int(btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

		addCollisionObject(body, collisionFilterGroup, collisionFilterMask);
	}
}

void btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body, int group, int mask)
{
	if (!body->isStaticOrKinematicObject() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
	{
		body->setGravity(m_gravity);
	}

	if (body->getCollisionShape())
	{
		if (!body->isStaticObject())
		{
			m_nonStaticRigidBodies.push_back(body);
		}
		else
		{
			body->setActivationState(ISLAND_SLEEPING);
		}
		addCollisionObject(body, group, mask);
	}
}

void btDiscreteDynamicsWorld::updateActions(btScalar timeStep)
{
	BT_PROFILE("updateActions");

	for (int i = 0; i < m_actions.size(); i++)
	{
		m_actions[i]->updateAction(this, timeStep);
	}
}

void btDiscreteDynamicsWorld::updateActivationState(btScalar timeStep)
{
	BT_PROFILE("updateActivationState");

	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body)
		{
			body->updateDeactivation(timeStep);

			if (body->wantsSleeping())
			{
				if (body->isStaticOrKinematicObject())
				{
					body->setActivationState(ISLAND_SLEEPING);
				}
				else
				{
					if (body->getActivationState() == ACTIVE_TAG)
						body->setActivationState(WANTS_DEACTIVATION);
					if (body->getActivationState() == ISLAND_SLEEPING)
					{
						body->setAngularVelocity(btVector3(0, 0, 0));
						body->setLinearVelocity(btVector3(0, 0, 0));
					}
				}
			}
			else
			{
				if (body->getActivationState() != DISABLE_DEACTIVATION)
					body->setActivationState(ACTIVE_TAG);
			}
		}
	}
}

void btDiscreteDynamicsWorld::addConstraint(btTypedConstraint* constraint, bool disableCollisionsBetweenLinkedBodies)
{
	m_constraints.push_back(constraint);
	//Make sure the two bodies of a type constraint are different (possibly add this to the btTypedConstraint constructor?)
	btAssert(&constraint->getRigidBodyA() != &constraint->getRigidBodyB());

	if (disableCollisionsBetweenLinkedBodies)
	{
		constraint->getRigidBodyA().addConstraintRef(constraint);
		constraint->getRigidBodyB().addConstraintRef(constraint);
	}
}

void btDiscreteDynamicsWorld::removeConstraint(btTypedConstraint* constraint)
{
	m_constraints.remove(constraint);
	constraint->getRigidBodyA().removeConstraintRef(constraint);
	constraint->getRigidBodyB().removeConstraintRef(constraint);
}

void btDiscreteDynamicsWorld::addAction(btActionInterface* action)
{
	m_actions.push_back(action);
}

void btDiscreteDynamicsWorld::removeAction(btActionInterface* action)
{
	m_actions.remove(action);
}

void btDiscreteDynamicsWorld::addVehicle(btActionInterface* vehicle)
{
	addAction(vehicle);
}

void btDiscreteDynamicsWorld::removeVehicle(btActionInterface* vehicle)
{
	removeAction(vehicle);
}

void btDiscreteDynamicsWorld::addCharacter(btActionInterface* character)
{
	addAction(character);
}

void btDiscreteDynamicsWorld::removeCharacter(btActionInterface* character)
{
	removeAction(character);
}

void btDiscreteDynamicsWorld::solveConstraints(btContactSolverInfo& solverInfo)
{
	BT_PROFILE("solveConstraints");

	m_sortedConstraints.resize(m_constraints.size());
	int i;
	for (i = 0; i < getNumConstraints(); i++)
	{
		m_sortedConstraints[i] = m_constraints[i];
	}

	//	btAssert(0);

	m_sortedConstraints.quickSort(btSortConstraintOnIslandPredicate());

	btTypedConstraint** constraintsPtr = getNumConstraints() ? &m_sortedConstraints[0] : 0;

	m_solverIslandCallback->setup(&solverInfo, constraintsPtr, m_sortedConstraints.size(), getDebugDrawer());
	m_constraintSolver->prepareSolve(getCollisionWorld()->getNumCollisionObjects(), getCollisionWorld()->getDispatcher()->getNumManifolds());

	/// solve all the constraints for this island
	m_islandManager->buildAndProcessIslands(getCollisionWorld()->getDispatcher(), getCollisionWorld(), m_solverIslandCallback);

	m_solverIslandCallback->processConstraints();

	m_constraintSolver->allSolved(solverInfo, m_debugDrawer);
}

void btDiscreteDynamicsWorld::calculateSimulationIslands()
{
	BT_PROFILE("calculateSimulationIslands");

	getSimulationIslandManager()->updateActivationState(getCollisionWorld(), getCollisionWorld()->getDispatcher());

	{
		//merge islands based on speculative contact manifolds too
		for (int i = 0; i < this->m_predictiveManifolds.size(); i++)
		{
			btPersistentManifold* manifold = m_predictiveManifolds[i];

			const btCollisionObject* colObj0 = manifold->getBody0();
			const btCollisionObject* colObj1 = manifold->getBody1();

			if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
				((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
			{
				getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
			}
		}
	}

	{
		int i;
		int numConstraints = int(m_constraints.size());
		for (i = 0; i < numConstraints; i++)
		{
			btTypedConstraint* constraint = m_constraints[i];
			if (constraint->isEnabled())
			{
				const btRigidBody* colObj0 = &constraint->getRigidBodyA();
				const btRigidBody* colObj1 = &constraint->getRigidBodyB();

				if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
					((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
				{
					getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
				}
			}
		}
	}

	//Store the island id in each body
	getSimulationIslandManager()->storeIslandActivationState(getCollisionWorld());
}

class btClosestNotMeConvexResultCallback : public btCollisionWorld::ClosestConvexResultCallback
{
public:
	btCollisionObject* m_me;
	btScalar m_allowedPenetration;
	btOverlappingPairCache* m_pairCache;
	btDispatcher* m_dispatcher;

public:
	btClosestNotMeConvexResultCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btCollisionWorld::ClosestConvexResultCallback(fromA, toA),
																																										   m_me(me),
																																										   m_allowedPenetration(0.0f),
																																										   m_pairCache(pairCache),
																																										   m_dispatcher(dispatcher)
	{
	}

	virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult, bool normalInWorldSpace)
	{
		if (convexResult.m_hitCollisionObject == m_me)
			return 1.0f;

		//ignore result if there is no contact response
		if (!convexResult.m_hitCollisionObject->hasContactResponse())
			return 1.0f;

		btVector3 linVelA, linVelB;
		linVelA = m_convexToWorld - m_convexFromWorld;
		linVelB = btVector3(0, 0, 0);  //toB.getOrigin()-fromB.getOrigin();

		btVector3 relativeVelocity = (linVelA - linVelB);
		//don't report time of impact for motion away from the contact normal (or causes minor penetration)
		if (convexResult.m_hitNormalLocal.dot(relativeVelocity) >= -m_allowedPenetration)
			return 1.f;

		return ClosestConvexResultCallback::addSingleResult(convexResult, normalInWorldSpace);
	}

	virtual bool needsCollision(btBroadphaseProxy* proxy0) const
	{
		//don't collide with itself
		if (proxy0->m_clientObject == m_me)
			return false;

		///don't do CCD when the collision filters are not matching
		if (!ClosestConvexResultCallback::needsCollision(proxy0))
			return false;
		if (m_pairCache->getOverlapFilterCallback()) {
			btBroadphaseProxy* proxy1 = m_me->getBroadphaseHandle();
			bool collides = m_pairCache->needsBroadphaseCollision(proxy0, proxy1);
			if (!collides)
			{
				return false;
			}
		}

		btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;

		if (!m_dispatcher->needsCollision(m_me, otherObj))
			return false;

		//call needsResponse, see http://code.google.com/p/bullet/issues/detail?id=179
		if (m_dispatcher->needsResponse(m_me, otherObj))
		{
#if 0
			///don't do CCD when there are already contact points (touching contact/penetration)
			btAlignedObjectArray<btPersistentManifold*> manifoldArray;
			btBroadphasePair* collisionPair = m_pairCache->findPair(m_me->getBroadphaseHandle(),proxy0);
			if (collisionPair)
			{
				if (collisionPair->m_algorithm)
				{
					manifoldArray.resize(0);
					collisionPair->m_algorithm->getAllContactManifolds(manifoldArray);
					for (int j=0;j<manifoldArray.size();j++)
					{
						btPersistentManifold* manifold = manifoldArray[j];
						if (manifold->getNumContacts()>0)
							return false;
					}
				}
			}
#endif
			return true;
		}

		return false;
	}
};

///internal debugging variable. this value shouldn't be too high
int gNumClampedCcdMotions = 0;

void btDiscreteDynamicsWorld::createPredictiveContactsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
	btTransform predictedTrans;
	for (int i = 0; i < numBodies; i++)
	{
		btRigidBody* body = bodies[i];
		body->setHitFraction(1.f);

		if (body->isActive() && (!body->isStaticOrKinematicObject()))
		{
			body->predictIntegratedTransform(timeStep, predictedTrans);

			btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();

			if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
			{
				BT_PROFILE("predictive convexSweepTest");
				if (body->getCollisionShape()->isConvex())
				{
					gNumClampedCcdMotions++;
#ifdef PREDICTIVE_CONTACT_USE_STATIC_ONLY
					class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
					{
					public:
						StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
						{
						}

						virtual bool needsCollision(btBroadphaseProxy* proxy0) const
						{
							btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
							if (!otherObj->isStaticOrKinematicObject())
								return false;
							return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
						}
					};

					StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
					btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
					//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					btSphereShape tmpSphere(body->getCcdSweptSphereRadius());  //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

					sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
					sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
					btTransform modifiedPredictedTrans = predictedTrans;
					modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

					convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
					if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
					{
						btVector3 distVec = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()) * sweepResults.m_closestHitFraction;
						btScalar distance = distVec.dot(-sweepResults.m_hitNormalWorld);

						btMutexLock(&m_predictiveManifoldsMutex);
						btPersistentManifold* manifold = m_dispatcher1->getNewManifold(body, sweepResults.m_hitCollisionObject);
						m_predictiveManifolds.push_back(manifold);
						btMutexUnlock(&m_predictiveManifoldsMutex);

						btVector3 worldPointB = body->getWorldTransform().getOrigin() + distVec;
						btVector3 localPointB = sweepResults.m_hitCollisionObject->getWorldTransform().inverse() * worldPointB;

						btManifoldPoint newPoint(btVector3(0, 0, 0), localPointB, sweepResults.m_hitNormalWorld, distance);

						bool isPredictive = true;
						int index = manifold->addManifoldPoint(newPoint, isPredictive);
						btManifoldPoint& pt = manifold->getContactPoint(index);
						pt.m_combinedRestitution = 0;
						pt.m_combinedFriction = gCalculateCombinedFrictionCallback(body, sweepResults.m_hitCollisionObject);
						pt.m_positionWorldOnA = body->getWorldTransform().getOrigin();
						pt.m_positionWorldOnB = worldPointB;
					}
				}
			}
		}
	}
}

void btDiscreteDynamicsWorld::releasePredictiveContacts()
{
	BT_PROFILE("release predictive contact manifolds");

	for (int i = 0; i < m_predictiveManifolds.size(); i++)
	{
		btPersistentManifold* manifold = m_predictiveManifolds[i];
		this->m_dispatcher1->releaseManifold(manifold);
	}
	m_predictiveManifolds.clear();
}

void btDiscreteDynamicsWorld::createPredictiveContacts(btScalar timeStep)
{
	BT_PROFILE("createPredictiveContacts");
	releasePredictiveContacts();
	if (m_nonStaticRigidBodies.size() > 0)
	{
		createPredictiveContactsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
	}
}

void btDiscreteDynamicsWorld::integrateTransformsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
	btTransform predictedTrans;
	for (int i = 0; i < numBodies; i++)
	{
		btRigidBody* body = bodies[i];
		body->setHitFraction(1.f);

		if (body->isActive() && (!body->isStaticOrKinematicObject()))
		{
			body->predictIntegratedTransform(timeStep, predictedTrans);

			btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();

			if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
			{
				BT_PROFILE("CCD motion clamping");
				if (body->getCollisionShape()->isConvex())
				{
					gNumClampedCcdMotions++;
#ifdef USE_STATIC_ONLY
					class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
					{
					public:
						StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
						{
						}

						virtual bool needsCollision(btBroadphaseProxy* proxy0) const
						{
							btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
							if (!otherObj->isStaticOrKinematicObject())
								return false;
							return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
						}
					};

					StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
					btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
					//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					btSphereShape tmpSphere(body->getCcdSweptSphereRadius());  //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

					sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
					sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
					btTransform modifiedPredictedTrans = predictedTrans;
					modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

					convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
					if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
					{
						//printf("clamped integration to hit fraction = %f\n",fraction);
						body->setHitFraction(sweepResults.m_closestHitFraction);
						body->predictIntegratedTransform(timeStep * body->getHitFraction(), predictedTrans);
						body->setHitFraction(0.f);
						body->proceedToTransform(predictedTrans);

#if 0
						btVector3 linVel = body->getLinearVelocity();

						btScalar maxSpeed = body->getCcdMotionThreshold()/getSolverInfo().m_timeStep;
						btScalar maxSpeedSqr = maxSpeed*maxSpeed;
						if (linVel.length2()>maxSpeedSqr)
						{
							linVel.normalize();
							linVel*= maxSpeed;
							body->setLinearVelocity(linVel);
							btScalar ms2 = body->getLinearVelocity().length2();
							body->predictIntegratedTransform(timeStep, predictedTrans);

							btScalar sm2 = (predictedTrans.getOrigin()-body->getWorldTransform().getOrigin()).length2();
							btScalar smt = body->getCcdSquareMotionThreshold();
							printf("sm2=%f\n",sm2);
						}
#else

						//don't apply the collision response right now, it will happen next frame
						//if you really need to, you can uncomment next 3 lines. Note that is uses zero restitution.
						//btScalar appliedImpulse = 0.f;
						//btScalar depth = 0.f;
						//appliedImpulse = resolveSingleCollision(body,(btCollisionObject*)sweepResults.m_hitCollisionObject,sweepResults.m_hitPointWorld,sweepResults.m_hitNormalWorld,getSolverInfo(), depth);

#endif

						continue;
					}
				}
			}

			body->proceedToTransform(predictedTrans);
		}
	}
}

void btDiscreteDynamicsWorld::integrateTransforms(btScalar timeStep)
{
	BT_PROFILE("integrateTransforms");
	if (m_nonStaticRigidBodies.size() > 0)
	{
		integrateTransformsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
	}

	///this should probably be switched on by default, but it is not well tested yet
	if (m_applySpeculativeContactRestitution)
	{
		BT_PROFILE("apply speculative contact restitution");
		for (int i = 0; i < m_predictiveManifolds.size(); i++)
		{
			btPersistentManifold* manifold = m_predictiveManifolds[i];
			btRigidBody* body0 = btRigidBody::upcast((btCollisionObject*)manifold->getBody0());
			btRigidBody* body1 = btRigidBody::upcast((btCollisionObject*)manifold->getBody1());

			for (int p = 0; p < manifold->getNumContacts(); p++)
			{
				const btManifoldPoint& pt = manifold->getContactPoint(p);
				btScalar combinedRestitution = gCalculateCombinedRestitutionCallback(body0, body1);

				if (combinedRestitution > 0 && pt.m_appliedImpulse != 0.f)
				//if (pt.getDistance()>0 && combinedRestitution>0 && pt.m_appliedImpulse != 0.f)
				{
					btVector3 imp = -pt.m_normalWorldOnB * pt.m_appliedImpulse * combinedRestitution;

					const btVector3& pos1 = pt.getPositionWorldOnA();
					const btVector3& pos2 = pt.getPositionWorldOnB();

					btVector3 rel_pos0 = pos1 - body0->getWorldTransform().getOrigin();
					btVector3 rel_pos1 = pos2 - body1->getWorldTransform().getOrigin();

					if (body0)
						body0->applyImpulse(imp, rel_pos0);
					if (body1)
						body1->applyImpulse(-imp, rel_pos1);
				}
			}
		}
	}
}

void btDiscreteDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
	BT_PROFILE("predictUnconstraintMotion");
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (!body->isStaticOrKinematicObject())
		{
			//don't integrate/update velocities here, it happens in the constraint solver

			body->applyDamping(timeStep);

			body->predictIntegratedTransform(timeStep, body->getInterpolationWorldTransform());
		}
	}
}

void btDiscreteDynamicsWorld::startProfiling(btScalar timeStep)
{
	(void)timeStep;

#ifndef BT_NO_PROFILE
	CProfileManager::Reset();
#endif  //BT_NO_PROFILE
}

void btDiscreteDynamicsWorld::debugDrawConstraint(btTypedConstraint* constraint)
{
	bool drawFrames = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraints) != 0;
	bool drawLimits = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraintLimits) != 0;
	btScalar dbgDrawSize = constraint->getDbgDrawSize();
	if (dbgDrawSize <= btScalar(0.f))
	{
		return;
	}

	switch (constraint->getConstraintType())
	{
		case POINT2POINT_CONSTRAINT_TYPE:
		{
			btPoint2PointConstraint* p2pC = (btPoint2PointConstraint*)constraint;
			btTransform tr;
			tr.setIdentity();
			btVector3 pivot = p2pC->getPivotInA();
			pivot = p2pC->getRigidBodyA().getCenterOfMassTransform() * pivot;
			tr.setOrigin(pivot);
			getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			// that ideally should draw the same frame
			pivot = p2pC->getPivotInB();
			pivot = p2pC->getRigidBodyB().getCenterOfMassTransform() * pivot;
			tr.setOrigin(pivot);
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
		}
		break;
		case HINGE_CONSTRAINT_TYPE:
		{
			btHingeConstraint* pHinge = (btHingeConstraint*)constraint;
			btTransform tr = pHinge->getRigidBodyA().getCenterOfMassTransform() * pHinge->getAFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pHinge->getRigidBodyB().getCenterOfMassTransform() * pHinge->getBFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			btScalar minAng = pHinge->getLowerLimit();
			btScalar maxAng = pHinge->getUpperLimit();
			if (minAng == maxAng)
			{
				break;
			}
			bool drawSect = true;
			if (!pHinge->hasLimit())
			{
				minAng = btScalar(0.f);
				maxAng = SIMD_2_PI;
				drawSect = false;
			}
			if (drawLimits)
			{
				btVector3& center = tr.getOrigin();
				btVector3 normal = tr.getBasis().getColumn(2);
				btVector3 axis = tr.getBasis().getColumn(0);
				getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, minAng, maxAng, btVector3(0, 0, 0), drawSect);
			}
		}
		break;
		case CONETWIST_CONSTRAINT_TYPE:
		{
			btConeTwistConstraint* pCT = (btConeTwistConstraint*)constraint;
			btTransform tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				//const btScalar length = btScalar(5);
				const btScalar length = dbgDrawSize;
				static int nSegments = 8 * 4;
				btScalar fAngleInRadians = btScalar(2. * 3.1415926) * (btScalar)(nSegments - 1) / btScalar(nSegments);
				btVector3 pPrev = pCT->GetPointForAngle(fAngleInRadians, length);
				pPrev = tr * pPrev;
				for (int i = 0; i < nSegments; i++)
				{
					fAngleInRadians = btScalar(2. * 3.1415926) * (btScalar)i / btScalar(nSegments);
					btVector3 pCur = pCT->GetPointForAngle(fAngleInRadians, length);
					pCur = tr * pCur;
					getDebugDrawer()->drawLine(pPrev, pCur, btVector3(0, 0, 0));

					if (i % (nSegments / 8) == 0)
						getDebugDrawer()->drawLine(tr.getOrigin(), pCur, btVector3(0, 0, 0));

					pPrev = pCur;
				}
				btScalar tws = pCT->getTwistSpan();
				btScalar twa = pCT->getTwistAngle();
				bool useFrameB = (pCT->getRigidBodyB().getInvMass() > btScalar(0.f));
				if (useFrameB)
				{
					tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
				}
				else
				{
					tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
				}
				btVector3 pivot = tr.getOrigin();
				btVector3 normal = tr.getBasis().getColumn(0);
				btVector3 axis1 = tr.getBasis().getColumn(1);
				getDebugDrawer()->drawArc(pivot, normal, axis1, dbgDrawSize, dbgDrawSize, -twa - tws, -twa + tws, btVector3(0, 0, 0), true);
			}
		}
		break;
		case D6_SPRING_CONSTRAINT_TYPE:
		case D6_CONSTRAINT_TYPE:
		{
			btGeneric6DofConstraint* p6DOF = (btGeneric6DofConstraint*)constraint;
			btTransform tr = p6DOF->getCalculatedTransformA();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = p6DOF->getCalculatedTransformB();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				tr = p6DOF->getCalculatedTransformA();
				const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
				btVector3 up = tr.getBasis().getColumn(2);
				btVector3 axis = tr.getBasis().getColumn(0);
				btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
				btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
				btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
				btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
				getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
				axis = tr.getBasis().getColumn(1);
				btScalar ay = p6DOF->getAngle(1);
				btScalar az = p6DOF->getAngle(2);
				btScalar cy = btCos(ay);
				btScalar sy = btSin(ay);
				btScalar cz = btCos(az);
				btScalar sz = btSin(az);
				btVector3 ref;
				ref[0] = cy * cz * axis[0] + cy * sz * axis[1] - sy * axis[2];
				ref[1] = -sz * axis[0] + cz * axis[1];
				ref[2] = cz * sy * axis[0] + sz * sy * axis[1] + cy * axis[2];
				tr = p6DOF->getCalculatedTransformB();
				btVector3 normal = -tr.getBasis().getColumn(0);
				btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
				btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
				if (minFi > maxFi)
				{
					getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
				}
				else if (minFi < maxFi)
				{
					getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
				}
				tr = p6DOF->getCalculatedTransformA();
				btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
				btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
				getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
			}
		}
		break;
		///note: the code for D6_SPRING_2_CONSTRAINT_TYPE is identical to D6_CONSTRAINT_TYPE, the D6_CONSTRAINT_TYPE+D6_SPRING_CONSTRAINT_TYPE will likely become obsolete/deprecated at some stage
		case D6_SPRING_2_CONSTRAINT_TYPE:
		{
			{
				btGeneric6DofSpring2Constraint* p6DOF = (btGeneric6DofSpring2Constraint*)constraint;
				btTransform tr = p6DOF->getCalculatedTransformA();
				if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
				tr = p6DOF->getCalculatedTransformB();
				if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
				if (drawLimits)
				{
					tr = p6DOF->getCalculatedTransformA();
					const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
					btVector3 up = tr.getBasis().getColumn(2);
					btVector3 axis = tr.getBasis().getColumn(0);
					btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
					btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
					if (minTh <= maxTh)
					{
						btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
						btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
						getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
					}
					axis = tr.getBasis().getColumn(1);
					btScalar ay = p6DOF->getAngle(1);
					btScalar az = p6DOF->getAngle(2);
					btScalar cy = btCos(ay);
					btScalar sy = btSin(ay);
					btScalar cz = btCos(az);
					btScalar sz = btSin(az);
					btVector3 ref;
					ref[0] = cy * cz * axis[0] + cy * sz * axis[1] - sy * axis[2];
					ref[1] = -sz * axis[0] + cz * axis[1];
					ref[2] = cz * sy * axis[0] + sz * sy * axis[1] + cy * axis[2];
					tr = p6DOF->getCalculatedTransformB();
					btVector3 normal = -tr.getBasis().getColumn(0);
					btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
					btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
					if (minFi > maxFi)
					{
						getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
					}
					else if (minFi < maxFi)
					{
						getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
					}
					tr = p6DOF->getCalculatedTransformA();
					btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
					btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
					getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
				}
			}
			break;
		}
		case SLIDER_CONSTRAINT_TYPE:
		{
			btSliderConstraint* pSlider = (btSliderConstraint*)constraint;
			btTransform tr = pSlider->getCalculatedTransformA();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pSlider->getCalculatedTransformB();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				btTransform tr = pSlider->getUseLinearReferenceFrameA() ? pSlider->getCalculatedTransformA() : pSlider->getCalculatedTransformB();
				btVector3 li_min = tr * btVector3(pSlider->getLowerLinLimit(), 0.f, 0.f);
				btVector3 li_max = tr * btVector3(pSlider->getUpperLinLimit(), 0.f, 0.f);
				getDebugDrawer()->drawLine(li_min, li_max, btVector3(0, 0, 0));
				btVector3 normal = tr.getBasis().getColumn(0);
				btVector3 axis = tr.getBasis().getColumn(1);
				btScalar a_min = pSlider->getLowerAngLimit();
				btScalar a_max = pSlider->getUpperAngLimit();
				const btVector3& center = pSlider->getCalculatedTransformB().getOrigin();
				getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, a_min, a_max, btVector3(0, 0, 0), true);
			}
		}
		break;
		default:
			break;
	}
	return;
}

void btDiscreteDynamicsWorld::setConstraintSolver(btConstraintSolver* solver)
{
	if (m_ownsConstraintSolver)
	{
		btAlignedFree(m_constraintSolver);
	}
	m_ownsConstraintSolver = false;
	m_constraintSolver = solver;
	m_solverIslandCallback->m_solver = solver;
}

btConstraintSolver* btDiscreteDynamicsWorld::getConstraintSolver()
{
	return m_constraintSolver;
}

int btDiscreteDynamicsWorld::getNumConstraints() const
{
	return int(m_constraints.size());
}
btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index)
{
	return m_constraints[index];
}
const btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index) const
{
	return m_constraints[index];
}

void btDiscreteDynamicsWorld::serializeRigidBodies(btSerializer* serializer)
{
	int i;
	//serialize all collision objects
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
		{
			int len = colObj->calculateSerializeBufferSize();
			btChunk* chunk = serializer->allocate(len, 1);
			const char* structType = colObj->serialize(chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, colObj);
		}
	}

	for (i = 0; i < m_constraints.size(); i++)
	{
		btTypedConstraint* constraint = m_constraints[i];
		int size = constraint->calculateSerializeBufferSize();
		btChunk* chunk = serializer->allocate(size, 1);
		const char* structType = constraint->serialize(chunk->m_oldPtr, serializer);
		serializer->finalizeChunk(chunk, structType, BT_CONSTRAINT_CODE, constraint);
	}
}

void btDiscreteDynamicsWorld::serializeDynamicsWorldInfo(btSerializer* serializer)
{
#ifdef BT_USE_DOUBLE_PRECISION
	int len = sizeof(btDynamicsWorldDoubleData);
	btChunk* chunk = serializer->allocate(len, 1);
	btDynamicsWorldDoubleData* worldInfo = (btDynamicsWorldDoubleData*)chunk->m_oldPtr;
#else   //BT_USE_DOUBLE_PRECISION
	int len = sizeof(btDynamicsWorldFloatData);
	btChunk* chunk = serializer->allocate(len, 1);
	btDynamicsWorldFloatData* worldInfo = (btDynamicsWorldFloatData*)chunk->m_oldPtr;
#endif  //BT_USE_DOUBLE_PRECISION

	memset(worldInfo, 0x00, len);

	m_gravity.serialize(worldInfo->m_gravity);
	worldInfo->m_solverInfo.m_tau = getSolverInfo().m_tau;
	worldInfo->m_solverInfo.m_damping = getSolverInfo().m_damping;
	worldInfo->m_solverInfo.m_friction = getSolverInfo().m_friction;
	worldInfo->m_solverInfo.m_timeStep = getSolverInfo().m_timeStep;

	worldInfo->m_solverInfo.m_restitution = getSolverInfo().m_restitution;
	worldInfo->m_solverInfo.m_maxErrorReduction = getSolverInfo().m_maxErrorReduction;
	worldInfo->m_solverInfo.m_sor = getSolverInfo().m_sor;
	worldInfo->m_solverInfo.m_erp = getSolverInfo().m_erp;

	worldInfo->m_solverInfo.m_erp2 = getSolverInfo().m_erp2;
	worldInfo->m_solverInfo.m_globalCfm = getSolverInfo().m_globalCfm;
	worldInfo->m_solverInfo.m_splitImpulsePenetrationThreshold = getSolverInfo().m_splitImpulsePenetrationThreshold;
	worldInfo->m_solverInfo.m_splitImpulseTurnErp = getSolverInfo().m_splitImpulseTurnErp;

	worldInfo->m_solverInfo.m_linearSlop = getSolverInfo().m_linearSlop;
	worldInfo->m_solverInfo.m_warmstartingFactor = getSolverInfo().m_warmstartingFactor;
	worldInfo->m_solverInfo.m_maxGyroscopicForce = getSolverInfo().m_maxGyroscopicForce;
	worldInfo->m_solverInfo.m_singleAxisRollingFrictionThreshold = getSolverInfo().m_singleAxisRollingFrictionThreshold;

	worldInfo->m_solverInfo.m_numIterations = getSolverInfo().m_numIterations;
	worldInfo->m_solverInfo.m_solverMode = getSolverInfo().m_solverMode;
	worldInfo->m_solverInfo.m_restingContactRestitutionThreshold = getSolverInfo().m_restingContactRestitutionThreshold;
	worldInfo->m_solverInfo.m_minimumSolverBatchSize = getSolverInfo().m_minimumSolverBatchSize;

	worldInfo->m_solverInfo.m_splitImpulse = getSolverInfo().m_splitImpulse;

	
#ifdef BT_USE_DOUBLE_PRECISION
	const char* structType = "btDynamicsWorldDoubleData";
#else   //BT_USE_DOUBLE_PRECISION
	const char* structType = "btDynamicsWorldFloatData";
#endif  //BT_USE_DOUBLE_PRECISION
	serializer->finalizeChunk(chunk, structType, BT_DYNAMICSWORLD_CODE, worldInfo);
}

void btDiscreteDynamicsWorld::serialize(btSerializer* serializer)
{
	serializer->startSerialization();

	serializeDynamicsWorldInfo(serializer);

	serializeCollisionObjects(serializer);

	serializeRigidBodies(serializer);

	serializeContactManifolds(serializer);

	serializer->finishSerialization();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_DISCRETE_DYNAMICS_WORLD_H
#define BT_DISCRETE_DYNAMICS_WORLD_H

#include "BulletDynamics/Dynamics/btDynamicsWorld.h"
class btDispatcher;
class btOverlappingPairCache;
class btConstraintSolver;
class btSimulationIslandManager;
class btTypedConstraint;
class btActionInterface;
class btPersistentManifold;
class btIDebugDraw;

struct InplaceSolverIslandCallback;

#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btThreads.h"

///btDiscreteDynamicsWorld provides discrete rigid body simulation
///those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
ATTRIBUTE_ALIGNED16(class)
btDiscreteDynamicsWorld : public btDynamicsWorld
{
protected:
	btAlignedObjectArray<btTypedConstraint*> m_sortedConstraints;
	InplaceSolverIslandCallback* m_solverIslandCallback;

	btConstraintSolver* m_constraintSolver;

	btSimulationIslandManager* m_islandManager;

	btAlignedObjectArray<btTypedConstraint*> m_constraints;

	btAlignedObjectArray<btRigidBody*> m_nonStaticRigidBodies;

	btVector3 m_gravity;

	//for variable timesteps
	btScalar m_localTime;
	btScalar m_fixedTimeStep;
	//for variable timesteps

	bool m_ownsIslandManager;
	bool m_ownsConstraintSolver;
	bool m_synchronizeAllMotionStates;
	bool m_applySpeculativeContactRestitution;

	btAlignedObjectArray<btActionInterface*> m_actions;

	int m_profileTimings;

	bool m_latencyMotionStateInterpolation;

	btAlignedObjectArray<btPersistentManifold*> m_predictiveManifolds;
	btSpinMutex m_predictiveManifoldsMutex;  // used to synchronize threads creating predictive contacts

	virtual void predictUnconstraintMotion(btScalar timeStep);

	void integrateTransformsInternal(btRigidBody * *bodies, int numBodies, btScalar timeStep);  // can be called in parallel
	virtual void integrateTransforms(btScalar timeStep);

	virtual void calculateSimulationIslands();

	

	virtual void updateActivationState(btScalar timeStep);

	void updateActions(btScalar timeStep);

	void startProfiling(btScalar timeStep);

	virtual void internalSingleStepSimulation(btScalar timeStep);

	void releasePredictiveContacts();
	void createPredictiveContactsInternal(btRigidBody * *bodies, int numBodies, btScalar timeStep);  // can be called in parallel
	virtual void createPredictiveContacts(btScalar timeStep);

	virtual void saveKinematicState(btScalar timeStep);

	void serializeRigidBodies(btSerializer * serializer);

	void serializeDynamicsWorldInfo(btSerializer * serializer);
    
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
	btDiscreteDynamicsWorld(btDispatcher * dispatcher, btBroadphaseInterface * pairCache, btConstraintSolver * constraintSolver, btCollisionConfiguration * collisionConfiguration);

	virtual ~btDiscreteDynamicsWorld();

	///if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's
	virtual int stepSimulation(btScalar timeStep, int maxSubSteps = 1, btScalar fixedTimeStep = btScalar(1.) / btScalar(60.));

    virtual void solveConstraints(btContactSolverInfo & solverInfo);
    
	virtual void synchronizeMotionStates();

	///this can be useful to synchronize a single rigid body -> graphics object
	void synchronizeSingleMotionState(btRigidBody * body);

	virtual void addConstraint(btTypedConstraint * constraint, bool disableCollisionsBetweenLinkedBodies = false);

	virtual void removeConstraint(btTypedConstraint * constraint);

	virtual void addAction(btActionInterface*);

	virtual void removeAction(btActionInterface*);

	btSimulationIslandManager* getSimulationIslandManager()
	{
		return m_islandManager;
	}

	const btSimulationIslandManager* getSimulationIslandManager() const
	{
		return m_islandManager;
	}

	btCollisionWorld* getCollisionWorld()
	{
		return this;
	}

	virtual void setGravity(const btVector3& gravity);

	virtual btVector3 getGravity() const;

	virtual void addCollisionObject(btCollisionObject * collisionObject, int collisionFilterGroup = btBroadphaseProxy::StaticFilter, int collisionFilterMask = btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

	virtual void addRigidBody(btRigidBody * body);

	virtual void addRigidBody(btRigidBody * body, int group, int mask);

	virtual void removeRigidBody(btRigidBody * body);

	///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
	virtual void removeCollisionObject(btCollisionObject * collisionObject);

	virtual void debugDrawConstraint(btTypedConstraint * constraint);

	virtual void debugDrawWorld();

	virtual void setConstraintSolver(btConstraintSolver * solver);

	virtual btConstraintSolver* getConstraintSolver();

	virtual int getNumConstraints() const;

	virtual btTypedConstraint* getConstraint(int index);

	virtual const btTypedConstraint* getConstraint(int index) const;

	virtual btDynamicsWorldType getWorldType() const
	{
		return BT_DISCRETE_DYNAMICS_WORLD;
	}

	///the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
	virtual void clearForces();

	///apply gravity, call this once per timestep
	virtual void applyGravity();

	virtual void setNumTasks(int numTasks)
	{
		(void)numTasks;
	}

	///obsolete, use updateActions instead
	virtual void updateVehicles(btScalar timeStep)
	{
		updateActions(timeStep);
	}

	///obsolete, use addAction instead
	virtual void addVehicle(btActionInterface * vehicle);
	///obsolete, use removeAction instead
	virtual void removeVehicle(btActionInterface * vehicle);
	///obsolete, use addAction instead
	virtual void addCharacter(btActionInterface * character);
	///obsolete, use removeAction instead
	virtual void removeCharacter(btActionInterface * character);

	void setSynchronizeAllMotionStates(bool synchronizeAll)
	{
		m_synchronizeAllMotionStates = synchronizeAll;
	}
	bool getSynchronizeAllMotionStates() const
	{
		return m_synchronizeAllMotionStates;
	}

	void setApplySpeculativeContactRestitution(bool enable)
	{
		m_applySpeculativeContactRestitution = enable;
	}

	bool getApplySpeculativeContactRestitution() const
	{
		return m_applySpeculativeContactRestitution;
	}

	///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
	virtual void serialize(btSerializer * serializer);

	///Interpolate motion state between previous and current transform, instead of current and next transform.
	///This can relieve discontinuities in the rendering, due to penetrations
	void setLatencyMotionStateInterpolation(bool latencyInterpolation)
	{
		m_latencyMotionStateInterpolation = latencyInterpolation;
	}
	bool getLatencyMotionStateInterpolation() const
	{
		return m_latencyMotionStateInterpolation;
	}
    
    btAlignedObjectArray<btRigidBody*>& getNonStaticRigidBodies()
    {
        return m_nonStaticRigidBodies;
    }
    
    const btAlignedObjectArray<btRigidBody*>& getNonStaticRigidBodies() const
    {
        return m_nonStaticRigidBodies;
    }
};

#endif  //BT_DISCRETE_DYNAMICS_WORLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleCallback.h"

btTriangleCallback::~btTriangleCallback()
{
}

btInternalTriangleIndexCallback::~btInternalTriangleIndexCallback()
{
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRIANGLE_CALLBACK_H
#define BT_TRIANGLE_CALLBACK_H

#include "LinearMath/btVector3.h"

///The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
///This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
class btTriangleCallback
{
public:
	virtual ~btTriangleCallback();
	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex) = 0;
};

class btInternalTriangleIndexCallback
{
public:
	virtual ~btInternalTriangleIndexCallback();
	virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex) = 0;
};

#endif  //BT_TRIANGLE_CALLBACK_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"

btTriangleRaycastCallback::btTriangleRaycastCallback(const btVector3& from, const btVector3& to, unsigned int flags)
	: m_from(from),
	  m_to(to),
	  //@BP Mod
	  m_flags(flags),
	  m_hitFraction(btScalar(1.))
{
}

void btTriangleRaycastCallback::processTriangle(btVector3* triangle, int partId, int triangleIndex)
{
	const btVector3& vert0 = triangle[0];
	const btVector3& vert1 = triangle[1];
	const btVector3& vert2 = triangle[2];

	btVector3 v10;
	v10 = vert1 - vert0;
	btVector3 v20;
	v20 = vert2 - vert0;

	btVector3 triangleNormal;
	triangleNormal = v10.cross(v20);

	const btScalar dist = vert0.dot(triangleNormal);
	btScalar dist_a = triangleNormal.dot(m_from);
	dist_a -= dist;
	btScalar dist_b = triangleNormal.dot(m_to);
	dist_b -= dist;

	if (dist_a * dist_b >= btScalar(0.0))
	{
		return;  // same sign
	}

	if (((m_flags & kF_FilterBackfaces) != 0) && (dist_a <= btScalar(0.0)))
	{
		// Backface, skip check
		return;
	}

	const btScalar proj_length = dist_a - dist_b;
	const btScalar distance = (dist_a) / (proj_length);
	// Now we have the intersection point on the plane, we'll see if it's inside the triangle
	// Add an epsilon as a tolerance for the raycast,
	// in case the ray hits exacly on the edge of the triangle.
	// It must be scaled for the triangle size.

	if (distance < m_hitFraction)
	{
		btScalar edge_tolerance = triangleNormal.length2();
		edge_tolerance *= btScalar(-0.0001);
		btVector3 point;
		point.setInterpolate3(m_from, m_to, distance);
		{
			btVector3 v0p;
			v0p = vert0 - point;
			btVector3 v1p;
			v1p = vert1 - point;
			btVector3 cp0;
			cp0 = v0p.cross(v1p);

			if ((btScalar)(cp0.dot(triangleNormal)) >= edge_tolerance)
			{
				btVector3 v2p;
				v2p = vert2 - point;
				btVector3 cp1;
				cp1 = v1p.cross(v2p);
				if ((btScalar)(cp1.dot(triangleNormal)) >= edge_tolerance)
				{
					btVector3 cp2;
					cp2 = v2p.cross(v0p);

					if ((btScalar)(cp2.dot(triangleNormal)) >= edge_tolerance)
					{
						//@BP Mod
						// Triangle normal isn't normalized
						triangleNormal.normalize();

						//@BP Mod - Allow for unflipped normal when raycasting against backfaces
						if (((m_flags & kF_KeepUnflippedNormal) == 0) && (dist_a <= btScalar(0.0)))
						{
							m_hitFraction = reportHit(-triangleNormal, distance, partId, triangleIndex);
						}
						else
						{
							m_hitFraction = reportHit(triangleNormal, distance, partId, triangleIndex);
						}
					}
				}
			}
		}
	}
}

btTriangleConvexcastCallback::btTriangleConvexcastCallback(const btConvexShape* convexShape, const btTransform& convexShapeFrom, const btTransform& convexShapeTo, const btTransform& triangleToWorld, const btScalar triangleCollisionMargin)
{
	m_convexShape = convexShape;
	m_convexShapeFrom = convexShapeFrom;
	m_convexShapeTo = convexShapeTo;
	m_triangleToWorld = triangleToWorld;
	m_hitFraction = 1.0f;
	m_triangleCollisionMargin = triangleCollisionMargin;
	m_allowedPenetration = 0.f;
}

void btTriangleConvexcastCallback::processTriangle(btVector3* triangle, int partId, int triangleIndex)
{
	btTriangleShape triangleShape(triangle[0], triangle[1], triangle[2]);
	triangleShape.setMargin(m_triangleCollisionMargin);

	btVoronoiSimplexSolver simplexSolver;
	btGjkEpaPenetrationDepthSolver gjkEpaPenetrationSolver;

//#define  USE_SUBSIMPLEX_CONVEX_CAST 1
//if you reenable USE_SUBSIMPLEX_CONVEX_CAST see commented out code below
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
	btSubsimplexConvexCast convexCaster(m_convexShape, &triangleShape, &simplexSolver);
#else
	//btGjkConvexCast	convexCaster(m_convexShape,&triangleShape,&simplexSolver);
	btContinuousConvexCollision convexCaster(m_convexShape, &triangleShape, &simplexSolver, &gjkEpaPenetrationSolver);
#endif  //#USE_SUBSIMPLEX_CONVEX_CAST

	btConvexCast::CastResult castResult;
	castResult.m_fraction = btScalar(1.);
	castResult.m_allowedPenetration = m_allowedPenetration;
	if (convexCaster.calcTimeOfImpact(m_convexShapeFrom, m_convexShapeTo, m_triangleToWorld, m_triangleToWorld, castResult))
	{
		//add hit
		if (castResult.m_normal.length2() > btScalar(0.0001))
		{
			if (castResult.m_fraction < m_hitFraction)
			{
				/* btContinuousConvexCast's normal is already in world space */
				/*
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
				//rotate normal into worldspace
				castResult.m_normal = m_convexShapeFrom.getBasis() * castResult.m_normal;
#endif //USE_SUBSIMPLEX_CONVEX_CAST
*/
				castResult.m_normal.normalize();

				reportHit(castResult.m_normal,
						  castResult.m_hitPoint,
						  castResult.m_fraction,
						  partId,
						  triangleIndex);
			}
		}
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_RAYCAST_TRI_CALLBACK_H
#define BT_RAYCAST_TRI_CALLBACK_H

#include "BulletCollision/CollisionShapes/btTriangleCallback.h"
#include "LinearMath/btTransform.h"
struct btBroadphaseProxy;
class btConvexShape;

class btTriangleRaycastCallback : public btTriangleCallback
{
public:
	//input
	btVector3 m_from;
	btVector3 m_to;

	//@BP Mod - allow backface filtering and unflipped normals
	enum EFlags
	{
		kF_None = 0,
		kF_FilterBackfaces = 1 << 0,
		kF_KeepUnflippedNormal = 1 << 1,             // Prevents returned face normal getting flipped when a ray hits a back-facing triangle
													 ///SubSimplexConvexCastRaytest is the default, even if kF_None is set.
		kF_UseSubSimplexConvexCastRaytest = 1 << 2,  // Uses an approximate but faster ray versus convex intersection algorithm
		kF_UseGjkConvexCastRaytest = 1 << 3,
		kF_DisableHeightfieldAccelerator  = 1 << 4, //don't use the heightfield raycast accelerator. See https://github.com/bulletphysics/bullet3/pull/2062
		kF_Terminator = 0xFFFFFFFF
	};
	unsigned int m_flags;

	btScalar m_hitFraction;

	btTriangleRaycastCallback(const btVector3& from, const btVector3& to, unsigned int flags = 0);

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex);

	virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex) = 0;
};

class btTriangleConvexcastCallback : public btTriangleCallback
{
public:
	const btConvexShape* m_convexShape;
	btTransform m_convexShapeFrom;
	btTransform m_convexShapeTo;
	btTransform m_triangleToWorld;
	btScalar m_hitFraction;
	btScalar m_triangleCollisionMargin;
	btScalar m_allowedPenetration;

	btTriangleConvexcastCallback(const btConvexShape* convexShape, const btTransform& convexShapeFrom, const btTransform& convexShapeTo, const btTransform& triangleToWorld, const btScalar triangleCollisionMargin);

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex);

	virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex) = 0;
};

#endif  //BT_RAYCAST_TRI_CALLBACK_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
/*
2007-09-09
Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btTransformUtil.h"

#define D6_USE_OBSOLETE_METHOD false
#define D6_USE_FRAME_OFFSET true

btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA)
	: btTypedConstraint(D6_CONSTRAINT_TYPE, rbA, rbB), m_frameInA(frameInA), m_frameInB(frameInB), m_useLinearReferenceFrameA(useLinearReferenceFrameA), m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET), m_flags(0), m_useSolveConstraintObsolete(D6_USE_OBSOLETE_METHOD)
{
	calculateTransforms();
}

btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbB, const btTransform& frameInB, bool useLinearReferenceFrameB)
	: btTypedConstraint(D6_CONSTRAINT_TYPE, getFixedBody(), rbB),
	  m_frameInB(frameInB),
	  m_useLinearReferenceFrameA(useLinearReferenceFrameB),
	  m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET),
	  m_flags(0),
	  m_useSolveConstraintObsolete(false)
{
	///not providing rigidbody A means implicitly using worldspace for body A
	m_frameInA = rbB.getCenterOfMassTransform() * m_frameInB;
	calculateTransforms();
}

#define GENERIC_D6_DISABLE_WARMSTARTING 1

btScalar btGetMatrixElem(const btMatrix3x3& mat, int index);
btScalar btGetMatrixElem(const btMatrix3x3& mat, int index)
{
	int i = index % 3;
	int j = index / 3;
	return mat[i][j];
}

///MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
bool matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz);
bool matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz)
{
	//	// rot =  cy*cz          -cy*sz           sy
	//	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
	//	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
	//

	btScalar fi = btGetMatrixElem(mat, 2);
	if (fi < btScalar(1.0f))
	{
		if (fi > btScalar(-1.0f))
		{
			xyz[0] = btAtan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 8));
			xyz[1] = btAsin(btGetMatrixElem(mat, 2));
			xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
			return true;
		}
		else
		{
			// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
			xyz[0] = -btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
			xyz[1] = -SIMD_HALF_PI;
			xyz[2] = btScalar(0.0);
			return false;
		}
	}
	else
	{
		// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
		xyz[0] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
		xyz[1] = SIMD_HALF_PI;
		xyz[2] = 0.0;
	}
	return false;
}

//////////////////////////// btRotationalLimitMotor ////////////////////////////////////

int btRotationalLimitMotor::testLimitValue(btScalar test_value)
{
	if (m_loLimit > m_hiLimit)
	{
		m_currentLimit = 0;  //Free from violation
		return 0;
	}
	if (test_value < m_loLimit)
	{
		m_currentLimit = 1;  //low limit violation
		m_currentLimitError = test_value - m_loLimit;
		if (m_currentLimitError > SIMD_PI)
			m_currentLimitError -= SIMD_2_PI;
		else if (m_currentLimitError < -SIMD_PI)
			m_currentLimitError += SIMD_2_PI;
		return 1;
	}
	else if (test_value > m_hiLimit)
	{
		m_currentLimit = 2;  //High limit violation
		m_currentLimitError = test_value - m_hiLimit;
		if (m_currentLimitError > SIMD_PI)
			m_currentLimitError -= SIMD_2_PI;
		else if (m_currentLimitError < -SIMD_PI)
			m_currentLimitError += SIMD_2_PI;
		return 2;
	};

	m_currentLimit = 0;  //Free from violation
	return 0;
}

btScalar btRotationalLimitMotor::solveAngularLimits(
	btScalar timeStep, btVector3& axis, btScalar jacDiagABInv,
	btRigidBody* body0, btRigidBody* body1)
{
	if (needApplyTorques() == false) return 0.0f;

	btScalar target_velocity = m_targetVelocity;
	btScalar maxMotorForce = m_maxMotorForce;

	//current error correction
	if (m_currentLimit != 0)
	{
		target_velocity = -m_stopERP * m_currentLimitError / (timeStep);
		maxMotorForce = m_maxLimitForce;
	}

	maxMotorForce *= timeStep;

	// current velocity difference

	btVector3 angVelA = body0->getAngularVelocity();
	btVector3 angVelB = body1->getAngularVelocity();

	btVector3 vel_diff;
	vel_diff = angVelA - angVelB;

	btScalar rel_vel = axis.dot(vel_diff);

	// correction velocity
	btScalar motor_relvel = m_limitSoftness * (target_velocity - m_damping * rel_vel);

	if (motor_relvel < SIMD_EPSILON && motor_relvel > -SIMD_EPSILON)
	{
		return 0.0f;  //no need for applying force
	}

	// correction impulse
	btScalar unclippedMotorImpulse = (1 + m_bounce) * motor_relvel * jacDiagABInv;

	// clip correction impulse
	btScalar clippedMotorImpulse;

	///@todo: should clip against accumulated impulse
	if (unclippedMotorImpulse > 0.0f)
	{
		clippedMotorImpulse = unclippedMotorImpulse > maxMotorForce ? maxMotorForce : unclippedMotorImpulse;
	}
	else
	{
		clippedMotorImpulse = unclippedMotorImpulse < -maxMotorForce ? -maxMotorForce : unclippedMotorImpulse;
	}

	// sort with accumulated impulses
	btScalar lo = btScalar(-BT_LARGE_FLOAT);
	btScalar hi = btScalar(BT_LARGE_FLOAT);

	btScalar oldaccumImpulse = m_accumulatedImpulse;
	btScalar sum = oldaccumImpulse + clippedMotorImpulse;
	m_accumulatedImpulse = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;

	clippedMotorImpulse = m_accumulatedImpulse - oldaccumImpulse;

	btVector3 motorImp = clippedMotorImpulse * axis;

	body0->applyTorqueImpulse(motorImp);
	body1->applyTorqueImpulse(-motorImp);

	return clippedMotorImpulse;
}

//////////////////////////// End btRotationalLimitMotor ////////////////////////////////////

//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////

int btTranslationalLimitMotor::testLimitValue(int limitIndex, btScalar test_value)
{
	btScalar loLimit = m_lowerLimit[limitIndex];
	btScalar hiLimit = m_upperLimit[limitIndex];
	if (loLimit > hiLimit)
	{
		m_currentLimit[limitIndex] = 0;  //Free from violation
		m_currentLimitError[limitIndex] = btScalar(0.f);
		return 0;
	}

	if (test_value < loLimit)
	{
		m_currentLimit[limitIndex] = 2;  //low limit violation
		m_currentLimitError[limitIndex] = test_value - loLimit;
		return 2;
	}
	else if (test_value > hiLimit)
	{
		m_currentLimit[limitIndex] = 1;  //High limit violation
		m_currentLimitError[limitIndex] = test_value - hiLimit;
		return 1;
	};

	m_currentLimit[limitIndex] = 0;  //Free from violation
	m_currentLimitError[limitIndex] = btScalar(0.f);
	return 0;
}

btScalar btTranslationalLimitMotor::solveLinearAxis(
	btScalar timeStep,
	btScalar jacDiagABInv,
	btRigidBody& body1, const btVector3& pointInA,
	btRigidBody& body2, const btVector3& pointInB,
	int limit_index,
	const btVector3& axis_normal_on_a,
	const btVector3& anchorPos)
{
	///find relative velocity
	//    btVector3 rel_pos1 = pointInA - body1.getCenterOfMassPosition();
	//    btVector3 rel_pos2 = pointInB - body2.getCenterOfMassPosition();
	btVector3 rel_pos1 = anchorPos - body1.getCenterOfMassPosition();
	btVector3 rel_pos2 = anchorPos - body2.getCenterOfMassPosition();

	btVector3 vel1 = body1.getVelocityInLocalPoint(rel_pos1);
	btVector3 vel2 = body2.getVelocityInLocalPoint(rel_pos2);
	btVector3 vel = vel1 - vel2;

	btScalar rel_vel = axis_normal_on_a.dot(vel);

	/// apply displacement correction

	//positional error (zeroth order error)
	btScalar depth = -(pointInA - pointInB).dot(axis_normal_on_a);
	btScalar lo = btScalar(-BT_LARGE_FLOAT);
	btScalar hi = btScalar(BT_LARGE_FLOAT);

	btScalar minLimit = m_lowerLimit[limit_index];
	btScalar maxLimit = m_upperLimit[limit_index];

	//handle the limits
	if (minLimit < maxLimit)
	{
		{
			if (depth > maxLimit)
			{
				depth -= maxLimit;
				lo = btScalar(0.);
			}
			else
			{
				if (depth < minLimit)
				{
					depth -= minLimit;
					hi = btScalar(0.);
				}
				else
				{
					return 0.0f;
				}
			}
		}
	}

	btScalar normalImpulse = m_limitSoftness * (m_restitution * depth / timeStep - m_damping * rel_vel) * jacDiagABInv;

	btScalar oldNormalImpulse = m_accumulatedImpulse[limit_index];
	btScalar sum = oldNormalImpulse + normalImpulse;
	m_accumulatedImpulse[limit_index] = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;
	normalImpulse = m_accumulatedImpulse[limit_index] - oldNormalImpulse;

	btVector3 impulse_vector = axis_normal_on_a * normalImpulse;
	body1.applyImpulse(impulse_vector, rel_pos1);
	body2.applyImpulse(-impulse_vector, rel_pos2);

	return normalImpulse;
}

//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////

void btGeneric6DofConstraint::calculateAngleInfo()
{
	btMatrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse() * m_calculatedTransformB.getBasis();
	matrixToEulerXYZ(relative_frame, m_calculatedAxisAngleDiff);
	// in euler angle mode we do not actually constrain the angular velocity
	// along the axes axis[0] and axis[2] (although we do use axis[1]) :
	//
	//    to get			constrain w2-w1 along		...not
	//    ------			---------------------		------
	//    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
	//    d(angle[1])/dt = 0	ax[1]
	//    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
	//
	// constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
	// to prove the result for angle[0], write the expression for angle[0] from
	// GetInfo1 then take the derivative. to prove this for angle[2] it is
	// easier to take the euler rate expression for d(angle[2])/dt with respect
	// to the components of w and set that to 0.
	btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
	btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);

	m_calculatedAxis[1] = axis2.cross(axis0);
	m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
	m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);

	m_calculatedAxis[0].normalize();
	m_calculatedAxis[1].normalize();
	m_calculatedAxis[2].normalize();
}

void btGeneric6DofConstraint::calculateTransforms()
{
	calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

void btGeneric6DofConstraint::calculateTransforms(const btTransform& transA, const btTransform& transB)
{
	m_calculatedTransformA = transA * m_frameInA;
	m_calculatedTransformB = transB * m_frameInB;
	calculateLinearInfo();
	calculateAngleInfo();
	if (m_useOffsetForConstraintFrame)
	{  //  get weight factors depending on masses
		btScalar miA = getRigidBodyA().getInvMass();
		btScalar miB = getRigidBodyB().getInvMass();
		m_hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
		btScalar miS = miA + miB;
		if (miS > btScalar(0.f))
		{
			m_factA = miB / miS;
		}
		else
		{
			m_factA = btScalar(0.5f);
		}
		m_factB = btScalar(1.0f) - m_factA;
	}
}

void btGeneric6DofConstraint::buildLinearJacobian(
	btJacobianEntry& jacLinear, const btVector3& normalWorld,
	const btVector3& pivotAInW, const btVector3& pivotBInW)
{
	new (&jacLinear) btJacobianEntry(
		m_rbA.getCenterOfMassTransform().getBasis().transpose(),
		m_rbB.getCenterOfMassTransform().getBasis().transpose(),
		pivotAInW - m_rbA.getCenterOfMassPosition(),
		pivotBInW - m_rbB.getCenterOfMassPosition(),
		normalWorld,
		m_rbA.getInvInertiaDiagLocal(),
		m_rbA.getInvMass(),
		m_rbB.getInvInertiaDiagLocal(),
		m_rbB.getInvMass());
}

void btGeneric6DofConstraint::buildAngularJacobian(
	btJacobianEntry& jacAngular, const btVector3& jointAxisW)
{
	new (&jacAngular) btJacobianEntry(jointAxisW,
									  m_rbA.getCenterOfMassTransform().getBasis().transpose(),
									  m_rbB.getCenterOfMassTransform().getBasis().transpose(),
									  m_rbA.getInvInertiaDiagLocal(),
									  m_rbB.getInvInertiaDiagLocal());
}

bool btGeneric6DofConstraint::testAngularLimitMotor(int axis_index)
{
	btScalar angle = m_calculatedAxisAngleDiff[axis_index];
	angle = btAdjustAngleToLimits(angle, m_angularLimits[axis_index].m_loLimit, m_angularLimits[axis_index].m_hiLimit);
	m_angularLimits[axis_index].m_currentPosition = angle;
	//test limits
	m_angularLimits[axis_index].testLimitValue(angle);
	return m_angularLimits[axis_index].needApplyTorques();
}

void btGeneric6DofConstraint::buildJacobian()
{
#ifndef __SPU__
	if (m_useSolveConstraintObsolete)
	{
		// Clear accumulated impulses for the next simulation step
		m_linearLimits.m_accumulatedImpulse.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
		int i;
		for (i = 0; i < 3; i++)
		{
			m_angularLimits[i].m_accumulatedImpulse = btScalar(0.);
		}
		//calculates transform
		calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());

		//  const btVector3& pivotAInW = m_calculatedTransformA.getOrigin();
		//  const btVector3& pivotBInW = m_calculatedTransformB.getOrigin();
		calcAnchorPos();
		btVector3 pivotAInW = m_AnchorPos;
		btVector3 pivotBInW = m_AnchorPos;

		// not used here
		//    btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
		//    btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

		btVector3 normalWorld;
		//linear part
		for (i = 0; i < 3; i++)
		{
			if (m_linearLimits.isLimited(i))
			{
				if (m_useLinearReferenceFrameA)
					normalWorld = m_calculatedTransformA.getBasis().getColumn(i);
				else
					normalWorld = m_calculatedTransformB.getBasis().getColumn(i);

				buildLinearJacobian(
					m_jacLinear[i], normalWorld,
					pivotAInW, pivotBInW);
			}
		}

		// angular part
		for (i = 0; i < 3; i++)
		{
			//calculates error angle
			if (testAngularLimitMotor(i))
			{
				normalWorld = this->getAxis(i);
				// Create angular atom
				buildAngularJacobian(m_jacAng[i], normalWorld);
			}
		}
	}
#endif  //__SPU__
}

void btGeneric6DofConstraint::getInfo1(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		//prepare constraint
		calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
		info->m_numConstraintRows = 0;
		info->nub = 6;
		int i;
		//test linear limits
		for (i = 0; i < 3; i++)
		{
			if (m_linearLimits.needApplyForce(i))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
		//test angular limits
		for (i = 0; i < 3; i++)
		{
			if (testAngularLimitMotor(i))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
	}
}

void btGeneric6DofConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		//pre-allocate all 6
		info->m_numConstraintRows = 6;
		info->nub = 0;
	}
}

void btGeneric6DofConstraint::getInfo2(btConstraintInfo2* info)
{
	btAssert(!m_useSolveConstraintObsolete);

	const btTransform& transA = m_rbA.getCenterOfMassTransform();
	const btTransform& transB = m_rbB.getCenterOfMassTransform();
	const btVector3& linVelA = m_rbA.getLinearVelocity();
	const btVector3& linVelB = m_rbB.getLinearVelocity();
	const btVector3& angVelA = m_rbA.getAngularVelocity();
	const btVector3& angVelB = m_rbB.getAngularVelocity();

	if (m_useOffsetForConstraintFrame)
	{  // for stability better to solve angular limits first
		int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
	else
	{  // leave old version for compatibility
		int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
}

void btGeneric6DofConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	btAssert(!m_useSolveConstraintObsolete);
	//prepare constraint
	calculateTransforms(transA, transB);

	int i;
	for (i = 0; i < 3; i++)
	{
		testAngularLimitMotor(i);
	}

	if (m_useOffsetForConstraintFrame)
	{  // for stability better to solve angular limits first
		int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
	else
	{  // leave old version for compatibility
		int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
}

int btGeneric6DofConstraint::setLinearLimits(btConstraintInfo2* info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	//	int row = 0;
	//solve linear limits
	btRotationalLimitMotor limot;
	for (int i = 0; i < 3; i++)
	{
		if (m_linearLimits.needApplyForce(i))
		{  // re-use rotational motor code
			limot.m_bounce = btScalar(0.f);
			limot.m_currentLimit = m_linearLimits.m_currentLimit[i];
			limot.m_currentPosition = m_linearLimits.m_currentLinearDiff[i];
			limot.m_currentLimitError = m_linearLimits.m_currentLimitError[i];
			limot.m_damping = m_linearLimits.m_damping;
			limot.m_enableMotor = m_linearLimits.m_enableMotor[i];
			limot.m_hiLimit = m_linearLimits.m_upperLimit[i];
			limot.m_limitSoftness = m_linearLimits.m_limitSoftness;
			limot.m_loLimit = m_linearLimits.m_lowerLimit[i];
			limot.m_maxLimitForce = btScalar(0.f);
			limot.m_maxMotorForce = m_linearLimits.m_maxMotorForce[i];
			limot.m_targetVelocity = m_linearLimits.m_targetVelocity[i];
			btVector3 axis = m_calculatedTransformA.getBasis().getColumn(i);
			int flags = m_flags >> (i * BT_6DOF_FLAGS_AXIS_SHIFT);
			limot.m_normalCFM = (flags & BT_6DOF_FLAGS_CFM_NORM) ? m_linearLimits.m_normalCFM[i] : info->cfm[0];
			limot.m_stopCFM = (flags & BT_6DOF_FLAGS_CFM_STOP) ? m_linearLimits.m_stopCFM[i] : info->cfm[0];
			limot.m_stopERP = (flags & BT_6DOF_FLAGS_ERP_STOP) ? m_linearLimits.m_stopERP[i] : info->erp;
			if (m_useOffsetForConstraintFrame)
			{
				int indx1 = (i + 1) % 3;
				int indx2 = (i + 2) % 3;
				int rotAllowed = 1;  // rotations around orthos to current axis
				if (m_angularLimits[indx1].m_currentLimit && m_angularLimits[indx2].m_currentLimit)
				{
					rotAllowed = 0;
				}
				row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0, rotAllowed);
			}
			else
			{
				row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0);
			}
		}
	}
	return row;
}

int btGeneric6DofConstraint::setAngularLimits(btConstraintInfo2* info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	btGeneric6DofConstraint* d6constraint = this;
	int row = row_offset;
	//solve angular limits
	for (int i = 0; i < 3; i++)
	{
		if (d6constraint->getRotationalLimitMotor(i)->needApplyTorques())
		{
			btVector3 axis = d6constraint->getAxis(i);
			int flags = m_flags >> ((i + 3) * BT_6DOF_FLAGS_AXIS_SHIFT);
			if (!(flags & BT_6DOF_FLAGS_CFM_NORM))
			{
				m_angularLimits[i].m_normalCFM = info->cfm[0];
			}
			if (!(flags & BT_6DOF_FLAGS_CFM_STOP))
			{
				m_angularLimits[i].m_stopCFM = info->cfm[0];
			}
			if (!(flags & BT_6DOF_FLAGS_ERP_STOP))
			{
				m_angularLimits[i].m_stopERP = info->erp;
			}
			row += get_limit_motor_info2(d6constraint->getRotationalLimitMotor(i),
										 transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 1);
		}
	}

	return row;
}

void btGeneric6DofConstraint::updateRHS(btScalar timeStep)
{
	(void)timeStep;
}

void btGeneric6DofConstraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
	m_frameInA = frameA;
	m_frameInB = frameB;
	buildJacobian();
	calculateTransforms();
}

btVector3 btGeneric6DofConstraint::getAxis(int axis_index) const
{
	return m_calculatedAxis[axis_index];
}

btScalar btGeneric6DofConstraint::getRelativePivotPosition(int axisIndex) const
{
	return m_calculatedLinearDiff[axisIndex];
}

btScalar btGeneric6DofConstraint::getAngle(int axisIndex) const
{
	return m_calculatedAxisAngleDiff[axisIndex];
}

void btGeneric6DofConstraint::calcAnchorPos(void)
{
	btScalar imA = m_rbA.getInvMass();
	btScalar imB = m_rbB.getInvMass();
	btScalar weight;
	if (imB == btScalar(0.0))
	{
		weight = btScalar(1.0);
	}
	else
	{
		weight = imA / (imA + imB);
	}
	const btVector3& pA = m_calculatedTransformA.getOrigin();
	const btVector3& pB = m_calculatedTransformB.getOrigin();
	m_AnchorPos = pA * weight + pB * (btScalar(1.0) - weight);
	return;
}

void btGeneric6DofConstraint::calculateLinearInfo()
{
	m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
	m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
	for (int i = 0; i < 3; i++)
	{
		m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
		m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
	}
}

int btGeneric6DofConstraint::get_limit_motor_info2(
	btRotationalLimitMotor* limot,
	const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
	btConstraintInfo2* info, int row, btVector3& ax1, int rotational, int rotAllowed)
{
	int srow = row * info->rowskip;
	bool powered = limot->m_enableMotor;
	int limit = limot->m_currentLimit;
	if (powered || limit)
	{  // if the joint is powered, or has joint limits, add in the extra row
		btScalar* J1 = rotational ? info->m_J1angularAxis : info->m_J1linearAxis;
		btScalar* J2 = rotational ? info->m_J2angularAxis : info->m_J2linearAxis;
		J1[srow + 0] = ax1[0];
		J1[srow + 1] = ax1[1];
		J1[srow + 2] = ax1[2];

		J2[srow + 0] = -ax1[0];
		J2[srow + 1] = -ax1[1];
		J2[srow + 2] = -ax1[2];

		if ((!rotational))
		{
			if (m_useOffsetForConstraintFrame)
			{
				btVector3 tmpA, tmpB, relA, relB;
				// get vector from bodyB to frameB in WCS
				relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
				// get its projection to constraint axis
				btVector3 projB = ax1 * relB.dot(ax1);
				// get vector directed from bodyB to constraint axis (and orthogonal to it)
				btVector3 orthoB = relB - projB;
				// same for bodyA
				relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
				btVector3 projA = ax1 * relA.dot(ax1);
				btVector3 orthoA = relA - projA;
				// get desired offset between frames A and B along constraint axis
				btScalar desiredOffs = limot->m_currentPosition - limot->m_currentLimitError;
				// desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis
				btVector3 totalDist = projA + ax1 * desiredOffs - projB;
				// get offset vectors relA and relB
				relA = orthoA + totalDist * m_factA;
				relB = orthoB - totalDist * m_factB;
				tmpA = relA.cross(ax1);
				tmpB = relB.cross(ax1);
				if (m_hasStaticBody && (!rotAllowed))
				{
					tmpA *= m_factA;
					tmpB *= m_factB;
				}
				int i;
				for (i = 0; i < 3; i++) info->m_J1angularAxis[srow + i] = tmpA[i];
				for (i = 0; i < 3; i++) info->m_J2angularAxis[srow + i] = -tmpB[i];
			}
			else
			{
				btVector3 ltd;  // Linear Torque Decoupling vector
				btVector3 c = m_calculatedTransformB.getOrigin() - transA.getOrigin();
				ltd = c.cross(ax1);
				info->m_J1angularAxis[srow + 0] = ltd[0];
				info->m_J1angularAxis[srow + 1] = ltd[1];
				info->m_J1angularAxis[srow + 2] = ltd[2];

				c = m_calculatedTransformB.getOrigin() - transB.getOrigin();
				ltd = -c.cross(ax1);
				info->m_J2angularAxis[srow + 0] = ltd[0];
				info->m_J2angularAxis[srow + 1] = ltd[1];
				info->m_J2angularAxis[srow + 2] = ltd[2];
			}
		}
		// if we're limited low and high simultaneously, the joint motor is
		// ineffective
		if (limit && (limot->m_loLimit == limot->m_hiLimit)) powered = false;
		info->m_constraintError[srow] = btScalar(0.f);
		if (powered)
		{
			info->cfm[srow] = limot->m_normalCFM;
			if (!limit)
			{
				btScalar tag_vel = rotational ? limot->m_targetVelocity : -limot->m_targetVelocity;

				btScalar mot_fact = getMotorFactor(limot->m_currentPosition,
												   limot->m_loLimit,
												   limot->m_hiLimit,
												   tag_vel,
												   info->fps * limot->m_stopERP);
				info->m_constraintError[srow] += mot_fact * limot->m_targetVelocity;
				info->m_lowerLimit[srow] = -limot->m_maxMotorForce / info->fps;
				info->m_upperLimit[srow] = limot->m_maxMotorForce / info->fps;
			}
		}
		if (limit)
		{
			btScalar k = info->fps * limot->m_stopERP;
			if (!rotational)
			{
				info->m_constraintError[srow] += k * limot->m_currentLimitError;
			}
			else
			{
				info->m_constraintError[srow] += -k * limot->m_currentLimitError;
			}
			info->cfm[srow] = limot->m_stopCFM;
			if (limot->m_loLimit == limot->m_hiLimit)
			{  // limited low and high simultaneously
				info->m_lowerLimit[srow] = -SIMD_INFINITY;
				info->m_upperLimit[srow] = SIMD_INFINITY;
			}
			else
			{
				if (limit == 1)
				{
					info->m_lowerLimit[srow] = 0;
					info->m_upperLimit[srow] = SIMD_INFINITY;
				}
				else
				{
					info->m_lowerLimit[srow] = -SIMD_INFINITY;
					info->m_upperLimit[srow] = 0;
				}
				// deal with bounce
				if (limot->m_bounce > 0)
				{
					// calculate joint velocity
					btScalar vel;
					if (rotational)
					{
						vel = angVelA.dot(ax1);
						//make sure that if no body -> angVelB == zero vec
						//                        if (body1)
						vel -= angVelB.dot(ax1);
					}
					else
					{
						vel = linVelA.dot(ax1);
						//make sure that if no body -> angVelB == zero vec
						//                        if (body1)
						vel -= linVelB.dot(ax1);
					}
					// only apply bounce if the velocity is incoming, and if the
					// resulting c[] exceeds what we already have.
					if (limit == 1)
					{
						if (vel < 0)
						{
							btScalar newc = -limot->m_bounce * vel;
							if (newc > info->m_constraintError[srow])
								info->m_constraintError[srow] = newc;
						}
					}
					else
					{
						if (vel > 0)
						{
							btScalar newc = -limot->m_bounce * vel;
							if (newc < info->m_constraintError[srow])
								info->m_constraintError[srow] = newc;
						}
					}
				}
			}
		}
		return 1;
	}
	else
		return 0;
}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
void btGeneric6DofConstraint::setParam(int num, btScalar value, int axis)
{
	if ((axis >= 0) && (axis < 3))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				m_linearLimits.m_stopERP[axis] = value;
				m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_STOP_CFM:
				m_linearLimits.m_stopCFM[axis] = value;
				m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_CFM:
				m_linearLimits.m_normalCFM[axis] = value;
				m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else if ((axis >= 3) && (axis < 6))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				m_angularLimits[axis - 3].m_stopERP = value;
				m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_STOP_CFM:
				m_angularLimits[axis - 3].m_stopCFM = value;
				m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_CFM:
				m_angularLimits[axis - 3].m_normalCFM = value;
				m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else
	{
		btAssertConstrParams(0);
	}
}

///return the local value of parameter
btScalar btGeneric6DofConstraint::getParam(int num, int axis) const
{
	btScalar retVal = 0;
	if ((axis >= 0) && (axis < 3))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_stopERP[axis];
				break;
			case BT_CONSTRAINT_STOP_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_stopCFM[axis];
				break;
			case BT_CONSTRAINT_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_normalCFM[axis];
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else if ((axis >= 3) && (axis < 6))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_stopERP;
				break;
			case BT_CONSTRAINT_STOP_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_stopCFM;
				break;
			case BT_CONSTRAINT_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_normalCFM;
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else
	{
		btAssertConstrParams(0);
	}
	return retVal;
}

void btGeneric6DofConstraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
	btVector3 zAxis = axis1.normalized();
	btVector3 yAxis = axis2.normalized();
	btVector3 xAxis = yAxis.cross(zAxis);  // we want right coordinate system

	btTransform frameInW;
	frameInW.setIdentity();
	frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
								 xAxis[1], yAxis[1], zAxis[1],
								 xAxis[2], yAxis[2], zAxis[2]);

	// now get constraint frame in local coordinate systems
	m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
	m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

	calculateTransforms();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/// 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/// Added support for generic constraint solver through getInfo1/getInfo2 methods

/*
2007-09-09
btGeneric6DofConstraint Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#ifndef BT_GENERIC_6DOF_CONSTRAINT_H
#define BT_GENERIC_6DOF_CONSTRAINT_H

#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

class btRigidBody;

#ifdef BT_USE_DOUBLE_PRECISION
#define btGeneric6DofConstraintData2 btGeneric6DofConstraintDoubleData2
#define btGeneric6DofConstraintDataName "btGeneric6DofConstraintDoubleData2"
#else
#define btGeneric6DofConstraintData2 btGeneric6DofConstraintData
#define btGeneric6DofConstraintDataName "btGeneric6DofConstraintData"
#endif  //BT_USE_DOUBLE_PRECISION

//! Rotation Limit structure for generic joints
class btRotationalLimitMotor
{
public:
	//! limit_parameters
	//!@{
	btScalar m_loLimit;         //!< joint limit
	btScalar m_hiLimit;         //!< joint limit
	btScalar m_targetVelocity;  //!< target motor velocity
	btScalar m_maxMotorForce;   //!< max force on motor
	btScalar m_maxLimitForce;   //!< max force on limit
	btScalar m_damping;         //!< Damping.
	btScalar m_limitSoftness;   //! Relaxation factor
	btScalar m_normalCFM;       //!< Constraint force mixing factor
	btScalar m_stopERP;         //!< Error tolerance factor when joint is at limit
	btScalar m_stopCFM;         //!< Constraint force mixing factor when joint is at limit
	btScalar m_bounce;          //!< restitution factor
	bool m_enableMotor;

	//!@}

	//! temp_variables
	//!@{
	btScalar m_currentLimitError;  //!  How much is violated this limit
	btScalar m_currentPosition;    //!  current value of angle
	int m_currentLimit;            //!< 0=free, 1=at lo limit, 2=at hi limit
	btScalar m_accumulatedImpulse;
	//!@}

	btRotationalLimitMotor()
	{
		m_accumulatedImpulse = 0.f;
		m_targetVelocity = 0;
		m_maxMotorForce = 6.0f;
		m_maxLimitForce = 300.0f;
		m_loLimit = 1.0f;
		m_hiLimit = -1.0f;
		m_normalCFM = 0.f;
		m_stopERP = 0.2f;
		m_stopCFM = 0.f;
		m_bounce = 0.0f;
		m_damping = 1.0f;
		m_limitSoftness = 0.5f;
		m_currentLimit = 0;
		m_currentLimitError = 0;
		m_enableMotor = false;
	}

	btRotationalLimitMotor(const btRotationalLimitMotor& limot)
	{
		m_targetVelocity = limot.m_targetVelocity;
		m_maxMotorForce = limot.m_maxMotorForce;
		m_limitSoftness = limot.m_limitSoftness;
		m_loLimit = limot.m_loLimit;
		m_hiLimit = limot.m_hiLimit;
		m_normalCFM = limot.m_normalCFM;
		m_stopERP = limot.m_stopERP;
		m_stopCFM = limot.m_stopCFM;
		m_bounce = limot.m_bounce;
		m_currentLimit = limot.m_currentLimit;
		m_currentLimitError = limot.m_currentLimitError;
		m_enableMotor = limot.m_enableMotor;
	}

	//! Is limited
	bool isLimited() const
	{
		if (m_loLimit > m_hiLimit) return false;
		return true;
	}

	//! Need apply correction
	bool needApplyTorques() const
	{
		if (m_currentLimit == 0 && m_enableMotor == false) return false;
		return true;
	}

	//! calculates  error
	/*!
	calculates m_currentLimit and m_currentLimitError.
	*/
	int testLimitValue(btScalar test_value);

	//! apply the correction impulses for two bodies
	btScalar solveAngularLimits(btScalar timeStep, btVector3& axis, btScalar jacDiagABInv, btRigidBody* body0, btRigidBody* body1);
};

class btTranslationalLimitMotor
{
public:
	btVector3 m_lowerLimit;  //!< the constraint lower limits
	btVector3 m_upperLimit;  //!< the constraint upper limits
	btVector3 m_accumulatedImpulse;
	//! Linear_Limit_parameters
	//!@{
	btScalar m_limitSoftness;  //!< Softness for linear limit
	btScalar m_damping;        //!< Damping for linear limit
	btScalar m_restitution;    //! Bounce parameter for linear limit
	btVector3 m_normalCFM;     //!< Constraint force mixing factor
	btVector3 m_stopERP;       //!< Error tolerance factor when joint is at limit
	btVector3 m_stopCFM;       //!< Constraint force mixing factor when joint is at limit
							   //!@}
	bool m_enableMotor[3];
	btVector3 m_targetVelocity;     //!< target motor velocity
	btVector3 m_maxMotorForce;      //!< max force on motor
	btVector3 m_currentLimitError;  //!  How much is violated this limit
	btVector3 m_currentLinearDiff;  //!  Current relative offset of constraint frames
	int m_currentLimit[3];          //!< 0=free, 1=at lower limit, 2=at upper limit

	btTranslationalLimitMotor()
	{
		m_lowerLimit.setValue(0.f, 0.f, 0.f);
		m_upperLimit.setValue(0.f, 0.f, 0.f);
		m_accumulatedImpulse.setValue(0.f, 0.f, 0.f);
		m_normalCFM.setValue(0.f, 0.f, 0.f);
		m_stopERP.setValue(0.2f, 0.2f, 0.2f);
		m_stopCFM.setValue(0.f, 0.f, 0.f);

		m_limitSoftness = 0.7f;
		m_damping = btScalar(1.0f);
		m_restitution = btScalar(0.5f);
		for (int i = 0; i < 3; i++)
		{
			m_enableMotor[i] = false;
			m_targetVelocity[i] = btScalar(0.f);
			m_maxMotorForce[i] = btScalar(0.f);
		}
	}

	btTranslationalLimitMotor(const btTranslationalLimitMotor& other)
	{
		m_lowerLimit = other.m_lowerLimit;
		m_upperLimit = other.m_upperLimit;
		m_accumulatedImpulse = other.m_accumulatedImpulse;

		m_limitSoftness = other.m_limitSoftness;
		m_damping = other.m_damping;
		m_restitution = other.m_restitution;
		m_normalCFM = other.m_normalCFM;
		m_stopERP = other.m_stopERP;
		m_stopCFM = other.m_stopCFM;

		for (int i = 0; i < 3; i++)
		{
			m_enableMotor[i] = other.m_enableMotor[i];
			m_targetVelocity[i] = other.m_targetVelocity[i];
			m_maxMotorForce[i] = other.m_maxMotorForce[i];
		}
	}

	//! Test limit
	/*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	inline bool isLimited(int limitIndex) const
	{
		return (m_upperLimit[limitIndex] >= m_lowerLimit[limitIndex]);
	}
	inline bool needApplyForce(int limitIndex) const
	{
		if (m_currentLimit[limitIndex] == 0 && m_enableMotor[limitIndex] == false) return false;
		return true;
	}
	int testLimitValue(int limitIndex, btScalar test_value);

	btScalar solveLinearAxis(
		btScalar timeStep,
		btScalar jacDiagABInv,
		btRigidBody& body1, const btVector3& pointInA,
		btRigidBody& body2, const btVector3& pointInB,
		int limit_index,
		const btVector3& axis_normal_on_a,
		const btVector3& anchorPos);
};

enum bt6DofFlags
{
	BT_6DOF_FLAGS_CFM_NORM = 1,
	BT_6DOF_FLAGS_CFM_STOP = 2,
	BT_6DOF_FLAGS_ERP_STOP = 4
};
#define BT_6DOF_FLAGS_AXIS_SHIFT 3  // bits per axis

/// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/*!
btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
currently this limit supports rotational motors<br>
<ul>
<li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
At this moment translational motors are not supported. May be in the future. </li>

<li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
This is accessible through btGeneric6DofConstraint.getLimitMotor method,
This brings support for limit parameters and motors. </li>

<li> Angulars limits have these possible ranges:
<table border=1 >
<tr>
	<td><b>AXIS</b></td>
	<td><b>MIN ANGLE</b></td>
	<td><b>MAX ANGLE</b></td>
</tr><tr>
	<td>X</td>
	<td>-PI</td>
	<td>PI</td>
</tr><tr>
	<td>Y</td>
	<td>-PI/2</td>
	<td>PI/2</td>
</tr><tr>
	<td>Z</td>
	<td>-PI</td>
	<td>PI</td>
</tr>
</table>
</li>
</ul>

*/
ATTRIBUTE_ALIGNED16(class)
btGeneric6DofConstraint : public btTypedConstraint
{
protected:
	//! relative_frames
	//!@{
	btTransform m_frameInA;  //!< the constraint space w.r.t body A
	btTransform m_frameInB;  //!< the constraint space w.r.t body B
	//!@}

	//! Jacobians
	//!@{
	btJacobianEntry m_jacLinear[3];  //!< 3 orthogonal linear constraints
	btJacobianEntry m_jacAng[3];     //!< 3 orthogonal angular constraints
	//!@}

	//! Linear_Limit_parameters
	//!@{
	btTranslationalLimitMotor m_linearLimits;
	//!@}

	//! hinge_parameters
	//!@{
	btRotationalLimitMotor m_angularLimits[3];
	//!@}

protected:
	//! temporal variables
	//!@{
	btScalar m_timeStep;
	btTransform m_calculatedTransformA;
	btTransform m_calculatedTransformB;
	btVector3 m_calculatedAxisAngleDiff;
	btVector3 m_calculatedAxis[3];
	btVector3 m_calculatedLinearDiff;
	btScalar m_factA;
	btScalar m_factB;
	bool m_hasStaticBody;

	btVector3 m_AnchorPos;  // point betwen pivots of bodies A and B to solve linear axes

	bool m_useLinearReferenceFrameA;
	bool m_useOffsetForConstraintFrame;

	int m_flags;

	//!@}

	btGeneric6DofConstraint& operator=(btGeneric6DofConstraint& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

	int setAngularLimits(btConstraintInfo2 * info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	int setLinearLimits(btConstraintInfo2 * info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	void buildLinearJacobian(
		btJacobianEntry & jacLinear, const btVector3& normalWorld,
		const btVector3& pivotAInW, const btVector3& pivotBInW);

	void buildAngularJacobian(btJacobianEntry & jacAngular, const btVector3& jointAxisW);

	// tests linear limits
	void calculateLinearInfo();

	//! calcs the euler angles between the two bodies.
	void calculateAngleInfo();

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///for backwards compatibility during the transition to 'getInfo/getInfo2'
	bool m_useSolveConstraintObsolete;

	btGeneric6DofConstraint(btRigidBody & rbA, btRigidBody & rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA);
	btGeneric6DofConstraint(btRigidBody & rbB, const btTransform& frameInB, bool useLinearReferenceFrameB);

	//! Calcs global transform of the offsets
	/*!
	Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
	\sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
	*/
	void calculateTransforms(const btTransform& transA, const btTransform& transB);

	void calculateTransforms();

	//! Gets the global transform of the offset for body A
	/*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	const btTransform& getCalculatedTransformA() const
	{
		return m_calculatedTransformA;
	}

	//! Gets the global transform of the offset for body B
	/*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	const btTransform& getCalculatedTransformB() const
	{
		return m_calculatedTransformB;
	}

	const btTransform& getFrameOffsetA() const
	{
		return m_frameInA;
	}

	const btTransform& getFrameOffsetB() const
	{
		return m_frameInB;
	}

	btTransform& getFrameOffsetA()
	{
		return m_frameInA;
	}

	btTransform& getFrameOffsetB()
	{
		return m_frameInB;
	}

	//! performs Jacobian calculation, and also calculates angle differences and axis
	virtual void buildJacobian();

	virtual void getInfo1(btConstraintInfo1 * info);

	void getInfo1NonVirtual(btConstraintInfo1 * info);

	virtual void getInfo2(btConstraintInfo2 * info);

	void getInfo2NonVirtual(btConstraintInfo2 * info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	void updateRHS(btScalar timeStep);

	//! Get the rotation axis in global coordinates
	/*!
	\pre btGeneric6DofConstraint.buildJacobian must be called previously.
	*/
	btVector3 getAxis(int axis_index) const;

	//! Get the relative Euler angle
	/*!
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	btScalar getAngle(int axis_index) const;

	//! Get the relative position of the constraint pivot
	/*!
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	btScalar getRelativePivotPosition(int axis_index) const;

	void setFrames(const btTransform& frameA, const btTransform& frameB);

	//! Test angular limit.
	/*!
	Calculates angular correction and returns true if limit needs to be corrected.
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	bool testAngularLimitMotor(int axis_index);

	void setLinearLowerLimit(const btVector3& linearLower)
	{
		m_linearLimits.m_lowerLimit = linearLower;
	}

	void getLinearLowerLimit(btVector3 & linearLower) const
	{
		linearLower = m_linearLimits.m_lowerLimit;
	}

	void setLinearUpperLimit(const btVector3& linearUpper)
	{
		m_linearLimits.m_upperLimit = linearUpper;
	}

	void getLinearUpperLimit(btVector3 & linearUpper) const
	{
		linearUpper = m_linearLimits.m_upperLimit;
	}

	void setAngularLowerLimit(const btVector3& angularLower)
	{
		for (int i = 0; i < 3; i++)
			m_angularLimits[i].m_loLimit = btNormalizeAngle(angularLower[i]);
	}

	void getAngularLowerLimit(btVector3 & angularLower) const
	{
		for (int i = 0; i < 3; i++)
			angularLower[i] = m_angularLimits[i].m_loLimit;
	}

	void setAngularUpperLimit(const btVector3& angularUpper)
	{
		for (int i = 0; i < 3; i++)
			m_angularLimits[i].m_hiLimit = btNormalizeAngle(angularUpper[i]);
	}

	void getAngularUpperLimit(btVector3 & angularUpper) const
	{
		for (int i = 0; i < 3; i++)
			angularUpper[i] = m_angularLimits[i].m_hiLimit;
	}

	//! Retrieves the angular limit informacion
	btRotationalLimitMotor* getRotationalLimitMotor(int index)
	{
		return &m_angularLimits[index];
	}

	//! Retrieves the  limit informacion
	btTranslationalLimitMotor* getTranslationalLimitMotor()
	{
		return &m_linearLimits;
	}

	//first 3 are linear, next 3 are angular
	void setLimit(int axis, btScalar lo, btScalar hi)
	{
		if (axis < 3)
		{
			m_linearLimits.m_lowerLimit[axis] = lo;
			m_linearLimits.m_upperLimit[axis] = hi;
		}
		else
		{
			lo = btNormalizeAngle(lo);
			hi = btNormalizeAngle(hi);
			m_angularLimits[axis - 3].m_loLimit = lo;
			m_angularLimits[axis - 3].m_hiLimit = hi;
		}
	}

	//! Test limit
	/*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	bool isLimited(int limitIndex) const
	{
		if (limitIndex < 3)
		{
			return m_linearLimits.isLimited(limitIndex);
		}
		return m_angularLimits[limitIndex - 3].isLimited();
	}

	virtual void calcAnchorPos(void);  // overridable

	int get_limit_motor_info2(btRotationalLimitMotor * limot,
							  const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
							  btConstraintInfo2* info, int row, btVector3& ax1, int rotational, int rotAllowed = false);

	// access for UseFrameOffset
	bool getUseFrameOffset() const { return m_useOffsetForConstraintFrame; }
	void setUseFrameOffset(bool frameOffsetOnOff) { m_useOffsetForConstraintFrame = frameOffsetOnOff; }

	bool getUseLinearReferenceFrameA() const { return m_useLinearReferenceFrameA; }
	void setUseLinearReferenceFrameA(bool linearReferenceFrameA) { m_useLinearReferenceFrameA = linearReferenceFrameA; }

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1);
	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const;

	void setAxis(const btVector3& axis1, const btVector3& axis2);

	virtual int getFlags() const
	{
		return m_flags;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

struct btGeneric6DofConstraintData
{
	btTypedConstraintData m_typeConstraintData;
	btTransformFloatData m_rbAFrame;  // constraint axii. Assumes z is hinge axis.
	btTransformFloatData m_rbBFrame;

	btVector3FloatData m_linearUpperLimit;
	btVector3FloatData m_linearLowerLimit;

	btVector3FloatData m_angularUpperLimit;
	btVector3FloatData m_angularLowerLimit;

	int m_useLinearReferenceFrameA;
	int m_useOffsetForConstraintFrame;
};

struct btGeneric6DofConstraintDoubleData2
{
	btTypedConstraintDoubleData m_typeConstraintData;
	btTransformDoubleData m_rbAFrame;  // constraint axii. Assumes z is hinge axis.
	btTransformDoubleData m_rbBFrame;

	btVector3DoubleData m_linearUpperLimit;
	btVector3DoubleData m_linearLowerLimit;

	btVector3DoubleData m_angularUpperLimit;
	btVector3DoubleData m_angularLowerLimit;

	int m_useLinearReferenceFrameA;
	int m_useOffsetForConstraintFrame;
};

SIMD_FORCE_INLINE int btGeneric6DofConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btGeneric6DofConstraintData2);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btGeneric6DofConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btGeneric6DofConstraintData2* dof = (btGeneric6DofConstraintData2*)dataBuffer;
	btTypedConstraint::serialize(&dof->m_typeConstraintData, serializer);

	m_frameInA.serialize(dof->m_rbAFrame);
	m_frameInB.serialize(dof->m_rbBFrame);

	int i;
	for (i = 0; i < 3; i++)
	{
		dof->m_angularLowerLimit.m_floats[i] = m_angularLimits[i].m_loLimit;
		dof->m_angularUpperLimit.m_floats[i] = m_angularLimits[i].m_hiLimit;
		dof->m_linearLowerLimit.m_floats[i] = m_linearLimits.m_lowerLimit[i];
		dof->m_linearUpperLimit.m_floats[i] = m_linearLimits.m_upperLimit[i];
	}

	dof->m_useLinearReferenceFrameA = m_useLinearReferenceFrameA ? 1 : 0;
	dof->m_useOffsetForConstraintFrame = m_useOffsetForConstraintFrame ? 1 : 0;

	return btGeneric6DofConstraintDataName;
}

#endif  //BT_GENERIC_6DOF_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/

#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMinMax.h"

//#define CONETWIST_USE_OBSOLETE_SOLVER true
#define CONETWIST_USE_OBSOLETE_SOLVER false
#define CONETWIST_DEF_FIX_THRESH btScalar(.05f)

SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis, const btMatrix3x3& invInertiaWorld)
{
	btVector3 vec = axis * invInertiaWorld;
	return axis.dot(vec);
}

btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, btRigidBody& rbB,
											 const btTransform& rbAFrame, const btTransform& rbBFrame)
	: btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA, rbB), m_rbAFrame(rbAFrame), m_rbBFrame(rbBFrame), m_angularOnly(false), m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
	init();
}

btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, const btTransform& rbAFrame)
	: btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA), m_rbAFrame(rbAFrame), m_angularOnly(false), m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
	m_rbBFrame = m_rbAFrame;
	m_rbBFrame.setOrigin(btVector3(0., 0., 0.));
	init();
}

void btConeTwistConstraint::init()
{
	m_angularOnly = false;
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;
	m_bMotorEnabled = false;
	m_maxMotorImpulse = btScalar(-1);

	setLimit(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
	m_damping = btScalar(0.01);
	m_fixThresh = CONETWIST_DEF_FIX_THRESH;
	m_flags = 0;
	m_linCFM = btScalar(0.f);
	m_linERP = btScalar(0.7f);
	m_angCFM = btScalar(0.f);
}

void btConeTwistConstraint::getInfo1(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		info->m_numConstraintRows = 3;
		info->nub = 3;
		calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
		if (m_solveSwingLimit)
		{
			info->m_numConstraintRows++;
			info->nub--;
			if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
		if (m_solveTwistLimit)
		{
			info->m_numConstraintRows++;
			info->nub--;
		}
	}
}

void btConeTwistConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
	//always reserve 6 rows: object transform is not available on SPU
	info->m_numConstraintRows = 6;
	info->nub = 0;
}

void btConeTwistConstraint::getInfo2(btConstraintInfo2* info)
{
	getInfo2NonVirtual(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
}

void btConeTwistConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
	calcAngleInfo2(transA, transB, invInertiaWorldA, invInertiaWorldB);

	btAssert(!m_useSolveConstraintObsolete);
	// set jacobian
	info->m_J1linearAxis[0] = 1;
	info->m_J1linearAxis[info->rowskip + 1] = 1;
	info->m_J1linearAxis[2 * info->rowskip + 2] = 1;
	btVector3 a1 = transA.getBasis() * m_rbAFrame.getOrigin();
	{
		btVector3* angular0 = (btVector3*)(info->m_J1angularAxis);
		btVector3* angular1 = (btVector3*)(info->m_J1angularAxis + info->rowskip);
		btVector3* angular2 = (btVector3*)(info->m_J1angularAxis + 2 * info->rowskip);
		btVector3 a1neg = -a1;
		a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
	}
	info->m_J2linearAxis[0] = -1;
	info->m_J2linearAxis[info->rowskip + 1] = -1;
	info->m_J2linearAxis[2 * info->rowskip + 2] = -1;
	btVector3 a2 = transB.getBasis() * m_rbBFrame.getOrigin();
	{
		btVector3* angular0 = (btVector3*)(info->m_J2angularAxis);
		btVector3* angular1 = (btVector3*)(info->m_J2angularAxis + info->rowskip);
		btVector3* angular2 = (btVector3*)(info->m_J2angularAxis + 2 * info->rowskip);
		a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
	}
	// set right hand side
	btScalar linERP = (m_flags & BT_CONETWIST_FLAGS_LIN_ERP) ? m_linERP : info->erp;
	btScalar k = info->fps * linERP;
	int j;
	for (j = 0; j < 3; j++)
	{
		info->m_constraintError[j * info->rowskip] = k * (a2[j] + transB.getOrigin()[j] - a1[j] - transA.getOrigin()[j]);
		info->m_lowerLimit[j * info->rowskip] = -SIMD_INFINITY;
		info->m_upperLimit[j * info->rowskip] = SIMD_INFINITY;
		if (m_flags & BT_CONETWIST_FLAGS_LIN_CFM)
		{
			info->cfm[j * info->rowskip] = m_linCFM;
		}
	}
	int row = 3;
	int srow = row * info->rowskip;
	btVector3 ax1;
	// angular limits
	if (m_solveSwingLimit)
	{
		btScalar* J1 = info->m_J1angularAxis;
		btScalar* J2 = info->m_J2angularAxis;
		if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
		{
			btTransform trA = transA * m_rbAFrame;
			btVector3 p = trA.getBasis().getColumn(1);
			btVector3 q = trA.getBasis().getColumn(2);
			int srow1 = srow + info->rowskip;
			J1[srow + 0] = p[0];
			J1[srow + 1] = p[1];
			J1[srow + 2] = p[2];
			J1[srow1 + 0] = q[0];
			J1[srow1 + 1] = q[1];
			J1[srow1 + 2] = q[2];
			J2[srow + 0] = -p[0];
			J2[srow + 1] = -p[1];
			J2[srow + 2] = -p[2];
			J2[srow1 + 0] = -q[0];
			J2[srow1 + 1] = -q[1];
			J2[srow1 + 2] = -q[2];
			btScalar fact = info->fps * m_relaxationFactor;
			info->m_constraintError[srow] = fact * m_swingAxis.dot(p);
			info->m_constraintError[srow1] = fact * m_swingAxis.dot(q);
			info->m_lowerLimit[srow] = -SIMD_INFINITY;
			info->m_upperLimit[srow] = SIMD_INFINITY;
			info->m_lowerLimit[srow1] = -SIMD_INFINITY;
			info->m_upperLimit[srow1] = SIMD_INFINITY;
			srow = srow1 + info->rowskip;
		}
		else
		{
			ax1 = m_swingAxis * m_relaxationFactor * m_relaxationFactor;
			J1[srow + 0] = ax1[0];
			J1[srow + 1] = ax1[1];
			J1[srow + 2] = ax1[2];
			J2[srow + 0] = -ax1[0];
			J2[srow + 1] = -ax1[1];
			J2[srow + 2] = -ax1[2];
			btScalar k = info->fps * m_biasFactor;

			info->m_constraintError[srow] = k * m_swingCorrection;
			if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
			{
				info->cfm[srow] = m_angCFM;
			}
			// m_swingCorrection is always positive or 0
			info->m_lowerLimit[srow] = 0;
			info->m_upperLimit[srow] = (m_bMotorEnabled && m_maxMotorImpulse >= 0.0f) ? m_maxMotorImpulse : SIMD_INFINITY;
			srow += info->rowskip;
		}
	}
	if (m_solveTwistLimit)
	{
		ax1 = m_twistAxis * m_relaxationFactor * m_relaxationFactor;
		btScalar* J1 = info->m_J1angularAxis;
		btScalar* J2 = info->m_J2angularAxis;
		J1[srow + 0] = ax1[0];
		J1[srow + 1] = ax1[1];
		J1[srow + 2] = ax1[2];
		J2[srow + 0] = -ax1[0];
		J2[srow + 1] = -ax1[1];
		J2[srow + 2] = -ax1[2];
		btScalar k = info->fps * m_biasFactor;
		info->m_constraintError[srow] = k * m_twistCorrection;
		if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
		{
			info->cfm[srow] = m_angCFM;
		}
		if (m_twistSpan > 0.0f)
		{
			if (m_twistCorrection > 0.0f)
			{
				info->m_lowerLimit[srow] = 0;
				info->m_upperLimit[srow] = SIMD_INFINITY;
			}
			else
			{
				info->m_lowerLimit[srow] = -SIMD_INFINITY;
				info->m_upperLimit[srow] = 0;
			}
		}
		else
		{
			info->m_lowerLimit[srow] = -SIMD_INFINITY;
			info->m_upperLimit[srow] = SIMD_INFINITY;
		}
		srow += info->rowskip;
	}
}

void btConeTwistConstraint::buildJacobian()
{
	if (m_useSolveConstraintObsolete)
	{
		m_appliedImpulse = btScalar(0.);
		m_accTwistLimitImpulse = btScalar(0.);
		m_accSwingLimitImpulse = btScalar(0.);
		m_accMotorImpulse = btVector3(0., 0., 0.);

		if (!m_angularOnly)
		{
			btVector3 pivotAInW = m_rbA.getCenterOfMassTransform() * m_rbAFrame.getOrigin();
			btVector3 pivotBInW = m_rbB.getCenterOfMassTransform() * m_rbBFrame.getOrigin();
			btVector3 relPos = pivotBInW - pivotAInW;

			btVector3 normal[3];
			if (relPos.length2() > SIMD_EPSILON)
			{
				normal[0] = relPos.normalized();
			}
			else
			{
				normal[0].setValue(btScalar(1.0), 0, 0);
			}

			btPlaneSpace1(normal[0], normal[1], normal[2]);

			for (int i = 0; i < 3; i++)
			{
				new (&m_jac[i]) btJacobianEntry(
					m_rbA.getCenterOfMassTransform().getBasis().transpose(),
					m_rbB.getCenterOfMassTransform().getBasis().transpose(),
					pivotAInW - m_rbA.getCenterOfMassPosition(),
					pivotBInW - m_rbB.getCenterOfMassPosition(),
					normal[i],
					m_rbA.getInvInertiaDiagLocal(),
					m_rbA.getInvMass(),
					m_rbB.getInvInertiaDiagLocal(),
					m_rbB.getInvMass());
			}
		}

		calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
	}
}

void btConeTwistConstraint::solveConstraintObsolete(btSolverBody& bodyA, btSolverBody& bodyB, btScalar timeStep)
{
#ifndef __SPU__
	if (m_useSolveConstraintObsolete)
	{
		btVector3 pivotAInW = m_rbA.getCenterOfMassTransform() * m_rbAFrame.getOrigin();
		btVector3 pivotBInW = m_rbB.getCenterOfMassTransform() * m_rbBFrame.getOrigin();

		btScalar tau = btScalar(0.3);

		//linear part
		if (!m_angularOnly)
		{
			btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
			btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

			btVector3 vel1;
			bodyA.internalGetVelocityInLocalPointObsolete(rel_pos1, vel1);
			btVector3 vel2;
			bodyB.internalGetVelocityInLocalPointObsolete(rel_pos2, vel2);
			btVector3 vel = vel1 - vel2;

			for (int i = 0; i < 3; i++)
			{
				const btVector3& normal = m_jac[i].m_linearJointAxis;
				btScalar jacDiagABInv = btScalar(1.) / m_jac[i].getDiagonal();

				btScalar rel_vel;
				rel_vel = normal.dot(vel);
				//positional error (zeroth order error)
				btScalar depth = -(pivotAInW - pivotBInW).dot(normal);  //this is the error projected on the normal
				btScalar impulse = depth * tau / timeStep * jacDiagABInv - rel_vel * jacDiagABInv;
				m_appliedImpulse += impulse;

				btVector3 ftorqueAxis1 = rel_pos1.cross(normal);
				btVector3 ftorqueAxis2 = rel_pos2.cross(normal);
				bodyA.internalApplyImpulse(normal * m_rbA.getInvMass(), m_rbA.getInvInertiaTensorWorld() * ftorqueAxis1, impulse);
				bodyB.internalApplyImpulse(normal * m_rbB.getInvMass(), m_rbB.getInvInertiaTensorWorld() * ftorqueAxis2, -impulse);
			}
		}

		// apply motor
		if (m_bMotorEnabled)
		{
			// compute current and predicted transforms
			btTransform trACur = m_rbA.getCenterOfMassTransform();
			btTransform trBCur = m_rbB.getCenterOfMassTransform();
			btVector3 omegaA;
			bodyA.internalGetAngularVelocity(omegaA);
			btVector3 omegaB;
			bodyB.internalGetAngularVelocity(omegaB);
			btTransform trAPred;
			trAPred.setIdentity();
			btVector3 zerovec(0, 0, 0);
			btTransformUtil::integrateTransform(
				trACur, zerovec, omegaA, timeStep, trAPred);
			btTransform trBPred;
			trBPred.setIdentity();
			btTransformUtil::integrateTransform(
				trBCur, zerovec, omegaB, timeStep, trBPred);

			// compute desired transforms in world
			btTransform trPose(m_qTarget);
			btTransform trABDes = m_rbBFrame * trPose * m_rbAFrame.inverse();
			btTransform trADes = trBPred * trABDes;
			btTransform trBDes = trAPred * trABDes.inverse();

			// compute desired omegas in world
			btVector3 omegaADes, omegaBDes;

			btTransformUtil::calculateVelocity(trACur, trADes, timeStep, zerovec, omegaADes);
			btTransformUtil::calculateVelocity(trBCur, trBDes, timeStep, zerovec, omegaBDes);

			// compute delta omegas
			btVector3 dOmegaA = omegaADes - omegaA;
			btVector3 dOmegaB = omegaBDes - omegaB;

			// compute weighted avg axis of dOmega (weighting based on inertias)
			btVector3 axisA, axisB;
			btScalar kAxisAInv = 0, kAxisBInv = 0;

			if (dOmegaA.length2() > SIMD_EPSILON)
			{
				axisA = dOmegaA.normalized();
				kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(axisA);
			}

			if (dOmegaB.length2() > SIMD_EPSILON)
			{
				axisB = dOmegaB.normalized();
				kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(axisB);
			}

			btVector3 avgAxis = kAxisAInv * axisA + kAxisBInv * axisB;

			static bool bDoTorque = true;
			if (bDoTorque && avgAxis.length2() > SIMD_EPSILON)
			{
				avgAxis.normalize();
				kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(avgAxis);
				kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(avgAxis);
				btScalar kInvCombined = kAxisAInv + kAxisBInv;

				btVector3 impulse = (kAxisAInv * dOmegaA - kAxisBInv * dOmegaB) /
									(kInvCombined * kInvCombined);

				if (m_maxMotorImpulse >= 0)
				{
					btScalar fMaxImpulse = m_maxMotorImpulse;
					if (m_bNormalizedMotorStrength)
						fMaxImpulse = fMaxImpulse / kAxisAInv;

					btVector3 newUnclampedAccImpulse = m_accMotorImpulse + impulse;
					btScalar newUnclampedMag = newUnclampedAccImpulse.length();
					if (newUnclampedMag > fMaxImpulse)
					{
						newUnclampedAccImpulse.normalize();
						newUnclampedAccImpulse *= fMaxImpulse;
						impulse = newUnclampedAccImpulse - m_accMotorImpulse;
					}
					m_accMotorImpulse += impulse;
				}

				btScalar impulseMag = impulse.length();
				btVector3 impulseAxis = impulse / impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * impulseAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * impulseAxis, -impulseMag);
			}
		}
		else if (m_damping > SIMD_EPSILON)  // no motor: do a little damping
		{
			btVector3 angVelA;
			bodyA.internalGetAngularVelocity(angVelA);
			btVector3 angVelB;
			bodyB.internalGetAngularVelocity(angVelB);
			btVector3 relVel = angVelB - angVelA;
			if (relVel.length2() > SIMD_EPSILON)
			{
				btVector3 relVelAxis = relVel.normalized();
				btScalar m_kDamping = btScalar(1.) /
									  (getRigidBodyA().computeAngularImpulseDenominator(relVelAxis) +
									   getRigidBodyB().computeAngularImpulseDenominator(relVelAxis));
				btVector3 impulse = m_damping * m_kDamping * relVel;

				btScalar impulseMag = impulse.length();
				btVector3 impulseAxis = impulse / impulseMag;
				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * impulseAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * impulseAxis, -impulseMag);
			}
		}

		// joint limits
		{
			///solve angular part
			btVector3 angVelA;
			bodyA.internalGetAngularVelocity(angVelA);
			btVector3 angVelB;
			bodyB.internalGetAngularVelocity(angVelB);

			// solve swing limit
			if (m_solveSwingLimit)
			{
				btScalar amplitude = m_swingLimitRatio * m_swingCorrection * m_biasFactor / timeStep;
				btScalar relSwingVel = (angVelB - angVelA).dot(m_swingAxis);
				if (relSwingVel > 0)
					amplitude += m_swingLimitRatio * relSwingVel * m_relaxationFactor;
				btScalar impulseMag = amplitude * m_kSwing;

				// Clamp the accumulated impulse
				btScalar temp = m_accSwingLimitImpulse;
				m_accSwingLimitImpulse = btMax(m_accSwingLimitImpulse + impulseMag, btScalar(0.0));
				impulseMag = m_accSwingLimitImpulse - temp;

				btVector3 impulse = m_swingAxis * impulseMag;

				// don't let cone response affect twist
				// (this can happen since body A's twist doesn't match body B's AND we use an elliptical cone limit)
				{
					btVector3 impulseTwistCouple = impulse.dot(m_twistAxisA) * m_twistAxisA;
					btVector3 impulseNoTwistCouple = impulse - impulseTwistCouple;
					impulse = impulseNoTwistCouple;
				}

				impulseMag = impulse.length();
				btVector3 noTwistSwingAxis = impulse / impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * noTwistSwingAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * noTwistSwingAxis, -impulseMag);
			}

			// solve twist limit
			if (m_solveTwistLimit)
			{
				btScalar amplitude = m_twistLimitRatio * m_twistCorrection * m_biasFactor / timeStep;
				btScalar relTwistVel = (angVelB - angVelA).dot(m_twistAxis);
				if (relTwistVel > 0)  // only damp when moving towards limit (m_twistAxis flipping is important)
					amplitude += m_twistLimitRatio * relTwistVel * m_relaxationFactor;
				btScalar impulseMag = amplitude * m_kTwist;

				// Clamp the accumulated impulse
				btScalar temp = m_accTwistLimitImpulse;
				m_accTwistLimitImpulse = btMax(m_accTwistLimitImpulse + impulseMag, btScalar(0.0));
				impulseMag = m_accTwistLimitImpulse - temp;

				//		btVector3 impulse = m_twistAxis * impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * m_twistAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * m_twistAxis, -impulseMag);
			}
		}
	}
#else
	btAssert(0);
#endif  //__SPU__
}

void btConeTwistConstraint::updateRHS(btScalar timeStep)
{
	(void)timeStep;
}

#ifndef __SPU__
void btConeTwistConstraint::calcAngleInfo()
{
	m_swingCorrection = btScalar(0.);
	m_twistLimitSign = btScalar(0.);
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;

	btVector3 b1Axis1(0, 0, 0), b1Axis2(0, 0, 0), b1Axis3(0, 0, 0);
	btVector3 b2Axis1(0, 0, 0), b2Axis2(0, 0, 0);

	b1Axis1 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(0);
	b2Axis1 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(0);

	btScalar swing1 = btScalar(0.), swing2 = btScalar(0.);

	btScalar swx = btScalar(0.), swy = btScalar(0.);
	btScalar thresh = btScalar(10.);
	btScalar fact;

	// Get Frame into world space
	if (m_swingSpan1 >= btScalar(0.05f))
	{
		b1Axis2 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(1);
		swx = b2Axis1.dot(b1Axis1);
		swy = b2Axis1.dot(b1Axis2);
		swing1 = btAtan2Fast(swy, swx);
		fact = (swy * swy + swx * swx) * thresh * thresh;
		fact = fact / (fact + btScalar(1.0));
		swing1 *= fact;
	}

	if (m_swingSpan2 >= btScalar(0.05f))
	{
		b1Axis3 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(2);
		swx = b2Axis1.dot(b1Axis1);
		swy = b2Axis1.dot(b1Axis3);
		swing2 = btAtan2Fast(swy, swx);
		fact = (swy * swy + swx * swx) * thresh * thresh;
		fact = fact / (fact + btScalar(1.0));
		swing2 *= fact;
	}

	btScalar RMaxAngle1Sq = 1.0f / (m_swingSpan1 * m_swingSpan1);
	btScalar RMaxAngle2Sq = 1.0f / (m_swingSpan2 * m_swingSpan2);
	btScalar EllipseAngle = btFabs(swing1 * swing1) * RMaxAngle1Sq + btFabs(swing2 * swing2) * RMaxAngle2Sq;

	if (EllipseAngle > 1.0f)
	{
		m_swingCorrection = EllipseAngle - 1.0f;
		m_solveSwingLimit = true;
		// Calculate necessary axis & factors
		m_swingAxis = b2Axis1.cross(b1Axis2 * b2Axis1.dot(b1Axis2) + b1Axis3 * b2Axis1.dot(b1Axis3));
		m_swingAxis.normalize();
		btScalar swingAxisSign = (b2Axis1.dot(b1Axis1) >= 0.0f) ? 1.0f : -1.0f;
		m_swingAxis *= swingAxisSign;
	}

	// Twist limits
	if (m_twistSpan >= btScalar(0.))
	{
		btVector3 b2Axis2 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(1);
		btQuaternion rotationArc = shortestArcQuat(b2Axis1, b1Axis1);
		btVector3 TwistRef = quatRotate(rotationArc, b2Axis2);
		btScalar twist = btAtan2Fast(TwistRef.dot(b1Axis3), TwistRef.dot(b1Axis2));
		m_twistAngle = twist;

		//		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? m_limitSoftness : btScalar(0.);
		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? btScalar(1.0f) : btScalar(0.);
		if (twist <= -m_twistSpan * lockedFreeFactor)
		{
			m_twistCorrection = -(twist + m_twistSpan);
			m_solveTwistLimit = true;
			m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
			m_twistAxis.normalize();
			m_twistAxis *= -1.0f;
		}
		else if (twist > m_twistSpan * lockedFreeFactor)
		{
			m_twistCorrection = (twist - m_twistSpan);
			m_solveTwistLimit = true;
			m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
			m_twistAxis.normalize();
		}
	}
}
#endif  //__SPU__

static btVector3 vTwist(1, 0, 0);  // twist axis in constraint's space

void btConeTwistConstraint::calcAngleInfo2(const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
	m_swingCorrection = btScalar(0.);
	m_twistLimitSign = btScalar(0.);
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;
	// compute rotation of A wrt B (in constraint space)
	if (m_bMotorEnabled && (!m_useSolveConstraintObsolete))
	{  // it is assumed that setMotorTarget() was alredy called
		// and motor target m_qTarget is within constraint limits
		// TODO : split rotation to pure swing and pure twist
		// compute desired transforms in world
		btTransform trPose(m_qTarget);
		btTransform trA = transA * m_rbAFrame;
		btTransform trB = transB * m_rbBFrame;
		btTransform trDeltaAB = trB * trPose * trA.inverse();
		btQuaternion qDeltaAB = trDeltaAB.getRotation();
		btVector3 swingAxis = btVector3(qDeltaAB.x(), qDeltaAB.y(), qDeltaAB.z());
		btScalar swingAxisLen2 = swingAxis.length2();
		if (btFuzzyZero(swingAxisLen2))
		{
			return;
		}
		m_swingAxis = swingAxis;
		m_swingAxis.normalize();
		m_swingCorrection = qDeltaAB.getAngle();
		if (!btFuzzyZero(m_swingCorrection))
		{
			m_solveSwingLimit = true;
		}
		return;
	}

	{
		// compute rotation of A wrt B (in constraint space)
		btQuaternion qA = transA.getRotation() * m_rbAFrame.getRotation();
		btQuaternion qB = transB.getRotation() * m_rbBFrame.getRotation();
		btQuaternion qAB = qB.inverse() * qA;
		// split rotation into cone and twist
		// (all this is done from B's perspective. Maybe I should be averaging axes...)
		btVector3 vConeNoTwist = quatRotate(qAB, vTwist);
		vConeNoTwist.normalize();
		btQuaternion qABCone = shortestArcQuat(vTwist, vConeNoTwist);
		qABCone.normalize();
		btQuaternion qABTwist = qABCone.inverse() * qAB;
		qABTwist.normalize();

		if (m_swingSpan1 >= m_fixThresh && m_swingSpan2 >= m_fixThresh)
		{
			btScalar swingAngle, swingLimit = 0;
			btVector3 swingAxis;
			computeConeLimitInfo(qABCone, swingAngle, swingAxis, swingLimit);

			if (swingAngle > swingLimit * m_limitSoftness)
			{
				m_solveSwingLimit = true;

				// compute limit ratio: 0->1, where
				// 0 == beginning of soft limit
				// 1 == hard/real limit
				m_swingLimitRatio = 1.f;
				if (swingAngle < swingLimit && m_limitSoftness < 1.f - SIMD_EPSILON)
				{
					m_swingLimitRatio = (swingAngle - swingLimit * m_limitSoftness) /
										(swingLimit - swingLimit * m_limitSoftness);
				}

				// swing correction tries to get back to soft limit
				m_swingCorrection = swingAngle - (swingLimit * m_limitSoftness);

				// adjustment of swing axis (based on ellipse normal)
				adjustSwingAxisToUseEllipseNormal(swingAxis);

				// Calculate necessary axis & factors
				m_swingAxis = quatRotate(qB, -swingAxis);

				m_twistAxisA.setValue(0, 0, 0);

				m_kSwing = btScalar(1.) /
						   (computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldA) +
							computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldB));
			}
		}
		else
		{
			// you haven't set any limits;
			// or you're trying to set at least one of the swing limits too small. (if so, do you really want a conetwist constraint?)
			// anyway, we have either hinge or fixed joint
			btVector3 ivA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(0);
			btVector3 jvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(1);
			btVector3 kvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(2);
			btVector3 ivB = transB.getBasis() * m_rbBFrame.getBasis().getColumn(0);
			btVector3 target;
			btScalar x = ivB.dot(ivA);
			btScalar y = ivB.dot(jvA);
			btScalar z = ivB.dot(kvA);
			if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
			{  // fixed. We'll need to add one more row to constraint
				if ((!btFuzzyZero(y)) || (!(btFuzzyZero(z))))
				{
					m_solveSwingLimit = true;
					m_swingAxis = -ivB.cross(ivA);
				}
			}
			else
			{
				if (m_swingSpan1 < m_fixThresh)
				{  // hinge around Y axis
					//					if(!(btFuzzyZero(y)))
					if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(z))))
					{
						m_solveSwingLimit = true;
						if (m_swingSpan2 >= m_fixThresh)
						{
							y = btScalar(0.f);
							btScalar span2 = btAtan2(z, x);
							if (span2 > m_swingSpan2)
							{
								x = btCos(m_swingSpan2);
								z = btSin(m_swingSpan2);
							}
							else if (span2 < -m_swingSpan2)
							{
								x = btCos(m_swingSpan2);
								z = -btSin(m_swingSpan2);
							}
						}
					}
				}
				else
				{  // hinge around Z axis
					//					if(!btFuzzyZero(z))
					if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(y))))
					{
						m_solveSwingLimit = true;
						if (m_swingSpan1 >= m_fixThresh)
						{
							z = btScalar(0.f);
							btScalar span1 = btAtan2(y, x);
							if (span1 > m_swingSpan1)
							{
								x = btCos(m_swingSpan1);
								y = btSin(m_swingSpan1);
							}
							else if (span1 < -m_swingSpan1)
							{
								x = btCos(m_swingSpan1);
								y = -btSin(m_swingSpan1);
							}
						}
					}
				}
				target[0] = x * ivA[0] + y * jvA[0] + z * kvA[0];
				target[1] = x * ivA[1] + y * jvA[1] + z * kvA[1];
				target[2] = x * ivA[2] + y * jvA[2] + z * kvA[2];
				target.normalize();
				m_swingAxis = -ivB.cross(target);
				m_swingCorrection = m_swingAxis.length();

				if (!btFuzzyZero(m_swingCorrection))
					m_swingAxis.normalize();
			}
		}

		if (m_twistSpan >= btScalar(0.f))
		{
			btVector3 twistAxis;
			computeTwistLimitInfo(qABTwist, m_twistAngle, twistAxis);

			if (m_twistAngle > m_twistSpan * m_limitSoftness)
			{
				m_solveTwistLimit = true;

				m_twistLimitRatio = 1.f;
				if (m_twistAngle < m_twistSpan && m_limitSoftness < 1.f - SIMD_EPSILON)
				{
					m_twistLimitRatio = (m_twistAngle - m_twistSpan * m_limitSoftness) /
										(m_twistSpan - m_twistSpan * m_limitSoftness);
				}

				// twist correction tries to get back to soft limit
				m_twistCorrection = m_twistAngle - (m_twistSpan * m_limitSoftness);

				m_twistAxis = quatRotate(qB, -twistAxis);

				m_kTwist = btScalar(1.) /
						   (computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldA) +
							computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldB));
			}

			if (m_solveSwingLimit)
				m_twistAxisA = quatRotate(qA, -twistAxis);
		}
		else
		{
			m_twistAngle = btScalar(0.f);
		}
	}
}

// given a cone rotation in constraint space, (pre: twist must already be removed)
// this method computes its corresponding swing angle and axis.
// more interestingly, it computes the cone/swing limit (angle) for this cone "pose".
void btConeTwistConstraint::computeConeLimitInfo(const btQuaternion& qCone,
												 btScalar& swingAngle,   // out
												 btVector3& vSwingAxis,  // out
												 btScalar& swingLimit)   // out
{
	swingAngle = qCone.getAngle();
	if (swingAngle > SIMD_EPSILON)
	{
		vSwingAxis = btVector3(qCone.x(), qCone.y(), qCone.z());
		vSwingAxis.normalize();
#if 0
        // non-zero twist?! this should never happen.
       btAssert(fabs(vSwingAxis.x()) <= SIMD_EPSILON));
#endif

		// Compute limit for given swing. tricky:
		// Given a swing axis, we're looking for the intersection with the bounding cone ellipse.
		// (Since we're dealing with angles, this ellipse is embedded on the surface of a sphere.)

		// For starters, compute the direction from center to surface of ellipse.
		// This is just the perpendicular (ie. rotate 2D vector by PI/2) of the swing axis.
		// (vSwingAxis is the cone rotation (in z,y); change vars and rotate to (x,y) coords.)
		btScalar xEllipse = vSwingAxis.y();
		btScalar yEllipse = -vSwingAxis.z();

		// Now, we use the slope of the vector (using x/yEllipse) and find the length
		// of the line that intersects the ellipse:
		//  x^2   y^2
		//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
		//  a^2   b^2
		// Do the math and it should be clear.

		swingLimit = m_swingSpan1;  // if xEllipse == 0, we have a pure vSwingAxis.z rotation: just use swingspan1
		if (fabs(xEllipse) > SIMD_EPSILON)
		{
			btScalar surfaceSlope2 = (yEllipse * yEllipse) / (xEllipse * xEllipse);
			btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
			norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
			btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
			swingLimit = std::sqrt(swingLimit2);
		}

		// test!
		/*swingLimit = m_swingSpan2;
		if (fabs(vSwingAxis.z()) > SIMD_EPSILON)
		{
		btScalar mag_2 = m_swingSpan1*m_swingSpan1 + m_swingSpan2*m_swingSpan2;
		btScalar sinphi = m_swingSpan2 / sqrt(mag_2);
		btScalar phi = asin(sinphi);
		btScalar theta = atan2(fabs(vSwingAxis.y()),fabs(vSwingAxis.z()));
		btScalar alpha = 3.14159f - theta - phi;
		btScalar sinalpha = sin(alpha);
		swingLimit = m_swingSpan1 * sinphi/sinalpha;
		}*/
	}
	else if (swingAngle < 0)
	{
		// this should never happen!
#if 0
        btAssert(0);
#endif
	}
}

btVector3 btConeTwistConstraint::GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const
{
	// compute x/y in ellipse using cone angle (0 -> 2*PI along surface of cone)
	btScalar xEllipse = btCos(fAngleInRadians);
	btScalar yEllipse = btSin(fAngleInRadians);

	// Use the slope of the vector (using x/yEllipse) and find the length
	// of the line that intersects the ellipse:
	//  x^2   y^2
	//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
	//  a^2   b^2
	// Do the math and it should be clear.

	btScalar swingLimit = m_swingSpan1;  // if xEllipse == 0, just use axis b (1)
	if (fabs(xEllipse) > SIMD_EPSILON)
	{
		btScalar surfaceSlope2 = (yEllipse * yEllipse) / (xEllipse * xEllipse);
		btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
		norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
		btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
		swingLimit = std::sqrt(swingLimit2);
	}

	// convert into point in constraint space:
	// note: twist is x-axis, swing 1 and 2 are along the z and y axes respectively
	btVector3 vSwingAxis(0, xEllipse, -yEllipse);
	btQuaternion qSwing(vSwingAxis, swingLimit);
	btVector3 vPointInConstraintSpace(fLength, 0, 0);
	return quatRotate(qSwing, vPointInConstraintSpace);
}

// given a twist rotation in constraint space, (pre: cone must already be removed)
// this method computes its corresponding angle and axis.
void btConeTwistConstraint::computeTwistLimitInfo(const btQuaternion& qTwist,
												  btScalar& twistAngle,   // out
												  btVector3& vTwistAxis)  // out
{
	btQuaternion qMinTwist = qTwist;
	twistAngle = qTwist.getAngle();

	if (twistAngle > SIMD_PI)  // long way around. flip quat and recalculate.
	{
		qMinTwist = -(qTwist);
		twistAngle = qMinTwist.getAngle();
	}
	if (twistAngle < 0)
	{
		// this should never happen
#if 0
        btAssert(0);
#endif
	}

	vTwistAxis = btVector3(qMinTwist.x(), qMinTwist.y(), qMinTwist.z());
	if (twistAngle > SIMD_EPSILON)
		vTwistAxis.normalize();
}

void btConeTwistConstraint::adjustSwingAxisToUseEllipseNormal(btVector3& vSwingAxis) const
{
	// the swing axis is computed as the "twist-free" cone rotation,
	// but the cone limit is not circular, but elliptical (if swingspan1 != swingspan2).
	// so, if we're outside the limits, the closest way back inside the cone isn't
	// along the vector back to the center. better (and more stable) to use the ellipse normal.

	// convert swing axis to direction from center to surface of ellipse
	// (ie. rotate 2D vector by PI/2)
	btScalar y = -vSwingAxis.z();
	btScalar z = vSwingAxis.y();

	// do the math...
	if (fabs(z) > SIMD_EPSILON)  // avoid division by 0. and we don't need an update if z == 0.
	{
		// compute gradient/normal of ellipse surface at current "point"
		btScalar grad = y / z;
		grad *= m_swingSpan2 / m_swingSpan1;

		// adjust y/z to represent normal at point (instead of vector to point)
		if (y > 0)
			y = fabs(grad * z);
		else
			y = -fabs(grad * z);

		// convert ellipse direction back to swing axis
		vSwingAxis.setZ(-y);
		vSwingAxis.setY(z);
		vSwingAxis.normalize();
	}
}

void btConeTwistConstraint::setMotorTarget(const btQuaternion& q)
{
	//btTransform trACur = m_rbA.getCenterOfMassTransform();
	//btTransform trBCur = m_rbB.getCenterOfMassTransform();
	//	btTransform trABCur = trBCur.inverse() * trACur;
	//	btQuaternion qABCur = trABCur.getRotation();
	//	btTransform trConstraintCur = (trBCur * m_rbBFrame).inverse() * (trACur * m_rbAFrame);
	//btQuaternion qConstraintCur = trConstraintCur.getRotation();

	btQuaternion qConstraint = m_rbBFrame.getRotation().inverse() * q * m_rbAFrame.getRotation();
	setMotorTargetInConstraintSpace(qConstraint);
}

void btConeTwistConstraint::setMotorTargetInConstraintSpace(const btQuaternion& q)
{
	m_qTarget = q;

	// clamp motor target to within limits
	{
		btScalar softness = 1.f;  //m_limitSoftness;

		// split into twist and cone
		btVector3 vTwisted = quatRotate(m_qTarget, vTwist);
		btQuaternion qTargetCone = shortestArcQuat(vTwist, vTwisted);
		qTargetCone.normalize();
		btQuaternion qTargetTwist = qTargetCone.inverse() * m_qTarget;
		qTargetTwist.normalize();

		// clamp cone
		if (m_swingSpan1 >= btScalar(0.05f) && m_swingSpan2 >= btScalar(0.05f))
		{
			btScalar swingAngle, swingLimit;
			btVector3 swingAxis;
			computeConeLimitInfo(qTargetCone, swingAngle, swingAxis, swingLimit);

			if (fabs(swingAngle) > SIMD_EPSILON)
			{
				if (swingAngle > swingLimit * softness)
					swingAngle = swingLimit * softness;
				else if (swingAngle < -swingLimit * softness)
					swingAngle = -swingLimit * softness;
				qTargetCone = btQuaternion(swingAxis, swingAngle);
			}
		}

		// clamp twist
		if (m_twistSpan >= btScalar(0.05f))
		{
			btScalar twistAngle;
			btVector3 twistAxis;
			computeTwistLimitInfo(qTargetTwist, twistAngle, twistAxis);

			if (fabs(twistAngle) > SIMD_EPSILON)
			{
				// eddy todo: limitSoftness used here???
				if (twistAngle > m_twistSpan * softness)
					twistAngle = m_twistSpan * softness;
				else if (twistAngle < -m_twistSpan * softness)
					twistAngle = -m_twistSpan * softness;
				qTargetTwist = btQuaternion(twistAxis, twistAngle);
			}
		}

		m_qTarget = qTargetCone * qTargetTwist;
	}
}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
void btConeTwistConstraint::setParam(int num, btScalar value, int axis)
{
	switch (num)
	{
		case BT_CONSTRAINT_ERP:
		case BT_CONSTRAINT_STOP_ERP:
			if ((axis >= 0) && (axis < 3))
			{
				m_linERP = value;
				m_flags |= BT_CONETWIST_FLAGS_LIN_ERP;
			}
			else
			{
				m_biasFactor = value;
			}
			break;
		case BT_CONSTRAINT_CFM:
		case BT_CONSTRAINT_STOP_CFM:
			if ((axis >= 0) && (axis < 3))
			{
				m_linCFM = value;
				m_flags |= BT_CONETWIST_FLAGS_LIN_CFM;
			}
			else
			{
				m_angCFM = value;
				m_flags |= BT_CONETWIST_FLAGS_ANG_CFM;
			}
			break;
		default:
			btAssertConstrParams(0);
			break;
	}
}

///return the local value of parameter
btScalar btConeTwistConstraint::getParam(int num, int axis) const
{
	btScalar retVal = 0;
	switch (num)
	{
		case BT_CONSTRAINT_ERP:
		case BT_CONSTRAINT_STOP_ERP:
			if ((axis >= 0) && (axis < 3))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_ERP);
				retVal = m_linERP;
			}
			else if ((axis >= 3) && (axis < 6))
			{
				retVal = m_biasFactor;
			}
			else
			{
				btAssertConstrParams(0);
			}
			break;
		case BT_CONSTRAINT_CFM:
		case BT_CONSTRAINT_STOP_CFM:
			if ((axis >= 0) && (axis < 3))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_CFM);
				retVal = m_linCFM;
			}
			else if ((axis >= 3) && (axis < 6))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_ANG_CFM);
				retVal = m_angCFM;
			}
			else
			{
				btAssertConstrParams(0);
			}
			break;
		default:
			btAssertConstrParams(0);
	}
	return retVal;
}

void btConeTwistConstraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
	m_rbAFrame = frameA;
	m_rbBFrame = frameB;
	buildJacobian();
	//calculateTransforms();
}





/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/

/*
Overview:

btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc).
It is a fixed translation, 3 degree-of-freedom (DOF) rotational "joint".
It divides the 3 rotational DOFs into swing (movement within a cone) and twist.
Swing is divided into swing1 and swing2 which can have different limits, giving an elliptical shape.
(Note: the cone's base isn't flat, so this ellipse is "embedded" on the surface of a sphere.)

In the contraint's frame of reference:
twist is along the x-axis,
and swing 1 and 2 are along the z and y axes respectively.
*/

#ifndef BT_CONETWISTCONSTRAINT_H
#define BT_CONETWISTCONSTRAINT_H

#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btConeTwistConstraintData2 btConeTwistConstraintDoubleData
#define btConeTwistConstraintDataName "btConeTwistConstraintDoubleData"
#else
#define btConeTwistConstraintData2 btConeTwistConstraintData
#define btConeTwistConstraintDataName "btConeTwistConstraintData"
#endif  //BT_USE_DOUBLE_PRECISION

class btRigidBody;

enum btConeTwistFlags
{
	BT_CONETWIST_FLAGS_LIN_CFM = 1,
	BT_CONETWIST_FLAGS_LIN_ERP = 2,
	BT_CONETWIST_FLAGS_ANG_CFM = 4
};

///btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
ATTRIBUTE_ALIGNED16(class)
btConeTwistConstraint : public btTypedConstraint
{
#ifdef IN_PARALLELL_SOLVER
public:
#endif
	btJacobianEntry m_jac[3];  //3 orthogonal linear constraints

	btTransform m_rbAFrame;
	btTransform m_rbBFrame;

	btScalar m_limitSoftness;
	btScalar m_biasFactor;
	btScalar m_relaxationFactor;

	btScalar m_damping;

	btScalar m_swingSpan1;
	btScalar m_swingSpan2;
	btScalar m_twistSpan;

	btScalar m_fixThresh;

	btVector3 m_swingAxis;
	btVector3 m_twistAxis;

	btScalar m_kSwing;
	btScalar m_kTwist;

	btScalar m_twistLimitSign;
	btScalar m_swingCorrection;
	btScalar m_twistCorrection;

	btScalar m_twistAngle;

	btScalar m_accSwingLimitImpulse;
	btScalar m_accTwistLimitImpulse;

	bool m_angularOnly;
	bool m_solveTwistLimit;
	bool m_solveSwingLimit;

	bool m_useSolveConstraintObsolete;

	// not yet used...
	btScalar m_swingLimitRatio;
	btScalar m_twistLimitRatio;
	btVector3 m_twistAxisA;

	// motor
	bool m_bMotorEnabled;
	bool m_bNormalizedMotorStrength;
	btQuaternion m_qTarget;
	btScalar m_maxMotorImpulse;
	btVector3 m_accMotorImpulse;

	// parameters
	int m_flags;
	btScalar m_linCFM;
	btScalar m_linERP;
	btScalar m_angCFM;

protected:
	void init();

	void computeConeLimitInfo(const btQuaternion& qCone,                                           // in
							  btScalar& swingAngle, btVector3& vSwingAxis, btScalar& swingLimit);  // all outs

	void computeTwistLimitInfo(const btQuaternion& qTwist,                    // in
							   btScalar& twistAngle, btVector3& vTwistAxis);  // all outs

	void adjustSwingAxisToUseEllipseNormal(btVector3 & vSwingAxis) const;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConeTwistConstraint(btRigidBody & rbA, btRigidBody & rbB, const btTransform& rbAFrame, const btTransform& rbBFrame);

	btConeTwistConstraint(btRigidBody & rbA, const btTransform& rbAFrame);

	virtual void buildJacobian();

	virtual void getInfo1(btConstraintInfo1 * info);

	void getInfo1NonVirtual(btConstraintInfo1 * info);

	virtual void getInfo2(btConstraintInfo2 * info);

	void getInfo2NonVirtual(btConstraintInfo2 * info, const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB);

	virtual void solveConstraintObsolete(btSolverBody & bodyA, btSolverBody & bodyB, btScalar timeStep);

	void updateRHS(btScalar timeStep);

	const btRigidBody& getRigidBodyA() const
	{
		return m_rbA;
	}
	const btRigidBody& getRigidBodyB() const
	{
		return m_rbB;
	}

	void setAngularOnly(bool angularOnly)
	{
		m_angularOnly = angularOnly;
	}

	bool getAngularOnly() const
	{
		return m_angularOnly;
	}

	void setLimit(int limitIndex, btScalar limitValue)
	{
		switch (limitIndex)
		{
			case 3:
			{
				m_twistSpan = limitValue;
				break;
			}
			case 4:
			{
				m_swingSpan2 = limitValue;
				break;
			}
			case 5:
			{
				m_swingSpan1 = limitValue;
				break;
			}
			default:
			{
			}
		};
	}

	btScalar getLimit(int limitIndex) const
	{
		switch (limitIndex)
		{
			case 3:
			{
				return m_twistSpan;
				break;
			}
			case 4:
			{
				return m_swingSpan2;
				break;
			}
			case 5:
			{
				return m_swingSpan1;
				break;
			}
			default:
			{
				btAssert(0 && "Invalid limitIndex specified for btConeTwistConstraint");
				return 0.0;
			}
		};
	}

	// setLimit(), a few notes:
	// _softness:
	//		0->1, recommend ~0.8->1.
	//		describes % of limits where movement is free.
	//		beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.
	// _biasFactor:
	//		0->1?, recommend 0.3 +/-0.3 or so.
	//		strength with which constraint resists zeroth order (angular, not angular velocity) limit violation.
	// __relaxationFactor:
	//		0->1, recommend to stay near 1.
	//		the lower the value, the less the constraint will fight velocities which violate the angular limits.
	void setLimit(btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness = 1.f, btScalar _biasFactor = 0.3f, btScalar _relaxationFactor = 1.0f)
	{
		m_swingSpan1 = _swingSpan1;
		m_swingSpan2 = _swingSpan2;
		m_twistSpan = _twistSpan;

		m_limitSoftness = _softness;
		m_biasFactor = _biasFactor;
		m_relaxationFactor = _relaxationFactor;
	}

	const btTransform& getAFrame() const { return m_rbAFrame; };
	const btTransform& getBFrame() const { return m_rbBFrame; };

	inline int getSolveTwistLimit()
	{
		return m_solveTwistLimit;
	}

	inline int getSolveSwingLimit()
	{
		return m_solveSwingLimit;
	}

	inline btScalar getTwistLimitSign()
	{
		return m_twistLimitSign;
	}

	void calcAngleInfo();
	void calcAngleInfo2(const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB);

	inline btScalar getSwingSpan1() const
	{
		return m_swingSpan1;
	}
	inline btScalar getSwingSpan2() const
	{
		return m_swingSpan2;
	}
	inline btScalar getTwistSpan() const
	{
		return m_twistSpan;
	}
	inline btScalar getLimitSoftness() const
	{
		return m_limitSoftness;
	}
	inline btScalar getBiasFactor() const
	{
		return m_biasFactor;
	}
	inline btScalar getRelaxationFactor() const
	{
		return m_relaxationFactor;
	}
	inline btScalar getTwistAngle() const
	{
		return m_twistAngle;
	}
	bool isPastSwingLimit() { return m_solveSwingLimit; }

	btScalar getDamping() const { return m_damping; }
	void setDamping(btScalar damping) { m_damping = damping; }

	void enableMotor(bool b) { m_bMotorEnabled = b; }
	bool isMotorEnabled() const { return m_bMotorEnabled; }
	btScalar getMaxMotorImpulse() const { return m_maxMotorImpulse; }
	bool isMaxMotorImpulseNormalized() const { return m_bNormalizedMotorStrength; }
	void setMaxMotorImpulse(btScalar maxMotorImpulse)
	{
		m_maxMotorImpulse = maxMotorImpulse;
		m_bNormalizedMotorStrength = false;
	}
	void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse)
	{
		m_maxMotorImpulse = maxMotorImpulse;
		m_bNormalizedMotorStrength = true;
	}

	btScalar getFixThresh() { return m_fixThresh; }
	void setFixThresh(btScalar fixThresh) { m_fixThresh = fixThresh; }

	// setMotorTarget:
	// q: the desired rotation of bodyA wrt bodyB.
	// note: if q violates the joint limits, the internal target is clamped to avoid conflicting impulses (very bad for stability)
	// note: don't forget to enableMotor()
	void setMotorTarget(const btQuaternion& q);
	const btQuaternion& getMotorTarget() const { return m_qTarget; }

	// same as above, but q is the desired rotation of frameA wrt frameB in constraint space
	void setMotorTargetInConstraintSpace(const btQuaternion& q);

	btVector3 GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const;

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1);

	virtual void setFrames(const btTransform& frameA, const btTransform& frameB);

	const btTransform& getFrameOffsetA() const
	{
		return m_rbAFrame;
	}

	const btTransform& getFrameOffsetB() const
	{
		return m_rbBFrame;
	}

	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const;

	int getFlags() const
	{
		return m_flags;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

struct btConeTwistConstraintDoubleData
{
	btTypedConstraintDoubleData m_typeConstraintData;
	btTransformDoubleData m_rbAFrame;
	btTransformDoubleData m_rbBFrame;

	//limits
	double m_swingSpan1;
	double m_swingSpan2;
	double m_twistSpan;
	double m_limitSoftness;
	double m_biasFactor;
	double m_relaxationFactor;

	double m_damping;
};

#ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
///this structure is not used, except for loading pre-2.82 .bullet files
struct btConeTwistConstraintData
{
	btTypedConstraintData m_typeConstraintData;
	btTransformFloatData m_rbAFrame;
	btTransformFloatData m_rbBFrame;

	//limits
	float m_swingSpan1;
	float m_swingSpan2;
	float m_twistSpan;
	float m_limitSoftness;
	float m_biasFactor;
	float m_relaxationFactor;

	float m_damping;

	char m_pad[4];
};
#endif  //BT_BACKWARDS_COMPATIBLE_SERIALIZATION
//

SIMD_FORCE_INLINE int btConeTwistConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btConeTwistConstraintData2);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btConeTwistConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btConeTwistConstraintData2* cone = (btConeTwistConstraintData2*)dataBuffer;
	btTypedConstraint::serialize(&cone->m_typeConstraintData, serializer);

	m_rbAFrame.serialize(cone->m_rbAFrame);
	m_rbBFrame.serialize(cone->m_rbBFrame);

	cone->m_swingSpan1 = m_swingSpan1;
	cone->m_swingSpan2 = m_swingSpan2;
	cone->m_twistSpan = m_twistSpan;
	cone->m_limitSoftness = m_limitSoftness;
	cone->m_biasFactor = m_biasFactor;
	cone->m_relaxationFactor = m_relaxationFactor;
	cone->m_damping = m_damping;

	return btConeTwistConstraintDataName;
}

#endif  //BT_CONETWISTCONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btUnionFind.h"

btUnionFind::~btUnionFind()
{
	Free();
}

btUnionFind::btUnionFind()
{
}

void btUnionFind::allocate(int N)
{
	m_elements.resize(N);
}
void btUnionFind::Free()
{
	m_elements.clear();
}

void btUnionFind::reset(int N)
{
	allocate(N);

	for (int i = 0; i < N; i++)
	{
		m_elements[i].m_id = i;
		m_elements[i].m_sz = 1;
	}
}

class btUnionFindElementSortPredicate
{
public:
	bool operator()(const btElement& lhs, const btElement& rhs) const
	{
		return lhs.m_id < rhs.m_id;
	}
};

///this is a special operation, destroying the content of btUnionFind.
///it sorts the elements, based on island id, in order to make it easy to iterate over islands
void btUnionFind::sortIslands()
{
	//first store the original body index, and islandId
	int numElements = m_elements.size();

	for (int i = 0; i < numElements; i++)
	{
		m_elements[i].m_id = find(i);
#ifndef STATIC_SIMULATION_ISLAND_OPTIMIZATION
		m_elements[i].m_sz = i;
#endif  //STATIC_SIMULATION_ISLAND_OPTIMIZATION
	}

	// Sort the vector using predicate and std::sort
	//std::sort(m_elements.begin(), m_elements.end(), btUnionFindElementSortPredicate);
	m_elements.quickSort(btUnionFindElementSortPredicate());
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_UNION_FIND_H
#define BT_UNION_FIND_H

#include "LinearMath/btAlignedObjectArray.h"

#define USE_PATH_COMPRESSION 1

///see for discussion of static island optimizations by Vroonsh here: http://code.google.com/p/bullet/issues/detail?id=406
#define STATIC_SIMULATION_ISLAND_OPTIMIZATION 1

struct btElement
{
	int m_id;
	int m_sz;
};

///UnionFind calculates connected subsets
// Implements weighted Quick Union with path compression
// optimization: could use short ints instead of ints (halving memory, would limit the number of rigid bodies to 64k, sounds reasonable)
class btUnionFind
{
private:
	btAlignedObjectArray<btElement> m_elements;

public:
	btUnionFind();
	~btUnionFind();

	//this is a special operation, destroying the content of btUnionFind.
	//it sorts the elements, based on island id, in order to make it easy to iterate over islands
	void sortIslands();

	void reset(int N);

	SIMD_FORCE_INLINE int getNumElements() const
	{
		return int(m_elements.size());
	}
	SIMD_FORCE_INLINE bool isRoot(int x) const
	{
		return (x == m_elements[x].m_id);
	}

	btElement& getElement(int index)
	{
		return m_elements[index];
	}
	const btElement& getElement(int index) const
	{
		return m_elements[index];
	}

	void allocate(int N);
	void Free();

	int find(int p, int q)
	{
		return (find(p) == find(q));
	}

	void unite(int p, int q)
	{
		int i = find(p), j = find(q);
		if (i == j)
			return;

#ifndef USE_PATH_COMPRESSION
		//weighted quick union, this keeps the 'trees' balanced, and keeps performance of unite O( log(n) )
		if (m_elements[i].m_sz < m_elements[j].m_sz)
		{
			m_elements[i].m_id = j;
			m_elements[j].m_sz += m_elements[i].m_sz;
		}
		else
		{
			m_elements[j].m_id = i;
			m_elements[i].m_sz += m_elements[j].m_sz;
		}
#else
		m_elements[i].m_id = j;
		m_elements[j].m_sz += m_elements[i].m_sz;
#endif  //USE_PATH_COMPRESSION
	}

	int find(int x)
	{
		//btAssert(x < m_N);
		//btAssert(x >= 0);

		while (x != m_elements[x].m_id)
		{
			//not really a reason not to use path compression, and it flattens the trees/improves find performance dramatically

#ifdef USE_PATH_COMPRESSION
			const btElement* elementPtr = &m_elements[m_elements[x].m_id];
			m_elements[x].m_id = elementPtr->m_id;
			x = elementPtr->m_id;
#else  //
			x = m_elements[x].m_id;
#endif
			//btAssert(x < m_N);
			//btAssert(x >= 0);
		}
		return x;
	}
};

#endif  //BT_UNION_FIND_H






/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btScalar.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"

#include "LinearMath/btQuickprof.h"

btSimulationIslandManager::btSimulationIslandManager() : m_splitIslands(true)
{
}

btSimulationIslandManager::~btSimulationIslandManager()
{
}

void btSimulationIslandManager::initUnionFind(int n)
{
	m_unionFind.reset(n);
}

void btSimulationIslandManager::findUnions(btDispatcher* /* dispatcher */, btCollisionWorld* colWorld)
{
	{
		btOverlappingPairCache* pairCachePtr = colWorld->getPairCache();
		const int numOverlappingPairs = pairCachePtr->getNumOverlappingPairs();
		if (numOverlappingPairs)
		{
			btBroadphasePair* pairPtr = pairCachePtr->getOverlappingPairArrayPtr();

			for (int i = 0; i < numOverlappingPairs; i++)
			{
				const btBroadphasePair& collisionPair = pairPtr[i];
				btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
				btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;

				if (((colObj0) && ((colObj0)->mergesSimulationIslands())) &&
					((colObj1) && ((colObj1)->mergesSimulationIslands())))
				{
					m_unionFind.unite((colObj0)->getIslandTag(),
									  (colObj1)->getIslandTag());
				}
			}
		}
	}
}

#ifdef STATIC_SIMULATION_ISLAND_OPTIMIZATION
void btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{
	// put the index into m_controllers into m_tag
	int index = 0;
	{
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			//Adding filtering here
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(index++);
			}
			collisionObject->setCompanionId(-1);
			collisionObject->setHitFraction(btScalar(1.));
		}
	}
	// do the union find

	initUnionFind(index);

	findUnions(dispatcher, colWorld);
}

void btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
	// put the islandId ('find' value) into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(m_unionFind.find(index));
				//Set the correct object offset in Collision Object Array
				m_unionFind.getElement(index).m_sz = i;
				collisionObject->setCompanionId(-1);
				index++;
			}
			else
			{
				collisionObject->setIslandTag(-1);
				collisionObject->setCompanionId(-2);
			}
		}
	}
}

#else  //STATIC_SIMULATION_ISLAND_OPTIMIZATION
void btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{
	initUnionFind(int(colWorld->getCollisionObjectArray().size()));

	// put the index into m_controllers into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			collisionObject->setIslandTag(index);
			collisionObject->setCompanionId(-1);
			collisionObject->setHitFraction(btScalar(1.));
			index++;
		}
	}
	// do the union find

	findUnions(dispatcher, colWorld);
}

void btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
	// put the islandId ('find' value) into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(m_unionFind.find(index));
				collisionObject->setCompanionId(-1);
			}
			else
			{
				collisionObject->setIslandTag(-1);
				collisionObject->setCompanionId(-2);
			}
			index++;
		}
	}
}

#endif  //STATIC_SIMULATION_ISLAND_OPTIMIZATION

inline int getIslandId(const btPersistentManifold* lhs)
{
	int islandId;
	const btCollisionObject* rcolObj0 = static_cast<const btCollisionObject*>(lhs->getBody0());
	const btCollisionObject* rcolObj1 = static_cast<const btCollisionObject*>(lhs->getBody1());
	islandId = rcolObj0->getIslandTag() >= 0 ? rcolObj0->getIslandTag() : rcolObj1->getIslandTag();
	return islandId;
}

/// function object that routes calls to operator<
class btPersistentManifoldSortPredicate
{
public:
	SIMD_FORCE_INLINE bool operator()(const btPersistentManifold* lhs, const btPersistentManifold* rhs) const
	{
		return getIslandId(lhs) < getIslandId(rhs);
	}
};

class btPersistentManifoldSortPredicateDeterministic
{
public:
	SIMD_FORCE_INLINE bool operator()(const btPersistentManifold* lhs, const btPersistentManifold* rhs) const
	{
		return (
			(getIslandId(lhs) < getIslandId(rhs)) || ((getIslandId(lhs) == getIslandId(rhs)) && lhs->getBody0()->getBroadphaseHandle()->m_uniqueId < rhs->getBody0()->getBroadphaseHandle()->m_uniqueId) || ((getIslandId(lhs) == getIslandId(rhs)) && (lhs->getBody0()->getBroadphaseHandle()->m_uniqueId == rhs->getBody0()->getBroadphaseHandle()->m_uniqueId) && (lhs->getBody1()->getBroadphaseHandle()->m_uniqueId < rhs->getBody1()->getBroadphaseHandle()->m_uniqueId)));
	}
};

void btSimulationIslandManager::buildIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld)
{
	BT_PROFILE("islandUnionFindAndQuickSort");

	btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

	m_islandmanifold.resize(0);

	//we are going to sort the unionfind array, and store the element id in the size
	//afterwards, we clean unionfind, to make sure no-one uses it anymore

	getUnionFind().sortIslands();
	int numElem = getUnionFind().getNumElements();

	int endIslandIndex = 1;
	int startIslandIndex;

	//update the sleeping state for bodies, if all are sleeping
	for (startIslandIndex = 0; startIslandIndex < numElem; startIslandIndex = endIslandIndex)
	{
		int islandId = getUnionFind().getElement(startIslandIndex).m_id;
		for (endIslandIndex = startIslandIndex + 1; (endIslandIndex < numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
		{
		}

		//int numSleeping = 0;

		bool allSleeping = true;

		int idx;
		for (idx = startIslandIndex; idx < endIslandIndex; idx++)
		{
			int i = getUnionFind().getElement(idx).m_sz;

			btCollisionObject* colObj0 = collisionObjects[i];
			if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
			{
				//				printf("error in island management\n");
			}

            btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));
			if (colObj0->getIslandTag() == islandId)
			{
				if (colObj0->getActivationState() == ACTIVE_TAG ||
					colObj0->getActivationState() == DISABLE_DEACTIVATION)
				{
					allSleeping = false;
					break;
				}
			}
		}

		if (allSleeping)
		{
			int idx;
			for (idx = startIslandIndex; idx < endIslandIndex; idx++)
			{
				int i = getUnionFind().getElement(idx).m_sz;
				btCollisionObject* colObj0 = collisionObjects[i];
				if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
				{
					//					printf("error in island management\n");
				}

                btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

				if (colObj0->getIslandTag() == islandId)
				{
					colObj0->setActivationState(ISLAND_SLEEPING);
				}
			}
		}
		else
		{
			int idx;
			for (idx = startIslandIndex; idx < endIslandIndex; idx++)
			{
				int i = getUnionFind().getElement(idx).m_sz;

				btCollisionObject* colObj0 = collisionObjects[i];
				if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
				{
					//					printf("error in island management\n");
				}

                 btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));


				if (colObj0->getIslandTag() == islandId)
				{
					if (colObj0->getActivationState() == ISLAND_SLEEPING)
					{
						colObj0->setActivationState(WANTS_DEACTIVATION);
						colObj0->setDeactivationTime(0.f);
					}
				}
			}
		}
	}

	int i;
	int maxNumManifolds = dispatcher->getNumManifolds();

	//#define SPLIT_ISLANDS 1
	//#ifdef SPLIT_ISLANDS

	//#endif //SPLIT_ISLANDS

	for (i = 0; i < maxNumManifolds; i++)
	{
		btPersistentManifold* manifold = dispatcher->getManifoldByIndexInternal(i);
		if (collisionWorld->getDispatchInfo().m_deterministicOverlappingPairs)
		{
			if (manifold->getNumContacts() == 0)
				continue;
		}

		const btCollisionObject* colObj0 = static_cast<const btCollisionObject*>(manifold->getBody0());
		const btCollisionObject* colObj1 = static_cast<const btCollisionObject*>(manifold->getBody1());

		///@todo: check sleeping conditions!
		if (((colObj0) && colObj0->getActivationState() != ISLAND_SLEEPING) ||
			((colObj1) && colObj1->getActivationState() != ISLAND_SLEEPING))
		{
			//kinematic objects don't merge islands, but wake up all connected objects
			if (colObj0->isKinematicObject() && colObj0->getActivationState() != ISLAND_SLEEPING)
			{
				if (colObj0->hasContactResponse())
					colObj1->activate();
			}
			if (colObj1->isKinematicObject() && colObj1->getActivationState() != ISLAND_SLEEPING)
			{
				if (colObj1->hasContactResponse())
					colObj0->activate();
			}
			if (m_splitIslands)
			{
				//filtering for response
				if (dispatcher->needsResponse(colObj0, colObj1))
					m_islandmanifold.push_back(manifold);
			}
		}
	}
}


///@todo: this is random access, it can be walked 'cache friendly'!
void btSimulationIslandManager::buildAndProcessIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback)
{
	buildIslands(dispatcher, collisionWorld);
    processIslands(dispatcher, collisionWorld, callback);
}

void btSimulationIslandManager::processIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback)
{
    btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();
	int endIslandIndex = 1;
	int startIslandIndex;
	int numElem = getUnionFind().getNumElements();

	BT_PROFILE("processIslands");

	if (!m_splitIslands)
	{
		btPersistentManifold** manifold = dispatcher->getInternalManifoldPointer();
		int maxNumManifolds = dispatcher->getNumManifolds();
		callback->processIsland(&collisionObjects[0], collisionObjects.size(), manifold, maxNumManifolds, -1);
	}
	else
	{
		// Sort manifolds, based on islands
		// Sort the vector using predicate and std::sort
		//std::sort(islandmanifold.begin(), islandmanifold.end(), btPersistentManifoldSortPredicate);

		int numManifolds = int(m_islandmanifold.size());

		//tried a radix sort, but quicksort/heapsort seems still faster
		//@todo rewrite island management
		//btPersistentManifoldSortPredicateDeterministic sorts contact manifolds based on islandid,
		//but also based on object0 unique id and object1 unique id
		if (collisionWorld->getDispatchInfo().m_deterministicOverlappingPairs)
		{
			m_islandmanifold.quickSort(btPersistentManifoldSortPredicateDeterministic());
		}
		else
		{
			m_islandmanifold.quickSort(btPersistentManifoldSortPredicate());
		}

		//m_islandmanifold.heapSort(btPersistentManifoldSortPredicate());

		//now process all active islands (sets of manifolds for now)

		int startManifoldIndex = 0;
		int endManifoldIndex = 1;

		//int islandId;

		//	printf("Start Islands\n");

		//traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
		for (startIslandIndex = 0; startIslandIndex < numElem; startIslandIndex = endIslandIndex)
		{
			int islandId = getUnionFind().getElement(startIslandIndex).m_id;

			bool islandSleeping = true;

			for (endIslandIndex = startIslandIndex; (endIslandIndex < numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
			{
				int i = getUnionFind().getElement(endIslandIndex).m_sz;
				btCollisionObject* colObj0 = collisionObjects[i];
				m_islandBodies.push_back(colObj0);
				if (colObj0->isActive())
					islandSleeping = false;
			}

			//find the accompanying contact manifold for this islandId
			int numIslandManifolds = 0;
			btPersistentManifold** startManifold = 0;

			if (startManifoldIndex < numManifolds)
			{
				int curIslandId = getIslandId(m_islandmanifold[startManifoldIndex]);
				if (curIslandId == islandId)
				{
					startManifold = &m_islandmanifold[startManifoldIndex];

					for (endManifoldIndex = startManifoldIndex + 1; (endManifoldIndex < numManifolds) && (islandId == getIslandId(m_islandmanifold[endManifoldIndex])); endManifoldIndex++)
					{
					}
					/// Process the actual simulation, only if not sleeping/deactivated
					numIslandManifolds = endManifoldIndex - startManifoldIndex;
				}
			}

			if (!islandSleeping)
			{
				callback->processIsland(&m_islandBodies[0], m_islandBodies.size(), startManifold, numIslandManifolds, islandId);
				//			printf("Island callback of size:%d bodies, %d manifolds\n",islandBodies.size(),numIslandManifolds);
			}

			if (numIslandManifolds)
			{
				startManifoldIndex = endManifoldIndex;
			}

			m_islandBodies.resize(0);
		}
	}  // else if(!splitIslands)
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMULATION_ISLAND_MANAGER_H
#define BT_SIMULATION_ISLAND_MANAGER_H

#include "BulletCollision/CollisionDispatch/btUnionFind.h"
#include "BulletCollision/CollisionDispatch/btCollisionCreateFunc.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

class btCollisionObject;
class btCollisionWorld;
class btDispatcher;
class btPersistentManifold;

///SimulationIslandManager creates and handles simulation islands, using btUnionFind
class btSimulationIslandManager
{
	btUnionFind m_unionFind;

	btAlignedObjectArray<btPersistentManifold*> m_islandmanifold;
	btAlignedObjectArray<btCollisionObject*> m_islandBodies;

	bool m_splitIslands;

public:
	btSimulationIslandManager();
	virtual ~btSimulationIslandManager();

	void initUnionFind(int n);

	btUnionFind& getUnionFind() { return m_unionFind; }

	virtual void updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher);
	virtual void storeIslandActivationState(btCollisionWorld* world);

	void findUnions(btDispatcher* dispatcher, btCollisionWorld* colWorld);

	struct IslandCallback
	{
		virtual ~IslandCallback(){};

		virtual void processIsland(btCollisionObject** bodies, int numBodies, class btPersistentManifold** manifolds, int numManifolds, int islandId) = 0;
	};

	void buildAndProcessIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback);
    
	void buildIslands(btDispatcher* dispatcher, btCollisionWorld* colWorld);

    void processIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback);
    
	bool getSplitIslands()
	{
		return m_splitIslands;
	}
	void setSplitIslands(bool doSplitIslands)
	{
		m_splitIslands = doSplitIslands;
	}
};

#endif  //BT_SIMULATION_ISLAND_MANAGER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONSTRAINT_SOLVER_H
#define BT_CONSTRAINT_SOLVER_H

#include "LinearMath/btScalar.h"

class btPersistentManifold;
class btRigidBody;
class btCollisionObject;
class btTypedConstraint;
struct btContactSolverInfo;
struct btBroadphaseProxy;
class btIDebugDraw;
class btStackAlloc;
class btDispatcher;
/// btConstraintSolver provides solver interface

enum btConstraintSolverType
{
	BT_SEQUENTIAL_IMPULSE_SOLVER = 1,
	BT_MLCP_SOLVER = 2,
	BT_NNCG_SOLVER = 4,
	BT_MULTIBODY_SOLVER = 8,
	BT_BLOCK_SOLVER = 16,
};

class btConstraintSolver
{
public:
	virtual ~btConstraintSolver() {}

	virtual void prepareSolve(int /* numBodies */, int /* numManifolds */) { ; }

	///solve a group of constraints
	virtual btScalar solveGroup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifold, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& info, class btIDebugDraw* debugDrawer, btDispatcher* dispatcher) = 0;

	virtual void allSolved(const btContactSolverInfo& /* info */, class btIDebugDraw* /* debugDrawer */) { ; }

	///clear internal cached data and reset random seed
	virtual void reset() = 0;

	virtual btConstraintSolverType getSolverType() const = 0;
};

#endif  //BT_CONSTRAINT_SOLVER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//#define COMPUTE_IMPULSE_DENOM 1
#ifdef BT_DEBUG
#	define BT_ADDITIONAL_DEBUG
#endif

//It is not necessary (redundant) to refresh contact manifolds, this refresh has been moved to the collision algorithms.

#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"

#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btCpuFeatureUtility.h"

#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "LinearMath/btMinMax.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "LinearMath/btStackAlloc.h"
#include "LinearMath/btQuickprof.h"
#include "BulletDynamics/ConstraintSolver/btSolverBody.h"
#include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
#include "LinearMath/btAlignedObjectArray.h"

int gNumSplitImpulseRecoveries = 0;

#include "BulletDynamics/Dynamics/btRigidBody.h"

//#define VERBOSE_RESIDUAL_PRINTF 1
///This is the scalar reference implementation of solving a single constraint row, the innerloop of the Projected Gauss Seidel/Sequential Impulse constraint solver
///Below are optional SSE2 and SSE4/FMA3 versions. We assume most hardware has SSE2. For SSE4/FMA3 we perform a CPU feature check.
static btScalar gResolveSingleConstraintRowGeneric_scalar_reference(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	btScalar deltaImpulse = c.m_rhs - btScalar(c.m_appliedImpulse) * c.m_cfm;
	const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(bodyA.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(bodyA.internalGetDeltaAngularVelocity());
	const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(bodyB.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(bodyB.internalGetDeltaAngularVelocity());

	//	const btScalar delta_rel_vel	=	deltaVel1Dotn-deltaVel2Dotn;
	deltaImpulse -= deltaVel1Dotn * c.m_jacDiagABInv;
	deltaImpulse -= deltaVel2Dotn * c.m_jacDiagABInv;

	const btScalar sum = btScalar(c.m_appliedImpulse) + deltaImpulse;
	if (sum < c.m_lowerLimit)
	{
		deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
		c.m_appliedImpulse = c.m_lowerLimit;
	}
	else if (sum > c.m_upperLimit)
	{
		deltaImpulse = c.m_upperLimit - c.m_appliedImpulse;
		c.m_appliedImpulse = c.m_upperLimit;
	}
	else
	{
		c.m_appliedImpulse = sum;
	}

	bodyA.internalApplyImpulse(c.m_contactNormal1 * bodyA.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
	bodyB.internalApplyImpulse(c.m_contactNormal2 * bodyB.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);

	return deltaImpulse * (1. / c.m_jacDiagABInv);
}

static btScalar gResolveSingleConstraintRowLowerLimit_scalar_reference(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	btScalar deltaImpulse = c.m_rhs - btScalar(c.m_appliedImpulse) * c.m_cfm;
	const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(bodyA.internalGetDeltaLinearVelocity()) + c.m_relpos1CrossNormal.dot(bodyA.internalGetDeltaAngularVelocity());
	const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(bodyB.internalGetDeltaLinearVelocity()) + c.m_relpos2CrossNormal.dot(bodyB.internalGetDeltaAngularVelocity());

	deltaImpulse -= deltaVel1Dotn * c.m_jacDiagABInv;
	deltaImpulse -= deltaVel2Dotn * c.m_jacDiagABInv;
	const btScalar sum = btScalar(c.m_appliedImpulse) + deltaImpulse;
	if (sum < c.m_lowerLimit)
	{
		deltaImpulse = c.m_lowerLimit - c.m_appliedImpulse;
		c.m_appliedImpulse = c.m_lowerLimit;
	}
	else
	{
		c.m_appliedImpulse = sum;
	}
	bodyA.internalApplyImpulse(c.m_contactNormal1 * bodyA.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
	bodyB.internalApplyImpulse(c.m_contactNormal2 * bodyB.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);

	return deltaImpulse * (1. / c.m_jacDiagABInv);
}

#ifdef USE_SIMD

#define btVecSplat(x, e) _mm_shuffle_ps(x, x, _MM_SHUFFLE(e, e, e, e))
static inline __m128 btSimdDot3(__m128 vec0, __m128 vec1)
{
	__m128 result = _mm_mul_ps(vec0, vec1);
	return _mm_add_ps(btVecSplat(result, 0), _mm_add_ps(btVecSplat(result, 1), btVecSplat(result, 2)));
}

#if defined(BT_ALLOW_SSE4)

#define USE_FMA 1
#define USE_FMA3_INSTEAD_FMA4 1
#define USE_SSE4_DOT 1

#define SSE4_DP(a, b) _mm_dp_ps(a, b, 0x7f)
#define SSE4_DP_FP(a, b) _mm_cvtss_f32(_mm_dp_ps(a, b, 0x7f))

#if USE_SSE4_DOT
#define DOT_PRODUCT(a, b) SSE4_DP(a, b)
#else
#define DOT_PRODUCT(a, b) btSimdDot3(a, b)
#endif

#if USE_FMA
#if USE_FMA3_INSTEAD_FMA4
// a*b + c
#define FMADD(a, b, c) _mm_fmadd_ps(a, b, c)
// -(a*b) + c
#define FMNADD(a, b, c) _mm_fnmadd_ps(a, b, c)
#else  // USE_FMA3
// a*b + c
#define FMADD(a, b, c) _mm_macc_ps(a, b, c)
// -(a*b) + c
#define FMNADD(a, b, c) _mm_nmacc_ps(a, b, c)
#endif
#else  // USE_FMA
// c + a*b
#define FMADD(a, b, c) _mm_add_ps(c, _mm_mul_ps(a, b))
// c - a*b
#define FMNADD(a, b, c) _mm_sub_ps(c, _mm_mul_ps(a, b))
#endif
#endif

// Project Gauss Seidel or the equivalent Sequential Impulse
static btScalar gResolveSingleConstraintRowGeneric_sse2(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	__m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
	__m128 lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
	__m128 upperLimit1 = _mm_set1_ps(c.m_upperLimit);
	btSimdScalar deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
	__m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, bodyA.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, bodyA.internalGetDeltaAngularVelocity().mVec128));
	__m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, bodyB.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, bodyB.internalGetDeltaAngularVelocity().mVec128));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
	btSimdScalar resultLowerLess, resultUpperLess;
	resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
	resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
	__m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
	deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
	c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
	__m128 upperMinApplied = _mm_sub_ps(upperLimit1, cpAppliedImp);
	deltaImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, deltaImpulse), _mm_andnot_ps(resultUpperLess, upperMinApplied));
	c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultUpperLess, c.m_appliedImpulse), _mm_andnot_ps(resultUpperLess, upperLimit1));
	__m128 linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, bodyA.internalGetInvMass().mVec128);
	__m128 linearComponentB = _mm_mul_ps((c.m_contactNormal2).mVec128, bodyB.internalGetInvMass().mVec128);
	__m128 impulseMagnitude = deltaImpulse;
	bodyA.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(bodyA.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
	bodyA.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(bodyA.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
	bodyB.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(bodyB.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
	bodyB.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(bodyB.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
	return deltaImpulse.m_floats[0] / c.m_jacDiagABInv;
}

// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
static btScalar gResolveSingleConstraintRowGeneric_sse4_1_fma3(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
#if defined(BT_ALLOW_SSE4)
	__m128 tmp = _mm_set_ps1(c.m_jacDiagABInv);
	__m128 deltaImpulse = _mm_set_ps1(c.m_rhs - btScalar(c.m_appliedImpulse) * c.m_cfm);
	const __m128 lowerLimit = _mm_set_ps1(c.m_lowerLimit);
	const __m128 upperLimit = _mm_set_ps1(c.m_upperLimit);
	const __m128 deltaVel1Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal1.mVec128, bodyA.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos1CrossNormal.mVec128, bodyA.internalGetDeltaAngularVelocity().mVec128));
	const __m128 deltaVel2Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal2.mVec128, bodyB.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos2CrossNormal.mVec128, bodyB.internalGetDeltaAngularVelocity().mVec128));
	deltaImpulse = FMNADD(deltaVel1Dotn, tmp, deltaImpulse);
	deltaImpulse = FMNADD(deltaVel2Dotn, tmp, deltaImpulse);
	tmp = _mm_add_ps(c.m_appliedImpulse, deltaImpulse);  // sum
	const __m128 maskLower = _mm_cmpgt_ps(tmp, lowerLimit);
	const __m128 maskUpper = _mm_cmpgt_ps(upperLimit, tmp);
	deltaImpulse = _mm_blendv_ps(_mm_sub_ps(lowerLimit, c.m_appliedImpulse), _mm_blendv_ps(_mm_sub_ps(upperLimit, c.m_appliedImpulse), deltaImpulse, maskUpper), maskLower);
	c.m_appliedImpulse = _mm_blendv_ps(lowerLimit, _mm_blendv_ps(upperLimit, tmp, maskUpper), maskLower);
	bodyA.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal1.mVec128, bodyA.internalGetInvMass().mVec128), deltaImpulse, bodyA.internalGetDeltaLinearVelocity().mVec128);
	bodyA.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentA.mVec128, deltaImpulse, bodyA.internalGetDeltaAngularVelocity().mVec128);
	bodyB.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal2.mVec128, bodyB.internalGetInvMass().mVec128), deltaImpulse, bodyB.internalGetDeltaLinearVelocity().mVec128);
	bodyB.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentB.mVec128, deltaImpulse, bodyB.internalGetDeltaAngularVelocity().mVec128);
	btSimdScalar deltaImp = deltaImpulse;
	return deltaImp.m_floats[0] * (1. / c.m_jacDiagABInv);
#else
	return gResolveSingleConstraintRowGeneric_sse2(bodyA, bodyB, c);
#endif
}

static btScalar gResolveSingleConstraintRowLowerLimit_sse2(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	__m128 cpAppliedImp = _mm_set1_ps(c.m_appliedImpulse);
	__m128 lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
	__m128 upperLimit1 = _mm_set1_ps(c.m_upperLimit);
	btSimdScalar deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhs), _mm_mul_ps(_mm_set1_ps(c.m_appliedImpulse), _mm_set1_ps(c.m_cfm)));
	__m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, bodyA.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, bodyA.internalGetDeltaAngularVelocity().mVec128));
	__m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, bodyB.internalGetDeltaLinearVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, bodyB.internalGetDeltaAngularVelocity().mVec128));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
	btSimdScalar resultLowerLess, resultUpperLess;
	resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
	resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
	__m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
	deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
	c.m_appliedImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
	__m128 linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, bodyA.internalGetInvMass().mVec128);
	__m128 linearComponentB = _mm_mul_ps(c.m_contactNormal2.mVec128, bodyB.internalGetInvMass().mVec128);
	__m128 impulseMagnitude = deltaImpulse;
	bodyA.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(bodyA.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
	bodyA.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(bodyA.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
	bodyB.internalGetDeltaLinearVelocity().mVec128 = _mm_add_ps(bodyB.internalGetDeltaLinearVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
	bodyB.internalGetDeltaAngularVelocity().mVec128 = _mm_add_ps(bodyB.internalGetDeltaAngularVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
	return deltaImpulse.m_floats[0] / c.m_jacDiagABInv;
}

// Enhanced version of gResolveSingleConstraintRowGeneric_sse2 with SSE4.1 and FMA3
static btScalar gResolveSingleConstraintRowLowerLimit_sse4_1_fma3(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
#ifdef BT_ALLOW_SSE4
	__m128 tmp = _mm_set_ps1(c.m_jacDiagABInv);
	__m128 deltaImpulse = _mm_set_ps1(c.m_rhs - btScalar(c.m_appliedImpulse) * c.m_cfm);
	const __m128 lowerLimit = _mm_set_ps1(c.m_lowerLimit);
	const __m128 deltaVel1Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal1.mVec128, bodyA.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos1CrossNormal.mVec128, bodyA.internalGetDeltaAngularVelocity().mVec128));
	const __m128 deltaVel2Dotn = _mm_add_ps(DOT_PRODUCT(c.m_contactNormal2.mVec128, bodyB.internalGetDeltaLinearVelocity().mVec128), DOT_PRODUCT(c.m_relpos2CrossNormal.mVec128, bodyB.internalGetDeltaAngularVelocity().mVec128));
	deltaImpulse = FMNADD(deltaVel1Dotn, tmp, deltaImpulse);
	deltaImpulse = FMNADD(deltaVel2Dotn, tmp, deltaImpulse);
	tmp = _mm_add_ps(c.m_appliedImpulse, deltaImpulse);
	const __m128 mask = _mm_cmpgt_ps(tmp, lowerLimit);
	deltaImpulse = _mm_blendv_ps(_mm_sub_ps(lowerLimit, c.m_appliedImpulse), deltaImpulse, mask);
	c.m_appliedImpulse = _mm_blendv_ps(lowerLimit, tmp, mask);
	bodyA.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal1.mVec128, bodyA.internalGetInvMass().mVec128), deltaImpulse, bodyA.internalGetDeltaLinearVelocity().mVec128);
	bodyA.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentA.mVec128, deltaImpulse, bodyA.internalGetDeltaAngularVelocity().mVec128);
	bodyB.internalGetDeltaLinearVelocity().mVec128 = FMADD(_mm_mul_ps(c.m_contactNormal2.mVec128, bodyB.internalGetInvMass().mVec128), deltaImpulse, bodyB.internalGetDeltaLinearVelocity().mVec128);
	bodyB.internalGetDeltaAngularVelocity().mVec128 = FMADD(c.m_angularComponentB.mVec128, deltaImpulse, bodyB.internalGetDeltaAngularVelocity().mVec128);
	btSimdScalar deltaImp = deltaImpulse;
	return deltaImp.m_floats[0] * (1. / c.m_jacDiagABInv);
#else
	return gResolveSingleConstraintRowLowerLimit_sse2(bodyA, bodyB, c);
#endif  //BT_ALLOW_SSE4
}

#endif  //USE_SIMD

btScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowGenericSIMD(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	return m_resolveSingleConstraintRowGeneric(bodyA, bodyB, c);
}

// Project Gauss Seidel or the equivalent Sequential Impulse
btScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowGeneric(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	return m_resolveSingleConstraintRowGeneric(bodyA, bodyB, c);
}

btScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowLowerLimitSIMD(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	return m_resolveSingleConstraintRowLowerLimit(bodyA, bodyB, c);
}

btScalar btSequentialImpulseConstraintSolver::resolveSingleConstraintRowLowerLimit(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
	return m_resolveSingleConstraintRowLowerLimit(bodyA, bodyB, c);
}

static btScalar gResolveSplitPenetrationImpulse_scalar_reference(
	btSolverBody& bodyA,
	btSolverBody& bodyB,
	const btSolverConstraint& c)
{
	btScalar deltaImpulse = 0.f;

	if (c.m_rhsPenetration)
	{
		gNumSplitImpulseRecoveries++;
		deltaImpulse = c.m_rhsPenetration - btScalar(c.m_appliedPushImpulse) * c.m_cfm;
		const btScalar deltaVel1Dotn = c.m_contactNormal1.dot(bodyA.internalGetPushVelocity()) + c.m_relpos1CrossNormal.dot(bodyA.internalGetTurnVelocity());
		const btScalar deltaVel2Dotn = c.m_contactNormal2.dot(bodyB.internalGetPushVelocity()) + c.m_relpos2CrossNormal.dot(bodyB.internalGetTurnVelocity());

		deltaImpulse -= deltaVel1Dotn * c.m_jacDiagABInv;
		deltaImpulse -= deltaVel2Dotn * c.m_jacDiagABInv;
		const btScalar sum = btScalar(c.m_appliedPushImpulse) + deltaImpulse;
		if (sum < c.m_lowerLimit)
		{
			deltaImpulse = c.m_lowerLimit - c.m_appliedPushImpulse;
			c.m_appliedPushImpulse = c.m_lowerLimit;
		}
		else
		{
			c.m_appliedPushImpulse = sum;
		}
		bodyA.internalApplyPushImpulse(c.m_contactNormal1 * bodyA.internalGetInvMass(), c.m_angularComponentA, deltaImpulse);
		bodyB.internalApplyPushImpulse(c.m_contactNormal2 * bodyB.internalGetInvMass(), c.m_angularComponentB, deltaImpulse);
	}
	return deltaImpulse * (1. / c.m_jacDiagABInv);
}

static btScalar gResolveSplitPenetrationImpulse_sse2(btSolverBody& bodyA, btSolverBody& bodyB, const btSolverConstraint& c)
{
#ifdef USE_SIMD
	if (!c.m_rhsPenetration)
		return 0.f;

	gNumSplitImpulseRecoveries++;

	__m128 cpAppliedImp = _mm_set1_ps(c.m_appliedPushImpulse);
	__m128 lowerLimit1 = _mm_set1_ps(c.m_lowerLimit);
	__m128 upperLimit1 = _mm_set1_ps(c.m_upperLimit);
	__m128 deltaImpulse = _mm_sub_ps(_mm_set1_ps(c.m_rhsPenetration), _mm_mul_ps(_mm_set1_ps(c.m_appliedPushImpulse), _mm_set1_ps(c.m_cfm)));
	__m128 deltaVel1Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal1.mVec128, bodyA.internalGetPushVelocity().mVec128), btSimdDot3(c.m_relpos1CrossNormal.mVec128, bodyA.internalGetTurnVelocity().mVec128));
	__m128 deltaVel2Dotn = _mm_add_ps(btSimdDot3(c.m_contactNormal2.mVec128, bodyB.internalGetPushVelocity().mVec128), btSimdDot3(c.m_relpos2CrossNormal.mVec128, bodyB.internalGetTurnVelocity().mVec128));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel1Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	deltaImpulse = _mm_sub_ps(deltaImpulse, _mm_mul_ps(deltaVel2Dotn, _mm_set1_ps(c.m_jacDiagABInv)));
	btSimdScalar sum = _mm_add_ps(cpAppliedImp, deltaImpulse);
	btSimdScalar resultLowerLess, resultUpperLess;
	resultLowerLess = _mm_cmplt_ps(sum, lowerLimit1);
	resultUpperLess = _mm_cmplt_ps(sum, upperLimit1);
	__m128 lowMinApplied = _mm_sub_ps(lowerLimit1, cpAppliedImp);
	deltaImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowMinApplied), _mm_andnot_ps(resultLowerLess, deltaImpulse));
	c.m_appliedPushImpulse = _mm_or_ps(_mm_and_ps(resultLowerLess, lowerLimit1), _mm_andnot_ps(resultLowerLess, sum));
	__m128 linearComponentA = _mm_mul_ps(c.m_contactNormal1.mVec128, bodyA.internalGetInvMass().mVec128);
	__m128 linearComponentB = _mm_mul_ps(c.m_contactNormal2.mVec128, bodyB.internalGetInvMass().mVec128);
	__m128 impulseMagnitude = deltaImpulse;
	bodyA.internalGetPushVelocity().mVec128 = _mm_add_ps(bodyA.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentA, impulseMagnitude));
	bodyA.internalGetTurnVelocity().mVec128 = _mm_add_ps(bodyA.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentA.mVec128, impulseMagnitude));
	bodyB.internalGetPushVelocity().mVec128 = _mm_add_ps(bodyB.internalGetPushVelocity().mVec128, _mm_mul_ps(linearComponentB, impulseMagnitude));
	bodyB.internalGetTurnVelocity().mVec128 = _mm_add_ps(bodyB.internalGetTurnVelocity().mVec128, _mm_mul_ps(c.m_angularComponentB.mVec128, impulseMagnitude));
	btSimdScalar deltaImp = deltaImpulse;
	return deltaImp.m_floats[0] * (1. / c.m_jacDiagABInv);
#else
	return gResolveSplitPenetrationImpulse_scalar_reference(bodyA, bodyB, c);
#endif
}

btSequentialImpulseConstraintSolver::btSequentialImpulseConstraintSolver()
{
	m_btSeed2 = 0;
	m_cachedSolverMode = 0;
	setupSolverFunctions(false);
}

void btSequentialImpulseConstraintSolver::setupSolverFunctions(bool useSimd)
{
	m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_scalar_reference;
	m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_scalar_reference;
	m_resolveSplitPenetrationImpulse = gResolveSplitPenetrationImpulse_scalar_reference;

	if (useSimd)
	{
#ifdef USE_SIMD
		m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_sse2;
		m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_sse2;
		m_resolveSplitPenetrationImpulse = gResolveSplitPenetrationImpulse_sse2;

#ifdef BT_ALLOW_SSE4
		int cpuFeatures = btCpuFeatureUtility::getCpuFeatures();
		if ((cpuFeatures & btCpuFeatureUtility::CPU_FEATURE_FMA3) && (cpuFeatures & btCpuFeatureUtility::CPU_FEATURE_SSE4_1))
		{
			m_resolveSingleConstraintRowGeneric = gResolveSingleConstraintRowGeneric_sse4_1_fma3;
			m_resolveSingleConstraintRowLowerLimit = gResolveSingleConstraintRowLowerLimit_sse4_1_fma3;
		}
#endif  //BT_ALLOW_SSE4
#endif  //USE_SIMD
	}
}

btSequentialImpulseConstraintSolver::~btSequentialImpulseConstraintSolver()
{
}

btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getScalarConstraintRowSolverGeneric()
{
	return gResolveSingleConstraintRowGeneric_scalar_reference;
}

btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getScalarConstraintRowSolverLowerLimit()
{
	return gResolveSingleConstraintRowLowerLimit_scalar_reference;
}

#ifdef USE_SIMD
btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getSSE2ConstraintRowSolverGeneric()
{
	return gResolveSingleConstraintRowGeneric_sse2;
}
btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getSSE2ConstraintRowSolverLowerLimit()
{
	return gResolveSingleConstraintRowLowerLimit_sse2;
}
#ifdef BT_ALLOW_SSE4
btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getSSE4_1ConstraintRowSolverGeneric()
{
	return gResolveSingleConstraintRowGeneric_sse4_1_fma3;
}
btSingleConstraintRowSolver btSequentialImpulseConstraintSolver::getSSE4_1ConstraintRowSolverLowerLimit()
{
	return gResolveSingleConstraintRowLowerLimit_sse4_1_fma3;
}
#endif  //BT_ALLOW_SSE4
#endif  //USE_SIMD

unsigned long btSequentialImpulseConstraintSolver::btRand2()
{
	m_btSeed2 = (1664525L * m_btSeed2 + 1013904223L) & 0xffffffff;
	return m_btSeed2;
}

//See ODE: adam's all-int straightforward(?) dRandInt (0..n-1)
int btSequentialImpulseConstraintSolver::btRandInt2(int n)
{
	// seems good; xor-fold and modulus
	const unsigned long un = static_cast<unsigned long>(n);
	unsigned long r = btRand2();

	// note: probably more aggressive than it needs to be -- might be
	//       able to get away without one or two of the innermost branches.
	if (un <= 0x00010000UL)
	{
		r ^= (r >> 16);
		if (un <= 0x00000100UL)
		{
			r ^= (r >> 8);
			if (un <= 0x00000010UL)
			{
				r ^= (r >> 4);
				if (un <= 0x00000004UL)
				{
					r ^= (r >> 2);
					if (un <= 0x00000002UL)
					{
						r ^= (r >> 1);
					}
				}
			}
		}
	}

	return (int)(r % un);
}

void btSequentialImpulseConstraintSolver::initSolverBody(btSolverBody* solverBody, btCollisionObject* collisionObject, btScalar timeStep)
{
	btRigidBody* rb = collisionObject ? btRigidBody::upcast(collisionObject) : 0;

	solverBody->internalGetDeltaLinearVelocity().setValue(0.f, 0.f, 0.f);
	solverBody->internalGetDeltaAngularVelocity().setValue(0.f, 0.f, 0.f);
	solverBody->internalGetPushVelocity().setValue(0.f, 0.f, 0.f);
	solverBody->internalGetTurnVelocity().setValue(0.f, 0.f, 0.f);

	if (rb)
	{
		solverBody->m_worldTransform = rb->getWorldTransform();
		solverBody->internalSetInvMass(btVector3(rb->getInvMass(), rb->getInvMass(), rb->getInvMass()) * rb->getLinearFactor());
		solverBody->m_originalBody = rb;
		solverBody->m_angularFactor = rb->getAngularFactor();
		solverBody->m_linearFactor = rb->getLinearFactor();
		solverBody->m_linearVelocity = rb->getLinearVelocity();
		solverBody->m_angularVelocity = rb->getAngularVelocity();
		solverBody->m_externalForceImpulse = rb->getTotalForce() * rb->getInvMass() * timeStep;
		solverBody->m_externalTorqueImpulse = rb->getTotalTorque() * rb->getInvInertiaTensorWorld() * timeStep;
	}
	else
		{
		solverBody->m_worldTransform.setIdentity();
		solverBody->internalSetInvMass(btVector3(0, 0, 0));
		solverBody->m_originalBody = 0;
		solverBody->m_angularFactor.setValue(1, 1, 1);
		solverBody->m_linearFactor.setValue(1, 1, 1);
		solverBody->m_linearVelocity.setValue(0, 0, 0);
		solverBody->m_angularVelocity.setValue(0, 0, 0);
		solverBody->m_externalForceImpulse.setValue(0, 0, 0);
		solverBody->m_externalTorqueImpulse.setValue(0, 0, 0);
					}
				}

btScalar btSequentialImpulseConstraintSolver::restitutionCurve(btScalar rel_vel, btScalar restitution, btScalar velocityThreshold)
{
	//printf("rel_vel =%f\n", rel_vel);
	if (btFabs(rel_vel) < velocityThreshold)
		return 0.;

	btScalar rest = restitution * -rel_vel;
	return rest;
}

void btSequentialImpulseConstraintSolver::applyAnisotropicFriction(btCollisionObject* colObj, btVector3& frictionDirection, int frictionMode)
{
	if (colObj && colObj->hasAnisotropicFriction(frictionMode))
	{
		// transform to local coordinates
		btVector3 loc_lateral = frictionDirection * colObj->getWorldTransform().getBasis();
		const btVector3& friction_scaling = colObj->getAnisotropicFriction();
		//apply anisotropic friction
		loc_lateral *= friction_scaling;
		// ... and transform it back to global coordinates
		frictionDirection = colObj->getWorldTransform().getBasis() * loc_lateral;
	}
}

void btSequentialImpulseConstraintSolver::setupFrictionConstraint(btSolverConstraint& solverConstraint, const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, const btContactSolverInfo& infoGlobal, btScalar desiredVelocity, btScalar cfmSlip)
{
	btSolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
	btSolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

	btRigidBody* body0 = m_tmpSolverBodyPool[solverBodyIdA].m_originalBody;
	btRigidBody* bodyA = m_tmpSolverBodyPool[solverBodyIdB].m_originalBody;

	solverConstraint.m_solverBodyIdA = solverBodyIdA;
	solverConstraint.m_solverBodyIdB = solverBodyIdB;

	solverConstraint.m_friction = cp.m_combinedFriction;
	solverConstraint.m_originalContactPoint = 0;

	solverConstraint.m_appliedImpulse = 0.f;
	solverConstraint.m_appliedPushImpulse = 0.f;

	if (body0)
	{
		solverConstraint.m_contactNormal1 = normalAxis;
		btVector3 ftorqueAxis1 = rel_pos1.cross(solverConstraint.m_contactNormal1);
		solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
		solverConstraint.m_angularComponentA = body0->getInvInertiaTensorWorld() * ftorqueAxis1 * body0->getAngularFactor();
	}
	else
	{
		solverConstraint.m_contactNormal1.setZero();
		solverConstraint.m_relpos1CrossNormal.setZero();
		solverConstraint.m_angularComponentA.setZero();
	}

	if (bodyA)
	{
		solverConstraint.m_contactNormal2 = -normalAxis;
		btVector3 ftorqueAxis1 = rel_pos2.cross(solverConstraint.m_contactNormal2);
		solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
		solverConstraint.m_angularComponentB = bodyA->getInvInertiaTensorWorld() * ftorqueAxis1 * bodyA->getAngularFactor();
	}
	else
	{
		solverConstraint.m_contactNormal2.setZero();
		solverConstraint.m_relpos2CrossNormal.setZero();
		solverConstraint.m_angularComponentB.setZero();
	}

	{
		btVector3 vec;
		btScalar denom0 = 0.f;
		btScalar denom1 = 0.f;
		if (body0)
		{
			vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
			denom0 = body0->getInvMass() + normalAxis.dot(vec);
		}
		if (bodyA)
		{
			vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
			denom1 = bodyA->getInvMass() + normalAxis.dot(vec);
		}
		btScalar denom = relaxation / (denom0 + denom1);
		solverConstraint.m_jacDiagABInv = denom;
	}

	{
		btScalar rel_vel;
		btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(body0 ? solverBodyA.m_linearVelocity + solverBodyA.m_externalForceImpulse : btVector3(0, 0, 0)) + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : btVector3(0, 0, 0));
		btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(bodyA ? solverBodyB.m_linearVelocity + solverBodyB.m_externalForceImpulse : btVector3(0, 0, 0)) + solverConstraint.m_relpos2CrossNormal.dot(bodyA ? solverBodyB.m_angularVelocity : btVector3(0, 0, 0));

		rel_vel = vel1Dotn + vel2Dotn;

		//		btScalar positionalError = 0.f;

		btScalar velocityError = desiredVelocity - rel_vel;
		btScalar velocityImpulse = velocityError * solverConstraint.m_jacDiagABInv;

		btScalar penetrationImpulse = btScalar(0);

		if (cp.m_contactPointFlags & BT_CONTACT_FLAG_FRICTION_ANCHOR)
		{
			btScalar distance = (cp.getPositionWorldOnA() - cp.getPositionWorldOnB()).dot(normalAxis);
			btScalar positionalError = -distance * infoGlobal.m_frictionERP / infoGlobal.m_timeStep;
			penetrationImpulse = positionalError * solverConstraint.m_jacDiagABInv;
		}

		solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
		solverConstraint.m_rhsPenetration = 0.f;
		solverConstraint.m_cfm = cfmSlip;
		solverConstraint.m_lowerLimit = -solverConstraint.m_friction;
		solverConstraint.m_upperLimit = solverConstraint.m_friction;
	}
}

btSolverConstraint& btSequentialImpulseConstraintSolver::addFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, const btContactSolverInfo& infoGlobal, btScalar desiredVelocity, btScalar cfmSlip)
{
	btSolverConstraint& solverConstraint = m_tmpSolverContactFrictionConstraintPool.expandNonInitializing();
	solverConstraint.m_frictionIndex = frictionIndex;
	setupFrictionConstraint(solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, rel_pos1, rel_pos2,
		colObj0, colObj1, relaxation, infoGlobal, desiredVelocity, cfmSlip);
	return solverConstraint;
}

void btSequentialImpulseConstraintSolver::setupTorsionalFrictionConstraint(btSolverConstraint& solverConstraint, const btVector3& normalAxis1, int solverBodyIdA, int solverBodyIdB,
	btManifoldPoint& cp, btScalar combinedTorsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2,
	btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation,
	btScalar desiredVelocity, btScalar cfmSlip)

{
	btVector3 normalAxis(0, 0, 0);

	solverConstraint.m_contactNormal1 = normalAxis;
	solverConstraint.m_contactNormal2 = -normalAxis;
	btSolverBody& solverBodyA = m_tmpSolverBodyPool[solverBodyIdA];
	btSolverBody& solverBodyB = m_tmpSolverBodyPool[solverBodyIdB];

	btRigidBody* body0 = m_tmpSolverBodyPool[solverBodyIdA].m_originalBody;
	btRigidBody* bodyA = m_tmpSolverBodyPool[solverBodyIdB].m_originalBody;

	solverConstraint.m_solverBodyIdA = solverBodyIdA;
	solverConstraint.m_solverBodyIdB = solverBodyIdB;

	solverConstraint.m_friction = combinedTorsionalFriction;
	solverConstraint.m_originalContactPoint = 0;

	solverConstraint.m_appliedImpulse = 0.f;
	solverConstraint.m_appliedPushImpulse = 0.f;

	{
		btVector3 ftorqueAxis1 = -normalAxis1;
		solverConstraint.m_relpos1CrossNormal = ftorqueAxis1;
		solverConstraint.m_angularComponentA = body0 ? body0->getInvInertiaTensorWorld() * ftorqueAxis1 * body0->getAngularFactor() : btVector3(0, 0, 0);
	}
	{
		btVector3 ftorqueAxis1 = normalAxis1;
		solverConstraint.m_relpos2CrossNormal = ftorqueAxis1;
		solverConstraint.m_angularComponentB = bodyA ? bodyA->getInvInertiaTensorWorld() * ftorqueAxis1 * bodyA->getAngularFactor() : btVector3(0, 0, 0);
	}

	{
		btVector3 iMJaA = body0 ? body0->getInvInertiaTensorWorld() * solverConstraint.m_relpos1CrossNormal : btVector3(0, 0, 0);
		btVector3 iMJaB = bodyA ? bodyA->getInvInertiaTensorWorld() * solverConstraint.m_relpos2CrossNormal : btVector3(0, 0, 0);
		btScalar sum = 0;
		sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
		sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
		solverConstraint.m_jacDiagABInv = btScalar(1.) / sum;
	}

	{
		btScalar rel_vel;
		btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(body0 ? solverBodyA.m_linearVelocity + solverBodyA.m_externalForceImpulse : btVector3(0, 0, 0)) + solverConstraint.m_relpos1CrossNormal.dot(body0 ? solverBodyA.m_angularVelocity : btVector3(0, 0, 0));
		btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(bodyA ? solverBodyB.m_linearVelocity + solverBodyB.m_externalForceImpulse : btVector3(0, 0, 0)) + solverConstraint.m_relpos2CrossNormal.dot(bodyA ? solverBodyB.m_angularVelocity : btVector3(0, 0, 0));

		rel_vel = vel1Dotn + vel2Dotn;

		//		btScalar positionalError = 0.f;

		btSimdScalar velocityError = desiredVelocity - rel_vel;
		btSimdScalar velocityImpulse = velocityError * btSimdScalar(solverConstraint.m_jacDiagABInv);
		solverConstraint.m_rhs = velocityImpulse;
		solverConstraint.m_cfm = cfmSlip;
		solverConstraint.m_lowerLimit = -solverConstraint.m_friction;
		solverConstraint.m_upperLimit = solverConstraint.m_friction;
	}
}

btSolverConstraint& btSequentialImpulseConstraintSolver::addTorsionalFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, btScalar combinedTorsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, btScalar desiredVelocity, btScalar cfmSlip)
{
	btSolverConstraint& solverConstraint = m_tmpSolverContactRollingFrictionConstraintPool.expandNonInitializing();
	solverConstraint.m_frictionIndex = frictionIndex;
	setupTorsionalFrictionConstraint(solverConstraint, normalAxis, solverBodyIdA, solverBodyIdB, cp, combinedTorsionalFriction, rel_pos1, rel_pos2,
		colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
	return solverConstraint;
}

int btSequentialImpulseConstraintSolver::getOrInitSolverBody(btCollisionObject& body, btScalar timeStep)
{
#if BT_THREADSAFE
	int solverBodyId = -1;
	const bool isRigidBodyType = btRigidBody::upcast(&body) != NULL;
	const bool isStaticOrKinematic = body.isStaticOrKinematicObject();
	const bool isKinematic = body.isKinematicObject();
	if (isRigidBodyType && !isStaticOrKinematic)
	{
		// dynamic body
		// Dynamic bodies can only be in one island, so it's safe to write to the companionId
		solverBodyId = body.getCompanionId();
		if (solverBodyId < 0)
		{
			solverBodyId = m_tmpSolverBodyPool.size();
			btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
			initSolverBody(&solverBody, &body, timeStep);
			body.setCompanionId(solverBodyId);
		}
	}
	else if (isRigidBodyType && isKinematic)
	{
		//
		// NOTE: must test for kinematic before static because some kinematic objects also
		//   identify as "static"
		//
		// Kinematic bodies can be in multiple islands at once, so it is a
		// race condition to write to them, so we use an alternate method
		// to record the solverBodyId
		int uniqueId = body.getWorldArrayIndex();
		const int INVALID_SOLVER_BODY_ID = -1;
		if (uniqueId >= m_kinematicBodyUniqueIdToSolverBodyTable.size())
		{
			m_kinematicBodyUniqueIdToSolverBodyTable.resize(uniqueId + 1, INVALID_SOLVER_BODY_ID);
		}
		solverBodyId = m_kinematicBodyUniqueIdToSolverBodyTable[uniqueId];
		// if no table entry yet,
		if (solverBodyId == INVALID_SOLVER_BODY_ID)
		{
			// create a table entry for this body
			solverBodyId = m_tmpSolverBodyPool.size();
			btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
			initSolverBody(&solverBody, &body, timeStep);
			m_kinematicBodyUniqueIdToSolverBodyTable[uniqueId] = solverBodyId;
		}
	}
	else
	{
		bool isMultiBodyType = (body.getInternalType() & btCollisionObject::CO_FEATHERSTONE_LINK);
		// Incorrectly set collision object flags can degrade performance in various ways.
		if (!isMultiBodyType)
		{
			btAssert(body.isStaticOrKinematicObject());
		}
		//it could be a multibody link collider
		// all fixed bodies (inf mass) get mapped to a single solver id
		if (m_fixedBodyId < 0)
		{
			m_fixedBodyId = m_tmpSolverBodyPool.size();
			btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
			initSolverBody(&fixedBody, 0, timeStep);
		}
		solverBodyId = m_fixedBodyId;
	}
	btAssert(solverBodyId >= 0 && solverBodyId < m_tmpSolverBodyPool.size());
	return solverBodyId;
#else   // BT_THREADSAFE

	int solverBodyIdA = -1;

	if (body.getCompanionId() >= 0)
	{
		//body has already been converted
		solverBodyIdA = body.getCompanionId();
		btAssert(solverBodyIdA < m_tmpSolverBodyPool.size());
	}
	else
	{
		btRigidBody* rb = btRigidBody::upcast(&body);
		//convert both active and kinematic objects (for their velocity)
		if (rb && (rb->getInvMass() || rb->isKinematicObject()))
		{
			solverBodyIdA = m_tmpSolverBodyPool.size();
			btSolverBody& solverBody = m_tmpSolverBodyPool.expand();
			initSolverBody(&solverBody, &body, timeStep);
			body.setCompanionId(solverBodyIdA);
		}
		else
		{
			if (m_fixedBodyId < 0)
			{
				m_fixedBodyId = m_tmpSolverBodyPool.size();
				btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
				initSolverBody(&fixedBody, 0, timeStep);
			}
			return m_fixedBodyId;
			//			return 0;//assume first one is a fixed solver body
		}
	}

	return solverBodyIdA;
#endif  // BT_THREADSAFE
}

void btSequentialImpulseConstraintSolver::setupContactConstraint(btSolverConstraint& solverConstraint,
	int solverBodyIdA, int solverBodyIdB,
	btManifoldPoint& cp, const btContactSolverInfo& infoGlobal,
	btScalar& relaxation,
	const btVector3& rel_pos1, const btVector3& rel_pos2)
{
	//	const btVector3& pos1 = cp.getPositionWorldOnA();
	//	const btVector3& pos2 = cp.getPositionWorldOnB();

	btSolverBody* bodyA = &m_tmpSolverBodyPool[solverBodyIdA];
	btSolverBody* bodyB = &m_tmpSolverBodyPool[solverBodyIdB];

	btRigidBody* rb0 = bodyA->m_originalBody;
	btRigidBody* rb1 = bodyB->m_originalBody;

	//			btVector3 rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin();
	//			btVector3 rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();
	//rel_pos1 = pos1 - bodyA->getWorldTransform().getOrigin();
	//rel_pos2 = pos2 - bodyB->getWorldTransform().getOrigin();

	relaxation = infoGlobal.m_sor;
	btScalar invTimeStep = btScalar(1) / infoGlobal.m_timeStep;

	//cfm = 1 /       ( dt * kp + kd )
	//erp = dt * kp / ( dt * kp + kd )

	btScalar cfm = infoGlobal.m_globalCfm;
	btScalar erp = infoGlobal.m_erp2;

	if ((cp.m_contactPointFlags & BT_CONTACT_FLAG_HAS_CONTACT_CFM) || (cp.m_contactPointFlags & BT_CONTACT_FLAG_HAS_CONTACT_ERP))
	{
		if (cp.m_contactPointFlags & BT_CONTACT_FLAG_HAS_CONTACT_CFM)
			cfm = cp.m_contactCFM;
		if (cp.m_contactPointFlags & BT_CONTACT_FLAG_HAS_CONTACT_ERP)
			erp = cp.m_contactERP;
	}
	else
	{
		if (cp.m_contactPointFlags & BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING)
		{
			btScalar denom = (infoGlobal.m_timeStep * cp.m_combinedContactStiffness1 + cp.m_combinedContactDamping1);
			if (denom < SIMD_EPSILON)
			{
				denom = SIMD_EPSILON;
			}
			cfm = btScalar(1) / denom;
			erp = (infoGlobal.m_timeStep * cp.m_combinedContactStiffness1) / denom;
		}
	}

	cfm *= invTimeStep;

	btVector3 torqueAxis0 = rel_pos1.cross(cp.m_normalWorldOnB);
	solverConstraint.m_angularComponentA = rb0 ? rb0->getInvInertiaTensorWorld() * torqueAxis0 * rb0->getAngularFactor() : btVector3(0, 0, 0);
	btVector3 torqueAxis1 = rel_pos2.cross(cp.m_normalWorldOnB);
	solverConstraint.m_angularComponentB = rb1 ? rb1->getInvInertiaTensorWorld() * -torqueAxis1 * rb1->getAngularFactor() : btVector3(0, 0, 0);

	{
#ifdef COMPUTE_IMPULSE_DENOM
		btScalar denom0 = rb0->computeImpulseDenominator(pos1, cp.m_normalWorldOnB);
		btScalar denom1 = rb1->computeImpulseDenominator(pos2, cp.m_normalWorldOnB);
#else
		btVector3 vec;
		btScalar denom0 = 0.f;
		btScalar denom1 = 0.f;
		if (rb0)
		{
			vec = (solverConstraint.m_angularComponentA).cross(rel_pos1);
			denom0 = rb0->getInvMass() + cp.m_normalWorldOnB.dot(vec);
		}
		if (rb1)
		{
			vec = (-solverConstraint.m_angularComponentB).cross(rel_pos2);
			denom1 = rb1->getInvMass() + cp.m_normalWorldOnB.dot(vec);
		}
#endif  //COMPUTE_IMPULSE_DENOM

		btScalar denom = relaxation / (denom0 + denom1 + cfm);
		solverConstraint.m_jacDiagABInv = denom;
	}

	if (rb0)
	{
		solverConstraint.m_contactNormal1 = cp.m_normalWorldOnB;
		solverConstraint.m_relpos1CrossNormal = torqueAxis0;
	}
	else
	{
		solverConstraint.m_contactNormal1.setZero();
		solverConstraint.m_relpos1CrossNormal.setZero();
	}
	if (rb1)
	{
		solverConstraint.m_contactNormal2 = -cp.m_normalWorldOnB;
		solverConstraint.m_relpos2CrossNormal = -torqueAxis1;
	}
	else
	{
		solverConstraint.m_contactNormal2.setZero();
		solverConstraint.m_relpos2CrossNormal.setZero();
	}

	btScalar restitution = 0.f;
	btScalar penetration = cp.getDistance() + infoGlobal.m_linearSlop;

	{
		btVector3 vel1, vel2;

		vel1 = rb0 ? rb0->getVelocityInLocalPoint(rel_pos1) : btVector3(0, 0, 0);
		vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : btVector3(0, 0, 0);

		//			btVector3 vel2 = rb1 ? rb1->getVelocityInLocalPoint(rel_pos2) : btVector3(0,0,0);
		btVector3 vel = vel1 - vel2;
		btScalar rel_vel = cp.m_normalWorldOnB.dot(vel);

		solverConstraint.m_friction = cp.m_combinedFriction;

		restitution = restitutionCurve(rel_vel, cp.m_combinedRestitution, infoGlobal.m_restitutionVelocityThreshold);
		if (restitution <= btScalar(0.))
		{
			restitution = 0.f;
		};
	}

	///warm starting (or zero if disabled)
	if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
	{
		solverConstraint.m_appliedImpulse = cp.m_appliedImpulse * infoGlobal.m_warmstartingFactor;
		if (rb0)
			bodyA->internalApplyImpulse(solverConstraint.m_contactNormal1 * bodyA->internalGetInvMass(), solverConstraint.m_angularComponentA, solverConstraint.m_appliedImpulse);
		if (rb1)
			bodyB->internalApplyImpulse(-solverConstraint.m_contactNormal2 * bodyB->internalGetInvMass(), -solverConstraint.m_angularComponentB, -(btScalar)solverConstraint.m_appliedImpulse);
	}
	else
	{
		solverConstraint.m_appliedImpulse = 0.f;
	}

	solverConstraint.m_appliedPushImpulse = 0.f;

	{
		btVector3 externalForceImpulseA = bodyA->m_originalBody ? bodyA->m_externalForceImpulse : btVector3(0, 0, 0);
		btVector3 externalTorqueImpulseA = bodyA->m_originalBody ? bodyA->m_externalTorqueImpulse : btVector3(0, 0, 0);
		btVector3 externalForceImpulseB = bodyB->m_originalBody ? bodyB->m_externalForceImpulse : btVector3(0, 0, 0);
		btVector3 externalTorqueImpulseB = bodyB->m_originalBody ? bodyB->m_externalTorqueImpulse : btVector3(0, 0, 0);

		btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(bodyA->m_linearVelocity + externalForceImpulseA) + solverConstraint.m_relpos1CrossNormal.dot(bodyA->m_angularVelocity + externalTorqueImpulseA);
		btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(bodyB->m_linearVelocity + externalForceImpulseB) + solverConstraint.m_relpos2CrossNormal.dot(bodyB->m_angularVelocity + externalTorqueImpulseB);
		btScalar rel_vel = vel1Dotn + vel2Dotn;

		btScalar positionalError = 0.f;
		btScalar velocityError = restitution - rel_vel;  // * damping;

		if (penetration > 0)
		{
			positionalError = 0;

			velocityError -= penetration * invTimeStep;
		}
		else
		{
			positionalError = -penetration * erp * invTimeStep;
		}

		btScalar penetrationImpulse = positionalError * solverConstraint.m_jacDiagABInv;
		btScalar velocityImpulse = velocityError * solverConstraint.m_jacDiagABInv;

		if (!infoGlobal.m_splitImpulse || (penetration > infoGlobal.m_splitImpulsePenetrationThreshold))
		{
			//combine position and velocity into rhs
			solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;  //-solverConstraint.m_contactNormal1.dot(bodyA->m_externalForce*bodyA->m_invMass-bodyB->m_externalForce/bodyB->m_invMass)*solverConstraint.m_jacDiagABInv;
			solverConstraint.m_rhsPenetration = 0.f;
		}
		else
		{
			//split position and velocity into rhs and m_rhsPenetration
			solverConstraint.m_rhs = velocityImpulse;
			solverConstraint.m_rhsPenetration = penetrationImpulse;
		}
		solverConstraint.m_cfm = cfm * solverConstraint.m_jacDiagABInv;
		solverConstraint.m_lowerLimit = 0;
		solverConstraint.m_upperLimit = 1e10f;
	}
}

void btSequentialImpulseConstraintSolver::setFrictionConstraintImpulse(btSolverConstraint& solverConstraint,
	int solverBodyIdA, int solverBodyIdB,
	btManifoldPoint& cp, const btContactSolverInfo& infoGlobal)
{
	{
		btSolverConstraint& frictionConstraint1 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex];
		
		frictionConstraint1.m_appliedImpulse = 0.f;
	}

	if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
	{
		btSolverConstraint& frictionConstraint2 = m_tmpSolverContactFrictionConstraintPool[solverConstraint.m_frictionIndex + 1];
		
		frictionConstraint2.m_appliedImpulse = 0.f;
	}
}

void btSequentialImpulseConstraintSolver::convertContact(btPersistentManifold* manifold, const btContactSolverInfo& infoGlobal)
{
	btCollisionObject *colObj0 = 0, *colObj1 = 0;

	colObj0 = (btCollisionObject*)manifold->getBody0();
	colObj1 = (btCollisionObject*)manifold->getBody1();

	int solverBodyIdA = getOrInitSolverBody(*colObj0, infoGlobal.m_timeStep);
	int solverBodyIdB = getOrInitSolverBody(*colObj1, infoGlobal.m_timeStep);

	//	btRigidBody* bodyA = btRigidBody::upcast(colObj0);
	//	btRigidBody* bodyB = btRigidBody::upcast(colObj1);

	btSolverBody* solverBodyA = &m_tmpSolverBodyPool[solverBodyIdA];
	btSolverBody* solverBodyB = &m_tmpSolverBodyPool[solverBodyIdB];

	///avoid collision response between two static objects
	if (!solverBodyA || (solverBodyA->m_invMass.fuzzyZero() && (!solverBodyB || solverBodyB->m_invMass.fuzzyZero())))
		return;

	int rollingFriction = 1;
	for (int j = 0; j < manifold->getNumContacts(); j++)
	{
		btManifoldPoint& cp = manifold->getContactPoint(j);

		if (cp.getDistance() <= manifold->getContactProcessingThreshold())
		{
			btVector3 rel_pos1;
			btVector3 rel_pos2;
			btScalar relaxation;

			int frictionIndex = m_tmpSolverContactConstraintPool.size();
			btSolverConstraint& solverConstraint = m_tmpSolverContactConstraintPool.expandNonInitializing();
			solverConstraint.m_solverBodyIdA = solverBodyIdA;
			solverConstraint.m_solverBodyIdB = solverBodyIdB;

			solverConstraint.m_originalContactPoint = &cp;

			const btVector3& pos1 = cp.getPositionWorldOnA();
			const btVector3& pos2 = cp.getPositionWorldOnB();

			rel_pos1 = pos1 - colObj0->getWorldTransform().getOrigin();
			rel_pos2 = pos2 - colObj1->getWorldTransform().getOrigin();

			btVector3 vel1;
			btVector3 vel2;

			solverBodyA->getVelocityInLocalPointNoDelta(rel_pos1, vel1);
			solverBodyB->getVelocityInLocalPointNoDelta(rel_pos2, vel2);

			btVector3 vel = vel1 - vel2;
			btScalar rel_vel = cp.m_normalWorldOnB.dot(vel);

			setupContactConstraint(solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal, relaxation, rel_pos1, rel_pos2);

			/////setup the friction constraints

			solverConstraint.m_frictionIndex = m_tmpSolverContactFrictionConstraintPool.size();

			if ((cp.m_combinedRollingFriction > 0.f) && (rollingFriction > 0))
			{
				{
					addTorsionalFrictionConstraint(cp.m_normalWorldOnB, solverBodyIdA, solverBodyIdB, frictionIndex, cp, cp.m_combinedSpinningFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
					btVector3 axis0, axis1;
					btPlaneSpace1(cp.m_normalWorldOnB, axis0, axis1);
					axis0.normalize();
					axis1.normalize();

					applyAnisotropicFriction(colObj0, axis0, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
					applyAnisotropicFriction(colObj1, axis0, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
					applyAnisotropicFriction(colObj0, axis1, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
					applyAnisotropicFriction(colObj1, axis1, btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION);
					if (axis0.length() > 0.001)
						addTorsionalFrictionConstraint(axis0, solverBodyIdA, solverBodyIdB, frictionIndex, cp,
							cp.m_combinedRollingFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
					if (axis1.length() > 0.001)
						addTorsionalFrictionConstraint(axis1, solverBodyIdA, solverBodyIdB, frictionIndex, cp,
							cp.m_combinedRollingFriction, rel_pos1, rel_pos2, colObj0, colObj1, relaxation);
					}
				}

			///Bullet has several options to set the friction directions
			///By default, each contact has only a single friction direction that is recomputed automatically very frame
			///based on the relative linear velocity.
			///If the relative velocity it zero, it will automatically compute a friction direction.

			///You can also enable two friction directions, using the SOLVER_USE_2_FRICTION_DIRECTIONS.
			///In that case, the second friction direction will be orthogonal to both contact normal and first friction direction.
			///
			///If you choose SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION, then the friction will be independent from the relative projected velocity.
			///
			///The user can manually override the friction directions for certain contacts using a contact callback,
			///and use contactPoint.m_contactPointFlags |= BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED
			///In that case, you can set the target relative motion in each friction direction (cp.m_contactMotion1 and cp.m_contactMotion2)
			///this will give a conveyor belt effect
			///

			if (!(infoGlobal.m_solverMode & SOLVER_ENABLE_FRICTION_DIRECTION_CACHING) || !(cp.m_contactPointFlags & BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED))
			{
				cp.m_lateralFrictionDir1 = vel - cp.m_normalWorldOnB * rel_vel;
				btScalar lat_rel_vel = cp.m_lateralFrictionDir1.length2();
				if (!(infoGlobal.m_solverMode & SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION) && lat_rel_vel > SIMD_EPSILON)
				{
					cp.m_lateralFrictionDir1 *= 1.f / btSqrt(lat_rel_vel);
					applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
					applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
					addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);

					if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
					{
						cp.m_lateralFrictionDir2 = cp.m_lateralFrictionDir1.cross(cp.m_normalWorldOnB);
						cp.m_lateralFrictionDir2.normalize();  //??
						applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
						applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
						addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);
					}
				}
				else
				{
					btPlaneSpace1(cp.m_normalWorldOnB, cp.m_lateralFrictionDir1, cp.m_lateralFrictionDir2);

					applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
					applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir1, btCollisionObject::CF_ANISOTROPIC_FRICTION);
					addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);

					if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
					{
						applyAnisotropicFriction(colObj0, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
						applyAnisotropicFriction(colObj1, cp.m_lateralFrictionDir2, btCollisionObject::CF_ANISOTROPIC_FRICTION);
						addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal);
					}

					if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS) && (infoGlobal.m_solverMode & SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION))
					{
						cp.m_contactPointFlags |= BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED;
					}
				}
			}
			else
			{
				addFrictionConstraint(cp.m_lateralFrictionDir1, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal, cp.m_contactMotion1, cp.m_frictionCFM);

				if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
					addFrictionConstraint(cp.m_lateralFrictionDir2, solverBodyIdA, solverBodyIdB, frictionIndex, cp, rel_pos1, rel_pos2, colObj0, colObj1, relaxation, infoGlobal, cp.m_contactMotion2, cp.m_frictionCFM);
				}
			setFrictionConstraintImpulse(solverConstraint, solverBodyIdA, solverBodyIdB, cp, infoGlobal);
			}
		}
	}

void btSequentialImpulseConstraintSolver::convertContacts(btPersistentManifold** manifoldPtr, int numManifolds, const btContactSolverInfo& infoGlobal)
{
	int i;
	btPersistentManifold* manifold = 0;
	//			btCollisionObject* colObj0=0,*colObj1=0;

	for (i = 0; i < numManifolds; i++)
	{
		manifold = manifoldPtr[i];
		convertContact(manifold, infoGlobal);
	}
}

void btSequentialImpulseConstraintSolver::convertJoint(btSolverConstraint* currentConstraintRow,
	btTypedConstraint* constraint,
	const btTypedConstraint::btConstraintInfo1& info1,
	int solverBodyIdA,
	int solverBodyIdB,
	const btContactSolverInfo& infoGlobal)
{
	const btRigidBody& rbA = constraint->getRigidBodyA();
	const btRigidBody& rbB = constraint->getRigidBodyB();

	const btSolverBody* bodyAPtr = &m_tmpSolverBodyPool[solverBodyIdA];
	const btSolverBody* bodyBPtr = &m_tmpSolverBodyPool[solverBodyIdB];

	int overrideNumSolverIterations = constraint->getOverrideNumSolverIterations() > 0 ? constraint->getOverrideNumSolverIterations() : infoGlobal.m_numIterations;
	if (overrideNumSolverIterations > m_maxOverrideNumSolverIterations)
		m_maxOverrideNumSolverIterations = overrideNumSolverIterations;

	for (int j = 0; j < info1.m_numConstraintRows; j++)
	{
		memset(&currentConstraintRow[j], 0, sizeof(btSolverConstraint));
		currentConstraintRow[j].m_lowerLimit = -SIMD_INFINITY;
		currentConstraintRow[j].m_upperLimit = SIMD_INFINITY;
		currentConstraintRow[j].m_appliedImpulse = 0.f;
		currentConstraintRow[j].m_appliedPushImpulse = 0.f;
		currentConstraintRow[j].m_solverBodyIdA = solverBodyIdA;
		currentConstraintRow[j].m_solverBodyIdB = solverBodyIdB;
		currentConstraintRow[j].m_overrideNumSolverIterations = overrideNumSolverIterations;
	}

	// these vectors are already cleared in initSolverBody, no need to redundantly clear again
	btAssert(bodyAPtr->getDeltaLinearVelocity().isZero());
	btAssert(bodyAPtr->getDeltaAngularVelocity().isZero());
	btAssert(bodyAPtr->getPushVelocity().isZero());
	btAssert(bodyAPtr->getTurnVelocity().isZero());
	btAssert(bodyBPtr->getDeltaLinearVelocity().isZero());
	btAssert(bodyBPtr->getDeltaAngularVelocity().isZero());
	btAssert(bodyBPtr->getPushVelocity().isZero());
	btAssert(bodyBPtr->getTurnVelocity().isZero());
	//bodyAPtr->internalGetDeltaLinearVelocity().setValue(0.f,0.f,0.f);
	//bodyAPtr->internalGetDeltaAngularVelocity().setValue(0.f,0.f,0.f);
	//bodyAPtr->internalGetPushVelocity().setValue(0.f,0.f,0.f);
	//bodyAPtr->internalGetTurnVelocity().setValue(0.f,0.f,0.f);
	//bodyBPtr->internalGetDeltaLinearVelocity().setValue(0.f,0.f,0.f);
	//bodyBPtr->internalGetDeltaAngularVelocity().setValue(0.f,0.f,0.f);
	//bodyBPtr->internalGetPushVelocity().setValue(0.f,0.f,0.f);
	//bodyBPtr->internalGetTurnVelocity().setValue(0.f,0.f,0.f);

	btTypedConstraint::btConstraintInfo2 info2;
	info2.fps = 1.f / infoGlobal.m_timeStep;
	info2.erp = infoGlobal.m_erp;
	info2.m_J1linearAxis = currentConstraintRow->m_contactNormal1;
	info2.m_J1angularAxis = currentConstraintRow->m_relpos1CrossNormal;
	info2.m_J2linearAxis = currentConstraintRow->m_contactNormal2;
	info2.m_J2angularAxis = currentConstraintRow->m_relpos2CrossNormal;
	info2.rowskip = sizeof(btSolverConstraint) / sizeof(btScalar);  //check this
																	///the size of btSolverConstraint needs be a multiple of btScalar
	btAssert(info2.rowskip * sizeof(btScalar) == sizeof(btSolverConstraint));
	info2.m_constraintError = &currentConstraintRow->m_rhs;
	currentConstraintRow->m_cfm = infoGlobal.m_globalCfm;
	info2.m_damping = infoGlobal.m_damping;
	info2.cfm = &currentConstraintRow->m_cfm;
	info2.m_lowerLimit = &currentConstraintRow->m_lowerLimit;
	info2.m_upperLimit = &currentConstraintRow->m_upperLimit;
	info2.m_numIterations = infoGlobal.m_numIterations;
	constraint->getInfo2(&info2);

	///finalize the constraint setup
	for (int j = 0; j < info1.m_numConstraintRows; j++)
	{
		btSolverConstraint& solverConstraint = currentConstraintRow[j];

		if (solverConstraint.m_upperLimit >= constraint->getBreakingImpulseThreshold())
		{
			solverConstraint.m_upperLimit = constraint->getBreakingImpulseThreshold();
		}

		if (solverConstraint.m_lowerLimit <= -constraint->getBreakingImpulseThreshold())
		{
			solverConstraint.m_lowerLimit = -constraint->getBreakingImpulseThreshold();
		}

		solverConstraint.m_originalContactPoint = constraint;

		{
			const btVector3& ftorqueAxis1 = solverConstraint.m_relpos1CrossNormal;
			solverConstraint.m_angularComponentA = constraint->getRigidBodyA().getInvInertiaTensorWorld() * ftorqueAxis1 * constraint->getRigidBodyA().getAngularFactor();
		}
		{
			const btVector3& ftorqueAxis2 = solverConstraint.m_relpos2CrossNormal;
			solverConstraint.m_angularComponentB = constraint->getRigidBodyB().getInvInertiaTensorWorld() * ftorqueAxis2 * constraint->getRigidBodyB().getAngularFactor();
		}

		{
			btVector3 iMJlA = solverConstraint.m_contactNormal1 * rbA.getInvMass();
			btVector3 iMJaA = rbA.getInvInertiaTensorWorld() * solverConstraint.m_relpos1CrossNormal;
			btVector3 iMJlB = solverConstraint.m_contactNormal2 * rbB.getInvMass();  //sign of normal?
			btVector3 iMJaB = rbB.getInvInertiaTensorWorld() * solverConstraint.m_relpos2CrossNormal;

			btScalar sum = iMJlA.dot(solverConstraint.m_contactNormal1);
			sum += iMJaA.dot(solverConstraint.m_relpos1CrossNormal);
			sum += iMJlB.dot(solverConstraint.m_contactNormal2);
			sum += iMJaB.dot(solverConstraint.m_relpos2CrossNormal);
			btScalar fsum = btFabs(sum);
			btAssert(fsum > SIMD_EPSILON);
			btScalar sorRelaxation = 1.f;  //todo: get from globalInfo?
			solverConstraint.m_jacDiagABInv = fsum > SIMD_EPSILON ? sorRelaxation / sum : 0.f;
		}

		{
			btScalar rel_vel;
			btVector3 externalForceImpulseA = bodyAPtr->m_originalBody ? bodyAPtr->m_externalForceImpulse : btVector3(0, 0, 0);
			btVector3 externalTorqueImpulseA = bodyAPtr->m_originalBody ? bodyAPtr->m_externalTorqueImpulse : btVector3(0, 0, 0);

			btVector3 externalForceImpulseB = bodyBPtr->m_originalBody ? bodyBPtr->m_externalForceImpulse : btVector3(0, 0, 0);
			btVector3 externalTorqueImpulseB = bodyBPtr->m_originalBody ? bodyBPtr->m_externalTorqueImpulse : btVector3(0, 0, 0);

			btScalar vel1Dotn = solverConstraint.m_contactNormal1.dot(rbA.getLinearVelocity() + externalForceImpulseA) + solverConstraint.m_relpos1CrossNormal.dot(rbA.getAngularVelocity() + externalTorqueImpulseA);

			btScalar vel2Dotn = solverConstraint.m_contactNormal2.dot(rbB.getLinearVelocity() + externalForceImpulseB) + solverConstraint.m_relpos2CrossNormal.dot(rbB.getAngularVelocity() + externalTorqueImpulseB);

			rel_vel = vel1Dotn + vel2Dotn;
			btScalar restitution = 0.f;
			btScalar positionalError = solverConstraint.m_rhs;  //already filled in by getConstraintInfo2
			btScalar velocityError = restitution - rel_vel * info2.m_damping;
			btScalar penetrationImpulse = positionalError * solverConstraint.m_jacDiagABInv;
			btScalar velocityImpulse = velocityError * solverConstraint.m_jacDiagABInv;
			solverConstraint.m_rhs = penetrationImpulse + velocityImpulse;
			solverConstraint.m_appliedImpulse = 0.f;
		}
	}
}

void btSequentialImpulseConstraintSolver::convertJoints(btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal)
{
	BT_PROFILE("convertJoints");
	for (int j = 0; j < numConstraints; j++)
	{
		btTypedConstraint* constraint = constraints[j];
		constraint->buildJacobian();
		constraint->internalSetAppliedImpulse(0.0f);
	}

	int totalNumRows = 0;

	m_tmpConstraintSizesPool.resizeNoInitialize(numConstraints);
	//calculate the total number of contraint rows
	for (int i = 0; i < numConstraints; i++)
	{
		btTypedConstraint::btConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];
		btJointFeedback* fb = constraints[i]->getJointFeedback();
		if (fb)
		{
			fb->m_appliedForceBodyA.setZero();
			fb->m_appliedTorqueBodyA.setZero();
			fb->m_appliedForceBodyB.setZero();
			fb->m_appliedTorqueBodyB.setZero();
		}

		if (constraints[i]->isEnabled())
		{
			constraints[i]->getInfo1(&info1);
		}
		else
		{
			info1.m_numConstraintRows = 0;
			info1.nub = 0;
		}
		totalNumRows += info1.m_numConstraintRows;
	}
	m_tmpSolverNonContactConstraintPool.resizeNoInitialize(totalNumRows);

	///setup the btSolverConstraints
	int currentRow = 0;

	for (int i = 0; i < numConstraints; i++)
	{
		const btTypedConstraint::btConstraintInfo1& info1 = m_tmpConstraintSizesPool[i];

		if (info1.m_numConstraintRows)
		{
			btAssert(currentRow < totalNumRows);

			btSolverConstraint* currentConstraintRow = &m_tmpSolverNonContactConstraintPool[currentRow];
			btTypedConstraint* constraint = constraints[i];
			btRigidBody& rbA = constraint->getRigidBodyA();
			btRigidBody& rbB = constraint->getRigidBodyB();

			int solverBodyIdA = getOrInitSolverBody(rbA, infoGlobal.m_timeStep);
			int solverBodyIdB = getOrInitSolverBody(rbB, infoGlobal.m_timeStep);

			convertJoint(currentConstraintRow, constraint, info1, solverBodyIdA, solverBodyIdB, infoGlobal);
		}
		currentRow += info1.m_numConstraintRows;
	}
}

void btSequentialImpulseConstraintSolver::convertBodies(btCollisionObject** bodies, int numBodies, const btContactSolverInfo& infoGlobal)
{
	BT_PROFILE("convertBodies");
	for (int i = 0; i < numBodies; i++)
	{
		bodies[i]->setCompanionId(-1);
	}
#if BT_THREADSAFE
	m_kinematicBodyUniqueIdToSolverBodyTable.resize(0);
#endif  // BT_THREADSAFE

	m_tmpSolverBodyPool.reserve(numBodies + 1);
	m_tmpSolverBodyPool.resize(0);

	//btSolverBody& fixedBody = m_tmpSolverBodyPool.expand();
	//initSolverBody(&fixedBody,0);

	for (int i = 0; i < numBodies; i++)
	{
		int bodyId = getOrInitSolverBody(*bodies[i], infoGlobal.m_timeStep);

		btRigidBody* body = btRigidBody::upcast(bodies[i]);
		if (body && body->getInvMass())
		{
			btSolverBody& solverBody = m_tmpSolverBodyPool[bodyId];
			btVector3 gyroForce(0, 0, 0);
			if (body->getFlags() & BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT)
			{
				gyroForce = body->computeGyroscopicForceExplicit(infoGlobal.m_maxGyroscopicForce);
				solverBody.m_externalTorqueImpulse -= gyroForce * body->getInvInertiaTensorWorld() * infoGlobal.m_timeStep;
			}
			if (body->getFlags() & BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD)
			{
				gyroForce = body->computeGyroscopicImpulseImplicit_World(infoGlobal.m_timeStep);
				solverBody.m_externalTorqueImpulse += gyroForce;
			}
			if (body->getFlags() & BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY)
			{
				gyroForce = body->computeGyroscopicImpulseImplicit_Body(infoGlobal.m_timeStep);
				solverBody.m_externalTorqueImpulse += gyroForce;
			}
		}
	}
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySetup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
	m_fixedBodyId = -1;
	BT_PROFILE("solveGroupCacheFriendlySetup");
	(void)debugDrawer;

	// if solver mode has changed,
	if (infoGlobal.m_solverMode != m_cachedSolverMode)
	{
		// update solver functions to use SIMD or non-SIMD
		bool useSimd = !!(infoGlobal.m_solverMode & SOLVER_SIMD);
		setupSolverFunctions(useSimd);
		m_cachedSolverMode = infoGlobal.m_solverMode;
	}
	m_maxOverrideNumSolverIterations = 0;

#ifdef BT_ADDITIONAL_DEBUG
	//make sure that dynamic bodies exist for all (enabled) constraints
	for (int i = 0; i < numConstraints; i++)
	{
		btTypedConstraint* constraint = constraints[i];
		if (constraint->isEnabled())
		{
			if (!constraint->getRigidBodyA().isStaticOrKinematicObject())
			{
				bool found = false;
				for (int b = 0; b < numBodies; b++)
				{
					if (&constraint->getRigidBodyA() == bodies[b])
					{
						found = true;
						break;
					}
				}
				btAssert(found);
			}
			if (!constraint->getRigidBodyB().isStaticOrKinematicObject())
			{
				bool found = false;
				for (int b = 0; b < numBodies; b++)
				{
					if (&constraint->getRigidBodyB() == bodies[b])
					{
						found = true;
						break;
					}
				}
				btAssert(found);
			}
		}
	}
	//make sure that dynamic bodies exist for all contact manifolds
	for (int i = 0; i < numManifolds; i++)
	{
		if (!manifoldPtr[i]->getBody0()->isStaticOrKinematicObject())
		{
			bool found = false;
			for (int b = 0; b < numBodies; b++)
			{
				if (manifoldPtr[i]->getBody0() == bodies[b])
				{
					found = true;
					break;
				}
			}
			btAssert(found);
		}
		if (!manifoldPtr[i]->getBody1()->isStaticOrKinematicObject())
		{
			bool found = false;
			for (int b = 0; b < numBodies; b++)
			{
				if (manifoldPtr[i]->getBody1() == bodies[b])
				{
					found = true;
					break;
				}
			}
			btAssert(found);
		}
	}
#endif  //BT_ADDITIONAL_DEBUG

	//convert all bodies
	convertBodies(bodies, numBodies, infoGlobal);

	convertJoints(constraints, numConstraints, infoGlobal);

	convertContacts(manifoldPtr, numManifolds, infoGlobal);

	//	btContactSolverInfo info = infoGlobal;

	int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
	int numConstraintPool = m_tmpSolverContactConstraintPool.size();
	int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

	///@todo: use stack allocator for such temporarily memory, same for solver bodies/constraints
	m_orderNonContactConstraintPool.resizeNoInitialize(numNonContactPool);
	if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
		m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool * 2);
	else
		m_orderTmpConstraintPool.resizeNoInitialize(numConstraintPool);

	m_orderFrictionConstraintPool.resizeNoInitialize(numFrictionPool);
	{
		int i;
		for (i = 0; i < numNonContactPool; i++)
		{
			m_orderNonContactConstraintPool[i] = i;
		}
		for (i = 0; i < numConstraintPool; i++)
		{
			m_orderTmpConstraintPool[i] = i;
		}
		for (i = 0; i < numFrictionPool; i++)
		{
			m_orderFrictionConstraintPool[i] = i;
		}
	}

	return 0.f;
}

btScalar btSequentialImpulseConstraintSolver::solveSingleIteration(int iteration, btCollisionObject** /*bodies */, int /*numBodies*/, btPersistentManifold** /*manifoldPtr*/, int /*numManifolds*/, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* /*debugDrawer*/)
{
	BT_PROFILE("solveSingleIteration");
	btScalar leastSquaresResidual = 0.f;

	int numNonContactPool = m_tmpSolverNonContactConstraintPool.size();
	int numConstraintPool = m_tmpSolverContactConstraintPool.size();
	int numFrictionPool = m_tmpSolverContactFrictionConstraintPool.size();

	if (infoGlobal.m_solverMode & SOLVER_RANDMIZE_ORDER)
	{
		if (1)  // uncomment this for a bit less random ((iteration & 7) == 0)
		{
			for (int j = 0; j < numNonContactPool; ++j)
			{
				int tmp = m_orderNonContactConstraintPool[j];
				int swapi = btRandInt2(j + 1);
				m_orderNonContactConstraintPool[j] = m_orderNonContactConstraintPool[swapi];
				m_orderNonContactConstraintPool[swapi] = tmp;
			}

			//contact/friction constraints are not solved more than
			if (iteration < infoGlobal.m_numIterations)
			{
				for (int j = 0; j < numConstraintPool; ++j)
				{
					int tmp = m_orderTmpConstraintPool[j];
					int swapi = btRandInt2(j + 1);
					m_orderTmpConstraintPool[j] = m_orderTmpConstraintPool[swapi];
					m_orderTmpConstraintPool[swapi] = tmp;
				}

				for (int j = 0; j < numFrictionPool; ++j)
				{
					int tmp = m_orderFrictionConstraintPool[j];
					int swapi = btRandInt2(j + 1);
					m_orderFrictionConstraintPool[j] = m_orderFrictionConstraintPool[swapi];
					m_orderFrictionConstraintPool[swapi] = tmp;
				}
			}
		}
	}

	///solve all joint constraints
	for (int j = 0; j < m_tmpSolverNonContactConstraintPool.size(); j++)
	{
		btSolverConstraint& constraint = m_tmpSolverNonContactConstraintPool[m_orderNonContactConstraintPool[j]];
		if (iteration < constraint.m_overrideNumSolverIterations)
		{
			btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[constraint.m_solverBodyIdA], m_tmpSolverBodyPool[constraint.m_solverBodyIdB], constraint);
			leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
		}
	}

	if (iteration < infoGlobal.m_numIterations)
	{
		for (int j = 0; j < numConstraints; j++)
		{
			if (constraints[j]->isEnabled())
			{
				int bodyAid = getOrInitSolverBody(constraints[j]->getRigidBodyA(), infoGlobal.m_timeStep);
				int bodyBid = getOrInitSolverBody(constraints[j]->getRigidBodyB(), infoGlobal.m_timeStep);
				btSolverBody& bodyA = m_tmpSolverBodyPool[bodyAid];
				btSolverBody& bodyB = m_tmpSolverBodyPool[bodyBid];
				constraints[j]->solveConstraintObsolete(bodyA, bodyB, infoGlobal.m_timeStep);
			}
		}

		///solve all contact constraints
		if (infoGlobal.m_solverMode & SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS)
		{
			int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
			int multiplier = (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS) ? 2 : 1;

			for (int c = 0; c < numPoolConstraints; c++)
			{
				btScalar totalImpulse = 0;

				{
					const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[c]];
					btScalar residual = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
					leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);

					totalImpulse = solveManifold.m_appliedImpulse;
				}
				bool applyFriction = true;
				if (applyFriction)
				{
					{
						btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c * multiplier]];

						if (totalImpulse > btScalar(0))
						{
							solveManifold.m_lowerLimit = -(solveManifold.m_friction * totalImpulse);
							solveManifold.m_upperLimit = solveManifold.m_friction * totalImpulse;

							btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
							leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
						}
					}

					if (infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS)
					{
						btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[c * multiplier + 1]];

						if (totalImpulse > btScalar(0))
						{
							solveManifold.m_lowerLimit = -(solveManifold.m_friction * totalImpulse);
							solveManifold.m_upperLimit = solveManifold.m_friction * totalImpulse;

							btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
							leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
						}
					}
				}
			}
		}
		else  //SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS
		{
			//solve the friction constraints after all contact constraints, don't interleave them
			int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
			int j;

			for (j = 0; j < numPoolConstraints; j++)
			{
				const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];
				btScalar residual = resolveSingleConstraintRowLowerLimit(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
				leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
			}

			///solve all friction constraints

			int numFrictionPoolConstraints = m_tmpSolverContactFrictionConstraintPool.size();
			for (j = 0; j < numFrictionPoolConstraints; j++)
			{
				btSolverConstraint& solveManifold = m_tmpSolverContactFrictionConstraintPool[m_orderFrictionConstraintPool[j]];
				btScalar totalImpulse = m_tmpSolverContactConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;

				if (totalImpulse > btScalar(0))
				{
					solveManifold.m_lowerLimit = -(solveManifold.m_friction * totalImpulse);
					solveManifold.m_upperLimit = solveManifold.m_friction * totalImpulse;

					btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
					leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
				}
			}
		}

		int numRollingFrictionPoolConstraints = m_tmpSolverContactRollingFrictionConstraintPool.size();
		for (int j = 0; j < numRollingFrictionPoolConstraints; j++)
		{
			btSolverConstraint& rollingFrictionConstraint = m_tmpSolverContactRollingFrictionConstraintPool[j];
			btScalar totalImpulse = m_tmpSolverContactConstraintPool[rollingFrictionConstraint.m_frictionIndex].m_appliedImpulse;
			if (totalImpulse > btScalar(0))
			{
				btScalar rollingFrictionMagnitude = rollingFrictionConstraint.m_friction * totalImpulse;
				if (rollingFrictionMagnitude > rollingFrictionConstraint.m_friction)
					rollingFrictionMagnitude = rollingFrictionConstraint.m_friction;

				rollingFrictionConstraint.m_lowerLimit = -rollingFrictionMagnitude;
				rollingFrictionConstraint.m_upperLimit = rollingFrictionMagnitude;

				btScalar residual = resolveSingleConstraintRowGeneric(m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdA], m_tmpSolverBodyPool[rollingFrictionConstraint.m_solverBodyIdB], rollingFrictionConstraint);
				leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
			}
		}
	}
	return leastSquaresResidual;
}

void btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySplitImpulseIterations(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
	BT_PROFILE("solveGroupCacheFriendlySplitImpulseIterations");
	int iteration;
	if (infoGlobal.m_splitImpulse)
	{
		{
			for (iteration = 0; iteration < infoGlobal.m_numIterations; iteration++)
			{
				btScalar leastSquaresResidual = 0.f;
				{
					int numPoolConstraints = m_tmpSolverContactConstraintPool.size();
					int j;
					for (j = 0; j < numPoolConstraints; j++)
					{
						const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[m_orderTmpConstraintPool[j]];

						btScalar residual = resolveSplitPenetrationImpulse(m_tmpSolverBodyPool[solveManifold.m_solverBodyIdA], m_tmpSolverBodyPool[solveManifold.m_solverBodyIdB], solveManifold);
						leastSquaresResidual = btMax(leastSquaresResidual, residual * residual);
					}
				}
				if (leastSquaresResidual <= infoGlobal.m_leastSquaresResidualThreshold || iteration >= (infoGlobal.m_numIterations - 1))
				{
#ifdef VERBOSE_RESIDUAL_PRINTF
					printf("residual = %f at iteration #%d\n", leastSquaresResidual, iteration);
#endif
					break;
				}
			}
		}
	}
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyIterations(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer)
{
	BT_PROFILE("solveGroupCacheFriendlyIterations");

	{
		///this is a special step to resolve penetrations (just for contacts)
		solveGroupCacheFriendlySplitImpulseIterations(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

		int maxIterations = m_maxOverrideNumSolverIterations > infoGlobal.m_numIterations ? m_maxOverrideNumSolverIterations : infoGlobal.m_numIterations;

		for (int iteration = 0; iteration < maxIterations; iteration++)
			//for ( int iteration = maxIterations-1  ; iteration >= 0;iteration--)
		{
			m_leastSquaresResidual = solveSingleIteration(iteration, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

			if (m_leastSquaresResidual <= infoGlobal.m_leastSquaresResidualThreshold || (iteration >= (maxIterations - 1)))
			{
#ifdef VERBOSE_RESIDUAL_PRINTF
				printf("residual = %f at iteration #%d\n", m_leastSquaresResidual, iteration);
#endif
				m_analyticsData.m_numSolverCalls++;
				m_analyticsData.m_numIterationsUsed = iteration+1;
				m_analyticsData.m_islandId = -2;
				if (numBodies>0)
					m_analyticsData.m_islandId = bodies[0]->getCompanionId();
				m_analyticsData.m_numBodies = numBodies;
				m_analyticsData.m_numContactManifolds = numManifolds;
				m_analyticsData.m_remainingLeastSquaresResidual = m_leastSquaresResidual;
				break;
			}
		}
	}
	return 0.f;
}

void btSequentialImpulseConstraintSolver::writeBackContacts(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal)
{
	for (int j = iBegin; j < iEnd; j++)
	{
		const btSolverConstraint& solveManifold = m_tmpSolverContactConstraintPool[j];
		btManifoldPoint* pt = (btManifoldPoint*)solveManifold.m_originalContactPoint;
		btAssert(pt);
		pt->m_appliedImpulse = solveManifold.m_appliedImpulse;
		//	float f = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
		//	printf("pt->m_appliedImpulseLateral1 = %f\n", f);
		pt->m_appliedImpulseLateral1 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex].m_appliedImpulse;
		//printf("pt->m_appliedImpulseLateral1 = %f\n", pt->m_appliedImpulseLateral1);
		if ((infoGlobal.m_solverMode & SOLVER_USE_2_FRICTION_DIRECTIONS))
		{
			pt->m_appliedImpulseLateral2 = m_tmpSolverContactFrictionConstraintPool[solveManifold.m_frictionIndex + 1].m_appliedImpulse;
		}
		//do a callback here?
	}
}

void btSequentialImpulseConstraintSolver::writeBackJoints(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal)
{
	for (int j = iBegin; j < iEnd; j++)
	{
		const btSolverConstraint& solverConstr = m_tmpSolverNonContactConstraintPool[j];
		btTypedConstraint* constr = (btTypedConstraint*)solverConstr.m_originalContactPoint;
		btJointFeedback* fb = constr->getJointFeedback();
		if (fb)
		{
			fb->m_appliedForceBodyA += solverConstr.m_contactNormal1 * solverConstr.m_appliedImpulse * constr->getRigidBodyA().getLinearFactor() / infoGlobal.m_timeStep;
			fb->m_appliedForceBodyB += solverConstr.m_contactNormal2 * solverConstr.m_appliedImpulse * constr->getRigidBodyB().getLinearFactor() / infoGlobal.m_timeStep;
			fb->m_appliedTorqueBodyA += solverConstr.m_relpos1CrossNormal * constr->getRigidBodyA().getAngularFactor() * solverConstr.m_appliedImpulse / infoGlobal.m_timeStep;
			fb->m_appliedTorqueBodyB += solverConstr.m_relpos2CrossNormal * constr->getRigidBodyB().getAngularFactor() * solverConstr.m_appliedImpulse / infoGlobal.m_timeStep; /*RGM ???? */
		}

		constr->internalSetAppliedImpulse(solverConstr.m_appliedImpulse);
		if (btFabs(solverConstr.m_appliedImpulse) >= constr->getBreakingImpulseThreshold())
		{
			constr->setEnabled(false);
		}
	}
}

void btSequentialImpulseConstraintSolver::writeBackBodies(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal)
{
	for (int i = iBegin; i < iEnd; i++)
	{
		btRigidBody* body = m_tmpSolverBodyPool[i].m_originalBody;
		if (body)
		{
			if (infoGlobal.m_splitImpulse)
				m_tmpSolverBodyPool[i].writebackVelocityAndTransform(infoGlobal.m_timeStep, infoGlobal.m_splitImpulseTurnErp);
			else
				m_tmpSolverBodyPool[i].writebackVelocity();

			m_tmpSolverBodyPool[i].m_originalBody->setLinearVelocity(
				m_tmpSolverBodyPool[i].m_linearVelocity +
				m_tmpSolverBodyPool[i].m_externalForceImpulse);

			m_tmpSolverBodyPool[i].m_originalBody->setAngularVelocity(
				m_tmpSolverBodyPool[i].m_angularVelocity +
				m_tmpSolverBodyPool[i].m_externalTorqueImpulse);

			if (infoGlobal.m_splitImpulse)
				m_tmpSolverBodyPool[i].m_originalBody->setWorldTransform(m_tmpSolverBodyPool[i].m_worldTransform);

			m_tmpSolverBodyPool[i].m_originalBody->setCompanionId(-1);
		}
	}
}

btScalar btSequentialImpulseConstraintSolver::solveGroupCacheFriendlyFinish(btCollisionObject** bodies, int numBodies, const btContactSolverInfo& infoGlobal)
{
	BT_PROFILE("solveGroupCacheFriendlyFinish");

	if (infoGlobal.m_solverMode & SOLVER_USE_WARMSTARTING)
	{
		writeBackContacts(0, m_tmpSolverContactConstraintPool.size(), infoGlobal);
	}

	writeBackJoints(0, m_tmpSolverNonContactConstraintPool.size(), infoGlobal);
	writeBackBodies(0, m_tmpSolverBodyPool.size(), infoGlobal);

	m_tmpSolverContactConstraintPool.resizeNoInitialize(0);
	m_tmpSolverNonContactConstraintPool.resizeNoInitialize(0);
	m_tmpSolverContactFrictionConstraintPool.resizeNoInitialize(0);
	m_tmpSolverContactRollingFrictionConstraintPool.resizeNoInitialize(0);

	m_tmpSolverBodyPool.resizeNoInitialize(0);
	return 0.f;
}

/// btSequentialImpulseConstraintSolver Sequentially applies impulses
btScalar btSequentialImpulseConstraintSolver::solveGroup(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer, btDispatcher* /*dispatcher*/)
{
	BT_PROFILE("solveGroup");
	//you need to provide at least some bodies

	solveGroupCacheFriendlySetup(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

	solveGroupCacheFriendlyIterations(bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer);

	solveGroupCacheFriendlyFinish(bodies, numBodies, infoGlobal);

	return 0.f;
}

void btSequentialImpulseConstraintSolver::reset()
{
	m_btSeed2 = 0;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H
#define BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H

class btIDebugDraw;
class btPersistentManifold;
class btDispatcher;
class btCollisionObject;
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "BulletDynamics/ConstraintSolver/btSolverBody.h"
#include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
#include "BulletDynamics/ConstraintSolver/btConstraintSolver.h"

typedef btScalar (*btSingleConstraintRowSolver)(btSolverBody&, btSolverBody&, const btSolverConstraint&);

struct btSolverAnalyticsData
{
	btSolverAnalyticsData()
	{
		m_numSolverCalls = 0;
		m_numIterationsUsed = -1;
		m_remainingLeastSquaresResidual = -1;
		m_islandId = -2;
	}
	int m_islandId;
	int m_numBodies;
	int m_numContactManifolds;
	int m_numSolverCalls;
	int m_numIterationsUsed;
	double m_remainingLeastSquaresResidual;
};

///The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
ATTRIBUTE_ALIGNED16(class)
btSequentialImpulseConstraintSolver : public btConstraintSolver
{
	

protected:
	btAlignedObjectArray<btSolverBody> m_tmpSolverBodyPool;
	btConstraintArray m_tmpSolverContactConstraintPool;
	btConstraintArray m_tmpSolverNonContactConstraintPool;
	btConstraintArray m_tmpSolverContactFrictionConstraintPool;
	btConstraintArray m_tmpSolverContactRollingFrictionConstraintPool;

	btAlignedObjectArray<int> m_orderTmpConstraintPool;
	btAlignedObjectArray<int> m_orderNonContactConstraintPool;
	btAlignedObjectArray<int> m_orderFrictionConstraintPool;
	btAlignedObjectArray<btTypedConstraint::btConstraintInfo1> m_tmpConstraintSizesPool;
	int m_maxOverrideNumSolverIterations;
	int m_fixedBodyId;
	// When running solvers on multiple threads, a race condition exists for Kinematic objects that
	// participate in more than one solver.
	// The getOrInitSolverBody() function writes the companionId of each body (storing the index of the solver body
	// for the current solver). For normal dynamic bodies it isn't an issue because they can only be in one island
	// (and therefore one thread) at a time. But kinematic bodies can be in multiple islands at once.
	// To avoid this race condition, this solver does not write the companionId, instead it stores the solver body
	// index in this solver-local table, indexed by the uniqueId of the body.
	btAlignedObjectArray<int> m_kinematicBodyUniqueIdToSolverBodyTable;  // only used for multithreading

	btSingleConstraintRowSolver m_resolveSingleConstraintRowGeneric;
	btSingleConstraintRowSolver m_resolveSingleConstraintRowLowerLimit;
	btSingleConstraintRowSolver m_resolveSplitPenetrationImpulse;
	int m_cachedSolverMode;  // used to check if SOLVER_SIMD flag has been changed
	void setupSolverFunctions(bool useSimd);

	btScalar m_leastSquaresResidual;

	void setupFrictionConstraint(btSolverConstraint & solverConstraint, const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB,
		btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2,
		btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation,
		const btContactSolverInfo& infoGlobal,
		btScalar desiredVelocity = 0., btScalar cfmSlip = 0.);

	void setupTorsionalFrictionConstraint(btSolverConstraint & solverConstraint, const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB,
		btManifoldPoint& cp, btScalar combinedTorsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2,
		btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation,
		btScalar desiredVelocity = 0., btScalar cfmSlip = 0.);

	btSolverConstraint& addFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, const btContactSolverInfo& infoGlobal, btScalar desiredVelocity = 0., btScalar cfmSlip = 0.);
	btSolverConstraint& addTorsionalFrictionConstraint(const btVector3& normalAxis, int solverBodyIdA, int solverBodyIdB, int frictionIndex, btManifoldPoint& cp, btScalar torsionalFriction, const btVector3& rel_pos1, const btVector3& rel_pos2, btCollisionObject* colObj0, btCollisionObject* colObj1, btScalar relaxation, btScalar desiredVelocity = 0, btScalar cfmSlip = 0.f);

	void setupContactConstraint(btSolverConstraint & solverConstraint, int solverBodyIdA, int solverBodyIdB, btManifoldPoint& cp,
		const btContactSolverInfo& infoGlobal, btScalar& relaxation, const btVector3& rel_pos1, const btVector3& rel_pos2);

	static void applyAnisotropicFriction(btCollisionObject * colObj, btVector3 & frictionDirection, int frictionMode);

	void setFrictionConstraintImpulse(btSolverConstraint & solverConstraint, int solverBodyIdA, int solverBodyIdB,
		btManifoldPoint& cp, const btContactSolverInfo& infoGlobal);

	///m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
	unsigned long m_btSeed2;

	btScalar restitutionCurve(btScalar rel_vel, btScalar restitution, btScalar velocityThreshold);

	virtual void convertContacts(btPersistentManifold * *manifoldPtr, int numManifolds, const btContactSolverInfo& infoGlobal);

	void convertContact(btPersistentManifold * manifold, const btContactSolverInfo& infoGlobal);

	virtual void convertJoints(btTypedConstraint * *constraints, int numConstraints, const btContactSolverInfo& infoGlobal);
	void convertJoint(btSolverConstraint * currentConstraintRow, btTypedConstraint * constraint, const btTypedConstraint::btConstraintInfo1& info1, int solverBodyIdA, int solverBodyIdB, const btContactSolverInfo& infoGlobal);

	virtual void convertBodies(btCollisionObject * *bodies, int numBodies, const btContactSolverInfo& infoGlobal);

	btScalar resolveSplitPenetrationSIMD(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint)
	{
		return m_resolveSplitPenetrationImpulse(bodyA, bodyB, contactConstraint);
	}

	btScalar resolveSplitPenetrationImpulseCacheFriendly(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint)
	{
		return m_resolveSplitPenetrationImpulse(bodyA, bodyB, contactConstraint);
	}

	//internal method
	int getOrInitSolverBody(btCollisionObject & body, btScalar timeStep);
	void initSolverBody(btSolverBody * solverBody, btCollisionObject * collisionObject, btScalar timeStep);

	btScalar resolveSingleConstraintRowGeneric(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint);
	btScalar resolveSingleConstraintRowGenericSIMD(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint);
	btScalar resolveSingleConstraintRowLowerLimit(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint);
	btScalar resolveSingleConstraintRowLowerLimitSIMD(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint);
	btScalar resolveSplitPenetrationImpulse(btSolverBody & bodyA, btSolverBody & bodyB, const btSolverConstraint& contactConstraint)
	{
		return m_resolveSplitPenetrationImpulse(bodyA, bodyB, contactConstraint);
	}

protected:
	void writeBackContacts(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal);
	void writeBackJoints(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal);
	void writeBackBodies(int iBegin, int iEnd, const btContactSolverInfo& infoGlobal);
	virtual void solveGroupCacheFriendlySplitImpulseIterations(btCollisionObject * *bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer);
	virtual btScalar solveGroupCacheFriendlyFinish(btCollisionObject * *bodies, int numBodies, const btContactSolverInfo& infoGlobal);
	virtual btScalar solveSingleIteration(int iteration, btCollisionObject** bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer);

	virtual btScalar solveGroupCacheFriendlySetup(btCollisionObject * *bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer);
	virtual btScalar solveGroupCacheFriendlyIterations(btCollisionObject * *bodies, int numBodies, btPersistentManifold** manifoldPtr, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& infoGlobal, btIDebugDraw* debugDrawer);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btSequentialImpulseConstraintSolver();
	virtual ~btSequentialImpulseConstraintSolver();

	virtual btScalar solveGroup(btCollisionObject * *bodies, int numBodies, btPersistentManifold** manifold, int numManifolds, btTypedConstraint** constraints, int numConstraints, const btContactSolverInfo& info, btIDebugDraw* debugDrawer, btDispatcher* dispatcher);

	///clear internal cached data and reset random seed
	virtual void reset();

	unsigned long btRand2();

	int btRandInt2(int n);

	void setRandSeed(unsigned long seed)
	{
		m_btSeed2 = seed;
	}
	unsigned long getRandSeed() const
	{
		return m_btSeed2;
	}

	virtual btConstraintSolverType getSolverType() const
	{
		return BT_SEQUENTIAL_IMPULSE_SOLVER;
	}

	btSingleConstraintRowSolver getActiveConstraintRowSolverGeneric()
	{
		return m_resolveSingleConstraintRowGeneric;
	}
	void setConstraintRowSolverGeneric(btSingleConstraintRowSolver rowSolver)
	{
		m_resolveSingleConstraintRowGeneric = rowSolver;
	}
	btSingleConstraintRowSolver getActiveConstraintRowSolverLowerLimit()
	{
		return m_resolveSingleConstraintRowLowerLimit;
	}
	void setConstraintRowSolverLowerLimit(btSingleConstraintRowSolver rowSolver)
	{
		m_resolveSingleConstraintRowLowerLimit = rowSolver;
	}



	///Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4
	btSingleConstraintRowSolver getScalarConstraintRowSolverGeneric();
	btSingleConstraintRowSolver getSSE2ConstraintRowSolverGeneric();
	btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverGeneric();

	///Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4
	btSingleConstraintRowSolver getScalarConstraintRowSolverLowerLimit();
	btSingleConstraintRowSolver getSSE2ConstraintRowSolverLowerLimit();
	btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverLowerLimit();
	btSolverAnalyticsData m_analyticsData;
};

#endif  //BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_IDEBUG_DRAW__H
#define BT_IDEBUG_DRAW__H

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"

///The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
///Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
///A class that implements the btIDebugDraw interface will need to provide non-empty implementations of the the drawLine and getDebugMode methods at a minimum.
///For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]
class btIDebugDraw
{
public:
	ATTRIBUTE_ALIGNED16(struct)
	DefaultColors
	{
		btVector3 m_activeObject;
		btVector3 m_deactivatedObject;
		btVector3 m_wantsDeactivationObject;
		btVector3 m_disabledDeactivationObject;
		btVector3 m_disabledSimulationObject;
		btVector3 m_aabb;
		btVector3 m_contactPoint;

		DefaultColors()
			: m_activeObject(1, 1, 1),
			  m_deactivatedObject(0, 1, 0),
			  m_wantsDeactivationObject(0, 1, 1),
			  m_disabledDeactivationObject(1, 0, 0),
			  m_disabledSimulationObject(1, 1, 0),
			  m_aabb(1, 0, 0),
			  m_contactPoint(1, 1, 0)
		{
		}
	};

	enum DebugDrawModes
	{
		DBG_NoDebug = 0,
		DBG_DrawWireframe = 1,
		DBG_DrawAabb = 2,
		DBG_DrawFeaturesText = 4,
		DBG_DrawContactPoints = 8,
		DBG_NoDeactivation = 16,
		DBG_NoHelpText = 32,
		DBG_DrawText = 64,
		DBG_ProfileTimings = 128,
		DBG_EnableSatComparison = 256,
		DBG_DisableBulletLCP = 512,
		DBG_EnableCCD = 1024,
		DBG_DrawConstraints = (1 << 11),
		DBG_DrawConstraintLimits = (1 << 12),
		DBG_FastWireframe = (1 << 13),
		DBG_DrawNormals = (1 << 14),
		DBG_DrawFrames = (1 << 15),
		DBG_MAX_DEBUG_DRAW_MODE
	};

	virtual ~btIDebugDraw(){};

	virtual DefaultColors getDefaultColors() const
	{
		DefaultColors colors;
		return colors;
	}
	///the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors.
	virtual void setDefaultColors(const DefaultColors& /*colors*/) {}

	virtual void drawLine(const btVector3& from, const btVector3& to, const btVector3& color) = 0;

	virtual void drawLine(const btVector3& from, const btVector3& to, const btVector3& fromColor, const btVector3& toColor)
	{
		(void)toColor;
		drawLine(from, to, fromColor);
	}

	virtual void drawSphere(btScalar radius, const btTransform& transform, const btVector3& color)
	{
		btVector3 center = transform.getOrigin();
		btVector3 up = transform.getBasis().getColumn(1);
		btVector3 axis = transform.getBasis().getColumn(0);
		btScalar minTh = -SIMD_HALF_PI;
		btScalar maxTh = SIMD_HALF_PI;
		btScalar minPs = -SIMD_HALF_PI;
		btScalar maxPs = SIMD_HALF_PI;
		btScalar stepDegrees = 30.f;
		drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, false);
		drawSpherePatch(center, up, -axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, false);
	}

	virtual void drawSphere(const btVector3& p, btScalar radius, const btVector3& color)
	{
		btTransform tr;
		tr.setIdentity();
		tr.setOrigin(p);
		drawSphere(radius, tr, color);
	}

	virtual void drawTriangle(const btVector3& v0, const btVector3& v1, const btVector3& v2, const btVector3& /*n0*/, const btVector3& /*n1*/, const btVector3& /*n2*/, const btVector3& color, btScalar alpha)
	{
		drawTriangle(v0, v1, v2, color, alpha);
	}
	virtual void drawTriangle(const btVector3& v0, const btVector3& v1, const btVector3& v2, const btVector3& color, btScalar /*alpha*/)
	{
		drawLine(v0, v1, color);
		drawLine(v1, v2, color);
		drawLine(v2, v0, color);
	}

	virtual void drawContactPoint(const btVector3& PointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) = 0;

	virtual void reportErrorWarning(const char* warningString) = 0;

	virtual void draw3dText(const btVector3& location, const char* textString) = 0;

	virtual void setDebugMode(int debugMode) = 0;

	virtual int getDebugMode() const = 0;

	virtual void drawAabb(const btVector3& from, const btVector3& to, const btVector3& color)
	{
		btVector3 halfExtents = (to - from) * 0.5f;
		btVector3 center = (to + from) * 0.5f;
		int i, j;

		btVector3 edgecoord(1.f, 1.f, 1.f), pa, pb;
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 3; j++)
			{
				pa = btVector3(edgecoord[0] * halfExtents[0], edgecoord[1] * halfExtents[1],
							   edgecoord[2] * halfExtents[2]);
				pa += center;

				int othercoord = j % 3;
				edgecoord[othercoord] *= -1.f;
				pb = btVector3(edgecoord[0] * halfExtents[0], edgecoord[1] * halfExtents[1],
							   edgecoord[2] * halfExtents[2]);
				pb += center;

				drawLine(pa, pb, color);
			}
			edgecoord = btVector3(-1.f, -1.f, -1.f);
			if (i < 3)
				edgecoord[i] *= -1.f;
		}
	}
	virtual void drawTransform(const btTransform& transform, btScalar orthoLen)
	{
		btVector3 start = transform.getOrigin();
		drawLine(start, start + transform.getBasis() * btVector3(orthoLen, 0, 0), btVector3(btScalar(1.), btScalar(0.3), btScalar(0.3)));
		drawLine(start, start + transform.getBasis() * btVector3(0, orthoLen, 0), btVector3(btScalar(0.3), btScalar(1.), btScalar(0.3)));
		drawLine(start, start + transform.getBasis() * btVector3(0, 0, orthoLen), btVector3(btScalar(0.3), btScalar(0.3), btScalar(1.)));
	}

	virtual void drawArc(const btVector3& center, const btVector3& normal, const btVector3& axis, btScalar radiusA, btScalar radiusB, btScalar minAngle, btScalar maxAngle,
						 const btVector3& color, bool drawSect, btScalar stepDegrees = btScalar(10.f))
	{
		const btVector3& vx = axis;
		btVector3 vy = normal.cross(axis);
		btScalar step = stepDegrees * SIMD_RADS_PER_DEG;
		int nSteps = (int)btFabs((maxAngle - minAngle) / step);
		if (!nSteps) nSteps = 1;
		btVector3 prev = center + radiusA * vx * btCos(minAngle) + radiusB * vy * btSin(minAngle);
		if (drawSect)
		{
			drawLine(center, prev, color);
		}
		for (int i = 1; i <= nSteps; i++)
		{
			btScalar angle = minAngle + (maxAngle - minAngle) * btScalar(i) / btScalar(nSteps);
			btVector3 next = center + radiusA * vx * btCos(angle) + radiusB * vy * btSin(angle);
			drawLine(prev, next, color);
			prev = next;
		}
		if (drawSect)
		{
			drawLine(center, prev, color);
		}
	}
	virtual void drawSpherePatch(const btVector3& center, const btVector3& up, const btVector3& axis, btScalar radius,
								 btScalar minTh, btScalar maxTh, btScalar minPs, btScalar maxPs, const btVector3& color, btScalar stepDegrees = btScalar(10.f), bool drawCenter = true)
	{
		btVector3 vA[74];
		btVector3 vB[74];
		btVector3 *pvA = vA, *pvB = vB, *pT;
		btVector3 npole = center + up * radius;
		btVector3 spole = center - up * radius;
		btVector3 arcStart;
		btScalar step = stepDegrees * SIMD_RADS_PER_DEG;
		const btVector3& kv = up;
		const btVector3& iv = axis;
		btVector3 jv = kv.cross(iv);
		bool drawN = false;
		bool drawS = false;
		if (minTh <= -SIMD_HALF_PI)
		{
			minTh = -SIMD_HALF_PI + step;
			drawN = true;
		}
		if (maxTh >= SIMD_HALF_PI)
		{
			maxTh = SIMD_HALF_PI - step;
			drawS = true;
		}
		if (minTh > maxTh)
		{
			minTh = -SIMD_HALF_PI + step;
			maxTh = SIMD_HALF_PI - step;
			drawN = drawS = true;
		}
		int n_hor = (int)((maxTh - minTh) / step) + 1;
		if (n_hor < 2) n_hor = 2;
		btScalar step_h = (maxTh - minTh) / btScalar(n_hor - 1);
		bool isClosed = false;
		if (minPs > maxPs)
		{
			minPs = -SIMD_PI + step;
			maxPs = SIMD_PI;
			isClosed = true;
		}
		else if ((maxPs - minPs) >= SIMD_PI * btScalar(2.f))
		{
			isClosed = true;
		}
		else
		{
			isClosed = false;
		}
		int n_vert = (int)((maxPs - minPs) / step) + 1;
		if (n_vert < 2) n_vert = 2;
		btScalar step_v = (maxPs - minPs) / btScalar(n_vert - 1);
		for (int i = 0; i < n_hor; i++)
		{
			btScalar th = minTh + btScalar(i) * step_h;
			btScalar sth = radius * btSin(th);
			btScalar cth = radius * btCos(th);
			for (int j = 0; j < n_vert; j++)
			{
				btScalar psi = minPs + btScalar(j) * step_v;
				btScalar sps = btSin(psi);
				btScalar cps = btCos(psi);
				pvB[j] = center + cth * cps * iv + cth * sps * jv + sth * kv;
				if (i)
				{
					drawLine(pvA[j], pvB[j], color);
				}
				else if (drawS)
				{
					drawLine(spole, pvB[j], color);
				}
				if (j)
				{
					drawLine(pvB[j - 1], pvB[j], color);
				}
				else
				{
					arcStart = pvB[j];
				}
				if ((i == (n_hor - 1)) && drawN)
				{
					drawLine(npole, pvB[j], color);
				}

				if (drawCenter)
				{
					if (isClosed)
					{
						if (j == (n_vert - 1))
						{
							drawLine(arcStart, pvB[j], color);
						}
					}
					else
					{
						if (((!i) || (i == (n_hor - 1))) && ((!j) || (j == (n_vert - 1))))
						{
							drawLine(center, pvB[j], color);
						}
					}
				}
			}
			pT = pvA;
			pvA = pvB;
			pvB = pT;
		}
	}

	virtual void drawBox(const btVector3& bbMin, const btVector3& bbMax, const btVector3& color)
	{
		drawLine(btVector3(bbMin[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMin[1], bbMin[2]), color);
		drawLine(btVector3(bbMax[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMax[1], bbMin[2]), color);
		drawLine(btVector3(bbMax[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMax[1], bbMin[2]), color);
		drawLine(btVector3(bbMin[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMin[1], bbMin[2]), color);
		drawLine(btVector3(bbMin[0], bbMin[1], bbMin[2]), btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
		drawLine(btVector3(bbMax[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
		drawLine(btVector3(bbMax[0], bbMax[1], bbMin[2]), btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
		drawLine(btVector3(bbMin[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
		drawLine(btVector3(bbMin[0], bbMin[1], bbMax[2]), btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
		drawLine(btVector3(bbMax[0], bbMin[1], bbMax[2]), btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
		drawLine(btVector3(bbMax[0], bbMax[1], bbMax[2]), btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
		drawLine(btVector3(bbMin[0], bbMax[1], bbMax[2]), btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
	}
	virtual void drawBox(const btVector3& bbMin, const btVector3& bbMax, const btTransform& trans, const btVector3& color)
	{
		drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), color);
		drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), color);
		drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
		drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
	}

	virtual void drawCapsule(btScalar radius, btScalar halfHeight, int upAxis, const btTransform& transform, const btVector3& color)
	{
		int stepDegrees = 30;

		btVector3 capStart(0.f, 0.f, 0.f);
		capStart[upAxis] = -halfHeight;

		btVector3 capEnd(0.f, 0.f, 0.f);
		capEnd[upAxis] = halfHeight;

		// Draw the ends
		{
			btTransform childTransform = transform;
			childTransform.getOrigin() = transform * capStart;
			{
				btVector3 center = childTransform.getOrigin();
				btVector3 up = childTransform.getBasis().getColumn((upAxis + 1) % 3);
				btVector3 axis = -childTransform.getBasis().getColumn(upAxis);
				btScalar minTh = -SIMD_HALF_PI;
				btScalar maxTh = SIMD_HALF_PI;
				btScalar minPs = -SIMD_HALF_PI;
				btScalar maxPs = SIMD_HALF_PI;

				drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, btScalar(stepDegrees), false);
			}
		}

		{
			btTransform childTransform = transform;
			childTransform.getOrigin() = transform * capEnd;
			{
				btVector3 center = childTransform.getOrigin();
				btVector3 up = childTransform.getBasis().getColumn((upAxis + 1) % 3);
				btVector3 axis = childTransform.getBasis().getColumn(upAxis);
				btScalar minTh = -SIMD_HALF_PI;
				btScalar maxTh = SIMD_HALF_PI;
				btScalar minPs = -SIMD_HALF_PI;
				btScalar maxPs = SIMD_HALF_PI;
				drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, btScalar(stepDegrees), false);
			}
		}

		// Draw some additional lines
		btVector3 start = transform.getOrigin();

		for (int i = 0; i < 360; i += stepDegrees)
		{
			capEnd[(upAxis + 1) % 3] = capStart[(upAxis + 1) % 3] = btSin(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			capEnd[(upAxis + 2) % 3] = capStart[(upAxis + 2) % 3] = btCos(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			drawLine(start + transform.getBasis() * capStart, start + transform.getBasis() * capEnd, color);
		}
	}

	virtual void drawCylinder(btScalar radius, btScalar halfHeight, int upAxis, const btTransform& transform, const btVector3& color)
	{
		btVector3 start = transform.getOrigin();
		btVector3 offsetHeight(0, 0, 0);
		offsetHeight[upAxis] = halfHeight;
		int stepDegrees = 30;
		btVector3 capStart(0.f, 0.f, 0.f);
		capStart[upAxis] = -halfHeight;
		btVector3 capEnd(0.f, 0.f, 0.f);
		capEnd[upAxis] = halfHeight;

		for (int i = 0; i < 360; i += stepDegrees)
		{
			capEnd[(upAxis + 1) % 3] = capStart[(upAxis + 1) % 3] = btSin(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			capEnd[(upAxis + 2) % 3] = capStart[(upAxis + 2) % 3] = btCos(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			drawLine(start + transform.getBasis() * capStart, start + transform.getBasis() * capEnd, color);
		}
		// Drawing top and bottom caps of the cylinder
		btVector3 yaxis(0, 0, 0);
		yaxis[upAxis] = btScalar(1.0);
		btVector3 xaxis(0, 0, 0);
		xaxis[(upAxis + 1) % 3] = btScalar(1.0);
		drawArc(start - transform.getBasis() * (offsetHeight), transform.getBasis() * yaxis, transform.getBasis() * xaxis, radius, radius, 0, SIMD_2_PI, color, false, btScalar(10.0));
		drawArc(start + transform.getBasis() * (offsetHeight), transform.getBasis() * yaxis, transform.getBasis() * xaxis, radius, radius, 0, SIMD_2_PI, color, false, btScalar(10.0));
	}

	virtual void drawCone(btScalar radius, btScalar height, int upAxis, const btTransform& transform, const btVector3& color)
	{
		int stepDegrees = 30;
		btVector3 start = transform.getOrigin();

		btVector3 offsetHeight(0, 0, 0);
		btScalar halfHeight = height * btScalar(0.5);
		offsetHeight[upAxis] = halfHeight;
		btVector3 offsetRadius(0, 0, 0);
		offsetRadius[(upAxis + 1) % 3] = radius;
		btVector3 offset2Radius(0, 0, 0);
		offset2Radius[(upAxis + 2) % 3] = radius;

		btVector3 capEnd(0.f, 0.f, 0.f);
		capEnd[upAxis] = -halfHeight;

		for (int i = 0; i < 360; i += stepDegrees)
		{
			capEnd[(upAxis + 1) % 3] = btSin(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			capEnd[(upAxis + 2) % 3] = btCos(btScalar(i) * SIMD_RADS_PER_DEG) * radius;
			drawLine(start + transform.getBasis() * (offsetHeight), start + transform.getBasis() * capEnd, color);
		}

		drawLine(start + transform.getBasis() * (offsetHeight), start + transform.getBasis() * (-offsetHeight + offsetRadius), color);
		drawLine(start + transform.getBasis() * (offsetHeight), start + transform.getBasis() * (-offsetHeight - offsetRadius), color);
		drawLine(start + transform.getBasis() * (offsetHeight), start + transform.getBasis() * (-offsetHeight + offset2Radius), color);
		drawLine(start + transform.getBasis() * (offsetHeight), start + transform.getBasis() * (-offsetHeight - offset2Radius), color);

		// Drawing the base of the cone
		btVector3 yaxis(0, 0, 0);
		yaxis[upAxis] = btScalar(1.0);
		btVector3 xaxis(0, 0, 0);
		xaxis[(upAxis + 1) % 3] = btScalar(1.0);
		drawArc(start - transform.getBasis() * (offsetHeight), transform.getBasis() * yaxis, transform.getBasis() * xaxis, radius, radius, 0, SIMD_2_PI, color, false, 10.0);
	}

	virtual void drawPlane(const btVector3& planeNormal, btScalar planeConst, const btTransform& transform, const btVector3& color)
	{
		btVector3 planeOrigin = planeNormal * planeConst;
		btVector3 vec0, vec1;
		btPlaneSpace1(planeNormal, vec0, vec1);
		btScalar vecLen = 100.f;
		btVector3 pt0 = planeOrigin + vec0 * vecLen;
		btVector3 pt1 = planeOrigin - vec0 * vecLen;
		btVector3 pt2 = planeOrigin + vec1 * vecLen;
		btVector3 pt3 = planeOrigin - vec1 * vecLen;
		drawLine(transform * pt0, transform * pt1, color);
		drawLine(transform * pt2, transform * pt3, color);
	}

	virtual void clearLines()
	{
	}

	virtual void flushLines()
	{
	}
};

#endif  //BT_IDEBUG_DRAW__H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"

btConvexCast::~btConvexCast()
{
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_CAST_H
#define BT_CONVEX_CAST_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btScalar.h"
class btMinkowskiSumShape;
#include "LinearMath/btIDebugDraw.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define MAX_CONVEX_CAST_ITERATIONS 64
#define MAX_CONVEX_CAST_EPSILON (SIMD_EPSILON * 10)
#else
#define MAX_CONVEX_CAST_ITERATIONS 32
#define MAX_CONVEX_CAST_EPSILON btScalar(0.0001)
#endif
///Typically the conservative advancement reaches solution in a few iterations, clip it to 32 for degenerate cases.
///See discussion about this here https://bulletphysics.orgphpBB2/viewtopic.php?t=565
//will need to digg deeper to make the algorithm more robust
//since, a large epsilon can cause an early termination with false
//positive results (ray intersections that shouldn't be there)

/// btConvexCast is an interface for Casting
class btConvexCast
{
public:
	virtual ~btConvexCast();

	///RayResult stores the closest result
	/// alternatively, add a callback method to decide about closest/all results
	struct CastResult
	{
		//virtual bool	addRayResult(const btVector3& normal,btScalar	fraction) = 0;

		virtual void DebugDraw(btScalar fraction) { (void)fraction; }
		virtual void drawCoordSystem(const btTransform& trans) { (void)trans; }
		virtual void reportFailure(int errNo, int numIterations)
		{
			(void)errNo;
			(void)numIterations;
		}
		CastResult()
			: m_fraction(btScalar(BT_LARGE_FLOAT)),
			  m_debugDrawer(0),
			  m_allowedPenetration(btScalar(0)),
			  m_subSimplexCastMaxIterations(MAX_CONVEX_CAST_ITERATIONS),
			  m_subSimplexCastEpsilon(MAX_CONVEX_CAST_EPSILON)
		{
		}

		virtual ~CastResult(){};

		btTransform m_hitTransformA;
		btTransform m_hitTransformB;
		btVector3 m_normal;
		btVector3 m_hitPoint;
		btScalar m_fraction;  //input and output
		btIDebugDraw* m_debugDrawer;
		btScalar m_allowedPenetration;
		
		int m_subSimplexCastMaxIterations;
		btScalar m_subSimplexCastEpsilon;

	};

	/// cast a convex against another convex object
	virtual bool calcTimeOfImpact(
		const btTransform& fromA,
		const btTransform& toA,
		const btTransform& fromB,
		const btTransform& toB,
		CastResult& result) = 0;
};

#endif  //BT_CONVEX_CAST_H






/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
	
	Elsevier CDROM license agreements grants nonexclusive license to use the software
	for any purpose, commercial or non-commercial as long as the following credit is included
	identifying the original source of the software:

	Parts of the source are "from the book Real-Time Collision Detection by
	Christer Ericson, published by Morgan Kaufmann Publishers,
	(c) 2005 Elsevier Inc."
		
*/

#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"

#define VERTA 0
#define VERTB 1
#define VERTC 2
#define VERTD 3

#define CATCH_DEGENERATE_TETRAHEDRON 1
void btVoronoiSimplexSolver::removeVertex(int index)
{
	btAssert(m_numVertices > 0);
	m_numVertices--;
	m_simplexVectorW[index] = m_simplexVectorW[m_numVertices];
	m_simplexPointsP[index] = m_simplexPointsP[m_numVertices];
	m_simplexPointsQ[index] = m_simplexPointsQ[m_numVertices];
}

void btVoronoiSimplexSolver::reduceVertices(const btUsageBitfield& usedVerts)
{
	if ((numVertices() >= 4) && (!usedVerts.usedVertexD))
		removeVertex(3);

	if ((numVertices() >= 3) && (!usedVerts.usedVertexC))
		removeVertex(2);

	if ((numVertices() >= 2) && (!usedVerts.usedVertexB))
		removeVertex(1);

	if ((numVertices() >= 1) && (!usedVerts.usedVertexA))
		removeVertex(0);
}

//clear the simplex, remove all the vertices
void btVoronoiSimplexSolver::reset()
{
	m_cachedValidClosest = false;
	m_numVertices = 0;
	m_needsUpdate = true;
	m_lastW = btVector3(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
	m_cachedBC.reset();
}

//add a vertex
void btVoronoiSimplexSolver::addVertex(const btVector3& w, const btVector3& p, const btVector3& q)
{
	m_lastW = w;
	m_needsUpdate = true;

	m_simplexVectorW[m_numVertices] = w;
	m_simplexPointsP[m_numVertices] = p;
	m_simplexPointsQ[m_numVertices] = q;

	m_numVertices++;
}

bool btVoronoiSimplexSolver::updateClosestVectorAndPoints()
{
	if (m_needsUpdate)
	{
		m_cachedBC.reset();

		m_needsUpdate = false;

		switch (numVertices())
		{
			case 0:
				m_cachedValidClosest = false;
				break;
			case 1:
			{
				m_cachedP1 = m_simplexPointsP[0];
				m_cachedP2 = m_simplexPointsQ[0];
				m_cachedV = m_cachedP1 - m_cachedP2;  //== m_simplexVectorW[0]
				m_cachedBC.reset();
				m_cachedBC.setBarycentricCoordinates(btScalar(1.), btScalar(0.), btScalar(0.), btScalar(0.));
				m_cachedValidClosest = m_cachedBC.isValid();
				break;
			};
			case 2:
			{
				//closest point origin from line segment
				const btVector3& from = m_simplexVectorW[0];
				const btVector3& to = m_simplexVectorW[1];
				btVector3 nearest;

				btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));
				btVector3 diff = p - from;
				btVector3 v = to - from;
				btScalar t = v.dot(diff);

				if (t > 0)
				{
					btScalar dotVV = v.dot(v);
					if (t < dotVV)
					{
						t /= dotVV;
						diff -= t * v;
						m_cachedBC.m_usedVertices.usedVertexA = true;
						m_cachedBC.m_usedVertices.usedVertexB = true;
					}
					else
					{
						t = 1;
						diff -= v;
						//reduce to 1 point
						m_cachedBC.m_usedVertices.usedVertexB = true;
					}
				}
				else
				{
					t = 0;
					//reduce to 1 point
					m_cachedBC.m_usedVertices.usedVertexA = true;
				}
				m_cachedBC.setBarycentricCoordinates(1 - t, t);
				nearest = from + t * v;

				m_cachedP1 = m_simplexPointsP[0] + t * (m_simplexPointsP[1] - m_simplexPointsP[0]);
				m_cachedP2 = m_simplexPointsQ[0] + t * (m_simplexPointsQ[1] - m_simplexPointsQ[0]);
				m_cachedV = m_cachedP1 - m_cachedP2;

				reduceVertices(m_cachedBC.m_usedVertices);

				m_cachedValidClosest = m_cachedBC.isValid();
				break;
			}
			case 3:
			{
				//closest point origin from triangle
				btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));

				const btVector3& a = m_simplexVectorW[0];
				const btVector3& b = m_simplexVectorW[1];
				const btVector3& c = m_simplexVectorW[2];

				closestPtPointTriangle(p, a, b, c, m_cachedBC);
				m_cachedP1 = m_simplexPointsP[0] * m_cachedBC.m_barycentricCoords[0] +
							 m_simplexPointsP[1] * m_cachedBC.m_barycentricCoords[1] +
							 m_simplexPointsP[2] * m_cachedBC.m_barycentricCoords[2];

				m_cachedP2 = m_simplexPointsQ[0] * m_cachedBC.m_barycentricCoords[0] +
							 m_simplexPointsQ[1] * m_cachedBC.m_barycentricCoords[1] +
							 m_simplexPointsQ[2] * m_cachedBC.m_barycentricCoords[2];

				m_cachedV = m_cachedP1 - m_cachedP2;

				reduceVertices(m_cachedBC.m_usedVertices);
				m_cachedValidClosest = m_cachedBC.isValid();

				break;
			}
			case 4:
			{
				btVector3 p(btScalar(0.), btScalar(0.), btScalar(0.));

				const btVector3& a = m_simplexVectorW[0];
				const btVector3& b = m_simplexVectorW[1];
				const btVector3& c = m_simplexVectorW[2];
				const btVector3& d = m_simplexVectorW[3];

				bool hasSeparation = closestPtPointTetrahedron(p, a, b, c, d, m_cachedBC);

				if (hasSeparation)
				{
					m_cachedP1 = m_simplexPointsP[0] * m_cachedBC.m_barycentricCoords[0] +
								 m_simplexPointsP[1] * m_cachedBC.m_barycentricCoords[1] +
								 m_simplexPointsP[2] * m_cachedBC.m_barycentricCoords[2] +
								 m_simplexPointsP[3] * m_cachedBC.m_barycentricCoords[3];

					m_cachedP2 = m_simplexPointsQ[0] * m_cachedBC.m_barycentricCoords[0] +
								 m_simplexPointsQ[1] * m_cachedBC.m_barycentricCoords[1] +
								 m_simplexPointsQ[2] * m_cachedBC.m_barycentricCoords[2] +
								 m_simplexPointsQ[3] * m_cachedBC.m_barycentricCoords[3];

					m_cachedV = m_cachedP1 - m_cachedP2;
					reduceVertices(m_cachedBC.m_usedVertices);
				}
				else
				{
					//					printf("sub distance got penetration\n");

					if (m_cachedBC.m_degenerate)
					{
						m_cachedValidClosest = false;
					}
					else
					{
						m_cachedValidClosest = true;
						//degenerate case == false, penetration = true + zero
						m_cachedV.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
					}
					break;
				}

				m_cachedValidClosest = m_cachedBC.isValid();

				//closest point origin from tetrahedron
				break;
			}
			default:
			{
				m_cachedValidClosest = false;
			}
		};
	}

	return m_cachedValidClosest;
}

//return/calculate the closest vertex
bool btVoronoiSimplexSolver::closest(btVector3& v)
{
	bool succes = updateClosestVectorAndPoints();
	v = m_cachedV;
	return succes;
}

btScalar btVoronoiSimplexSolver::maxVertex()
{
	int i, numverts = numVertices();
	btScalar maxV = btScalar(0.);
	for (i = 0; i < numverts; i++)
	{
		btScalar curLen2 = m_simplexVectorW[i].length2();
		if (maxV < curLen2)
			maxV = curLen2;
	}
	return maxV;
}

//return the current simplex
int btVoronoiSimplexSolver::getSimplex(btVector3* pBuf, btVector3* qBuf, btVector3* yBuf) const
{
	int i;
	for (i = 0; i < numVertices(); i++)
	{
		yBuf[i] = m_simplexVectorW[i];
		pBuf[i] = m_simplexPointsP[i];
		qBuf[i] = m_simplexPointsQ[i];
	}
	return numVertices();
}

bool btVoronoiSimplexSolver::inSimplex(const btVector3& w)
{
	bool found = false;
	int i, numverts = numVertices();
	//btScalar maxV = btScalar(0.);

	//w is in the current (reduced) simplex
	for (i = 0; i < numverts; i++)
	{
#ifdef BT_USE_EQUAL_VERTEX_THRESHOLD
		if (m_simplexVectorW[i].distance2(w) <= m_equalVertexThreshold)
#else
		if (m_simplexVectorW[i] == w)
#endif
		{
			found = true;
			break;
		}
	}

	//check in case lastW is already removed
	if (w == m_lastW)
		return true;

	return found;
}

void btVoronoiSimplexSolver::backup_closest(btVector3& v)
{
	v = m_cachedV;
}

bool btVoronoiSimplexSolver::emptySimplex() const
{
	return (numVertices() == 0);
}

void btVoronoiSimplexSolver::compute_points(btVector3& p1, btVector3& p2)
{
	updateClosestVectorAndPoints();
	p1 = m_cachedP1;
	p2 = m_cachedP2;
}

bool btVoronoiSimplexSolver::closestPtPointTriangle(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, btSubSimplexClosestResult& result)
{
	result.m_usedVertices.reset();

	// Check if P in vertex region outside A
	btVector3 ab = b - a;
	btVector3 ac = c - a;
	btVector3 ap = p - a;
	btScalar d1 = ab.dot(ap);
	btScalar d2 = ac.dot(ap);
	if (d1 <= btScalar(0.0) && d2 <= btScalar(0.0))
	{
		result.m_closestPointOnSimplex = a;
		result.m_usedVertices.usedVertexA = true;
		result.setBarycentricCoordinates(1, 0, 0);
		return true;  // a; // barycentric coordinates (1,0,0)
	}

	// Check if P in vertex region outside B
	btVector3 bp = p - b;
	btScalar d3 = ab.dot(bp);
	btScalar d4 = ac.dot(bp);
	if (d3 >= btScalar(0.0) && d4 <= d3)
	{
		result.m_closestPointOnSimplex = b;
		result.m_usedVertices.usedVertexB = true;
		result.setBarycentricCoordinates(0, 1, 0);

		return true;  // b; // barycentric coordinates (0,1,0)
	}
	// Check if P in edge region of AB, if so return projection of P onto AB
	btScalar vc = d1 * d4 - d3 * d2;
	if (vc <= btScalar(0.0) && d1 >= btScalar(0.0) && d3 <= btScalar(0.0))
	{
		btScalar v = d1 / (d1 - d3);
		result.m_closestPointOnSimplex = a + v * ab;
		result.m_usedVertices.usedVertexA = true;
		result.m_usedVertices.usedVertexB = true;
		result.setBarycentricCoordinates(1 - v, v, 0);
		return true;
		//return a + v * ab; // barycentric coordinates (1-v,v,0)
	}

	// Check if P in vertex region outside C
	btVector3 cp = p - c;
	btScalar d5 = ab.dot(cp);
	btScalar d6 = ac.dot(cp);
	if (d6 >= btScalar(0.0) && d5 <= d6)
	{
		result.m_closestPointOnSimplex = c;
		result.m_usedVertices.usedVertexC = true;
		result.setBarycentricCoordinates(0, 0, 1);
		return true;  //c; // barycentric coordinates (0,0,1)
	}

	// Check if P in edge region of AC, if so return projection of P onto AC
	btScalar vb = d5 * d2 - d1 * d6;
	if (vb <= btScalar(0.0) && d2 >= btScalar(0.0) && d6 <= btScalar(0.0))
	{
		btScalar w = d2 / (d2 - d6);
		result.m_closestPointOnSimplex = a + w * ac;
		result.m_usedVertices.usedVertexA = true;
		result.m_usedVertices.usedVertexC = true;
		result.setBarycentricCoordinates(1 - w, 0, w);
		return true;
		//return a + w * ac; // barycentric coordinates (1-w,0,w)
	}

	// Check if P in edge region of BC, if so return projection of P onto BC
	btScalar va = d3 * d6 - d5 * d4;
	if (va <= btScalar(0.0) && (d4 - d3) >= btScalar(0.0) && (d5 - d6) >= btScalar(0.0))
	{
		btScalar w = (d4 - d3) / ((d4 - d3) + (d5 - d6));

		result.m_closestPointOnSimplex = b + w * (c - b);
		result.m_usedVertices.usedVertexB = true;
		result.m_usedVertices.usedVertexC = true;
		result.setBarycentricCoordinates(0, 1 - w, w);
		return true;
		// return b + w * (c - b); // barycentric coordinates (0,1-w,w)
	}

	// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
	btScalar denom = btScalar(1.0) / (va + vb + vc);
	btScalar v = vb * denom;
	btScalar w = vc * denom;

	result.m_closestPointOnSimplex = a + ab * v + ac * w;
	result.m_usedVertices.usedVertexA = true;
	result.m_usedVertices.usedVertexB = true;
	result.m_usedVertices.usedVertexC = true;
	result.setBarycentricCoordinates(1 - v - w, v, w);

	return true;
	//	return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = btScalar(1.0) - v - w
}

/// Test if point p and d lie on opposite sides of plane through abc
int btVoronoiSimplexSolver::pointOutsideOfPlane(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d)
{
	btVector3 normal = (b - a).cross(c - a);

	btScalar signp = (p - a).dot(normal);  // [AP AB AC]
	btScalar signd = (d - a).dot(normal);  // [AD AB AC]

#ifdef CATCH_DEGENERATE_TETRAHEDRON
#ifdef BT_USE_DOUBLE_PRECISION
	if (signd * signd < (btScalar(1e-8) * btScalar(1e-8)))
	{
		return -1;
	}
#else
	if (signd * signd < (btScalar(1e-4) * btScalar(1e-4)))
	{
		//		printf("affine dependent/degenerate\n");//
		return -1;
	}
#endif

#endif
	// Points on opposite sides if expression signs are opposite
	return signp * signd < btScalar(0.);
}

bool btVoronoiSimplexSolver::closestPtPointTetrahedron(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d, btSubSimplexClosestResult& finalResult)
{
	btSubSimplexClosestResult tempResult;

	// Start out assuming point inside all halfspaces, so closest to itself
	finalResult.m_closestPointOnSimplex = p;
	finalResult.m_usedVertices.reset();
	finalResult.m_usedVertices.usedVertexA = true;
	finalResult.m_usedVertices.usedVertexB = true;
	finalResult.m_usedVertices.usedVertexC = true;
	finalResult.m_usedVertices.usedVertexD = true;

	int pointOutsideABC = pointOutsideOfPlane(p, a, b, c, d);
	int pointOutsideACD = pointOutsideOfPlane(p, a, c, d, b);
	int pointOutsideADB = pointOutsideOfPlane(p, a, d, b, c);
	int pointOutsideBDC = pointOutsideOfPlane(p, b, d, c, a);

	if (pointOutsideABC < 0 || pointOutsideACD < 0 || pointOutsideADB < 0 || pointOutsideBDC < 0)
	{
		finalResult.m_degenerate = true;
		return false;
	}

	if (!pointOutsideABC && !pointOutsideACD && !pointOutsideADB && !pointOutsideBDC)
	{
		return false;
	}

	btScalar bestSqDist = FLT_MAX;
	// If point outside face abc then compute closest point on abc
	if (pointOutsideABC)
	{
		closestPtPointTriangle(p, a, b, c, tempResult);
		btVector3 q = tempResult.m_closestPointOnSimplex;

		btScalar sqDist = (q - p).dot(q - p);
		// Update best closest point if (squared) distance is less than current best
		if (sqDist < bestSqDist)
		{
			bestSqDist = sqDist;
			finalResult.m_closestPointOnSimplex = q;
			//convert result bitmask!
			finalResult.m_usedVertices.reset();
			finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;
			finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexB;
			finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexC;
			finalResult.setBarycentricCoordinates(
				tempResult.m_barycentricCoords[VERTA],
				tempResult.m_barycentricCoords[VERTB],
				tempResult.m_barycentricCoords[VERTC],
				0);
		}
	}

	// Repeat test for face acd
	if (pointOutsideACD)
	{
		closestPtPointTriangle(p, a, c, d, tempResult);
		btVector3 q = tempResult.m_closestPointOnSimplex;
		//convert result bitmask!

		btScalar sqDist = (q - p).dot(q - p);
		if (sqDist < bestSqDist)
		{
			bestSqDist = sqDist;
			finalResult.m_closestPointOnSimplex = q;
			finalResult.m_usedVertices.reset();
			finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;

			finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexB;
			finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexC;
			finalResult.setBarycentricCoordinates(
				tempResult.m_barycentricCoords[VERTA],
				0,
				tempResult.m_barycentricCoords[VERTB],
				tempResult.m_barycentricCoords[VERTC]);
		}
	}
	// Repeat test for face adb

	if (pointOutsideADB)
	{
		closestPtPointTriangle(p, a, d, b, tempResult);
		btVector3 q = tempResult.m_closestPointOnSimplex;
		//convert result bitmask!

		btScalar sqDist = (q - p).dot(q - p);
		if (sqDist < bestSqDist)
		{
			bestSqDist = sqDist;
			finalResult.m_closestPointOnSimplex = q;
			finalResult.m_usedVertices.reset();
			finalResult.m_usedVertices.usedVertexA = tempResult.m_usedVertices.usedVertexA;
			finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexC;

			finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexB;
			finalResult.setBarycentricCoordinates(
				tempResult.m_barycentricCoords[VERTA],
				tempResult.m_barycentricCoords[VERTC],
				0,
				tempResult.m_barycentricCoords[VERTB]);
		}
	}
	// Repeat test for face bdc

	if (pointOutsideBDC)
	{
		closestPtPointTriangle(p, b, d, c, tempResult);
		btVector3 q = tempResult.m_closestPointOnSimplex;
		//convert result bitmask!
		btScalar sqDist = (q - p).dot(q - p);
		if (sqDist < bestSqDist)
		{
			bestSqDist = sqDist;
			finalResult.m_closestPointOnSimplex = q;
			finalResult.m_usedVertices.reset();
			//
			finalResult.m_usedVertices.usedVertexB = tempResult.m_usedVertices.usedVertexA;
			finalResult.m_usedVertices.usedVertexC = tempResult.m_usedVertices.usedVertexC;
			finalResult.m_usedVertices.usedVertexD = tempResult.m_usedVertices.usedVertexB;

			finalResult.setBarycentricCoordinates(
				0,
				tempResult.m_barycentricCoords[VERTA],
				tempResult.m_barycentricCoords[VERTC],
				tempResult.m_barycentricCoords[VERTB]);
		}
	}

	//help! we ended up full !

	if (finalResult.m_usedVertices.usedVertexA &&
		finalResult.m_usedVertices.usedVertexB &&
		finalResult.m_usedVertices.usedVertexC &&
		finalResult.m_usedVertices.usedVertexD)
	{
		return true;
	}

	return true;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_VORONOI_SIMPLEX_SOLVER_H
#define BT_VORONOI_SIMPLEX_SOLVER_H

#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"

#define VORONOI_SIMPLEX_MAX_VERTS 5

///disable next define, or use defaultCollisionConfiguration->getSimplexSolver()->setEqualVertexThreshold(0.f) to disable/configure
#define BT_USE_EQUAL_VERTEX_THRESHOLD

#ifdef BT_USE_DOUBLE_PRECISION
#define VORONOI_DEFAULT_EQUAL_VERTEX_THRESHOLD 1e-12f
#else
#define VORONOI_DEFAULT_EQUAL_VERTEX_THRESHOLD 0.0001f
#endif  //BT_USE_DOUBLE_PRECISION

struct btUsageBitfield
{
	btUsageBitfield()
	{
		reset();
	}

	void reset()
	{
		usedVertexA = false;
		usedVertexB = false;
		usedVertexC = false;
		usedVertexD = false;
	}
	unsigned short usedVertexA : 1;
	unsigned short usedVertexB : 1;
	unsigned short usedVertexC : 1;
	unsigned short usedVertexD : 1;
	unsigned short unused1 : 1;
	unsigned short unused2 : 1;
	unsigned short unused3 : 1;
	unsigned short unused4 : 1;
};

struct btSubSimplexClosestResult
{
	btVector3 m_closestPointOnSimplex;
	//MASK for m_usedVertices
	//stores the simplex vertex-usage, using the MASK,
	// if m_usedVertices & MASK then the related vertex is used
	btUsageBitfield m_usedVertices;
	btScalar m_barycentricCoords[4];
	bool m_degenerate;

	void reset()
	{
		m_degenerate = false;
		setBarycentricCoordinates();
		m_usedVertices.reset();
	}
	bool isValid()
	{
		bool valid = (m_barycentricCoords[0] >= btScalar(0.)) &&
					 (m_barycentricCoords[1] >= btScalar(0.)) &&
					 (m_barycentricCoords[2] >= btScalar(0.)) &&
					 (m_barycentricCoords[3] >= btScalar(0.));

		return valid;
	}
	void setBarycentricCoordinates(btScalar a = btScalar(0.), btScalar b = btScalar(0.), btScalar c = btScalar(0.), btScalar d = btScalar(0.))
	{
		m_barycentricCoords[0] = a;
		m_barycentricCoords[1] = b;
		m_barycentricCoords[2] = c;
		m_barycentricCoords[3] = d;
	}
};

/// btVoronoiSimplexSolver is an implementation of the closest point distance algorithm from a 1-4 points simplex to the origin.
/// Can be used with GJK, as an alternative to Johnson distance algorithm.
#ifdef NO_VIRTUAL_INTERFACE
ATTRIBUTE_ALIGNED16(class)
btVoronoiSimplexSolver
#else
ATTRIBUTE_ALIGNED16(class)
btVoronoiSimplexSolver : public btSimplexSolverInterface
#endif
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	int m_numVertices;

	btVector3 m_simplexVectorW[VORONOI_SIMPLEX_MAX_VERTS];
	btVector3 m_simplexPointsP[VORONOI_SIMPLEX_MAX_VERTS];
	btVector3 m_simplexPointsQ[VORONOI_SIMPLEX_MAX_VERTS];

	btVector3 m_cachedP1;
	btVector3 m_cachedP2;
	btVector3 m_cachedV;
	btVector3 m_lastW;

	btScalar m_equalVertexThreshold;
	bool m_cachedValidClosest;

	btSubSimplexClosestResult m_cachedBC;

	bool m_needsUpdate;

	void removeVertex(int index);
	void reduceVertices(const btUsageBitfield& usedVerts);
	bool updateClosestVectorAndPoints();

	bool closestPtPointTetrahedron(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d, btSubSimplexClosestResult& finalResult);
	int pointOutsideOfPlane(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, const btVector3& d);
	bool closestPtPointTriangle(const btVector3& p, const btVector3& a, const btVector3& b, const btVector3& c, btSubSimplexClosestResult& result);

public:
	btVoronoiSimplexSolver()
		: m_equalVertexThreshold(VORONOI_DEFAULT_EQUAL_VERTEX_THRESHOLD)
	{
	}
	void reset();

	void addVertex(const btVector3& w, const btVector3& p, const btVector3& q);

	void setEqualVertexThreshold(btScalar threshold)
	{
		m_equalVertexThreshold = threshold;
	}

	btScalar getEqualVertexThreshold() const
	{
		return m_equalVertexThreshold;
	}

	bool closest(btVector3 & v);

	btScalar maxVertex();

	bool fullSimplex() const
	{
		return (m_numVertices == 4);
	}

	int getSimplex(btVector3 * pBuf, btVector3 * qBuf, btVector3 * yBuf) const;

	bool inSimplex(const btVector3& w);

	void backup_closest(btVector3 & v);

	bool emptySimplex() const;

	void compute_points(btVector3 & p1, btVector3 & p2);

	int numVertices() const
	{
		return m_numVertices;
	}
};

#endif  //BT_VORONOI_SIMPLEX_SOLVER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMPLEX_SOLVER_INTERFACE_H
#define BT_SIMPLEX_SOLVER_INTERFACE_H

#include "LinearMath/btVector3.h"

#define NO_VIRTUAL_INTERFACE 1
#ifdef NO_VIRTUAL_INTERFACE
#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
#define btSimplexSolverInterface btVoronoiSimplexSolver
#else

/// btSimplexSolverInterface can incrementally calculate distance between origin and up to 4 vertices
/// Used by GJK or Linear Casting. Can be implemented by the Johnson-algorithm or alternative approaches based on
/// voronoi regions or barycentric coordinates
class btSimplexSolverInterface
{
public:
	virtual ~btSimplexSolverInterface(){};

	virtual void reset() = 0;

	virtual void addVertex(const btVector3& w, const btVector3& p, const btVector3& q) = 0;

	virtual bool closest(btVector3& v) = 0;

	virtual btScalar maxVertex() = 0;

	virtual bool fullSimplex() const = 0;

	virtual int getSimplex(btVector3* pBuf, btVector3* qBuf, btVector3* yBuf) const = 0;

	virtual bool inSimplex(const btVector3& w) = 0;

	virtual void backup_closest(btVector3& v) = 0;

	virtual bool emptySimplex() const = 0;

	virtual void compute_points(btVector3& p1, btVector3& p2) = 0;

	virtual int numVertices() const = 0;
};
#endif
#endif  //BT_SIMPLEX_SOLVER_INTERFACE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "LinearMath/btTransformUtil.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define MAX_ITERATIONS 64
#else
#define MAX_ITERATIONS 32
#endif

btGjkConvexCast::btGjkConvexCast(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver)
	: m_simplexSolver(simplexSolver),
	  m_convexA(convexA),
	  m_convexB(convexB)
{
}

bool btGjkConvexCast::calcTimeOfImpact(
	const btTransform& fromA,
	const btTransform& toA,
	const btTransform& fromB,
	const btTransform& toB,
	CastResult& result)
{
	m_simplexSolver->reset();

	/// compute linear velocity for this interval, to interpolate
	//assume no rotation/angular velocity, assert here?
	btVector3 linVelA, linVelB;
	linVelA = toA.getOrigin() - fromA.getOrigin();
	linVelB = toB.getOrigin() - fromB.getOrigin();

	btScalar radius = btScalar(0.001);
	btScalar lambda = btScalar(0.);
	btVector3 v(1, 0, 0);

	int maxIter = MAX_ITERATIONS;

	btVector3 n;
	n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	bool hasResult = false;
	btVector3 c;
	btVector3 r = (linVelA - linVelB);

	btScalar lastLambda = lambda;
	//btScalar epsilon = btScalar(0.001);

	int numIter = 0;
	//first solution, using GJK

	btTransform identityTrans;
	identityTrans.setIdentity();

	//	result.drawCoordSystem(sphereTr);

	btPointCollector pointCollector;

	btGjkPairDetector gjk(m_convexA, m_convexB, m_simplexSolver, 0);  //m_penetrationDepthSolver);
	btGjkPairDetector::ClosestPointInput input;

	//we don't use margins during CCD
	//	gjk.setIgnoreMargin(true);

	input.m_transformA = fromA;
	input.m_transformB = fromB;
	gjk.getClosestPoints(input, pointCollector, 0);

	hasResult = pointCollector.m_hasResult;
	c = pointCollector.m_pointInWorld;

	if (hasResult)
	{
		btScalar dist;
		dist = pointCollector.m_distance;
		n = pointCollector.m_normalOnBInWorld;

		//not close enough
		while (dist > radius)
		{
			numIter++;
			if (numIter > maxIter)
			{
				return false;  //todo: report a failure
			}
			btScalar dLambda = btScalar(0.);

			btScalar projectedLinearVelocity = r.dot(n);

			dLambda = dist / (projectedLinearVelocity);

			lambda = lambda - dLambda;

			if (lambda > btScalar(1.))
				return false;

			if (lambda < btScalar(0.))
				return false;

			//todo: next check with relative epsilon
			if (lambda <= lastLambda)
			{
				return false;
				//n.setValue(0,0,0);
				break;
			}
			lastLambda = lambda;

			//interpolate to next lambda
			result.DebugDraw(lambda);
			input.m_transformA.getOrigin().setInterpolate3(fromA.getOrigin(), toA.getOrigin(), lambda);
			input.m_transformB.getOrigin().setInterpolate3(fromB.getOrigin(), toB.getOrigin(), lambda);

			gjk.getClosestPoints(input, pointCollector, 0);
			if (pointCollector.m_hasResult)
			{
				if (pointCollector.m_distance < btScalar(0.))
				{
					result.m_fraction = lastLambda;
					n = pointCollector.m_normalOnBInWorld;
					result.m_normal = n;
					result.m_hitPoint = pointCollector.m_pointInWorld;
					return true;
				}
				c = pointCollector.m_pointInWorld;
				n = pointCollector.m_normalOnBInWorld;
				dist = pointCollector.m_distance;
			}
			else
			{
				//??
				return false;
			}
		}

		//is n normalized?
		//don't report time of impact for motion away from the contact normal (or causes minor penetration)
		if (n.dot(r) >= -result.m_allowedPenetration)
			return false;

		result.m_fraction = lambda;
		result.m_normal = n;
		result.m_hitPoint = c;
		return true;
	}

	return false;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GJK_CONVEX_CAST_H
#define BT_GJK_CONVEX_CAST_H

#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btVector3.h"
#include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"
class btConvexShape;
class btMinkowskiSumShape;
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"

///GjkConvexCast performs a raycast on a convex object using support mapping.
class btGjkConvexCast : public btConvexCast
{
	btSimplexSolverInterface* m_simplexSolver;
	const btConvexShape* m_convexA;
	const btConvexShape* m_convexB;

public:
	btGjkConvexCast(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver);

	/// cast a convex against another convex object
	virtual bool calcTimeOfImpact(
		const btTransform& fromA,
		const btTransform& toA,
		const btTransform& fromB,
		const btTransform& toB,
		CastResult& result);
};

#endif  //BT_GJK_CONVEX_CAST_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConcaveShape.h"

btConcaveShape::btConcaveShape() : m_collisionMargin(btScalar(0.))
{
}

btConcaveShape::~btConcaveShape()
{
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONCAVE_SHAPE_H
#define BT_CONCAVE_SHAPE_H

#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionShapes/btTriangleCallback.h"

/// PHY_ScalarType enumerates possible scalar types.
/// See the btStridingMeshInterface or btHeightfieldTerrainShape for its use
typedef enum PHY_ScalarType
{
	PHY_FLOAT,
	PHY_DOUBLE,
	PHY_INTEGER,
	PHY_SHORT,
	PHY_FIXEDPOINT88,
	PHY_UCHAR
} PHY_ScalarType;

///The btConcaveShape class provides an interface for non-moving (static) concave shapes.
///It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
ATTRIBUTE_ALIGNED16(class)
btConcaveShape : public btCollisionShape
{
protected:
	btScalar m_collisionMargin;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConcaveShape();

	virtual ~btConcaveShape();

	virtual void processAllTriangles(btTriangleCallback * callback, const btVector3& aabbMin, const btVector3& aabbMax) const = 0;

	virtual btScalar getMargin() const
	{
		return m_collisionMargin;
	}
	virtual void setMargin(btScalar collisionMargin)
	{
		m_collisionMargin = collisionMargin;
	}
};

#endif  //BT_CONCAVE_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_STRIDING_MESHINTERFACE_H
#define BT_STRIDING_MESHINTERFACE_H

#include "LinearMath/btVector3.h"
#include "BulletCollision/CollisionShapes/btTriangleCallback.h"
#include "BulletCollision/CollisionShapes/btConcaveShape.h"

///	The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
/// Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
/// It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
ATTRIBUTE_ALIGNED16(class)
btStridingMeshInterface
{
protected:
	btVector3 m_scaling;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btStridingMeshInterface() : m_scaling(btScalar(1.), btScalar(1.), btScalar(1.))
	{
	}

	virtual ~btStridingMeshInterface();

	virtual void InternalProcessAllTriangles(btInternalTriangleIndexCallback * callback, const btVector3& aabbMin, const btVector3& aabbMax) const;

	///brute force method to calculate aabb
	void calculateAabbBruteForce(btVector3 & aabbMin, btVector3 & aabbMax);

	/// get read and write access to a subpart of a triangle mesh
	/// this subpart has a continuous array of vertices and indices
	/// in this way the mesh can be handled as chunks of memory with striding
	/// very similar to OpenGL vertexarray support
	/// make a call to unLockVertexBase when the read and write access is finished
	virtual void getLockedVertexIndexBase(unsigned char** vertexbase, int& numverts, PHY_ScalarType& type, int& stride, unsigned char** indexbase, int& indexstride, int& numfaces, PHY_ScalarType& indicestype, int subpart = 0) = 0;

	virtual void getLockedReadOnlyVertexIndexBase(const unsigned char** vertexbase, int& numverts, PHY_ScalarType& type, int& stride, const unsigned char** indexbase, int& indexstride, int& numfaces, PHY_ScalarType& indicestype, int subpart = 0) const = 0;

	/// unLockVertexBase finishes the access to a subpart of the triangle mesh
	/// make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished
	virtual void unLockVertexBase(int subpart) = 0;

	virtual void unLockReadOnlyVertexBase(int subpart) const = 0;

	/// getNumSubParts returns the number of separate subparts
	/// each subpart has a continuous array of vertices and indices
	virtual int getNumSubParts() const = 0;

	virtual void preallocateVertices(int numverts) = 0;
	virtual void preallocateIndices(int numindices) = 0;

	virtual bool hasPremadeAabb() const { return false; }
	virtual void setPremadeAabb(const btVector3& aabbMin, const btVector3& aabbMax) const
	{
		(void)aabbMin;
		(void)aabbMax;
	}
	virtual void getPremadeAabb(btVector3 * aabbMin, btVector3 * aabbMax) const
	{
		(void)aabbMin;
		(void)aabbMax;
	}

	const btVector3& getScaling() const
	{
		return m_scaling;
	}
	void setScaling(const btVector3& scaling)
	{
		m_scaling = scaling;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

struct btIntIndexData
{
	int m_value;
};

struct btShortIntIndexData
{
	short m_value;
	char m_pad[2];
};

struct btShortIntIndexTripletData
{
	short m_values[3];
	char m_pad[2];
};

struct btCharIndexTripletData
{
	unsigned char m_values[3];
	char m_pad;
};

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btMeshPartData
{
	btVector3FloatData			*m_vertices3f;
	btVector3DoubleData			*m_vertices3d;

	btIntIndexData				*m_indices32;
	btShortIntIndexTripletData	*m_3indices16;
	btCharIndexTripletData		*m_3indices8;

	btShortIntIndexData			*m_indices16;//backwards compatibility

	int                     m_numTriangles;//length of m_indices = m_numTriangles
	int                     m_numVertices;
};


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btStridingMeshInterfaceData
{
	btMeshPartData	*m_meshPartsPtr;
	btVector3FloatData	m_scaling;
	int	m_numMeshParts;
	char m_padding[4];
};

// clang-format on

SIMD_FORCE_INLINE int btStridingMeshInterface::calculateSerializeBufferSize() const
{
	return sizeof(btStridingMeshInterfaceData);
}

#endif  //BT_STRIDING_MESHINTERFACE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btQuaternion.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btAabbUtil2.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

btTriangleMeshShape::btTriangleMeshShape(btStridingMeshInterface* meshInterface)
	: btConcaveShape(), m_meshInterface(meshInterface)
{
	m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
	if (meshInterface->hasPremadeAabb())
	{
		meshInterface->getPremadeAabb(&m_localAabbMin, &m_localAabbMax);
	}
	else
	{
		recalcLocalAabb();
	}
}

btTriangleMeshShape::~btTriangleMeshShape()
{
}

void btTriangleMeshShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	btVector3 localHalfExtents = btScalar(0.5) * (m_localAabbMax - m_localAabbMin);
	localHalfExtents += btVector3(getMargin(), getMargin(), getMargin());
	btVector3 localCenter = btScalar(0.5) * (m_localAabbMax + m_localAabbMin);

	btMatrix3x3 abs_b = trans.getBasis().absolute();

	btVector3 center = trans(localCenter);

	btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMin = center - extent;
	aabbMax = center + extent;
}

void btTriangleMeshShape::recalcLocalAabb()
{
	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i] + m_collisionMargin;
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i] - m_collisionMargin;
	}
}

class SupportVertexCallback : public btTriangleCallback
{
	btVector3 m_supportVertexLocal;

public:
	btTransform m_worldTrans;
	btScalar m_maxDot;
	btVector3 m_supportVecLocal;

	SupportVertexCallback(const btVector3& supportVecWorld, const btTransform& trans)
		: m_supportVertexLocal(btScalar(0.), btScalar(0.), btScalar(0.)), m_worldTrans(trans), m_maxDot(btScalar(-BT_LARGE_FLOAT))

	{
		m_supportVecLocal = supportVecWorld * m_worldTrans.getBasis();
	}

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
	{
		(void)partId;
		(void)triangleIndex;
		for (int i = 0; i < 3; i++)
		{
			btScalar dot = m_supportVecLocal.dot(triangle[i]);
			if (dot > m_maxDot)
			{
				m_maxDot = dot;
				m_supportVertexLocal = triangle[i];
			}
		}
	}

	btVector3 GetSupportVertexWorldSpace()
	{
		return m_worldTrans(m_supportVertexLocal);
	}

	btVector3 GetSupportVertexLocal()
	{
		return m_supportVertexLocal;
	}
};

void btTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
	m_meshInterface->setScaling(scaling);
	recalcLocalAabb();
}

const btVector3& btTriangleMeshShape::getLocalScaling() const
{
	return m_meshInterface->getScaling();
}

//#define DEBUG_TRIANGLE_MESH

void btTriangleMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	struct FilteredCallback : public btInternalTriangleIndexCallback
	{
		btTriangleCallback* m_callback;
		btVector3 m_aabbMin;
		btVector3 m_aabbMax;

		FilteredCallback(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax)
			: m_callback(callback),
			  m_aabbMin(aabbMin),
			  m_aabbMax(aabbMax)
		{
		}

		virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
		{
			if (TestTriangleAgainstAabb2(&triangle[0], m_aabbMin, m_aabbMax))
			{
				//check aabb in triangle-space, before doing this
				m_callback->processTriangle(triangle, partId, triangleIndex);
			}
		}
	};

	FilteredCallback filterCallback(callback, aabbMin, aabbMax);

	m_meshInterface->InternalProcessAllTriangles(&filterCallback, aabbMin, aabbMax);
}

void btTriangleMeshShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	(void)mass;
	//moving concave objects not supported
	btAssert(0);
	inertia.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
}

btVector3 btTriangleMeshShape::localGetSupportingVertex(const btVector3& vec) const
{
	btVector3 supportVertex;

	btTransform ident;
	ident.setIdentity();

	SupportVertexCallback supportCallback(vec, ident);

	btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));

	processAllTriangles(&supportCallback, -aabbMax, aabbMax);

	supportVertex = supportCallback.GetSupportVertexLocal();

	return supportVertex;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRIANGLE_MESH_SHAPE_H
#define BT_TRIANGLE_MESH_SHAPE_H

#include "BulletCollision/CollisionShapes/btConcaveShape.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"

///The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
ATTRIBUTE_ALIGNED16(class)
btTriangleMeshShape : public btConcaveShape
{
protected:
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	btStridingMeshInterface* m_meshInterface;

	///btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
	///Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!
	btTriangleMeshShape(btStridingMeshInterface * meshInterface);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btTriangleMeshShape();

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;

	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const
	{
		btAssert(0);
		return localGetSupportingVertex(vec);
	}

	void recalcLocalAabb();

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void processAllTriangles(btTriangleCallback * callback, const btVector3& aabbMin, const btVector3& aabbMax) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void setLocalScaling(const btVector3& scaling);
	virtual const btVector3& getLocalScaling() const;

	btStridingMeshInterface* getMeshInterface()
	{
		return m_meshInterface;
	}

	const btStridingMeshInterface* getMeshInterface() const
	{
		return m_meshInterface;
	}

	const btVector3& getLocalAabbMin() const
	{
		return m_localAabbMin;
	}
	const btVector3& getLocalAabbMax() const
	{
		return m_localAabbMax;
	}

	//debugging
	virtual const char* getName() const { return "TRIANGLEMESH"; }
};

#endif  //BT_TRIANGLE_MESH_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/BroadphaseCollision/btQuantizedBvh.h"

#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btIDebugDraw.h"
#include "LinearMath/btSerializer.h"

#define RAYAABB2

btQuantizedBvh::btQuantizedBvh() : m_bulletVersion(BT_BULLET_VERSION),
								   m_useQuantization(false),
								   //m_traversalMode(TRAVERSAL_STACKLESS_CACHE_FRIENDLY)
								   m_traversalMode(TRAVERSAL_STACKLESS)
								   //m_traversalMode(TRAVERSAL_RECURSIVE)
								   ,
								   m_subtreeHeaderCount(0)  //PCK: add this line
{
	m_bvhAabbMin.setValue(-SIMD_INFINITY, -SIMD_INFINITY, -SIMD_INFINITY);
	m_bvhAabbMax.setValue(SIMD_INFINITY, SIMD_INFINITY, SIMD_INFINITY);
}

void btQuantizedBvh::buildInternal()
{
	///assumes that caller filled in the m_quantizedLeafNodes
	m_useQuantization = true;
	int numLeafNodes = 0;

	if (m_useQuantization)
	{
		//now we have an array of leafnodes in m_leafNodes
		numLeafNodes = m_quantizedLeafNodes.size();

		m_quantizedContiguousNodes.resize(2 * numLeafNodes);
	}

	m_curNodeIndex = 0;

	buildTree(0, numLeafNodes);

	///if the entire tree is small then subtree size, we need to create a header info for the tree
	if (m_useQuantization && !m_SubtreeHeaders.size())
	{
		btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
		subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[0]);
		subtree.m_rootNodeIndex = 0;
		subtree.m_subtreeSize = m_quantizedContiguousNodes[0].isLeafNode() ? 1 : m_quantizedContiguousNodes[0].getEscapeIndex();
	}

	//PCK: update the copy of the size
	m_subtreeHeaderCount = m_SubtreeHeaders.size();

	//PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
	m_quantizedLeafNodes.clear();
	m_leafNodes.clear();
}

///just for debugging, to visualize the individual patches/subtrees
#ifdef DEBUG_PATCH_COLORS
btVector3 color[4] =
	{
		btVector3(1, 0, 0),
		btVector3(0, 1, 0),
		btVector3(0, 0, 1),
		btVector3(0, 1, 1)};
#endif  //DEBUG_PATCH_COLORS

void btQuantizedBvh::setQuantizationValues(const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, btScalar quantizationMargin)
{
	//enlarge the AABB to avoid division by zero when initializing the quantization values
	btVector3 clampValue(quantizationMargin, quantizationMargin, quantizationMargin);
	m_bvhAabbMin = bvhAabbMin - clampValue;
	m_bvhAabbMax = bvhAabbMax + clampValue;
	btVector3 aabbSize = m_bvhAabbMax - m_bvhAabbMin;
	m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;

	m_useQuantization = true;

	{
		unsigned short vecIn[3];
		btVector3 v;
		{
			quantize(vecIn, m_bvhAabbMin, false);
			v = unQuantize(vecIn);
			m_bvhAabbMin.setMin(v - clampValue);
		}
		aabbSize = m_bvhAabbMax - m_bvhAabbMin;
		m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;
		{
			quantize(vecIn, m_bvhAabbMax, true);
			v = unQuantize(vecIn);
			m_bvhAabbMax.setMax(v + clampValue);
		}
		aabbSize = m_bvhAabbMax - m_bvhAabbMin;
		m_bvhQuantization = btVector3(btScalar(65533.0), btScalar(65533.0), btScalar(65533.0)) / aabbSize;
	}
}

btQuantizedBvh::~btQuantizedBvh()
{
}

#ifdef DEBUG_TREE_BUILDING
int gStackDepth = 0;
int gMaxStackDepth = 0;
#endif  //DEBUG_TREE_BUILDING

void btQuantizedBvh::buildTree(int startIndex, int endIndex)
{
#ifdef DEBUG_TREE_BUILDING
	gStackDepth++;
	if (gStackDepth > gMaxStackDepth)
		gMaxStackDepth = gStackDepth;
#endif  //DEBUG_TREE_BUILDING

	int splitAxis, splitIndex, i;
	int numIndices = endIndex - startIndex;
	int curIndex = m_curNodeIndex;

	btAssert(numIndices > 0);

	if (numIndices == 1)
	{
#ifdef DEBUG_TREE_BUILDING
		gStackDepth--;
#endif  //DEBUG_TREE_BUILDING

		assignInternalNodeFromLeafNode(m_curNodeIndex, startIndex);

		m_curNodeIndex++;
		return;
	}
	//calculate Best Splitting Axis and where to split it. Sort the incoming 'leafNodes' array within range 'startIndex/endIndex'.

	splitAxis = calcSplittingAxis(startIndex, endIndex);

	splitIndex = sortAndCalcSplittingIndex(startIndex, endIndex, splitAxis);

	int internalNodeIndex = m_curNodeIndex;

	//set the min aabb to 'inf' or a max value, and set the max aabb to a -inf/minimum value.
	//the aabb will be expanded during buildTree/mergeInternalNodeAabb with actual node values
	setInternalNodeAabbMin(m_curNodeIndex, m_bvhAabbMax);  //can't use btVector3(SIMD_INFINITY,SIMD_INFINITY,SIMD_INFINITY)) because of quantization
	setInternalNodeAabbMax(m_curNodeIndex, m_bvhAabbMin);  //can't use btVector3(-SIMD_INFINITY,-SIMD_INFINITY,-SIMD_INFINITY)) because of quantization

	for (i = startIndex; i < endIndex; i++)
	{
		mergeInternalNodeAabb(m_curNodeIndex, getAabbMin(i), getAabbMax(i));
	}

	m_curNodeIndex++;

	//internalNode->m_escapeIndex;

	int leftChildNodexIndex = m_curNodeIndex;

	//build left child tree
	buildTree(startIndex, splitIndex);

	int rightChildNodexIndex = m_curNodeIndex;
	//build right child tree
	buildTree(splitIndex, endIndex);

#ifdef DEBUG_TREE_BUILDING
	gStackDepth--;
#endif  //DEBUG_TREE_BUILDING

	int escapeIndex = m_curNodeIndex - curIndex;

	if (m_useQuantization)
	{
		//escapeIndex is the number of nodes of this subtree
		const int sizeQuantizedNode = sizeof(btQuantizedBvhNode);
		const int treeSizeInBytes = escapeIndex * sizeQuantizedNode;
		if (treeSizeInBytes > MAX_SUBTREE_SIZE_IN_BYTES)
		{
			updateSubtreeHeaders(leftChildNodexIndex, rightChildNodexIndex);
		}
	}
	else
	{
	}

	setInternalNodeEscapeIndex(internalNodeIndex, escapeIndex);
}

void btQuantizedBvh::updateSubtreeHeaders(int leftChildNodexIndex, int rightChildNodexIndex)
{
	btAssert(m_useQuantization);

	btQuantizedBvhNode& leftChildNode = m_quantizedContiguousNodes[leftChildNodexIndex];
	int leftSubTreeSize = leftChildNode.isLeafNode() ? 1 : leftChildNode.getEscapeIndex();
	int leftSubTreeSizeInBytes = leftSubTreeSize * static_cast<int>(sizeof(btQuantizedBvhNode));

	btQuantizedBvhNode& rightChildNode = m_quantizedContiguousNodes[rightChildNodexIndex];
	int rightSubTreeSize = rightChildNode.isLeafNode() ? 1 : rightChildNode.getEscapeIndex();
	int rightSubTreeSizeInBytes = rightSubTreeSize * static_cast<int>(sizeof(btQuantizedBvhNode));

	if (leftSubTreeSizeInBytes <= MAX_SUBTREE_SIZE_IN_BYTES)
	{
		btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
		subtree.setAabbFromQuantizeNode(leftChildNode);
		subtree.m_rootNodeIndex = leftChildNodexIndex;
		subtree.m_subtreeSize = leftSubTreeSize;
	}

	if (rightSubTreeSizeInBytes <= MAX_SUBTREE_SIZE_IN_BYTES)
	{
		btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
		subtree.setAabbFromQuantizeNode(rightChildNode);
		subtree.m_rootNodeIndex = rightChildNodexIndex;
		subtree.m_subtreeSize = rightSubTreeSize;
	}

	//PCK: update the copy of the size
	m_subtreeHeaderCount = m_SubtreeHeaders.size();
}

int btQuantizedBvh::sortAndCalcSplittingIndex(int startIndex, int endIndex, int splitAxis)
{
	int i;
	int splitIndex = startIndex;
	int numIndices = endIndex - startIndex;
	btScalar splitValue;

	btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
	for (i = startIndex; i < endIndex; i++)
	{
		btVector3 center = btScalar(0.5) * (getAabbMax(i) + getAabbMin(i));
		means += center;
	}
	means *= (btScalar(1.) / (btScalar)numIndices);

	splitValue = means[splitAxis];

	//sort leafNodes so all values larger then splitValue comes first, and smaller values start from 'splitIndex'.
	for (i = startIndex; i < endIndex; i++)
	{
		btVector3 center = btScalar(0.5) * (getAabbMax(i) + getAabbMin(i));
		if (center[splitAxis] > splitValue)
		{
			//swap
			swapLeafNodes(i, splitIndex);
			splitIndex++;
		}
	}

	//if the splitIndex causes unbalanced trees, fix this by using the center in between startIndex and endIndex
	//otherwise the tree-building might fail due to stack-overflows in certain cases.
	//unbalanced1 is unsafe: it can cause stack overflows
	//bool unbalanced1 = ((splitIndex==startIndex) || (splitIndex == (endIndex-1)));

	//unbalanced2 should work too: always use center (perfect balanced trees)
	//bool unbalanced2 = true;

	//this should be safe too:
	int rangeBalancedIndices = numIndices / 3;
	bool unbalanced = ((splitIndex <= (startIndex + rangeBalancedIndices)) || (splitIndex >= (endIndex - 1 - rangeBalancedIndices)));

	if (unbalanced)
	{
		splitIndex = startIndex + (numIndices >> 1);
	}

	bool unbal = (splitIndex == startIndex) || (splitIndex == (endIndex));
	(void)unbal;
	btAssert(!unbal);

	return splitIndex;
}

int btQuantizedBvh::calcSplittingAxis(int startIndex, int endIndex)
{
	int i;

	btVector3 means(btScalar(0.), btScalar(0.), btScalar(0.));
	btVector3 variance(btScalar(0.), btScalar(0.), btScalar(0.));
	int numIndices = endIndex - startIndex;

	for (i = startIndex; i < endIndex; i++)
	{
		btVector3 center = btScalar(0.5) * (getAabbMax(i) + getAabbMin(i));
		means += center;
	}
	means *= (btScalar(1.) / (btScalar)numIndices);

	for (i = startIndex; i < endIndex; i++)
	{
		btVector3 center = btScalar(0.5) * (getAabbMax(i) + getAabbMin(i));
		btVector3 diff2 = center - means;
		diff2 = diff2 * diff2;
		variance += diff2;
	}
	variance *= (btScalar(1.) / ((btScalar)numIndices - 1));

	return variance.maxAxis();
}

void btQuantizedBvh::reportAabbOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	//either choose recursive traversal (walkTree) or stackless (walkStacklessTree)

	if (m_useQuantization)
	{
		///quantize query AABB
		unsigned short int quantizedQueryAabbMin[3];
		unsigned short int quantizedQueryAabbMax[3];
		quantizeWithClamp(quantizedQueryAabbMin, aabbMin, 0);
		quantizeWithClamp(quantizedQueryAabbMax, aabbMax, 1);

		switch (m_traversalMode)
		{
			case TRAVERSAL_STACKLESS:
				walkStacklessQuantizedTree(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax, 0, m_curNodeIndex);
				break;
			case TRAVERSAL_STACKLESS_CACHE_FRIENDLY:
				walkStacklessQuantizedTreeCacheFriendly(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
				break;
			case TRAVERSAL_RECURSIVE:
			{
				const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[0];
				walkRecursiveQuantizedTreeAgainstQueryAabb(rootNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
			}
			break;
			default:
				//unsupported
				btAssert(0);
		}
	}
	else
	{
		walkStacklessTree(nodeCallback, aabbMin, aabbMax);
	}
}

void btQuantizedBvh::walkStacklessTree(btNodeOverlapCallback* nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	btAssert(!m_useQuantization);

	const btOptimizedBvhNode* rootNode = &m_contiguousNodes[0];
	int escapeIndex, curIndex = 0;
	int walkIterations = 0;
	bool isLeafNode;
	//PCK: unsigned instead of bool
	unsigned aabbOverlap;

	while (curIndex < m_curNodeIndex)
	{
		//catch bugs in tree data
		btAssert(walkIterations < m_curNodeIndex);

		walkIterations++;
		aabbOverlap = TestAabbAgainstAabb2(aabbMin, aabbMax, rootNode->m_aabbMinOrg, rootNode->m_aabbMaxOrg);
		isLeafNode = rootNode->m_escapeIndex == -1;

		//PCK: unsigned instead of bool
		if (isLeafNode && (aabbOverlap != 0))
		{
			nodeCallback->processNode(rootNode->m_subPart, rootNode->m_triangleIndex);
		}

		//PCK: unsigned instead of bool
		if ((aabbOverlap != 0) || isLeafNode)
		{
			rootNode++;
			curIndex++;
		}
		else
		{
			escapeIndex = rootNode->m_escapeIndex;
			rootNode += escapeIndex;
			curIndex += escapeIndex;
		}
	}
}

/*
///this was the original recursive traversal, before we optimized towards stackless traversal
void	btQuantizedBvh::walkTree(btOptimizedBvhNode* rootNode,btNodeOverlapCallback* nodeCallback,const btVector3& aabbMin,const btVector3& aabbMax) const
{
	bool isLeafNode, aabbOverlap = TestAabbAgainstAabb2(aabbMin,aabbMax,rootNode->m_aabbMin,rootNode->m_aabbMax);
	if (aabbOverlap)
	{
		isLeafNode = (!rootNode->m_leftChild && !rootNode->m_rightChild);
		if (isLeafNode)
		{
			nodeCallback->processNode(rootNode);
		} else
		{
			walkTree(rootNode->m_leftChild,nodeCallback,aabbMin,aabbMax);
			walkTree(rootNode->m_rightChild,nodeCallback,aabbMin,aabbMax);
		}
	}

}
*/

void btQuantizedBvh::walkRecursiveQuantizedTreeAgainstQueryAabb(const btQuantizedBvhNode* currentNode, btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const
{
	btAssert(m_useQuantization);

	bool isLeafNode;
	//PCK: unsigned instead of bool
	unsigned aabbOverlap;

	//PCK: unsigned instead of bool
	aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, currentNode->m_quantizedAabbMin, currentNode->m_quantizedAabbMax);
	isLeafNode = currentNode->isLeafNode();

	//PCK: unsigned instead of bool
	if (aabbOverlap != 0)
	{
		if (isLeafNode)
		{
			nodeCallback->processNode(currentNode->getPartId(), currentNode->getTriangleIndex());
		}
		else
		{
			//process left and right children
			const btQuantizedBvhNode* leftChildNode = currentNode + 1;
			walkRecursiveQuantizedTreeAgainstQueryAabb(leftChildNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);

			const btQuantizedBvhNode* rightChildNode = leftChildNode->isLeafNode() ? leftChildNode + 1 : leftChildNode + leftChildNode->getEscapeIndex();
			walkRecursiveQuantizedTreeAgainstQueryAabb(rightChildNode, nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax);
		}
	}
}

void btQuantizedBvh::walkStacklessTreeAgainstRay(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const
{
	btAssert(!m_useQuantization);

	const btOptimizedBvhNode* rootNode = &m_contiguousNodes[0];
	int escapeIndex, curIndex = 0;
	int walkIterations = 0;
	bool isLeafNode;
	//PCK: unsigned instead of bool
	unsigned aabbOverlap = 0;
	unsigned rayBoxOverlap = 0;
	btScalar lambda_max = 1.0;

	/* Quick pruning by quantized box */
	btVector3 rayAabbMin = raySource;
	btVector3 rayAabbMax = raySource;
	rayAabbMin.setMin(rayTarget);
	rayAabbMax.setMax(rayTarget);

	/* Add box cast extents to bounding box */
	rayAabbMin += aabbMin;
	rayAabbMax += aabbMax;

#ifdef RAYAABB2
	btVector3 rayDir = (rayTarget - raySource);
	rayDir.safeNormalize();// stephengold changed normalize to safeNormalize 2020-02-17
	lambda_max = rayDir.dot(rayTarget - raySource);
	///what about division by zero? --> just set rayDirection[i] to 1.0
	btVector3 rayDirectionInverse;
	rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
	rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
	rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
	unsigned int sign[3] = {rayDirectionInverse[0] < 0.0, rayDirectionInverse[1] < 0.0, rayDirectionInverse[2] < 0.0};
#endif

	btVector3 bounds[2];

	while (curIndex < m_curNodeIndex)
	{
		btScalar param = 1.0;
		//catch bugs in tree data
		btAssert(walkIterations < m_curNodeIndex);

		walkIterations++;

		bounds[0] = rootNode->m_aabbMinOrg;
		bounds[1] = rootNode->m_aabbMaxOrg;
		/* Add box cast extents */
		bounds[0] -= aabbMax;
		bounds[1] -= aabbMin;

		aabbOverlap = TestAabbAgainstAabb2(rayAabbMin, rayAabbMax, rootNode->m_aabbMinOrg, rootNode->m_aabbMaxOrg);
		//perhaps profile if it is worth doing the aabbOverlap test first

#ifdef RAYAABB2
		///careful with this check: need to check division by zero (above) and fix the unQuantize method
		///thanks Joerg/hiker for the reproduction case!
		///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858
		rayBoxOverlap = aabbOverlap ? btRayAabb2(raySource, rayDirectionInverse, sign, bounds, param, 0.0f, lambda_max) : false;

#else
		btVector3 normal;
		rayBoxOverlap = btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
#endif

		isLeafNode = rootNode->m_escapeIndex == -1;

		//PCK: unsigned instead of bool
		if (isLeafNode && (rayBoxOverlap != 0))
		{
			nodeCallback->processNode(rootNode->m_subPart, rootNode->m_triangleIndex);
		}

		//PCK: unsigned instead of bool
		if ((rayBoxOverlap != 0) || isLeafNode)
		{
			rootNode++;
			curIndex++;
		}
		else
		{
			escapeIndex = rootNode->m_escapeIndex;
			rootNode += escapeIndex;
			curIndex += escapeIndex;
		}
	}
}

void btQuantizedBvh::walkStacklessQuantizedTreeAgainstRay(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const
{
	btAssert(m_useQuantization);

	int curIndex = startNodeIndex;
	int walkIterations = 0;
	int subTreeSize = endNodeIndex - startNodeIndex;
	(void)subTreeSize;

	const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[startNodeIndex];
	int escapeIndex;

	bool isLeafNode;
	//PCK: unsigned instead of bool
	unsigned boxBoxOverlap = 0;
	unsigned rayBoxOverlap = 0;

	btScalar lambda_max = 1.0;

#ifdef RAYAABB2
	btVector3 rayDirection = (rayTarget - raySource);
	rayDirection.safeNormalize();// stephengold changed normalize to safeNormalize 2020-02-17
	lambda_max = rayDirection.dot(rayTarget - raySource);
	///what about division by zero? --> just set rayDirection[i] to 1.0
	rayDirection[0] = rayDirection[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[0];
	rayDirection[1] = rayDirection[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[1];
	rayDirection[2] = rayDirection[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDirection[2];
	unsigned int sign[3] = {rayDirection[0] < 0.0, rayDirection[1] < 0.0, rayDirection[2] < 0.0};
#endif

	/* Quick pruning by quantized box */
	btVector3 rayAabbMin = raySource;
	btVector3 rayAabbMax = raySource;
	rayAabbMin.setMin(rayTarget);
	rayAabbMax.setMax(rayTarget);

	/* Add box cast extents to bounding box */
	rayAabbMin += aabbMin;
	rayAabbMax += aabbMax;

	unsigned short int quantizedQueryAabbMin[3];
	unsigned short int quantizedQueryAabbMax[3];
	quantizeWithClamp(quantizedQueryAabbMin, rayAabbMin, 0);
	quantizeWithClamp(quantizedQueryAabbMax, rayAabbMax, 1);

	while (curIndex < endNodeIndex)
	{
//#define VISUALLY_ANALYZE_BVH 1
#ifdef VISUALLY_ANALYZE_BVH
		//some code snippet to debugDraw aabb, to visually analyze bvh structure
		static int drawPatch = 0;
		//need some global access to a debugDrawer
		extern btIDebugDraw* debugDrawerPtr;
		if (curIndex == drawPatch)
		{
			btVector3 aabbMin, aabbMax;
			aabbMin = unQuantize(rootNode->m_quantizedAabbMin);
			aabbMax = unQuantize(rootNode->m_quantizedAabbMax);
			btVector3 color(1, 0, 0);
			debugDrawerPtr->drawAabb(aabbMin, aabbMax, color);
		}
#endif  //VISUALLY_ANALYZE_BVH

		//catch bugs in tree data
		btAssert(walkIterations < subTreeSize);

		walkIterations++;
		//PCK: unsigned instead of bool
		// only interested if this is closer than any previous hit
		btScalar param = 1.0;
		rayBoxOverlap = 0;
		boxBoxOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, rootNode->m_quantizedAabbMin, rootNode->m_quantizedAabbMax);
		isLeafNode = rootNode->isLeafNode();
		if (boxBoxOverlap)
		{
			btVector3 bounds[2];
			bounds[0] = unQuantize(rootNode->m_quantizedAabbMin);
			bounds[1] = unQuantize(rootNode->m_quantizedAabbMax);
			/* Add box cast extents */
			bounds[0] -= aabbMax;
			bounds[1] -= aabbMin;
			btVector3 normal;
#if 0
			bool ra2 = btRayAabb2 (raySource, rayDirection, sign, bounds, param, 0.0, lambda_max);
			bool ra = btRayAabb (raySource, rayTarget, bounds[0], bounds[1], param, normal);
			if (ra2 != ra)
			{
				printf("functions don't match\n");
			}
#endif
#ifdef RAYAABB2
			///careful with this check: need to check division by zero (above) and fix the unQuantize method
			///thanks Joerg/hiker for the reproduction case!
			///http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=9&t=1858

			//BT_PROFILE("btRayAabb2");
			rayBoxOverlap = btRayAabb2(raySource, rayDirection, sign, bounds, param, 0.0f, lambda_max);

#else
			rayBoxOverlap = true;  //btRayAabb(raySource, rayTarget, bounds[0], bounds[1], param, normal);
#endif
		}

		if (isLeafNode && rayBoxOverlap)
		{
			nodeCallback->processNode(rootNode->getPartId(), rootNode->getTriangleIndex());
		}

		//PCK: unsigned instead of bool
		if ((rayBoxOverlap != 0) || isLeafNode)
		{
			rootNode++;
			curIndex++;
		}
		else
		{
			escapeIndex = rootNode->getEscapeIndex();
			rootNode += escapeIndex;
			curIndex += escapeIndex;
		}
	}
}

void btQuantizedBvh::walkStacklessQuantizedTree(btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax, int startNodeIndex, int endNodeIndex) const
{
	btAssert(m_useQuantization);

	int curIndex = startNodeIndex;
	int walkIterations = 0;
	int subTreeSize = endNodeIndex - startNodeIndex;
	(void)subTreeSize;

	const btQuantizedBvhNode* rootNode = &m_quantizedContiguousNodes[startNodeIndex];
	int escapeIndex;

	bool isLeafNode;
	//PCK: unsigned instead of bool
	unsigned aabbOverlap;

	while (curIndex < endNodeIndex)
	{
//#define VISUALLY_ANALYZE_BVH 1
#ifdef VISUALLY_ANALYZE_BVH
		//some code snippet to debugDraw aabb, to visually analyze bvh structure
		static int drawPatch = 0;
		//need some global access to a debugDrawer
		extern btIDebugDraw* debugDrawerPtr;
		if (curIndex == drawPatch)
		{
			btVector3 aabbMin, aabbMax;
			aabbMin = unQuantize(rootNode->m_quantizedAabbMin);
			aabbMax = unQuantize(rootNode->m_quantizedAabbMax);
			btVector3 color(1, 0, 0);
			debugDrawerPtr->drawAabb(aabbMin, aabbMax, color);
		}
#endif  //VISUALLY_ANALYZE_BVH

		//catch bugs in tree data
		btAssert(walkIterations < subTreeSize);

		walkIterations++;
		//PCK: unsigned instead of bool
		aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, rootNode->m_quantizedAabbMin, rootNode->m_quantizedAabbMax);
		isLeafNode = rootNode->isLeafNode();

		if (isLeafNode && aabbOverlap)
		{
			nodeCallback->processNode(rootNode->getPartId(), rootNode->getTriangleIndex());
		}

		//PCK: unsigned instead of bool
		if ((aabbOverlap != 0) || isLeafNode)
		{
			rootNode++;
			curIndex++;
		}
		else
		{
			escapeIndex = rootNode->getEscapeIndex();
			rootNode += escapeIndex;
			curIndex += escapeIndex;
		}
	}
}

//This traversal can be called from Playstation 3 SPU
void btQuantizedBvh::walkStacklessQuantizedTreeCacheFriendly(btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const
{
	btAssert(m_useQuantization);

	int i;

	for (i = 0; i < this->m_SubtreeHeaders.size(); i++)
	{
		const btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];

		//PCK: unsigned instead of bool
		unsigned overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, subtree.m_quantizedAabbMin, subtree.m_quantizedAabbMax);
		if (overlap != 0)
		{
			walkStacklessQuantizedTree(nodeCallback, quantizedQueryAabbMin, quantizedQueryAabbMax,
									   subtree.m_rootNodeIndex,
									   subtree.m_rootNodeIndex + subtree.m_subtreeSize);
		}
	}
}

void btQuantizedBvh::reportRayOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget) const
{
	reportBoxCastOverlappingNodex(nodeCallback, raySource, rayTarget, btVector3(0, 0, 0), btVector3(0, 0, 0));
}

void btQuantizedBvh::reportBoxCastOverlappingNodex(btNodeOverlapCallback* nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	//always use stackless

	if (m_useQuantization)
	{
		walkStacklessQuantizedTreeAgainstRay(nodeCallback, raySource, rayTarget, aabbMin, aabbMax, 0, m_curNodeIndex);
	}
	else
	{
		walkStacklessTreeAgainstRay(nodeCallback, raySource, rayTarget, aabbMin, aabbMax, 0, m_curNodeIndex);
	}
	/*
	{
		//recursive traversal
		btVector3 qaabbMin = raySource;
		btVector3 qaabbMax = raySource;
		qaabbMin.setMin(rayTarget);
		qaabbMax.setMax(rayTarget);
		qaabbMin += aabbMin;
		qaabbMax += aabbMax;
		reportAabbOverlappingNodex(nodeCallback,qaabbMin,qaabbMax);
	}
	*/
}

void btQuantizedBvh::swapLeafNodes(int i, int splitIndex)
{
	if (m_useQuantization)
	{
		btQuantizedBvhNode tmp = m_quantizedLeafNodes[i];
		m_quantizedLeafNodes[i] = m_quantizedLeafNodes[splitIndex];
		m_quantizedLeafNodes[splitIndex] = tmp;
	}
	else
	{
		btOptimizedBvhNode tmp = m_leafNodes[i];
		m_leafNodes[i] = m_leafNodes[splitIndex];
		m_leafNodes[splitIndex] = tmp;
	}
}

void btQuantizedBvh::assignInternalNodeFromLeafNode(int internalNode, int leafNodeIndex)
{
	if (m_useQuantization)
	{
		m_quantizedContiguousNodes[internalNode] = m_quantizedLeafNodes[leafNodeIndex];
	}
	else
	{
		m_contiguousNodes[internalNode] = m_leafNodes[leafNodeIndex];
	}
}

//PCK: include

#if 0
//PCK: consts
static const unsigned BVH_ALIGNMENT = 16;
static const unsigned BVH_ALIGNMENT_MASK = BVH_ALIGNMENT-1;

static const unsigned BVH_ALIGNMENT_BLOCKS = 2;
#endif

unsigned int btQuantizedBvh::getAlignmentSerializationPadding()
{
	// I changed this to 0 since the extra padding is not needed or used.
	return 0;  //BVH_ALIGNMENT_BLOCKS * BVH_ALIGNMENT;
}

unsigned btQuantizedBvh::calculateSerializeBufferSize() const
{
	unsigned baseSize = sizeof(btQuantizedBvh) + getAlignmentSerializationPadding();
	baseSize += sizeof(btBvhSubtreeInfo) * m_subtreeHeaderCount;
	if (m_useQuantization)
	{
		return baseSize + m_curNodeIndex * sizeof(btQuantizedBvhNode);
	}
	return baseSize + m_curNodeIndex * sizeof(btOptimizedBvhNode);
}

bool btQuantizedBvh::serialize(void* o_alignedDataBuffer, unsigned /*i_dataBufferSize */, bool i_swapEndian) const
{
	btAssert(m_subtreeHeaderCount == m_SubtreeHeaders.size());
	m_subtreeHeaderCount = m_SubtreeHeaders.size();

	/*	if (i_dataBufferSize < calculateSerializeBufferSize() || o_alignedDataBuffer == NULL || (((unsigned)o_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
	{
		///check alignedment for buffer?
		btAssert(0);
		return false;
	}
*/

	btQuantizedBvh* targetBvh = (btQuantizedBvh*)o_alignedDataBuffer;

	// construct the class so the virtual function table, etc will be set up
	// Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
	new (targetBvh) btQuantizedBvh;

	if (i_swapEndian)
	{
		targetBvh->m_curNodeIndex = static_cast<int>(btSwapEndian(m_curNodeIndex));

		btSwapVector3Endian(m_bvhAabbMin, targetBvh->m_bvhAabbMin);
		btSwapVector3Endian(m_bvhAabbMax, targetBvh->m_bvhAabbMax);
		btSwapVector3Endian(m_bvhQuantization, targetBvh->m_bvhQuantization);

		targetBvh->m_traversalMode = (btTraversalMode)btSwapEndian(m_traversalMode);
		targetBvh->m_subtreeHeaderCount = static_cast<int>(btSwapEndian(m_subtreeHeaderCount));
	}
	else
	{
		targetBvh->m_curNodeIndex = m_curNodeIndex;
		targetBvh->m_bvhAabbMin = m_bvhAabbMin;
		targetBvh->m_bvhAabbMax = m_bvhAabbMax;
		targetBvh->m_bvhQuantization = m_bvhQuantization;
		targetBvh->m_traversalMode = m_traversalMode;
		targetBvh->m_subtreeHeaderCount = m_subtreeHeaderCount;
	}

	targetBvh->m_useQuantization = m_useQuantization;

	unsigned char* nodeData = (unsigned char*)targetBvh;
	nodeData += sizeof(btQuantizedBvh);

	unsigned sizeToAdd = 0;  //(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
	nodeData += sizeToAdd;

	int nodeCount = m_curNodeIndex;

	if (m_useQuantization)
	{
		targetBvh->m_quantizedContiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

		if (i_swapEndian)
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0]);
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1]);
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2]);

				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0]);
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1]);
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2]);

				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = static_cast<int>(btSwapEndian(m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex));
			}
		}
		else
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0];
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1];
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2];

				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0];
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1];
				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2];

				targetBvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex;
			}
		}
		nodeData += sizeof(btQuantizedBvhNode) * nodeCount;

		// this clears the pointer in the member variable it doesn't really do anything to the data
		// it does call the destructor on the contained objects, but they are all classes with no destructor defined
		// so the memory (which is not freed) is left alone
		targetBvh->m_quantizedContiguousNodes.initializeFromBuffer(NULL, 0, 0);
	}
	else
	{
		targetBvh->m_contiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

		if (i_swapEndian)
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				btSwapVector3Endian(m_contiguousNodes[nodeIndex].m_aabbMinOrg, targetBvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg);
				btSwapVector3Endian(m_contiguousNodes[nodeIndex].m_aabbMaxOrg, targetBvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg);

				targetBvh->m_contiguousNodes[nodeIndex].m_escapeIndex = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_escapeIndex));
				targetBvh->m_contiguousNodes[nodeIndex].m_subPart = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_subPart));
				targetBvh->m_contiguousNodes[nodeIndex].m_triangleIndex = static_cast<int>(btSwapEndian(m_contiguousNodes[nodeIndex].m_triangleIndex));
			}
		}
		else
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				targetBvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg = m_contiguousNodes[nodeIndex].m_aabbMinOrg;
				targetBvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg = m_contiguousNodes[nodeIndex].m_aabbMaxOrg;

				targetBvh->m_contiguousNodes[nodeIndex].m_escapeIndex = m_contiguousNodes[nodeIndex].m_escapeIndex;
				targetBvh->m_contiguousNodes[nodeIndex].m_subPart = m_contiguousNodes[nodeIndex].m_subPart;
				targetBvh->m_contiguousNodes[nodeIndex].m_triangleIndex = m_contiguousNodes[nodeIndex].m_triangleIndex;
			}
		}
		nodeData += sizeof(btOptimizedBvhNode) * nodeCount;

		// this clears the pointer in the member variable it doesn't really do anything to the data
		// it does call the destructor on the contained objects, but they are all classes with no destructor defined
		// so the memory (which is not freed) is left alone
		targetBvh->m_contiguousNodes.initializeFromBuffer(NULL, 0, 0);
	}

	sizeToAdd = 0;  //(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
	nodeData += sizeToAdd;

	// Now serialize the subtree headers
	targetBvh->m_SubtreeHeaders.initializeFromBuffer(nodeData, m_subtreeHeaderCount, m_subtreeHeaderCount);
	if (i_swapEndian)
	{
		for (int i = 0; i < m_subtreeHeaderCount; i++)
		{
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = btSwapEndian(m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

			targetBvh->m_SubtreeHeaders[i].m_rootNodeIndex = static_cast<int>(btSwapEndian(m_SubtreeHeaders[i].m_rootNodeIndex));
			targetBvh->m_SubtreeHeaders[i].m_subtreeSize = static_cast<int>(btSwapEndian(m_SubtreeHeaders[i].m_subtreeSize));
		}
	}
	else
	{
		for (int i = 0; i < m_subtreeHeaderCount; i++)
		{
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = (m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = (m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = (m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = (m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = (m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
			targetBvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = (m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

			targetBvh->m_SubtreeHeaders[i].m_rootNodeIndex = (m_SubtreeHeaders[i].m_rootNodeIndex);
			targetBvh->m_SubtreeHeaders[i].m_subtreeSize = (m_SubtreeHeaders[i].m_subtreeSize);

			// need to clear padding in destination buffer
			targetBvh->m_SubtreeHeaders[i].m_padding[0] = 0;
			targetBvh->m_SubtreeHeaders[i].m_padding[1] = 0;
			targetBvh->m_SubtreeHeaders[i].m_padding[2] = 0;
		}
	}
	nodeData += sizeof(btBvhSubtreeInfo) * m_subtreeHeaderCount;

	// this clears the pointer in the member variable it doesn't really do anything to the data
	// it does call the destructor on the contained objects, but they are all classes with no destructor defined
	// so the memory (which is not freed) is left alone
	targetBvh->m_SubtreeHeaders.initializeFromBuffer(NULL, 0, 0);

	// this wipes the virtual function table pointer at the start of the buffer for the class
	*((void**)o_alignedDataBuffer) = NULL;

	return true;
}

btQuantizedBvh* btQuantizedBvh::deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian)
{
	if (i_alignedDataBuffer == NULL)  // || (((unsigned)i_alignedDataBuffer & BVH_ALIGNMENT_MASK) != 0))
	{
		return NULL;
	}
	btQuantizedBvh* bvh = (btQuantizedBvh*)i_alignedDataBuffer;

	if (i_swapEndian)
	{
		bvh->m_curNodeIndex = static_cast<int>(btSwapEndian(bvh->m_curNodeIndex));

		btUnSwapVector3Endian(bvh->m_bvhAabbMin);
		btUnSwapVector3Endian(bvh->m_bvhAabbMax);
		btUnSwapVector3Endian(bvh->m_bvhQuantization);

		bvh->m_traversalMode = (btTraversalMode)btSwapEndian(bvh->m_traversalMode);
		bvh->m_subtreeHeaderCount = static_cast<int>(btSwapEndian(bvh->m_subtreeHeaderCount));
	}

	unsigned int calculatedBufSize = bvh->calculateSerializeBufferSize();
	btAssert(calculatedBufSize <= i_dataBufferSize);

	if (calculatedBufSize > i_dataBufferSize)
	{
		return NULL;
	}

	unsigned char* nodeData = (unsigned char*)bvh;
	nodeData += sizeof(btQuantizedBvh);

	unsigned sizeToAdd = 0;  //(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
	nodeData += sizeToAdd;

	int nodeCount = bvh->m_curNodeIndex;

	// Must call placement new to fill in virtual function table, etc, but we don't want to overwrite most data, so call a special version of the constructor
	// Also, m_leafNodes and m_quantizedLeafNodes will be initialized to default values by the constructor
	new (bvh) btQuantizedBvh(*bvh, false);

	if (bvh->m_useQuantization)
	{
		bvh->m_quantizedContiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

		if (i_swapEndian)
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0]);
				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[1]);
				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[2]);

				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0]);
				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[1]);
				bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2] = btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[2]);

				bvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = static_cast<int>(btSwapEndian(bvh->m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex));
			}
		}
		nodeData += sizeof(btQuantizedBvhNode) * nodeCount;
	}
	else
	{
		bvh->m_contiguousNodes.initializeFromBuffer(nodeData, nodeCount, nodeCount);

		if (i_swapEndian)
		{
			for (int nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++)
			{
				btUnSwapVector3Endian(bvh->m_contiguousNodes[nodeIndex].m_aabbMinOrg);
				btUnSwapVector3Endian(bvh->m_contiguousNodes[nodeIndex].m_aabbMaxOrg);

				bvh->m_contiguousNodes[nodeIndex].m_escapeIndex = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_escapeIndex));
				bvh->m_contiguousNodes[nodeIndex].m_subPart = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_subPart));
				bvh->m_contiguousNodes[nodeIndex].m_triangleIndex = static_cast<int>(btSwapEndian(bvh->m_contiguousNodes[nodeIndex].m_triangleIndex));
			}
		}
		nodeData += sizeof(btOptimizedBvhNode) * nodeCount;
	}

	sizeToAdd = 0;  //(BVH_ALIGNMENT-((unsigned)nodeData & BVH_ALIGNMENT_MASK))&BVH_ALIGNMENT_MASK;
	nodeData += sizeToAdd;

	// Now serialize the subtree headers
	bvh->m_SubtreeHeaders.initializeFromBuffer(nodeData, bvh->m_subtreeHeaderCount, bvh->m_subtreeHeaderCount);
	if (i_swapEndian)
	{
		for (int i = 0; i < bvh->m_subtreeHeaderCount; i++)
		{
			bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[0]);
			bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[1]);
			bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMin[2]);

			bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[0]);
			bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[1]);
			bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2] = btSwapEndian(bvh->m_SubtreeHeaders[i].m_quantizedAabbMax[2]);

			bvh->m_SubtreeHeaders[i].m_rootNodeIndex = static_cast<int>(btSwapEndian(bvh->m_SubtreeHeaders[i].m_rootNodeIndex));
			bvh->m_SubtreeHeaders[i].m_subtreeSize = static_cast<int>(btSwapEndian(bvh->m_SubtreeHeaders[i].m_subtreeSize));
		}
	}

	return bvh;
}

// Constructor that prevents btVector3's default constructor from being called
btQuantizedBvh::btQuantizedBvh(btQuantizedBvh& self, bool /* ownsMemory */) : m_bvhAabbMin(self.m_bvhAabbMin),
																			  m_bvhAabbMax(self.m_bvhAabbMax),
																			  m_bvhQuantization(self.m_bvhQuantization),
																			  m_bulletVersion(BT_BULLET_VERSION)
{
}

void btQuantizedBvh::deSerializeFloat(struct btQuantizedBvhFloatData& quantizedBvhFloatData)
{
	m_bvhAabbMax.deSerializeFloat(quantizedBvhFloatData.m_bvhAabbMax);
	m_bvhAabbMin.deSerializeFloat(quantizedBvhFloatData.m_bvhAabbMin);
	m_bvhQuantization.deSerializeFloat(quantizedBvhFloatData.m_bvhQuantization);

	m_curNodeIndex = quantizedBvhFloatData.m_curNodeIndex;
	m_useQuantization = quantizedBvhFloatData.m_useQuantization != 0;

	{
		int numElem = quantizedBvhFloatData.m_numContiguousLeafNodes;
		m_contiguousNodes.resize(numElem);

		if (numElem)
		{
			btOptimizedBvhNodeFloatData* memPtr = quantizedBvhFloatData.m_contiguousNodesPtr;

			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_contiguousNodes[i].m_aabbMaxOrg.deSerializeFloat(memPtr->m_aabbMaxOrg);
				m_contiguousNodes[i].m_aabbMinOrg.deSerializeFloat(memPtr->m_aabbMinOrg);
				m_contiguousNodes[i].m_escapeIndex = memPtr->m_escapeIndex;
				m_contiguousNodes[i].m_subPart = memPtr->m_subPart;
				m_contiguousNodes[i].m_triangleIndex = memPtr->m_triangleIndex;
			}
		}
	}

	{
		int numElem = quantizedBvhFloatData.m_numQuantizedContiguousNodes;
		m_quantizedContiguousNodes.resize(numElem);

		if (numElem)
		{
			btQuantizedBvhNodeData* memPtr = quantizedBvhFloatData.m_quantizedContiguousNodesPtr;
			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex = memPtr->m_escapeIndexOrTriangleIndex;
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
			}
		}
	}

	m_traversalMode = btTraversalMode(quantizedBvhFloatData.m_traversalMode);

	{
		int numElem = quantizedBvhFloatData.m_numSubtreeHeaders;
		m_SubtreeHeaders.resize(numElem);
		if (numElem)
		{
			btBvhSubtreeInfoData* memPtr = quantizedBvhFloatData.m_subTreeInfoPtr;
			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_SubtreeHeaders[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
				m_SubtreeHeaders[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
				m_SubtreeHeaders[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
				m_SubtreeHeaders[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
				m_SubtreeHeaders[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
				m_SubtreeHeaders[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
				m_SubtreeHeaders[i].m_rootNodeIndex = memPtr->m_rootNodeIndex;
				m_SubtreeHeaders[i].m_subtreeSize = memPtr->m_subtreeSize;
			}
		}
	}
}

void btQuantizedBvh::deSerializeDouble(struct btQuantizedBvhDoubleData& quantizedBvhDoubleData)
{
	m_bvhAabbMax.deSerializeDouble(quantizedBvhDoubleData.m_bvhAabbMax);
	m_bvhAabbMin.deSerializeDouble(quantizedBvhDoubleData.m_bvhAabbMin);
	m_bvhQuantization.deSerializeDouble(quantizedBvhDoubleData.m_bvhQuantization);

	m_curNodeIndex = quantizedBvhDoubleData.m_curNodeIndex;
	m_useQuantization = quantizedBvhDoubleData.m_useQuantization != 0;

	{
		int numElem = quantizedBvhDoubleData.m_numContiguousLeafNodes;
		m_contiguousNodes.resize(numElem);

		if (numElem)
		{
			btOptimizedBvhNodeDoubleData* memPtr = quantizedBvhDoubleData.m_contiguousNodesPtr;

			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_contiguousNodes[i].m_aabbMaxOrg.deSerializeDouble(memPtr->m_aabbMaxOrg);
				m_contiguousNodes[i].m_aabbMinOrg.deSerializeDouble(memPtr->m_aabbMinOrg);
				m_contiguousNodes[i].m_escapeIndex = memPtr->m_escapeIndex;
				m_contiguousNodes[i].m_subPart = memPtr->m_subPart;
				m_contiguousNodes[i].m_triangleIndex = memPtr->m_triangleIndex;
			}
		}
	}

	{
		int numElem = quantizedBvhDoubleData.m_numQuantizedContiguousNodes;
		m_quantizedContiguousNodes.resize(numElem);

		if (numElem)
		{
			btQuantizedBvhNodeData* memPtr = quantizedBvhDoubleData.m_quantizedContiguousNodesPtr;
			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex = memPtr->m_escapeIndexOrTriangleIndex;
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
				m_quantizedContiguousNodes[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
				m_quantizedContiguousNodes[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
			}
		}
	}

	m_traversalMode = btTraversalMode(quantizedBvhDoubleData.m_traversalMode);

	{
		int numElem = quantizedBvhDoubleData.m_numSubtreeHeaders;
		m_SubtreeHeaders.resize(numElem);
		if (numElem)
		{
			btBvhSubtreeInfoData* memPtr = quantizedBvhDoubleData.m_subTreeInfoPtr;
			for (int i = 0; i < numElem; i++, memPtr++)
			{
				m_SubtreeHeaders[i].m_quantizedAabbMax[0] = memPtr->m_quantizedAabbMax[0];
				m_SubtreeHeaders[i].m_quantizedAabbMax[1] = memPtr->m_quantizedAabbMax[1];
				m_SubtreeHeaders[i].m_quantizedAabbMax[2] = memPtr->m_quantizedAabbMax[2];
				m_SubtreeHeaders[i].m_quantizedAabbMin[0] = memPtr->m_quantizedAabbMin[0];
				m_SubtreeHeaders[i].m_quantizedAabbMin[1] = memPtr->m_quantizedAabbMin[1];
				m_SubtreeHeaders[i].m_quantizedAabbMin[2] = memPtr->m_quantizedAabbMin[2];
				m_SubtreeHeaders[i].m_rootNodeIndex = memPtr->m_rootNodeIndex;
				m_SubtreeHeaders[i].m_subtreeSize = memPtr->m_subtreeSize;
			}
		}
	}
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btQuantizedBvh::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btQuantizedBvhData* quantizedData = (btQuantizedBvhData*)dataBuffer;

	m_bvhAabbMax.serialize(quantizedData->m_bvhAabbMax);
	m_bvhAabbMin.serialize(quantizedData->m_bvhAabbMin);
	m_bvhQuantization.serialize(quantizedData->m_bvhQuantization);

	quantizedData->m_curNodeIndex = m_curNodeIndex;
	quantizedData->m_useQuantization = m_useQuantization;

	quantizedData->m_numContiguousLeafNodes = m_contiguousNodes.size();
	quantizedData->m_contiguousNodesPtr = (btOptimizedBvhNodeData*)(m_contiguousNodes.size() ? serializer->getUniquePointer((void*)&m_contiguousNodes[0]) : 0);
	if (quantizedData->m_contiguousNodesPtr)
	{
		int sz = sizeof(btOptimizedBvhNodeData);
		int numElem = m_contiguousNodes.size();
		btChunk* chunk = serializer->allocate(sz, numElem);
		btOptimizedBvhNodeData* memPtr = (btOptimizedBvhNodeData*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			m_contiguousNodes[i].m_aabbMaxOrg.serialize(memPtr->m_aabbMaxOrg);
			m_contiguousNodes[i].m_aabbMinOrg.serialize(memPtr->m_aabbMinOrg);
			memPtr->m_escapeIndex = m_contiguousNodes[i].m_escapeIndex;
			memPtr->m_subPart = m_contiguousNodes[i].m_subPart;
			memPtr->m_triangleIndex = m_contiguousNodes[i].m_triangleIndex;
			// Fill padding with zeros to appease msan.
			memset(memPtr->m_pad, 0, sizeof(memPtr->m_pad));
		}
		serializer->finalizeChunk(chunk, "btOptimizedBvhNodeData", BT_ARRAY_CODE, (void*)&m_contiguousNodes[0]);
	}

	quantizedData->m_numQuantizedContiguousNodes = m_quantizedContiguousNodes.size();
	//	printf("quantizedData->m_numQuantizedContiguousNodes=%d\n",quantizedData->m_numQuantizedContiguousNodes);
	quantizedData->m_quantizedContiguousNodesPtr = (btQuantizedBvhNodeData*)(m_quantizedContiguousNodes.size() ? serializer->getUniquePointer((void*)&m_quantizedContiguousNodes[0]) : 0);
	if (quantizedData->m_quantizedContiguousNodesPtr)
	{
		int sz = sizeof(btQuantizedBvhNodeData);
		int numElem = m_quantizedContiguousNodes.size();
		btChunk* chunk = serializer->allocate(sz, numElem);
		btQuantizedBvhNodeData* memPtr = (btQuantizedBvhNodeData*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			memPtr->m_escapeIndexOrTriangleIndex = m_quantizedContiguousNodes[i].m_escapeIndexOrTriangleIndex;
			memPtr->m_quantizedAabbMax[0] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[0];
			memPtr->m_quantizedAabbMax[1] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[1];
			memPtr->m_quantizedAabbMax[2] = m_quantizedContiguousNodes[i].m_quantizedAabbMax[2];
			memPtr->m_quantizedAabbMin[0] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[0];
			memPtr->m_quantizedAabbMin[1] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[1];
			memPtr->m_quantizedAabbMin[2] = m_quantizedContiguousNodes[i].m_quantizedAabbMin[2];
		}
		serializer->finalizeChunk(chunk, "btQuantizedBvhNodeData", BT_ARRAY_CODE, (void*)&m_quantizedContiguousNodes[0]);
	}

	quantizedData->m_traversalMode = int(m_traversalMode);
	quantizedData->m_numSubtreeHeaders = m_SubtreeHeaders.size();

	quantizedData->m_subTreeInfoPtr = (btBvhSubtreeInfoData*)(m_SubtreeHeaders.size() ? serializer->getUniquePointer((void*)&m_SubtreeHeaders[0]) : 0);
	if (quantizedData->m_subTreeInfoPtr)
	{
		int sz = sizeof(btBvhSubtreeInfoData);
		int numElem = m_SubtreeHeaders.size();
		btChunk* chunk = serializer->allocate(sz, numElem);
		btBvhSubtreeInfoData* memPtr = (btBvhSubtreeInfoData*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			memPtr->m_quantizedAabbMax[0] = m_SubtreeHeaders[i].m_quantizedAabbMax[0];
			memPtr->m_quantizedAabbMax[1] = m_SubtreeHeaders[i].m_quantizedAabbMax[1];
			memPtr->m_quantizedAabbMax[2] = m_SubtreeHeaders[i].m_quantizedAabbMax[2];
			memPtr->m_quantizedAabbMin[0] = m_SubtreeHeaders[i].m_quantizedAabbMin[0];
			memPtr->m_quantizedAabbMin[1] = m_SubtreeHeaders[i].m_quantizedAabbMin[1];
			memPtr->m_quantizedAabbMin[2] = m_SubtreeHeaders[i].m_quantizedAabbMin[2];

			memPtr->m_rootNodeIndex = m_SubtreeHeaders[i].m_rootNodeIndex;
			memPtr->m_subtreeSize = m_SubtreeHeaders[i].m_subtreeSize;
		}
		serializer->finalizeChunk(chunk, "btBvhSubtreeInfoData", BT_ARRAY_CODE, (void*)&m_SubtreeHeaders[0]);
	}
	return btQuantizedBvhDataName;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_QUANTIZED_BVH_H
#define BT_QUANTIZED_BVH_H

class btSerializer;

//#define DEBUG_CHECK_DEQUANTIZATION 1
#ifdef DEBUG_CHECK_DEQUANTIZATION
#ifdef __SPU__
#define printf spu_printf
#endif  //__SPU__

#endif  //DEBUG_CHECK_DEQUANTIZATION

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btQuantizedBvhData btQuantizedBvhDoubleData
#define btOptimizedBvhNodeData btOptimizedBvhNodeDoubleData
#define btQuantizedBvhDataName "btQuantizedBvhDoubleData"
#else
#define btQuantizedBvhData btQuantizedBvhFloatData
#define btOptimizedBvhNodeData btOptimizedBvhNodeFloatData
#define btQuantizedBvhDataName "btQuantizedBvhFloatData"
#endif

//http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/vclrf__m128.asp

//Note: currently we have 16 bytes per quantized node
#define MAX_SUBTREE_SIZE_IN_BYTES 2048

// 10 gives the potential for 1024 parts, with at most 2^21 (2097152) (minus one
// 4 gives the potential for 16 parts, each with 2^27 triangles (134217728)
// actually) triangles each (since the sign bit is reserved
//#define MAX_NUM_PARTS_IN_BITS 10
#define MAX_NUM_PARTS_IN_BITS 4

///btQuantizedBvhNode is a compressed aabb node, 16 bytes.
///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
ATTRIBUTE_ALIGNED16(struct)
btQuantizedBvhNode
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	//12 bytes
	unsigned short int m_quantizedAabbMin[3];
	unsigned short int m_quantizedAabbMax[3];
	//4 bytes
	int m_escapeIndexOrTriangleIndex;

	bool isLeafNode() const
	{
		//skipindex is negative (internal node), triangleindex >=0 (leafnode)
		return (m_escapeIndexOrTriangleIndex >= 0);
	}
	int getEscapeIndex() const
	{
		btAssert(!isLeafNode());
		return -m_escapeIndexOrTriangleIndex;
	}
	int getTriangleIndex() const
	{
		btAssert(isLeafNode());
		unsigned int x = 0;
		unsigned int y = (~(x & 0)) << (31 - MAX_NUM_PARTS_IN_BITS);
		// Get only the lower bits where the triangle index is stored
		return (m_escapeIndexOrTriangleIndex & ~(y));
	}
	int getPartId() const
	{
		btAssert(isLeafNode());
		// Get only the highest bits where the part index is stored
		return (m_escapeIndexOrTriangleIndex >> (31 - MAX_NUM_PARTS_IN_BITS));
	}
};

/// btOptimizedBvhNode contains both internal and leaf node information.
/// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
ATTRIBUTE_ALIGNED16(struct)
btOptimizedBvhNode
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	//32 bytes
	btVector3 m_aabbMinOrg;
	btVector3 m_aabbMaxOrg;

	//4
	int m_escapeIndex;

	//8
	//for child nodes
	int m_subPart;
	int m_triangleIndex;

	//pad the size to 64 bytes
	char m_padding[20];
};

///btBvhSubtreeInfo provides info to gather a subtree of limited size
ATTRIBUTE_ALIGNED16(class)
btBvhSubtreeInfo
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	//12 bytes
	unsigned short int m_quantizedAabbMin[3];
	unsigned short int m_quantizedAabbMax[3];
	//4 bytes, points to the root of the subtree
	int m_rootNodeIndex;
	//4 bytes
	int m_subtreeSize;
	int m_padding[3];

	btBvhSubtreeInfo()
	{
		//memset(&m_padding[0], 0, sizeof(m_padding));
	}

	void setAabbFromQuantizeNode(const btQuantizedBvhNode& quantizedNode)
	{
		m_quantizedAabbMin[0] = quantizedNode.m_quantizedAabbMin[0];
		m_quantizedAabbMin[1] = quantizedNode.m_quantizedAabbMin[1];
		m_quantizedAabbMin[2] = quantizedNode.m_quantizedAabbMin[2];
		m_quantizedAabbMax[0] = quantizedNode.m_quantizedAabbMax[0];
		m_quantizedAabbMax[1] = quantizedNode.m_quantizedAabbMax[1];
		m_quantizedAabbMax[2] = quantizedNode.m_quantizedAabbMax[2];
	}
};

class btNodeOverlapCallback
{
public:
	virtual ~btNodeOverlapCallback(){};

	virtual void processNode(int subPart, int triangleIndex) = 0;
};

#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btAlignedObjectArray.h"

///for code readability:
typedef btAlignedObjectArray<btOptimizedBvhNode> NodeArray;
typedef btAlignedObjectArray<btQuantizedBvhNode> QuantizedNodeArray;
typedef btAlignedObjectArray<btBvhSubtreeInfo> BvhSubtreeInfoArray;

///The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
///It is used by the btBvhTriangleMeshShape as midphase.
///It is recommended to use quantization for better performance and lower memory requirements.
ATTRIBUTE_ALIGNED16(class)
btQuantizedBvh
{
public:
	enum btTraversalMode
	{
		TRAVERSAL_STACKLESS = 0,
		TRAVERSAL_STACKLESS_CACHE_FRIENDLY,
		TRAVERSAL_RECURSIVE
	};

protected:
	btVector3 m_bvhAabbMin;
	btVector3 m_bvhAabbMax;
	btVector3 m_bvhQuantization;

	int m_bulletVersion;  //for serialization versioning. It could also be used to detect endianess.

	int m_curNodeIndex;
	//quantization data
	bool m_useQuantization;

	NodeArray m_leafNodes;
	NodeArray m_contiguousNodes;
	QuantizedNodeArray m_quantizedLeafNodes;
	QuantizedNodeArray m_quantizedContiguousNodes;

	btTraversalMode m_traversalMode;
	BvhSubtreeInfoArray m_SubtreeHeaders;

	//This is only used for serialization so we don't have to add serialization directly to btAlignedObjectArray
	mutable int m_subtreeHeaderCount;

	///two versions, one for quantized and normal nodes. This allows code-reuse while maintaining readability (no template/macro!)
	///this might be refactored into a virtual, it is usually not calculated at run-time
	void setInternalNodeAabbMin(int nodeIndex, const btVector3& aabbMin)
	{
		if (m_useQuantization)
		{
			quantize(&m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[0], aabbMin, 0);
		}
		else
		{
			m_contiguousNodes[nodeIndex].m_aabbMinOrg = aabbMin;
		}
	}
	void setInternalNodeAabbMax(int nodeIndex, const btVector3& aabbMax)
	{
		if (m_useQuantization)
		{
			quantize(&m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[0], aabbMax, 1);
		}
		else
		{
			m_contiguousNodes[nodeIndex].m_aabbMaxOrg = aabbMax;
		}
	}

	btVector3 getAabbMin(int nodeIndex) const
	{
		if (m_useQuantization)
		{
			return unQuantize(&m_quantizedLeafNodes[nodeIndex].m_quantizedAabbMin[0]);
		}
		//non-quantized
		return m_leafNodes[nodeIndex].m_aabbMinOrg;
	}
	btVector3 getAabbMax(int nodeIndex) const
	{
		if (m_useQuantization)
		{
			return unQuantize(&m_quantizedLeafNodes[nodeIndex].m_quantizedAabbMax[0]);
		}
		//non-quantized
		return m_leafNodes[nodeIndex].m_aabbMaxOrg;
	}

	void setInternalNodeEscapeIndex(int nodeIndex, int escapeIndex)
	{
		if (m_useQuantization)
		{
			m_quantizedContiguousNodes[nodeIndex].m_escapeIndexOrTriangleIndex = -escapeIndex;
		}
		else
		{
			m_contiguousNodes[nodeIndex].m_escapeIndex = escapeIndex;
		}
	}

	void mergeInternalNodeAabb(int nodeIndex, const btVector3& newAabbMin, const btVector3& newAabbMax)
	{
		if (m_useQuantization)
		{
			unsigned short int quantizedAabbMin[3];
			unsigned short int quantizedAabbMax[3];
			quantize(quantizedAabbMin, newAabbMin, 0);
			quantize(quantizedAabbMax, newAabbMax, 1);
			for (int i = 0; i < 3; i++)
			{
				if (m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[i] > quantizedAabbMin[i])
					m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMin[i] = quantizedAabbMin[i];

				if (m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[i] < quantizedAabbMax[i])
					m_quantizedContiguousNodes[nodeIndex].m_quantizedAabbMax[i] = quantizedAabbMax[i];
			}
		}
		else
		{
			//non-quantized
			m_contiguousNodes[nodeIndex].m_aabbMinOrg.setMin(newAabbMin);
			m_contiguousNodes[nodeIndex].m_aabbMaxOrg.setMax(newAabbMax);
		}
	}

	void swapLeafNodes(int firstIndex, int secondIndex);

	void assignInternalNodeFromLeafNode(int internalNode, int leafNodeIndex);

protected:
	void buildTree(int startIndex, int endIndex);

	int calcSplittingAxis(int startIndex, int endIndex);

	int sortAndCalcSplittingIndex(int startIndex, int endIndex, int splitAxis);

	void walkStacklessTree(btNodeOverlapCallback * nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const;

	void walkStacklessQuantizedTreeAgainstRay(btNodeOverlapCallback * nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const;
	void walkStacklessQuantizedTree(btNodeOverlapCallback * nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax, int startNodeIndex, int endNodeIndex) const;
	void walkStacklessTreeAgainstRay(btNodeOverlapCallback * nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax, int startNodeIndex, int endNodeIndex) const;

	///tree traversal designed for small-memory processors like PS3 SPU
	void walkStacklessQuantizedTreeCacheFriendly(btNodeOverlapCallback * nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const;

	///use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
	void walkRecursiveQuantizedTreeAgainstQueryAabb(const btQuantizedBvhNode* currentNode, btNodeOverlapCallback* nodeCallback, unsigned short int* quantizedQueryAabbMin, unsigned short int* quantizedQueryAabbMax) const;

	///use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
	void walkRecursiveQuantizedTreeAgainstQuantizedTree(const btQuantizedBvhNode* treeNodeA, const btQuantizedBvhNode* treeNodeB, btNodeOverlapCallback* nodeCallback) const;

	void updateSubtreeHeaders(int leftChildNodexIndex, int rightChildNodexIndex);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btQuantizedBvh();

	virtual ~btQuantizedBvh();

	///***************************************** expert/internal use only *************************
	void setQuantizationValues(const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, btScalar quantizationMargin = btScalar(1.0));
	QuantizedNodeArray& getLeafNodeArray() { return m_quantizedLeafNodes; }
	///buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized
	void buildInternal();
	///***************************************** expert/internal use only *************************

	void reportAabbOverlappingNodex(btNodeOverlapCallback * nodeCallback, const btVector3& aabbMin, const btVector3& aabbMax) const;
	void reportRayOverlappingNodex(btNodeOverlapCallback * nodeCallback, const btVector3& raySource, const btVector3& rayTarget) const;
	void reportBoxCastOverlappingNodex(btNodeOverlapCallback * nodeCallback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax) const;

	SIMD_FORCE_INLINE void quantize(unsigned short* out, const btVector3& point, int isMax) const
	{
		btAssert(m_useQuantization);

		btAssert(point.getX() <= m_bvhAabbMax.getX());
		btAssert(point.getY() <= m_bvhAabbMax.getY());
		btAssert(point.getZ() <= m_bvhAabbMax.getZ());

		btAssert(point.getX() >= m_bvhAabbMin.getX());
		btAssert(point.getY() >= m_bvhAabbMin.getY());
		btAssert(point.getZ() >= m_bvhAabbMin.getZ());

		btVector3 v = (point - m_bvhAabbMin) * m_bvhQuantization;
		///Make sure rounding is done in a way that unQuantize(quantizeWithClamp(...)) is conservative
		///end-points always set the first bit, so that they are sorted properly (so that neighbouring AABBs overlap properly)
		///@todo: double-check this
		if (isMax)
		{
			out[0] = (unsigned short)(((unsigned short)(v.getX() + btScalar(1.)) | 1));
			out[1] = (unsigned short)(((unsigned short)(v.getY() + btScalar(1.)) | 1));
			out[2] = (unsigned short)(((unsigned short)(v.getZ() + btScalar(1.)) | 1));
		}
		else
		{
			out[0] = (unsigned short)(((unsigned short)(v.getX()) & 0xfffe));
			out[1] = (unsigned short)(((unsigned short)(v.getY()) & 0xfffe));
			out[2] = (unsigned short)(((unsigned short)(v.getZ()) & 0xfffe));
		}

#ifdef DEBUG_CHECK_DEQUANTIZATION
		btVector3 newPoint = unQuantize(out);
		if (isMax)
		{
			if (newPoint.getX() < point.getX())
			{
				printf("unconservative X, diffX = %f, oldX=%f,newX=%f\n", newPoint.getX() - point.getX(), newPoint.getX(), point.getX());
			}
			if (newPoint.getY() < point.getY())
			{
				printf("unconservative Y, diffY = %f, oldY=%f,newY=%f\n", newPoint.getY() - point.getY(), newPoint.getY(), point.getY());
			}
			if (newPoint.getZ() < point.getZ())
			{
				printf("unconservative Z, diffZ = %f, oldZ=%f,newZ=%f\n", newPoint.getZ() - point.getZ(), newPoint.getZ(), point.getZ());
			}
		}
		else
		{
			if (newPoint.getX() > point.getX())
			{
				printf("unconservative X, diffX = %f, oldX=%f,newX=%f\n", newPoint.getX() - point.getX(), newPoint.getX(), point.getX());
			}
			if (newPoint.getY() > point.getY())
			{
				printf("unconservative Y, diffY = %f, oldY=%f,newY=%f\n", newPoint.getY() - point.getY(), newPoint.getY(), point.getY());
			}
			if (newPoint.getZ() > point.getZ())
			{
				printf("unconservative Z, diffZ = %f, oldZ=%f,newZ=%f\n", newPoint.getZ() - point.getZ(), newPoint.getZ(), point.getZ());
			}
		}
#endif  //DEBUG_CHECK_DEQUANTIZATION
	}

	SIMD_FORCE_INLINE void quantizeWithClamp(unsigned short* out, const btVector3& point2, int isMax) const
	{
		btAssert(m_useQuantization);

		btVector3 clampedPoint(point2);
		clampedPoint.setMax(m_bvhAabbMin);
		clampedPoint.setMin(m_bvhAabbMax);

		quantize(out, clampedPoint, isMax);
	}

	SIMD_FORCE_INLINE btVector3 unQuantize(const unsigned short* vecIn) const
	{
		btVector3 vecOut;
		vecOut.setValue(
			(btScalar)(vecIn[0]) / (m_bvhQuantization.getX()),
			(btScalar)(vecIn[1]) / (m_bvhQuantization.getY()),
			(btScalar)(vecIn[2]) / (m_bvhQuantization.getZ()));
		vecOut += m_bvhAabbMin;
		return vecOut;
	}

	///setTraversalMode let's you choose between stackless, recursive or stackless cache friendly tree traversal. Note this is only implemented for quantized trees.
	void setTraversalMode(btTraversalMode traversalMode)
	{
		m_traversalMode = traversalMode;
	}

	SIMD_FORCE_INLINE QuantizedNodeArray& getQuantizedNodeArray()
	{
		return m_quantizedContiguousNodes;
	}

	SIMD_FORCE_INLINE BvhSubtreeInfoArray& getSubtreeInfoArray()
	{
		return m_SubtreeHeaders;
	}

	////////////////////////////////////////////////////////////////////

	/////Calculate space needed to store BVH for serialization
	unsigned calculateSerializeBufferSize() const;

	/// Data buffer MUST be 16 byte aligned
	virtual bool serialize(void* o_alignedDataBuffer, unsigned i_dataBufferSize, bool i_swapEndian) const;

	///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
	static btQuantizedBvh* deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);

	static unsigned int getAlignmentSerializationPadding();
	//////////////////////////////////////////////////////////////////////

	virtual int calculateSerializeBufferSizeNew() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	virtual void deSerializeFloat(struct btQuantizedBvhFloatData & quantizedBvhFloatData);

	virtual void deSerializeDouble(struct btQuantizedBvhDoubleData & quantizedBvhDoubleData);

	////////////////////////////////////////////////////////////////////

	SIMD_FORCE_INLINE bool isQuantized()
	{
		return m_useQuantization;
	}

private:
	// Special "copy" constructor that allows for in-place deserialization
	// Prevents btVector3's default constructor from being called, but doesn't inialize much else
	// ownsMemory should most likely be false if deserializing, and if you are not, don't call this (it also changes the function signature, which we need)
	btQuantizedBvh(btQuantizedBvh & other, bool ownsMemory);
};

// clang-format off
// parser needs * with the name
struct btBvhSubtreeInfoData
{
	int m_rootNodeIndex;
	int m_subtreeSize;
	unsigned short m_quantizedAabbMin[3];
	unsigned short m_quantizedAabbMax[3];
};

struct btOptimizedBvhNodeFloatData
{
	btVector3FloatData m_aabbMinOrg;
	btVector3FloatData m_aabbMaxOrg;
	int m_escapeIndex;
	int m_subPart;
	int m_triangleIndex;
	char m_pad[4];
};

struct btOptimizedBvhNodeDoubleData
{
	btVector3DoubleData m_aabbMinOrg;
	btVector3DoubleData m_aabbMaxOrg;
	int m_escapeIndex;
	int m_subPart;
	int m_triangleIndex;
	char m_pad[4];
};


struct btQuantizedBvhNodeData
{
	unsigned short m_quantizedAabbMin[3];
	unsigned short m_quantizedAabbMax[3];
	int	m_escapeIndexOrTriangleIndex;
};

struct	btQuantizedBvhFloatData
{
	btVector3FloatData			m_bvhAabbMin;
	btVector3FloatData			m_bvhAabbMax;
	btVector3FloatData			m_bvhQuantization;
	int					m_curNodeIndex;
	int					m_useQuantization;
	int					m_numContiguousLeafNodes;
	int					m_numQuantizedContiguousNodes;
	btOptimizedBvhNodeFloatData	*m_contiguousNodesPtr;
	btQuantizedBvhNodeData		*m_quantizedContiguousNodesPtr;
	btBvhSubtreeInfoData	*m_subTreeInfoPtr;
	int					m_traversalMode;
	int					m_numSubtreeHeaders;
	
};

struct	btQuantizedBvhDoubleData
{
	btVector3DoubleData			m_bvhAabbMin;
	btVector3DoubleData			m_bvhAabbMax;
	btVector3DoubleData			m_bvhQuantization;
	int							m_curNodeIndex;
	int							m_useQuantization;
	int							m_numContiguousLeafNodes;
	int							m_numQuantizedContiguousNodes;
	btOptimizedBvhNodeDoubleData	*m_contiguousNodesPtr;
	btQuantizedBvhNodeData			*m_quantizedContiguousNodesPtr;

	int							m_traversalMode;
	int							m_numSubtreeHeaders;
	btBvhSubtreeInfoData		*m_subTreeInfoPtr;
};
// clang-format on

SIMD_FORCE_INLINE int btQuantizedBvh::calculateSerializeBufferSizeNew() const
{
	return sizeof(btQuantizedBvhData);
}

#endif  //BT_QUANTIZED_BVH_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btIDebugDraw.h"

btOptimizedBvh::btOptimizedBvh()
{
}

btOptimizedBvh::~btOptimizedBvh()
{
}

void btOptimizedBvh::build(btStridingMeshInterface* triangles, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax)
{
	m_useQuantization = useQuantizedAabbCompression;

	// NodeArray	triangleNodes;

	struct NodeTriangleCallback : public btInternalTriangleIndexCallback
	{
		NodeArray& m_triangleNodes;

		NodeTriangleCallback& operator=(NodeTriangleCallback& other)
		{
			m_triangleNodes.copyFromArray(other.m_triangleNodes);
			return *this;
		}

		NodeTriangleCallback(NodeArray& triangleNodes)
			: m_triangleNodes(triangleNodes)
		{
		}

		virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
		{
			btOptimizedBvhNode node;
			btVector3 aabbMin, aabbMax;
			aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
			aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
			aabbMin.setMin(triangle[0]);
			aabbMax.setMax(triangle[0]);
			aabbMin.setMin(triangle[1]);
			aabbMax.setMax(triangle[1]);
			aabbMin.setMin(triangle[2]);
			aabbMax.setMax(triangle[2]);

			//with quantization?
			node.m_aabbMinOrg = aabbMin;
			node.m_aabbMaxOrg = aabbMax;

			node.m_escapeIndex = -1;

			//for child nodes
			node.m_subPart = partId;
			node.m_triangleIndex = triangleIndex;
			m_triangleNodes.push_back(node);
		}
	};
	struct QuantizedNodeTriangleCallback : public btInternalTriangleIndexCallback
	{
		QuantizedNodeArray& m_triangleNodes;
		const btQuantizedBvh* m_optimizedTree;  // for quantization

		QuantizedNodeTriangleCallback& operator=(QuantizedNodeTriangleCallback& other)
		{
			m_triangleNodes.copyFromArray(other.m_triangleNodes);
			m_optimizedTree = other.m_optimizedTree;
			return *this;
		}

		QuantizedNodeTriangleCallback(QuantizedNodeArray& triangleNodes, const btQuantizedBvh* tree)
			: m_triangleNodes(triangleNodes), m_optimizedTree(tree)
		{
		}

		virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
		{
			// The partId and triangle index must fit in the same (positive) integer
			btAssert(partId < (1 << MAX_NUM_PARTS_IN_BITS));
			btAssert(triangleIndex < (1 << (31 - MAX_NUM_PARTS_IN_BITS)));
			//negative indices are reserved for escapeIndex
			btAssert(triangleIndex >= 0);

			btQuantizedBvhNode node;
			btVector3 aabbMin, aabbMax;
			aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
			aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
			aabbMin.setMin(triangle[0]);
			aabbMax.setMax(triangle[0]);
			aabbMin.setMin(triangle[1]);
			aabbMax.setMax(triangle[1]);
			aabbMin.setMin(triangle[2]);
			aabbMax.setMax(triangle[2]);

			//PCK: add these checks for zero dimensions of aabb
			const btScalar MIN_AABB_DIMENSION = btScalar(0.002);
			const btScalar MIN_AABB_HALF_DIMENSION = btScalar(0.001);
			if (aabbMax.x() - aabbMin.x() < MIN_AABB_DIMENSION)
			{
				aabbMax.setX(aabbMax.x() + MIN_AABB_HALF_DIMENSION);
				aabbMin.setX(aabbMin.x() - MIN_AABB_HALF_DIMENSION);
			}
			if (aabbMax.y() - aabbMin.y() < MIN_AABB_DIMENSION)
			{
				aabbMax.setY(aabbMax.y() + MIN_AABB_HALF_DIMENSION);
				aabbMin.setY(aabbMin.y() - MIN_AABB_HALF_DIMENSION);
			}
			if (aabbMax.z() - aabbMin.z() < MIN_AABB_DIMENSION)
			{
				aabbMax.setZ(aabbMax.z() + MIN_AABB_HALF_DIMENSION);
				aabbMin.setZ(aabbMin.z() - MIN_AABB_HALF_DIMENSION);
			}

			m_optimizedTree->quantize(&node.m_quantizedAabbMin[0], aabbMin, 0);
			m_optimizedTree->quantize(&node.m_quantizedAabbMax[0], aabbMax, 1);

			node.m_escapeIndexOrTriangleIndex = (partId << (31 - MAX_NUM_PARTS_IN_BITS)) | triangleIndex;

			m_triangleNodes.push_back(node);
		}
	};

	int numLeafNodes = 0;

	if (m_useQuantization)
	{
		//initialize quantization values
		setQuantizationValues(bvhAabbMin, bvhAabbMax);

		QuantizedNodeTriangleCallback callback(m_quantizedLeafNodes, this);

		triangles->InternalProcessAllTriangles(&callback, m_bvhAabbMin, m_bvhAabbMax);

		//now we have an array of leafnodes in m_leafNodes
		numLeafNodes = m_quantizedLeafNodes.size();

		m_quantizedContiguousNodes.resize(2 * numLeafNodes);
	}
	else
	{
		NodeTriangleCallback callback(m_leafNodes);

		btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
		btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));

		triangles->InternalProcessAllTriangles(&callback, aabbMin, aabbMax);

		//now we have an array of leafnodes in m_leafNodes
		numLeafNodes = m_leafNodes.size();

		m_contiguousNodes.resize(2 * numLeafNodes);
	}

	m_curNodeIndex = 0;

	buildTree(0, numLeafNodes);

	///if the entire tree is small then subtree size, we need to create a header info for the tree
	if (m_useQuantization && !m_SubtreeHeaders.size())
	{
		btBvhSubtreeInfo& subtree = m_SubtreeHeaders.expand();
		subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[0]);
		subtree.m_rootNodeIndex = 0;
		subtree.m_subtreeSize = m_quantizedContiguousNodes[0].isLeafNode() ? 1 : m_quantizedContiguousNodes[0].getEscapeIndex();
	}

	//PCK: update the copy of the size
	m_subtreeHeaderCount = m_SubtreeHeaders.size();

	//PCK: clear m_quantizedLeafNodes and m_leafNodes, they are temporary
	m_quantizedLeafNodes.clear();
	m_leafNodes.clear();
}

void btOptimizedBvh::refit(btStridingMeshInterface* meshInterface, const btVector3& aabbMin, const btVector3& aabbMax)
{
	if (m_useQuantization)
	{
		setQuantizationValues(aabbMin, aabbMax);

		updateBvhNodes(meshInterface, 0, m_curNodeIndex, 0);

		///now update all subtree headers

		int i;
		for (i = 0; i < m_SubtreeHeaders.size(); i++)
		{
			btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];
			subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[subtree.m_rootNodeIndex]);
		}
	}
	else
	{
	}
}

void btOptimizedBvh::refitPartial(btStridingMeshInterface* meshInterface, const btVector3& aabbMin, const btVector3& aabbMax)
{
	//incrementally initialize quantization values
	btAssert(m_useQuantization);

	btAssert(aabbMin.getX() > m_bvhAabbMin.getX());
	btAssert(aabbMin.getY() > m_bvhAabbMin.getY());
	btAssert(aabbMin.getZ() > m_bvhAabbMin.getZ());

	btAssert(aabbMax.getX() < m_bvhAabbMax.getX());
	btAssert(aabbMax.getY() < m_bvhAabbMax.getY());
	btAssert(aabbMax.getZ() < m_bvhAabbMax.getZ());

	///we should update all quantization values, using updateBvhNodes(meshInterface);
	///but we only update chunks that overlap the given aabb

	unsigned short quantizedQueryAabbMin[3];
	unsigned short quantizedQueryAabbMax[3];

	quantize(&quantizedQueryAabbMin[0], aabbMin, 0);
	quantize(&quantizedQueryAabbMax[0], aabbMax, 1);

	int i;
	for (i = 0; i < this->m_SubtreeHeaders.size(); i++)
	{
		btBvhSubtreeInfo& subtree = m_SubtreeHeaders[i];

		//PCK: unsigned instead of bool
		unsigned overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin, quantizedQueryAabbMax, subtree.m_quantizedAabbMin, subtree.m_quantizedAabbMax);
		if (overlap != 0)
		{
			updateBvhNodes(meshInterface, subtree.m_rootNodeIndex, subtree.m_rootNodeIndex + subtree.m_subtreeSize, i);

			subtree.setAabbFromQuantizeNode(m_quantizedContiguousNodes[subtree.m_rootNodeIndex]);
		}
	}
}

void btOptimizedBvh::updateBvhNodes(btStridingMeshInterface* meshInterface, int firstNode, int endNode, int index)
{
	(void)index;

	btAssert(m_useQuantization);

	int curNodeSubPart = -1;

	//get access info to trianglemesh data
	const unsigned char* vertexbase = 0;
	int numverts = 0;
	PHY_ScalarType type = PHY_INTEGER;
	int stride = 0;
	const unsigned char* indexbase = 0;
	int indexstride = 0;
	int numfaces = 0;
	PHY_ScalarType indicestype = PHY_INTEGER;

	btVector3 triangleVerts[3];
	btVector3 aabbMin, aabbMax;
	const btVector3& meshScaling = meshInterface->getScaling();

	int i;
	for (i = endNode - 1; i >= firstNode; i--)
	{
		btQuantizedBvhNode& curNode = m_quantizedContiguousNodes[i];
		if (curNode.isLeafNode())
		{
			//recalc aabb from triangle data
			int nodeSubPart = curNode.getPartId();
			int nodeTriangleIndex = curNode.getTriangleIndex();
			if (nodeSubPart != curNodeSubPart)
			{
				if (curNodeSubPart >= 0)
					meshInterface->unLockReadOnlyVertexBase(curNodeSubPart);
				meshInterface->getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numfaces, indicestype, nodeSubPart);

				curNodeSubPart = nodeSubPart;
			}
			//triangles->getLockedReadOnlyVertexIndexBase(vertexBase,numVerts,

			unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex * indexstride);

			for (int j = 2; j >= 0; j--)
			{
				int graphicsindex;
                                switch (indicestype) {
                                        case PHY_INTEGER: graphicsindex = gfxbase[j]; break;
                                        case PHY_SHORT: graphicsindex = ((unsigned short*)gfxbase)[j]; break;
                                        case PHY_UCHAR: graphicsindex = ((unsigned char*)gfxbase)[j]; break;
                                        default: btAssert(0);
                                }
				if (type == PHY_FLOAT)
				{
					float* graphicsbase = (float*)(vertexbase + graphicsindex * stride);
					triangleVerts[j] = btVector3(
						graphicsbase[0] * meshScaling.getX(),
						graphicsbase[1] * meshScaling.getY(),
						graphicsbase[2] * meshScaling.getZ());
				}
				else
				{
					double* graphicsbase = (double*)(vertexbase + graphicsindex * stride);
					triangleVerts[j] = btVector3(btScalar(graphicsbase[0] * meshScaling.getX()), btScalar(graphicsbase[1] * meshScaling.getY()), btScalar(graphicsbase[2] * meshScaling.getZ()));
				}
			}

			aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
			aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
			aabbMin.setMin(triangleVerts[0]);
			aabbMax.setMax(triangleVerts[0]);
			aabbMin.setMin(triangleVerts[1]);
			aabbMax.setMax(triangleVerts[1]);
			aabbMin.setMin(triangleVerts[2]);
			aabbMax.setMax(triangleVerts[2]);

			quantize(&curNode.m_quantizedAabbMin[0], aabbMin, 0);
			quantize(&curNode.m_quantizedAabbMax[0], aabbMax, 1);
		}
		else
		{
			//combine aabb from both children

			btQuantizedBvhNode* leftChildNode = &m_quantizedContiguousNodes[i + 1];

			btQuantizedBvhNode* rightChildNode = leftChildNode->isLeafNode() ? &m_quantizedContiguousNodes[i + 2] : &m_quantizedContiguousNodes[i + 1 + leftChildNode->getEscapeIndex()];

			{
				for (int i = 0; i < 3; i++)
				{
					curNode.m_quantizedAabbMin[i] = leftChildNode->m_quantizedAabbMin[i];
					if (curNode.m_quantizedAabbMin[i] > rightChildNode->m_quantizedAabbMin[i])
						curNode.m_quantizedAabbMin[i] = rightChildNode->m_quantizedAabbMin[i];

					curNode.m_quantizedAabbMax[i] = leftChildNode->m_quantizedAabbMax[i];
					if (curNode.m_quantizedAabbMax[i] < rightChildNode->m_quantizedAabbMax[i])
						curNode.m_quantizedAabbMax[i] = rightChildNode->m_quantizedAabbMax[i];
				}
			}
		}
	}

	if (curNodeSubPart >= 0)
		meshInterface->unLockReadOnlyVertexBase(curNodeSubPart);
}

///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
btOptimizedBvh* btOptimizedBvh::deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian)
{
	btQuantizedBvh* bvh = btQuantizedBvh::deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian);

	//we don't add additional data so just do a static upcast
	return static_cast<btOptimizedBvh*>(bvh);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///Contains contributions from Disney Studio's

#ifndef BT_OPTIMIZED_BVH_H
#define BT_OPTIMIZED_BVH_H

#include "BulletCollision/BroadphaseCollision/btQuantizedBvh.h"

class btStridingMeshInterface;

///The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
ATTRIBUTE_ALIGNED16(class)
btOptimizedBvh : public btQuantizedBvh
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

protected:
public:
	btOptimizedBvh();

	virtual ~btOptimizedBvh();

	void build(btStridingMeshInterface * triangles, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax);

	void refit(btStridingMeshInterface * triangles, const btVector3& aabbMin, const btVector3& aabbMax);

	void refitPartial(btStridingMeshInterface * triangles, const btVector3& aabbMin, const btVector3& aabbMax);

	void updateBvhNodes(btStridingMeshInterface * meshInterface, int firstNode, int endNode, int index);

	/// Data buffer MUST be 16 byte aligned
	virtual bool serializeInPlace(void* o_alignedDataBuffer, unsigned i_dataBufferSize, bool i_swapEndian) const
	{
		return btQuantizedBvh::serialize(o_alignedDataBuffer, i_dataBufferSize, i_swapEndian);
	}

	///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
	static btOptimizedBvh* deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);
};

#endif  //BT_OPTIMIZED_BVH_H





char sBulletDNAstr[]= {
char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-74),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(111),
char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(76),char(111),char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(66),char(91),char(52),char(93),char(0),
char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),
char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(78),char(111),char(114),char(109),
char(97),char(108),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),
char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(68),char(105),char(114),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),
char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(68),char(105),char(114),char(50),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(68),char(105),char(115),char(116),
char(97),char(110),char(99),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(114),char(101),char(118),char(82),char(72),char(83),char(91),char(52),char(93),
char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),
char(100),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(111),char(108),char(108),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(83),char(112),char(105),char(110),char(110),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),
char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),
char(97),char(114),char(116),char(73),char(100),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(80),char(97),char(114),char(116),char(73),char(100),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),
char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),
char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(111),char(105),char(110),
char(116),char(70),char(108),char(97),char(103),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),
char(114),char(97),char(108),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),char(114),char(97),
char(108),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),char(110),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),
char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),
char(110),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(67),char(70),char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(69),char(82),char(80),char(91),char(52),char(93),char(0),char(109),
char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(67),char(70),
char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(105),char(102),
char(101),char(84),char(105),char(109),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(97),char(99),char(104),char(101),char(100),
char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),
char(65),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(66),char(0),char(109),char(95),char(105),
char(110),char(100),char(101),char(120),char(49),char(97),char(0),char(109),char(95),char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),
char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(66),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),
char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(42),char(109),char(95),char(98),
char(111),char(100),char(121),char(48),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(49),char(0),char(109),char(95),char(103),char(105),char(109),char(112),
char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),
char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),
char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),
char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),
char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),
char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),
char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),
char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),
char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),
char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),
char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),
char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),
char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),
char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),
char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),
char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),
char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),
char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),
char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),
char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),
char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(105),char(108),
char(116),char(101),char(114),char(71),char(114),char(111),char(117),char(112),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(105),char(108),char(116),char(101),char(114),char(77),char(97),char(115),char(107),char(0),char(109),char(95),char(117),char(110),char(105),char(113),char(117),char(101),char(73),
char(100),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),char(114),char(111),char(114),char(82),
char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),char(95),char(101),char(114),char(112),
char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),char(67),char(102),char(109),char(0),
char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),char(110),char(101),char(116),char(114),
char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(115),char(112),char(108),
char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),char(115),char(116),char(97),char(114),
char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(114),char(116),char(105),char(99),char(117),char(108),
char(97),char(116),char(101),char(100),char(87),char(97),char(114),char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),
char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),
char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),
char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),
char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),
char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),
char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),
char(114),char(116),char(105),char(97),char(84),char(101),char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),
char(114),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),
char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),
char(97),char(108),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),
char(116),char(97),char(108),char(84),char(111),char(114),char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),
char(97),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),
char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),
char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),
char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),
char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),
char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),
char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),
char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),
char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(82),char(111),char(119),char(115),char(0),char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),
char(114),char(98),char(66),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),char(100),char(98),char(97),char(99),char(107),char(0),
char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(100),
char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),char(105),char(115),char(97),char(98),char(108),char(101),
char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),char(101),char(101),char(110),char(76),char(105),char(110),
char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),char(101),char(114),char(114),char(105),char(100),char(101),
char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(0),char(112),
char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),
char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),
char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),
char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),
char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),
char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),
char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),
char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),
char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),
char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),
char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),
char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),
char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),
char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),
char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),
char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),
char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),
char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),
char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),
char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(97),char(120),char(77),
char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),
char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),
char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),
char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),
char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),
char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),
char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),
char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),char(114),
char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),char(100),char(101),char(114),char(0),char(109),char(95),
char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(66),char(0),char(109),char(95),
char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),
char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),
char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),
char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),
char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),
char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),
char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),
char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),
char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),
char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),
char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),
char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),
char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),
char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),
char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),
char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),
char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),
char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),
char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),
char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),
char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),
char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),
char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),
char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),
char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),
char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),
char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),
char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),
char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),
char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),
char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),
char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),
char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),
char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),
char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),
char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),
char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),
char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),
char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),
char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),
char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),
char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),
char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),
char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),
char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),
char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),
char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),
char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),
char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),
char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),
char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),
char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(109),
char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),char(84),char(111),char(84),char(104),char(105),char(115),
char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),char(84),char(104),char(105),char(115),char(80),char(105),
char(118),char(111),char(116),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),char(80),char(105),char(118),char(111),
char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(106),
char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),
char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),
char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),
char(70),char(114),char(97),char(109),char(101),char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),
char(111),char(109),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),char(99),char(86),char(101),char(108),char(111),
char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),
char(99),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),char(111),char(109),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),
char(0),char(109),char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),
char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(84),char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
char(106),char(111),char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(77),char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),
char(95),char(108),char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),
char(100),char(105),char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(80),
char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(79),
char(114),char(105),char(101),char(110),char(116),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(76),char(105),char(110),
char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),
char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),
char(109),char(95),char(98),char(97),char(115),char(101),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),
char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(79),char(98),char(106),char(68),char(97),char(116),char(97),char(0),
char(42),char(109),char(95),char(109),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(107),char(0),
char(84),char(89),char(80),char(69),char(99),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),
char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),
char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),
char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),
char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),
char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),
char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),
char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),
char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),
char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),
char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),
char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),
char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),
char(112),char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),
char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),
char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),
char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),
char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),
char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),
char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),
char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),
char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),
char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),
char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(67),char(111),char(108),char(108),
char(105),char(100),char(101),char(114),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),
char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),
char(12),char(0),char(36),char(0),char(8),char(0),char(16),char(0),char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(84),char(0),char(-124),char(0),char(12),char(0),char(52),char(0),char(52),char(0),
char(20),char(0),char(64),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(32),char(0),char(28),char(0),char(60),char(0),char(56),char(0),
char(76),char(0),char(76),char(0),char(24),char(0),char(60),char(0),char(60),char(0),char(60),char(0),char(16),char(0),char(16),char(6),char(-24),char(1),char(72),char(3),
char(16),char(1),char(64),char(0),char(68),char(0),char(-96),char(0),char(88),char(0),char(-64),char(0),char(104),char(0),char(-8),char(1),char(-72),char(3),char(8),char(0),
char(52),char(0),char(52),char(0),char(0),char(0),char(68),char(0),char(84),char(0),char(-124),char(0),char(116),char(0),char(92),char(1),char(-36),char(0),char(-116),char(1),
char(124),char(1),char(-44),char(0),char(-4),char(0),char(-52),char(1),char(92),char(1),char(116),char(2),char(-124),char(2),char(-76),char(4),char(-52),char(0),char(108),char(1),
char(92),char(0),char(-116),char(0),char(16),char(0),char(100),char(0),char(20),char(0),char(36),char(0),char(100),char(0),char(92),char(0),char(104),char(0),char(-64),char(0),
char(92),char(1),char(104),char(0),char(-68),char(1),char(112),char(3),char(-56),char(1),char(-68),char(0),char(100),char(0),char(28),char(1),char(-12),char(1),char(0),char(0),
char(83),char(84),char(82),char(67),char(88),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),
char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),
char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(16),char(0),char(1),char(0),
char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),char(18),char(0),char(10),char(0),
char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(25),char(0),char(12),char(0),
char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(21),char(0),char(32),char(0),
char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(21),char(0),char(32),char(0),
char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(28),char(0),char(5),char(0),
char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(31),char(0),char(4),char(0),
char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(32),char(0),char(1),char(0),
char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(34),char(0),char(2),char(0),
char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),char(34),char(0),char(57),char(0),
char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(37),char(0),char(4),char(0),
char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(38),char(0),char(7),char(0),
char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),char(39),char(0),char(68),char(0),
char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(3),char(0),
char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),char(29),char(0),char(47),char(0),
char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),char(7),char(0),char(80),char(0),
char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),char(4),char(0),char(84),char(0),
char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),
char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),
char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(39),char(0),char(14),char(0),char(96),char(0),char(14),char(0),char(97),char(0),
char(14),char(0),char(98),char(0),char(14),char(0),char(99),char(0),char(14),char(0),char(100),char(0),char(14),char(0),char(101),char(0),char(14),char(0),char(102),char(0),
char(8),char(0),char(103),char(0),char(8),char(0),char(104),char(0),char(8),char(0),char(105),char(0),char(8),char(0),char(106),char(0),char(8),char(0),char(107),char(0),
char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),
char(8),char(0),char(118),char(0),char(8),char(0),char(119),char(0),char(8),char(0),char(120),char(0),char(8),char(0),char(121),char(0),char(8),char(0),char(122),char(0),
char(8),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(48),char(0),char(-124),char(0),char(48),char(0),char(-123),char(0),char(49),char(0),char(39),char(0),char(13),char(0),char(96),char(0),char(13),char(0),char(97),char(0),
char(13),char(0),char(98),char(0),char(13),char(0),char(99),char(0),char(13),char(0),char(100),char(0),char(13),char(0),char(101),char(0),char(13),char(0),char(102),char(0),
char(7),char(0),char(103),char(0),char(7),char(0),char(104),char(0),char(7),char(0),char(105),char(0),char(7),char(0),char(106),char(0),char(7),char(0),char(107),char(0),
char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),
char(7),char(0),char(118),char(0),char(7),char(0),char(119),char(0),char(7),char(0),char(120),char(0),char(7),char(0),char(121),char(0),char(7),char(0),char(122),char(0),
char(7),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(50),char(0),char(-124),char(0),char(50),char(0),char(-123),char(0),char(51),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),
char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(-122),char(0),char(52),char(0),char(5),char(0),char(29),char(0),char(47),char(0),
char(13),char(0),char(-121),char(0),char(14),char(0),char(-120),char(0),char(4),char(0),char(-119),char(0),char(0),char(0),char(-118),char(0),char(48),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(20),char(0),char(-114),char(0),
char(20),char(0),char(-113),char(0),char(14),char(0),char(-112),char(0),char(14),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),char(8),char(0),char(-125),char(0),
char(8),char(0),char(-109),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-107),char(0),char(8),char(0),char(-106),char(0),char(8),char(0),char(-105),char(0),
char(8),char(0),char(-104),char(0),char(8),char(0),char(-103),char(0),char(8),char(0),char(-102),char(0),char(8),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(50),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(-114),char(0),
char(19),char(0),char(-113),char(0),char(13),char(0),char(-112),char(0),char(13),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(7),char(0),char(-125),char(0),
char(7),char(0),char(-109),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-107),char(0),char(7),char(0),char(-106),char(0),char(7),char(0),char(-105),char(0),
char(7),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),char(7),char(0),char(-102),char(0),char(7),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(53),char(0),char(23),char(0),
char(8),char(0),char(-90),char(0),char(8),char(0),char(-89),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-88),char(0),char(8),char(0),char(-104),char(0),
char(8),char(0),char(-87),char(0),char(8),char(0),char(-86),char(0),char(8),char(0),char(-85),char(0),char(8),char(0),char(-84),char(0),char(8),char(0),char(-83),char(0),
char(8),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(-78),char(0),
char(8),char(0),char(-77),char(0),char(8),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),
char(4),char(0),char(-72),char(0),char(4),char(0),char(-71),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(22),char(0),char(7),char(0),char(-90),char(0),
char(7),char(0),char(-89),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-104),char(0),char(7),char(0),char(-87),char(0),
char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(7),char(0),char(-82),char(0),
char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-79),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
char(7),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(4),char(0),char(-72),char(0),
char(4),char(0),char(-71),char(0),char(55),char(0),char(2),char(0),char(53),char(0),char(-70),char(0),char(14),char(0),char(-69),char(0),char(56),char(0),char(2),char(0),
char(54),char(0),char(-70),char(0),char(13),char(0),char(-69),char(0),char(57),char(0),char(21),char(0),char(50),char(0),char(-68),char(0),char(17),char(0),char(-67),char(0),
char(13),char(0),char(-66),char(0),char(13),char(0),char(-65),char(0),char(13),char(0),char(-64),char(0),char(13),char(0),char(-63),char(0),char(13),char(0),char(-69),char(0),
char(13),char(0),char(-62),char(0),char(13),char(0),char(-61),char(0),char(13),char(0),char(-60),char(0),char(13),char(0),char(-59),char(0),char(7),char(0),char(-58),char(0),
char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
char(7),char(0),char(-52),char(0),char(7),char(0),char(-51),char(0),char(7),char(0),char(-50),char(0),char(4),char(0),char(-49),char(0),char(58),char(0),char(22),char(0),
char(48),char(0),char(-68),char(0),char(18),char(0),char(-67),char(0),char(14),char(0),char(-66),char(0),char(14),char(0),char(-65),char(0),char(14),char(0),char(-64),char(0),
char(14),char(0),char(-63),char(0),char(14),char(0),char(-69),char(0),char(14),char(0),char(-62),char(0),char(14),char(0),char(-61),char(0),char(14),char(0),char(-60),char(0),
char(14),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),char(8),char(0),char(-55),char(0),
char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),char(8),char(0),char(-52),char(0),char(8),char(0),char(-51),char(0),char(8),char(0),char(-50),char(0),
char(4),char(0),char(-49),char(0),char(0),char(0),char(37),char(0),char(59),char(0),char(2),char(0),char(4),char(0),char(-48),char(0),char(4),char(0),char(-47),char(0),
char(60),char(0),char(13),char(0),char(57),char(0),char(-46),char(0),char(57),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),
char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),
char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(61),char(0),char(13),char(0),
char(62),char(0),char(-46),char(0),char(62),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),
char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(63),char(0),char(14),char(0),char(58),char(0),char(-46),char(0),
char(58),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),
char(4),char(0),char(-42),char(0),char(8),char(0),char(-41),char(0),char(8),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),
char(8),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(0),char(0),char(-35),char(0),char(64),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),
char(13),char(0),char(-33),char(0),char(13),char(0),char(-32),char(0),char(65),char(0),char(3),char(0),char(63),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),
char(14),char(0),char(-32),char(0),char(66),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),char(14),char(0),char(-32),char(0),
char(67),char(0),char(13),char(0),char(61),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),
char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),
char(7),char(0),char(-23),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(68),char(0),char(13),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),
char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),
char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(69),char(0),char(14),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),
char(8),char(0),char(-26),char(0),char(8),char(0),char(-25),char(0),char(8),char(0),char(-24),char(0),char(8),char(0),char(-23),char(0),char(8),char(0),char(-22),char(0),
char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(0),char(0),char(-19),char(0),char(70),char(0),char(10),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(8),char(0),char(-18),char(0),char(8),char(0),char(-17),char(0),char(8),char(0),char(-16),char(0),
char(8),char(0),char(-22),char(0),char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(8),char(0),char(-89),char(0),char(71),char(0),char(11),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(7),char(0),char(-18),char(0),char(7),char(0),char(-17),char(0),
char(7),char(0),char(-16),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-89),char(0),
char(0),char(0),char(21),char(0),char(72),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),
char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(73),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),
char(14),char(0),char(-15),char(0),char(14),char(0),char(-14),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(74),char(0),char(5),char(0),char(72),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),
char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(75),char(0),char(5),char(0),char(73),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),
char(8),char(0),char(-7),char(0),char(8),char(0),char(-6),char(0),char(8),char(0),char(-5),char(0),char(76),char(0),char(41),char(0),char(61),char(0),char(-34),char(0),
char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-4),char(0),
char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),char(13),char(0),char(0),char(1),char(13),char(0),char(1),char(1),
char(13),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(13),char(0),char(5),char(1),char(13),char(0),char(6),char(1),
char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),
char(0),char(0),char(-19),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(13),char(0),char(12),char(1),char(13),char(0),char(13),char(1),
char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),char(13),char(0),char(17),char(1),char(13),char(0),char(18),char(1),
char(13),char(0),char(19),char(1),char(13),char(0),char(20),char(1),char(13),char(0),char(21),char(1),char(13),char(0),char(22),char(1),char(0),char(0),char(23),char(1),
char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),
char(77),char(0),char(41),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(14),char(0),char(-15),char(0),
char(14),char(0),char(-14),char(0),char(14),char(0),char(-4),char(0),char(14),char(0),char(-3),char(0),char(14),char(0),char(-2),char(0),char(14),char(0),char(-1),char(0),
char(14),char(0),char(0),char(1),char(14),char(0),char(1),char(1),char(14),char(0),char(2),char(1),char(14),char(0),char(3),char(1),char(14),char(0),char(4),char(1),
char(14),char(0),char(5),char(1),char(14),char(0),char(6),char(1),char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),
char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),char(0),char(0),char(-19),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),
char(14),char(0),char(12),char(1),char(14),char(0),char(13),char(1),char(14),char(0),char(14),char(1),char(14),char(0),char(15),char(1),char(14),char(0),char(16),char(1),
char(14),char(0),char(17),char(1),char(14),char(0),char(18),char(1),char(14),char(0),char(19),char(1),char(14),char(0),char(20),char(1),char(14),char(0),char(21),char(1),
char(14),char(0),char(22),char(1),char(0),char(0),char(23),char(1),char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),
char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),char(78),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),
char(19),char(0),char(-30),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),char(7),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(79),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),
char(20),char(0),char(-30),char(0),char(8),char(0),char(-15),char(0),char(8),char(0),char(-14),char(0),char(8),char(0),char(-13),char(0),char(8),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(80),char(0),char(5),char(0),char(60),char(0),char(-34),char(0),char(13),char(0),char(29),char(1),
char(13),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(0),char(0),char(37),char(0),char(81),char(0),char(4),char(0),char(63),char(0),char(-34),char(0),
char(14),char(0),char(29),char(1),char(14),char(0),char(30),char(1),char(8),char(0),char(31),char(1),char(82),char(0),char(4),char(0),char(7),char(0),char(32),char(1),
char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),char(4),char(0),char(79),char(0),char(83),char(0),char(10),char(0),char(82),char(0),char(35),char(1),
char(13),char(0),char(36),char(1),char(13),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(13),char(0),char(39),char(1),char(13),char(0),char(40),char(1),
char(7),char(0),char(-58),char(0),char(7),char(0),char(41),char(1),char(4),char(0),char(42),char(1),char(4),char(0),char(53),char(0),char(84),char(0),char(4),char(0),
char(82),char(0),char(35),char(1),char(4),char(0),char(43),char(1),char(7),char(0),char(44),char(1),char(4),char(0),char(45),char(1),char(85),char(0),char(4),char(0),
char(13),char(0),char(40),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(46),char(1),char(7),char(0),char(47),char(1),char(86),char(0),char(7),char(0),
char(13),char(0),char(48),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(49),char(1),char(7),char(0),char(50),char(1),char(7),char(0),char(51),char(1),
char(7),char(0),char(52),char(1),char(4),char(0),char(53),char(0),char(87),char(0),char(6),char(0),char(17),char(0),char(53),char(1),char(13),char(0),char(51),char(1),
char(13),char(0),char(54),char(1),char(62),char(0),char(55),char(1),char(4),char(0),char(56),char(1),char(7),char(0),char(52),char(1),char(88),char(0),char(26),char(0),
char(4),char(0),char(57),char(1),char(7),char(0),char(58),char(1),char(7),char(0),char(-89),char(0),char(7),char(0),char(59),char(1),char(7),char(0),char(60),char(1),
char(7),char(0),char(61),char(1),char(7),char(0),char(62),char(1),char(7),char(0),char(63),char(1),char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),
char(7),char(0),char(66),char(1),char(7),char(0),char(67),char(1),char(7),char(0),char(68),char(1),char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),
char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),char(7),char(0),char(74),char(1),char(7),char(0),char(75),char(1),
char(7),char(0),char(76),char(1),char(4),char(0),char(77),char(1),char(4),char(0),char(78),char(1),char(4),char(0),char(79),char(1),char(4),char(0),char(80),char(1),
char(4),char(0),char(-99),char(0),char(89),char(0),char(12),char(0),char(17),char(0),char(81),char(1),char(17),char(0),char(82),char(1),char(17),char(0),char(83),char(1),
char(13),char(0),char(84),char(1),char(13),char(0),char(85),char(1),char(7),char(0),char(86),char(1),char(4),char(0),char(87),char(1),char(4),char(0),char(88),char(1),
char(4),char(0),char(89),char(1),char(4),char(0),char(90),char(1),char(7),char(0),char(50),char(1),char(4),char(0),char(53),char(0),char(90),char(0),char(27),char(0),
char(19),char(0),char(91),char(1),char(17),char(0),char(92),char(1),char(17),char(0),char(93),char(1),char(13),char(0),char(84),char(1),char(13),char(0),char(94),char(1),
char(13),char(0),char(95),char(1),char(13),char(0),char(96),char(1),char(13),char(0),char(97),char(1),char(13),char(0),char(98),char(1),char(4),char(0),char(99),char(1),
char(7),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(103),char(1),char(7),char(0),char(104),char(1),
char(7),char(0),char(105),char(1),char(4),char(0),char(106),char(1),char(4),char(0),char(107),char(1),char(7),char(0),char(108),char(1),char(7),char(0),char(109),char(1),
char(7),char(0),char(110),char(1),char(7),char(0),char(111),char(1),char(7),char(0),char(112),char(1),char(7),char(0),char(113),char(1),char(4),char(0),char(114),char(1),
char(4),char(0),char(115),char(1),char(4),char(0),char(116),char(1),char(91),char(0),char(12),char(0),char(9),char(0),char(117),char(1),char(9),char(0),char(118),char(1),
char(13),char(0),char(119),char(1),char(7),char(0),char(120),char(1),char(7),char(0),char(-85),char(0),char(7),char(0),char(121),char(1),char(4),char(0),char(122),char(1),
char(13),char(0),char(123),char(1),char(4),char(0),char(124),char(1),char(4),char(0),char(125),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(53),char(0),
char(92),char(0),char(19),char(0),char(50),char(0),char(-68),char(0),char(89),char(0),char(127),char(1),char(82),char(0),char(-128),char(1),char(83),char(0),char(-127),char(1),
char(84),char(0),char(-126),char(1),char(85),char(0),char(-125),char(1),char(86),char(0),char(-124),char(1),char(87),char(0),char(-123),char(1),char(90),char(0),char(-122),char(1),
char(91),char(0),char(-121),char(1),char(4),char(0),char(-120),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(-119),char(1),char(4),char(0),char(-118),char(1),
char(4),char(0),char(-117),char(1),char(4),char(0),char(-116),char(1),char(4),char(0),char(-115),char(1),char(4),char(0),char(-114),char(1),char(88),char(0),char(-113),char(1),
char(93),char(0),char(28),char(0),char(16),char(0),char(-112),char(1),char(14),char(0),char(-111),char(1),char(14),char(0),char(-110),char(1),char(14),char(0),char(-109),char(1),
char(14),char(0),char(-108),char(1),char(14),char(0),char(-107),char(1),char(14),char(0),char(-106),char(1),char(14),char(0),char(-105),char(1),char(14),char(0),char(-104),char(1),
char(14),char(0),char(-103),char(1),char(8),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(-100),char(1),
char(4),char(0),char(-99),char(1),char(8),char(0),char(-98),char(1),char(8),char(0),char(-97),char(1),char(8),char(0),char(-96),char(1),char(8),char(0),char(-95),char(1),
char(8),char(0),char(-94),char(1),char(8),char(0),char(-93),char(1),char(8),char(0),char(-92),char(1),char(8),char(0),char(-91),char(1),char(8),char(0),char(-90),char(1),
char(0),char(0),char(-89),char(1),char(0),char(0),char(-88),char(1),char(48),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(94),char(0),char(28),char(0),
char(15),char(0),char(-112),char(1),char(13),char(0),char(-111),char(1),char(13),char(0),char(-110),char(1),char(13),char(0),char(-109),char(1),char(13),char(0),char(-108),char(1),
char(13),char(0),char(-107),char(1),char(13),char(0),char(-106),char(1),char(13),char(0),char(-105),char(1),char(13),char(0),char(-104),char(1),char(13),char(0),char(-103),char(1),
char(4),char(0),char(-100),char(1),char(7),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(7),char(0),char(-98),char(1),
char(7),char(0),char(-97),char(1),char(7),char(0),char(-96),char(1),char(4),char(0),char(-99),char(1),char(7),char(0),char(-95),char(1),char(7),char(0),char(-94),char(1),
char(7),char(0),char(-93),char(1),char(7),char(0),char(-92),char(1),char(7),char(0),char(-91),char(1),char(7),char(0),char(-90),char(1),char(0),char(0),char(-89),char(1),
char(0),char(0),char(-88),char(1),char(50),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(95),char(0),char(11),char(0),char(14),char(0),char(-85),char(1),
char(16),char(0),char(-84),char(1),char(14),char(0),char(-83),char(1),char(14),char(0),char(-82),char(1),char(14),char(0),char(-81),char(1),char(8),char(0),char(-80),char(1),
char(4),char(0),char(-119),char(1),char(0),char(0),char(37),char(0),char(0),char(0),char(-79),char(1),char(93),char(0),char(-126),char(1),char(48),char(0),char(-78),char(1),
char(96),char(0),char(10),char(0),char(13),char(0),char(-85),char(1),char(15),char(0),char(-84),char(1),char(13),char(0),char(-83),char(1),char(13),char(0),char(-82),char(1),
char(13),char(0),char(-81),char(1),char(7),char(0),char(-80),char(1),char(4),char(0),char(-119),char(1),char(0),char(0),char(-79),char(1),char(94),char(0),char(-126),char(1),
char(50),char(0),char(-78),char(1),char(97),char(0),char(4),char(0),char(50),char(0),char(-77),char(1),char(96),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),char(98),char(0),char(4),char(0),char(48),char(0),char(-77),char(1),char(95),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),};
int sBulletDNAlen= sizeof(sBulletDNAstr);





char sBulletDNAstr64[]= {
char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-74),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(111),
char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(76),char(111),char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(66),char(91),char(52),char(93),char(0),
char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),
char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(78),char(111),char(114),char(109),
char(97),char(108),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),
char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(68),char(105),char(114),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),
char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(68),char(105),char(114),char(50),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(68),char(105),char(115),char(116),
char(97),char(110),char(99),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(114),char(101),char(118),char(82),char(72),char(83),char(91),char(52),char(93),
char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),
char(100),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(111),char(108),char(108),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(83),char(112),char(105),char(110),char(110),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),
char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),
char(97),char(114),char(116),char(73),char(100),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(80),char(97),char(114),char(116),char(73),char(100),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),
char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),
char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(111),char(105),char(110),
char(116),char(70),char(108),char(97),char(103),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),
char(114),char(97),char(108),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),char(114),char(97),
char(108),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),char(110),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),
char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),
char(110),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(67),char(70),char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(69),char(82),char(80),char(91),char(52),char(93),char(0),char(109),
char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(67),char(70),
char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(105),char(102),
char(101),char(84),char(105),char(109),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(97),char(99),char(104),char(101),char(100),
char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),
char(65),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(66),char(0),char(109),char(95),char(105),
char(110),char(100),char(101),char(120),char(49),char(97),char(0),char(109),char(95),char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),
char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(66),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),
char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(42),char(109),char(95),char(98),
char(111),char(100),char(121),char(48),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(49),char(0),char(109),char(95),char(103),char(105),char(109),char(112),
char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),
char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),
char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),
char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),
char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),
char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),
char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),
char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),
char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),
char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),
char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),
char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),
char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),
char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),
char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),
char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),
char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),
char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),
char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),
char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),
char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(105),char(108),
char(116),char(101),char(114),char(71),char(114),char(111),char(117),char(112),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(105),char(108),char(116),char(101),char(114),char(77),char(97),char(115),char(107),char(0),char(109),char(95),char(117),char(110),char(105),char(113),char(117),char(101),char(73),
char(100),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),char(114),char(111),char(114),char(82),
char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),char(95),char(101),char(114),char(112),
char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),char(67),char(102),char(109),char(0),
char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),char(110),char(101),char(116),char(114),
char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(115),char(112),char(108),
char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),char(115),char(116),char(97),char(114),
char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(114),char(116),char(105),char(99),char(117),char(108),
char(97),char(116),char(101),char(100),char(87),char(97),char(114),char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),
char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),
char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),
char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),
char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),
char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),
char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),
char(114),char(116),char(105),char(97),char(84),char(101),char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),
char(114),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),
char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),
char(97),char(108),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),
char(116),char(97),char(108),char(84),char(111),char(114),char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),
char(97),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),
char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),
char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),
char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),
char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),
char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),
char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),
char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),
char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(82),char(111),char(119),char(115),char(0),char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),
char(114),char(98),char(66),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),char(100),char(98),char(97),char(99),char(107),char(0),
char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(100),
char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),char(105),char(115),char(97),char(98),char(108),char(101),
char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),char(101),char(101),char(110),char(76),char(105),char(110),
char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),char(101),char(114),char(114),char(105),char(100),char(101),
char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(0),char(112),
char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),
char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),
char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),
char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),
char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),
char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),
char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),
char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),
char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),
char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),
char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),
char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),
char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),
char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),
char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),
char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),
char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),
char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),
char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),
char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(97),char(120),char(77),
char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),
char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),
char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),
char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),
char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),
char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),
char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),
char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),char(114),
char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),char(100),char(101),char(114),char(0),char(109),char(95),
char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(66),char(0),char(109),char(95),
char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),
char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),
char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),
char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),
char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),
char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),
char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),
char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),
char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),
char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),
char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),
char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),
char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),
char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),
char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),
char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),
char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),
char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),
char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),
char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),
char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),
char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),
char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),
char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),
char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),
char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),
char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),
char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),
char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),
char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),
char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),
char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),
char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),
char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),
char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),
char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),
char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),
char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),
char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),
char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),
char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),
char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),
char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),
char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),
char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),
char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),
char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),
char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),
char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),
char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),
char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),
char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(109),
char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),char(84),char(111),char(84),char(104),char(105),char(115),
char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),char(84),char(104),char(105),char(115),char(80),char(105),
char(118),char(111),char(116),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),char(80),char(105),char(118),char(111),
char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(106),
char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),
char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),
char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),
char(70),char(114),char(97),char(109),char(101),char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),
char(111),char(109),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),char(99),char(86),char(101),char(108),char(111),
char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),
char(99),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),char(111),char(109),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),
char(0),char(109),char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),
char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(84),char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
char(106),char(111),char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(77),char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),
char(95),char(108),char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),
char(100),char(105),char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(80),
char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(79),
char(114),char(105),char(101),char(110),char(116),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(76),char(105),char(110),
char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),
char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),
char(109),char(95),char(98),char(97),char(115),char(101),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),
char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(79),char(98),char(106),char(68),char(97),char(116),char(97),char(0),
char(42),char(109),char(95),char(109),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(107),char(0),
char(84),char(89),char(80),char(69),char(99),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),
char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),
char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),
char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),
char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),
char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),
char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),
char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),
char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),
char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),
char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),
char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),
char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),
char(112),char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),
char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),
char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),
char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),
char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),
char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),
char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),
char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),
char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),
char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),
char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(67),char(111),char(108),char(108),
char(105),char(100),char(101),char(114),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),
char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),
char(16),char(0),char(48),char(0),char(16),char(0),char(16),char(0),char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(96),char(0),char(-112),char(0),char(16),char(0),char(56),char(0),char(56),char(0),
char(20),char(0),char(72),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(56),char(0),char(32),char(0),char(80),char(0),char(72),char(0),
char(96),char(0),char(80),char(0),char(32),char(0),char(64),char(0),char(64),char(0),char(64),char(0),char(16),char(0),char(24),char(6),char(-8),char(1),char(80),char(3),
char(32),char(1),char(72),char(0),char(80),char(0),char(-96),char(0),char(88),char(0),char(-64),char(0),char(104),char(0),char(8),char(2),char(-56),char(3),char(8),char(0),
char(64),char(0),char(64),char(0),char(0),char(0),char(80),char(0),char(96),char(0),char(-112),char(0),char(-128),char(0),char(104),char(1),char(-24),char(0),char(-104),char(1),
char(-120),char(1),char(-32),char(0),char(8),char(1),char(-40),char(1),char(104),char(1),char(-128),char(2),char(-112),char(2),char(-64),char(4),char(-40),char(0),char(120),char(1),
char(104),char(0),char(-104),char(0),char(16),char(0),char(104),char(0),char(24),char(0),char(40),char(0),char(104),char(0),char(96),char(0),char(104),char(0),char(-56),char(0),
char(104),char(1),char(112),char(0),char(-16),char(1),char(-128),char(3),char(-40),char(1),char(-56),char(0),char(112),char(0),char(48),char(1),char(8),char(2),char(0),char(0),
char(83),char(84),char(82),char(67),char(88),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),
char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),
char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(16),char(0),char(1),char(0),
char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),char(18),char(0),char(10),char(0),
char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(25),char(0),char(12),char(0),
char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(21),char(0),char(32),char(0),
char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(21),char(0),char(32),char(0),
char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(28),char(0),char(5),char(0),
char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(31),char(0),char(4),char(0),
char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(32),char(0),char(1),char(0),
char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(34),char(0),char(2),char(0),
char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),char(34),char(0),char(57),char(0),
char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(37),char(0),char(4),char(0),
char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(38),char(0),char(7),char(0),
char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),char(39),char(0),char(68),char(0),
char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(3),char(0),
char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),char(29),char(0),char(47),char(0),
char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),char(7),char(0),char(80),char(0),
char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),char(4),char(0),char(84),char(0),
char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),
char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),
char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(39),char(0),char(14),char(0),char(96),char(0),char(14),char(0),char(97),char(0),
char(14),char(0),char(98),char(0),char(14),char(0),char(99),char(0),char(14),char(0),char(100),char(0),char(14),char(0),char(101),char(0),char(14),char(0),char(102),char(0),
char(8),char(0),char(103),char(0),char(8),char(0),char(104),char(0),char(8),char(0),char(105),char(0),char(8),char(0),char(106),char(0),char(8),char(0),char(107),char(0),
char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),
char(8),char(0),char(118),char(0),char(8),char(0),char(119),char(0),char(8),char(0),char(120),char(0),char(8),char(0),char(121),char(0),char(8),char(0),char(122),char(0),
char(8),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(48),char(0),char(-124),char(0),char(48),char(0),char(-123),char(0),char(49),char(0),char(39),char(0),char(13),char(0),char(96),char(0),char(13),char(0),char(97),char(0),
char(13),char(0),char(98),char(0),char(13),char(0),char(99),char(0),char(13),char(0),char(100),char(0),char(13),char(0),char(101),char(0),char(13),char(0),char(102),char(0),
char(7),char(0),char(103),char(0),char(7),char(0),char(104),char(0),char(7),char(0),char(105),char(0),char(7),char(0),char(106),char(0),char(7),char(0),char(107),char(0),
char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),
char(7),char(0),char(118),char(0),char(7),char(0),char(119),char(0),char(7),char(0),char(120),char(0),char(7),char(0),char(121),char(0),char(7),char(0),char(122),char(0),
char(7),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(50),char(0),char(-124),char(0),char(50),char(0),char(-123),char(0),char(51),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),
char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(-122),char(0),char(52),char(0),char(5),char(0),char(29),char(0),char(47),char(0),
char(13),char(0),char(-121),char(0),char(14),char(0),char(-120),char(0),char(4),char(0),char(-119),char(0),char(0),char(0),char(-118),char(0),char(48),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(20),char(0),char(-114),char(0),
char(20),char(0),char(-113),char(0),char(14),char(0),char(-112),char(0),char(14),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),char(8),char(0),char(-125),char(0),
char(8),char(0),char(-109),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-107),char(0),char(8),char(0),char(-106),char(0),char(8),char(0),char(-105),char(0),
char(8),char(0),char(-104),char(0),char(8),char(0),char(-103),char(0),char(8),char(0),char(-102),char(0),char(8),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(50),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(-114),char(0),
char(19),char(0),char(-113),char(0),char(13),char(0),char(-112),char(0),char(13),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(7),char(0),char(-125),char(0),
char(7),char(0),char(-109),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-107),char(0),char(7),char(0),char(-106),char(0),char(7),char(0),char(-105),char(0),
char(7),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),char(7),char(0),char(-102),char(0),char(7),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(53),char(0),char(23),char(0),
char(8),char(0),char(-90),char(0),char(8),char(0),char(-89),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-88),char(0),char(8),char(0),char(-104),char(0),
char(8),char(0),char(-87),char(0),char(8),char(0),char(-86),char(0),char(8),char(0),char(-85),char(0),char(8),char(0),char(-84),char(0),char(8),char(0),char(-83),char(0),
char(8),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(-78),char(0),
char(8),char(0),char(-77),char(0),char(8),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),
char(4),char(0),char(-72),char(0),char(4),char(0),char(-71),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(22),char(0),char(7),char(0),char(-90),char(0),
char(7),char(0),char(-89),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-104),char(0),char(7),char(0),char(-87),char(0),
char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(7),char(0),char(-82),char(0),
char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-79),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
char(7),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(4),char(0),char(-72),char(0),
char(4),char(0),char(-71),char(0),char(55),char(0),char(2),char(0),char(53),char(0),char(-70),char(0),char(14),char(0),char(-69),char(0),char(56),char(0),char(2),char(0),
char(54),char(0),char(-70),char(0),char(13),char(0),char(-69),char(0),char(57),char(0),char(21),char(0),char(50),char(0),char(-68),char(0),char(17),char(0),char(-67),char(0),
char(13),char(0),char(-66),char(0),char(13),char(0),char(-65),char(0),char(13),char(0),char(-64),char(0),char(13),char(0),char(-63),char(0),char(13),char(0),char(-69),char(0),
char(13),char(0),char(-62),char(0),char(13),char(0),char(-61),char(0),char(13),char(0),char(-60),char(0),char(13),char(0),char(-59),char(0),char(7),char(0),char(-58),char(0),
char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
char(7),char(0),char(-52),char(0),char(7),char(0),char(-51),char(0),char(7),char(0),char(-50),char(0),char(4),char(0),char(-49),char(0),char(58),char(0),char(22),char(0),
char(48),char(0),char(-68),char(0),char(18),char(0),char(-67),char(0),char(14),char(0),char(-66),char(0),char(14),char(0),char(-65),char(0),char(14),char(0),char(-64),char(0),
char(14),char(0),char(-63),char(0),char(14),char(0),char(-69),char(0),char(14),char(0),char(-62),char(0),char(14),char(0),char(-61),char(0),char(14),char(0),char(-60),char(0),
char(14),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),char(8),char(0),char(-55),char(0),
char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),char(8),char(0),char(-52),char(0),char(8),char(0),char(-51),char(0),char(8),char(0),char(-50),char(0),
char(4),char(0),char(-49),char(0),char(0),char(0),char(37),char(0),char(59),char(0),char(2),char(0),char(4),char(0),char(-48),char(0),char(4),char(0),char(-47),char(0),
char(60),char(0),char(13),char(0),char(57),char(0),char(-46),char(0),char(57),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),
char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),
char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(61),char(0),char(13),char(0),
char(62),char(0),char(-46),char(0),char(62),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),
char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(63),char(0),char(14),char(0),char(58),char(0),char(-46),char(0),
char(58),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),
char(4),char(0),char(-42),char(0),char(8),char(0),char(-41),char(0),char(8),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),
char(8),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(0),char(0),char(-35),char(0),char(64),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),
char(13),char(0),char(-33),char(0),char(13),char(0),char(-32),char(0),char(65),char(0),char(3),char(0),char(63),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),
char(14),char(0),char(-32),char(0),char(66),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),char(14),char(0),char(-32),char(0),
char(67),char(0),char(13),char(0),char(61),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),
char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),
char(7),char(0),char(-23),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(68),char(0),char(13),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),
char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),
char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(69),char(0),char(14),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),
char(8),char(0),char(-26),char(0),char(8),char(0),char(-25),char(0),char(8),char(0),char(-24),char(0),char(8),char(0),char(-23),char(0),char(8),char(0),char(-22),char(0),
char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(0),char(0),char(-19),char(0),char(70),char(0),char(10),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(8),char(0),char(-18),char(0),char(8),char(0),char(-17),char(0),char(8),char(0),char(-16),char(0),
char(8),char(0),char(-22),char(0),char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(8),char(0),char(-89),char(0),char(71),char(0),char(11),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(7),char(0),char(-18),char(0),char(7),char(0),char(-17),char(0),
char(7),char(0),char(-16),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-89),char(0),
char(0),char(0),char(21),char(0),char(72),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),
char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(73),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),
char(14),char(0),char(-15),char(0),char(14),char(0),char(-14),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(74),char(0),char(5),char(0),char(72),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),
char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(75),char(0),char(5),char(0),char(73),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),
char(8),char(0),char(-7),char(0),char(8),char(0),char(-6),char(0),char(8),char(0),char(-5),char(0),char(76),char(0),char(41),char(0),char(61),char(0),char(-34),char(0),
char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-4),char(0),
char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),char(13),char(0),char(0),char(1),char(13),char(0),char(1),char(1),
char(13),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(13),char(0),char(5),char(1),char(13),char(0),char(6),char(1),
char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),
char(0),char(0),char(-19),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(13),char(0),char(12),char(1),char(13),char(0),char(13),char(1),
char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),char(13),char(0),char(17),char(1),char(13),char(0),char(18),char(1),
char(13),char(0),char(19),char(1),char(13),char(0),char(20),char(1),char(13),char(0),char(21),char(1),char(13),char(0),char(22),char(1),char(0),char(0),char(23),char(1),
char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),
char(77),char(0),char(41),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(14),char(0),char(-15),char(0),
char(14),char(0),char(-14),char(0),char(14),char(0),char(-4),char(0),char(14),char(0),char(-3),char(0),char(14),char(0),char(-2),char(0),char(14),char(0),char(-1),char(0),
char(14),char(0),char(0),char(1),char(14),char(0),char(1),char(1),char(14),char(0),char(2),char(1),char(14),char(0),char(3),char(1),char(14),char(0),char(4),char(1),
char(14),char(0),char(5),char(1),char(14),char(0),char(6),char(1),char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),
char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),char(0),char(0),char(-19),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),
char(14),char(0),char(12),char(1),char(14),char(0),char(13),char(1),char(14),char(0),char(14),char(1),char(14),char(0),char(15),char(1),char(14),char(0),char(16),char(1),
char(14),char(0),char(17),char(1),char(14),char(0),char(18),char(1),char(14),char(0),char(19),char(1),char(14),char(0),char(20),char(1),char(14),char(0),char(21),char(1),
char(14),char(0),char(22),char(1),char(0),char(0),char(23),char(1),char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),
char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),char(78),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),
char(19),char(0),char(-30),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),char(7),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(79),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),
char(20),char(0),char(-30),char(0),char(8),char(0),char(-15),char(0),char(8),char(0),char(-14),char(0),char(8),char(0),char(-13),char(0),char(8),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(80),char(0),char(5),char(0),char(60),char(0),char(-34),char(0),char(13),char(0),char(29),char(1),
char(13),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(0),char(0),char(37),char(0),char(81),char(0),char(4),char(0),char(63),char(0),char(-34),char(0),
char(14),char(0),char(29),char(1),char(14),char(0),char(30),char(1),char(8),char(0),char(31),char(1),char(82),char(0),char(4),char(0),char(7),char(0),char(32),char(1),
char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),char(4),char(0),char(79),char(0),char(83),char(0),char(10),char(0),char(82),char(0),char(35),char(1),
char(13),char(0),char(36),char(1),char(13),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(13),char(0),char(39),char(1),char(13),char(0),char(40),char(1),
char(7),char(0),char(-58),char(0),char(7),char(0),char(41),char(1),char(4),char(0),char(42),char(1),char(4),char(0),char(53),char(0),char(84),char(0),char(4),char(0),
char(82),char(0),char(35),char(1),char(4),char(0),char(43),char(1),char(7),char(0),char(44),char(1),char(4),char(0),char(45),char(1),char(85),char(0),char(4),char(0),
char(13),char(0),char(40),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(46),char(1),char(7),char(0),char(47),char(1),char(86),char(0),char(7),char(0),
char(13),char(0),char(48),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(49),char(1),char(7),char(0),char(50),char(1),char(7),char(0),char(51),char(1),
char(7),char(0),char(52),char(1),char(4),char(0),char(53),char(0),char(87),char(0),char(6),char(0),char(17),char(0),char(53),char(1),char(13),char(0),char(51),char(1),
char(13),char(0),char(54),char(1),char(62),char(0),char(55),char(1),char(4),char(0),char(56),char(1),char(7),char(0),char(52),char(1),char(88),char(0),char(26),char(0),
char(4),char(0),char(57),char(1),char(7),char(0),char(58),char(1),char(7),char(0),char(-89),char(0),char(7),char(0),char(59),char(1),char(7),char(0),char(60),char(1),
char(7),char(0),char(61),char(1),char(7),char(0),char(62),char(1),char(7),char(0),char(63),char(1),char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),
char(7),char(0),char(66),char(1),char(7),char(0),char(67),char(1),char(7),char(0),char(68),char(1),char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),
char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),char(7),char(0),char(74),char(1),char(7),char(0),char(75),char(1),
char(7),char(0),char(76),char(1),char(4),char(0),char(77),char(1),char(4),char(0),char(78),char(1),char(4),char(0),char(79),char(1),char(4),char(0),char(80),char(1),
char(4),char(0),char(-99),char(0),char(89),char(0),char(12),char(0),char(17),char(0),char(81),char(1),char(17),char(0),char(82),char(1),char(17),char(0),char(83),char(1),
char(13),char(0),char(84),char(1),char(13),char(0),char(85),char(1),char(7),char(0),char(86),char(1),char(4),char(0),char(87),char(1),char(4),char(0),char(88),char(1),
char(4),char(0),char(89),char(1),char(4),char(0),char(90),char(1),char(7),char(0),char(50),char(1),char(4),char(0),char(53),char(0),char(90),char(0),char(27),char(0),
char(19),char(0),char(91),char(1),char(17),char(0),char(92),char(1),char(17),char(0),char(93),char(1),char(13),char(0),char(84),char(1),char(13),char(0),char(94),char(1),
char(13),char(0),char(95),char(1),char(13),char(0),char(96),char(1),char(13),char(0),char(97),char(1),char(13),char(0),char(98),char(1),char(4),char(0),char(99),char(1),
char(7),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(103),char(1),char(7),char(0),char(104),char(1),
char(7),char(0),char(105),char(1),char(4),char(0),char(106),char(1),char(4),char(0),char(107),char(1),char(7),char(0),char(108),char(1),char(7),char(0),char(109),char(1),
char(7),char(0),char(110),char(1),char(7),char(0),char(111),char(1),char(7),char(0),char(112),char(1),char(7),char(0),char(113),char(1),char(4),char(0),char(114),char(1),
char(4),char(0),char(115),char(1),char(4),char(0),char(116),char(1),char(91),char(0),char(12),char(0),char(9),char(0),char(117),char(1),char(9),char(0),char(118),char(1),
char(13),char(0),char(119),char(1),char(7),char(0),char(120),char(1),char(7),char(0),char(-85),char(0),char(7),char(0),char(121),char(1),char(4),char(0),char(122),char(1),
char(13),char(0),char(123),char(1),char(4),char(0),char(124),char(1),char(4),char(0),char(125),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(53),char(0),
char(92),char(0),char(19),char(0),char(50),char(0),char(-68),char(0),char(89),char(0),char(127),char(1),char(82),char(0),char(-128),char(1),char(83),char(0),char(-127),char(1),
char(84),char(0),char(-126),char(1),char(85),char(0),char(-125),char(1),char(86),char(0),char(-124),char(1),char(87),char(0),char(-123),char(1),char(90),char(0),char(-122),char(1),
char(91),char(0),char(-121),char(1),char(4),char(0),char(-120),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(-119),char(1),char(4),char(0),char(-118),char(1),
char(4),char(0),char(-117),char(1),char(4),char(0),char(-116),char(1),char(4),char(0),char(-115),char(1),char(4),char(0),char(-114),char(1),char(88),char(0),char(-113),char(1),
char(93),char(0),char(28),char(0),char(16),char(0),char(-112),char(1),char(14),char(0),char(-111),char(1),char(14),char(0),char(-110),char(1),char(14),char(0),char(-109),char(1),
char(14),char(0),char(-108),char(1),char(14),char(0),char(-107),char(1),char(14),char(0),char(-106),char(1),char(14),char(0),char(-105),char(1),char(14),char(0),char(-104),char(1),
char(14),char(0),char(-103),char(1),char(8),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(-100),char(1),
char(4),char(0),char(-99),char(1),char(8),char(0),char(-98),char(1),char(8),char(0),char(-97),char(1),char(8),char(0),char(-96),char(1),char(8),char(0),char(-95),char(1),
char(8),char(0),char(-94),char(1),char(8),char(0),char(-93),char(1),char(8),char(0),char(-92),char(1),char(8),char(0),char(-91),char(1),char(8),char(0),char(-90),char(1),
char(0),char(0),char(-89),char(1),char(0),char(0),char(-88),char(1),char(48),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(94),char(0),char(28),char(0),
char(15),char(0),char(-112),char(1),char(13),char(0),char(-111),char(1),char(13),char(0),char(-110),char(1),char(13),char(0),char(-109),char(1),char(13),char(0),char(-108),char(1),
char(13),char(0),char(-107),char(1),char(13),char(0),char(-106),char(1),char(13),char(0),char(-105),char(1),char(13),char(0),char(-104),char(1),char(13),char(0),char(-103),char(1),
char(4),char(0),char(-100),char(1),char(7),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(7),char(0),char(-98),char(1),
char(7),char(0),char(-97),char(1),char(7),char(0),char(-96),char(1),char(4),char(0),char(-99),char(1),char(7),char(0),char(-95),char(1),char(7),char(0),char(-94),char(1),
char(7),char(0),char(-93),char(1),char(7),char(0),char(-92),char(1),char(7),char(0),char(-91),char(1),char(7),char(0),char(-90),char(1),char(0),char(0),char(-89),char(1),
char(0),char(0),char(-88),char(1),char(50),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(95),char(0),char(11),char(0),char(14),char(0),char(-85),char(1),
char(16),char(0),char(-84),char(1),char(14),char(0),char(-83),char(1),char(14),char(0),char(-82),char(1),char(14),char(0),char(-81),char(1),char(8),char(0),char(-80),char(1),
char(4),char(0),char(-119),char(1),char(0),char(0),char(37),char(0),char(0),char(0),char(-79),char(1),char(93),char(0),char(-126),char(1),char(48),char(0),char(-78),char(1),
char(96),char(0),char(10),char(0),char(13),char(0),char(-85),char(1),char(15),char(0),char(-84),char(1),char(13),char(0),char(-83),char(1),char(13),char(0),char(-82),char(1),
char(13),char(0),char(-81),char(1),char(7),char(0),char(-80),char(1),char(4),char(0),char(-119),char(1),char(0),char(0),char(-79),char(1),char(94),char(0),char(-126),char(1),
char(50),char(0),char(-78),char(1),char(97),char(0),char(4),char(0),char(50),char(0),char(-77),char(1),char(96),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),char(98),char(0),char(4),char(0),char(48),char(0),char(-77),char(1),char(95),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),};
int sBulletDNAlen64= sizeof(sBulletDNAstr64);





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SERIALIZER_H
#define BT_SERIALIZER_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btHashMap.h"

#if !defined(__CELLOS_LV2__) && !defined(__MWERKS__)
#endif

extern char sBulletDNAstr[];
extern int sBulletDNAlen;
extern char sBulletDNAstr64[];
extern int sBulletDNAlen64;

SIMD_FORCE_INLINE int btStrLen(const char* str)
{
	if (!str)
		return (0);
	int len = 0;

	while (*str != 0)
	{
		str++;
		len++;
	}

	return len;
}

class btChunk
{
public:
	int m_chunkCode;
	int m_length;
	void* m_oldPtr;
	int m_dna_nr;
	int m_number;
};

enum btSerializationFlags
{
	BT_SERIALIZE_NO_BVH = 1,
	BT_SERIALIZE_NO_TRIANGLEINFOMAP = 2,
	BT_SERIALIZE_NO_DUPLICATE_ASSERT = 4,
	BT_SERIALIZE_CONTACT_MANIFOLDS = 8,
};

class btSerializer
{
public:
	virtual ~btSerializer() {}

	virtual const unsigned char* getBufferPointer() const = 0;

	virtual int getCurrentBufferSize() const = 0;

	virtual btChunk* allocate(size_t size, int numElements) = 0;

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr) = 0;

	virtual void* findPointer(void* oldPtr) = 0;

	virtual void* getUniquePointer(void* oldPtr) = 0;

	virtual void startSerialization() = 0;

	virtual void finishSerialization() = 0;

	virtual const char* findNameForPointer(const void* ptr) const = 0;

	virtual void registerNameForPointer(const void* ptr, const char* name) = 0;

	virtual void serializeName(const char* ptr) = 0;

	virtual int getSerializationFlags() const = 0;

	virtual void setSerializationFlags(int flags) = 0;

	virtual int getNumChunks() const = 0;

	virtual const btChunk* getChunk(int chunkIndex) const = 0;
};

#define BT_HEADER_LENGTH 12
#if defined(__sgi) || defined(__sparc) || defined(__sparc__) || defined(__PPC__) || defined(__ppc__) || defined(__BIG_ENDIAN__)
#define BT_MAKE_ID(a, b, c, d) ((int)(a) << 24 | (int)(b) << 16 | (c) << 8 | (d))
#else
#define BT_MAKE_ID(a, b, c, d) ((int)(d) << 24 | (int)(c) << 16 | (b) << 8 | (a))
#endif

#define BT_MULTIBODY_CODE BT_MAKE_ID('M', 'B', 'D', 'Y')
#define BT_MB_LINKCOLLIDER_CODE BT_MAKE_ID('M', 'B', 'L', 'C')
#define BT_SOFTBODY_CODE BT_MAKE_ID('S', 'B', 'D', 'Y')
#define BT_COLLISIONOBJECT_CODE BT_MAKE_ID('C', 'O', 'B', 'J')
#define BT_RIGIDBODY_CODE BT_MAKE_ID('R', 'B', 'D', 'Y')
#define BT_CONSTRAINT_CODE BT_MAKE_ID('C', 'O', 'N', 'S')
#define BT_BOXSHAPE_CODE BT_MAKE_ID('B', 'O', 'X', 'S')
#define BT_QUANTIZED_BVH_CODE BT_MAKE_ID('Q', 'B', 'V', 'H')
#define BT_TRIANLGE_INFO_MAP BT_MAKE_ID('T', 'M', 'A', 'P')
#define BT_SHAPE_CODE BT_MAKE_ID('S', 'H', 'A', 'P')
#define BT_ARRAY_CODE BT_MAKE_ID('A', 'R', 'A', 'Y')
#define BT_SBMATERIAL_CODE BT_MAKE_ID('S', 'B', 'M', 'T')
#define BT_SBNODE_CODE BT_MAKE_ID('S', 'B', 'N', 'D')
#define BT_DYNAMICSWORLD_CODE BT_MAKE_ID('D', 'W', 'L', 'D')
#define BT_CONTACTMANIFOLD_CODE BT_MAKE_ID('C', 'O', 'N', 'T')
#define BT_DNA_CODE BT_MAKE_ID('D', 'N', 'A', '1')

struct btPointerUid
{
	union {
		void* m_ptr;
		int m_uniqueIds[2];
	};
};

struct btBulletSerializedArrays
{
	btBulletSerializedArrays()
	{
	}
	btAlignedObjectArray<struct btQuantizedBvhDoubleData*> m_bvhsDouble;
	btAlignedObjectArray<struct btQuantizedBvhFloatData*> m_bvhsFloat;
	btAlignedObjectArray<struct btCollisionShapeData*> m_colShapeData;
	btAlignedObjectArray<struct btDynamicsWorldDoubleData*> m_dynamicWorldInfoDataDouble;
	btAlignedObjectArray<struct btDynamicsWorldFloatData*> m_dynamicWorldInfoDataFloat;
	btAlignedObjectArray<struct btRigidBodyDoubleData*> m_rigidBodyDataDouble;
	btAlignedObjectArray<struct btRigidBodyFloatData*> m_rigidBodyDataFloat;
	btAlignedObjectArray<struct btCollisionObjectDoubleData*> m_collisionObjectDataDouble;
	btAlignedObjectArray<struct btCollisionObjectFloatData*> m_collisionObjectDataFloat;
	btAlignedObjectArray<struct btTypedConstraintFloatData*> m_constraintDataFloat;
	btAlignedObjectArray<struct btTypedConstraintDoubleData*> m_constraintDataDouble;
	btAlignedObjectArray<struct btTypedConstraintData*> m_constraintData;  //for backwards compatibility
	btAlignedObjectArray<struct btSoftBodyFloatData*> m_softBodyFloatData;
	btAlignedObjectArray<struct btSoftBodyDoubleData*> m_softBodyDoubleData;
};

///The btDefaultSerializer is the main Bullet serialization class.
///The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
class btDefaultSerializer : public btSerializer
{
protected:
	btAlignedObjectArray<char*> mTypes;
	btAlignedObjectArray<short*> mStructs;
	btAlignedObjectArray<short> mTlens;
	btHashMap<btHashInt, int> mStructReverse;
	btHashMap<btHashString, int> mTypeLookup;

	btHashMap<btHashPtr, void*> m_chunkP;

	btHashMap<btHashPtr, const char*> m_nameMap;

	btHashMap<btHashPtr, btPointerUid> m_uniquePointers;
	int m_uniqueIdGenerator;

	int m_totalSize;
	unsigned char* m_buffer;
	bool m_ownsBuffer;
	int m_currentSize;
	void* m_dna;
	int m_dnaLength;

	int m_serializationFlags;

	btAlignedObjectArray<btChunk*> m_chunkPtrs;

protected:
	virtual void* findPointer(void* oldPtr)
	{
		void** ptr = m_chunkP.find(oldPtr);
		if (ptr && *ptr)
			return *ptr;
		return 0;
	}

	virtual void writeDNA()
	{
		btChunk* dnaChunk = allocate(m_dnaLength, 1);
		memcpy(dnaChunk->m_oldPtr, m_dna, m_dnaLength);
		finalizeChunk(dnaChunk, "DNA1", BT_DNA_CODE, m_dna);
	}

	int getReverseType(const char* type) const
	{
		btHashString key(type);
		const int* valuePtr = mTypeLookup.find(key);
		if (valuePtr)
			return *valuePtr;

		return -1;
	}

	void initDNA(const char* bdnaOrg, int dnalen)
	{
		///was already initialized
		if (m_dna)
			return;

		int littleEndian = 1;
		littleEndian = ((char*)&littleEndian)[0];

		m_dna = btAlignedAlloc(dnalen, 16);
		memcpy(m_dna, bdnaOrg, dnalen);
		m_dnaLength = dnalen;

		int* intPtr = 0;
		short* shtPtr = 0;
		char* cp = 0;
		int dataLen = 0;
		intPtr = (int*)m_dna;

		/*
				SDNA (4 bytes) (magic number)
				NAME (4 bytes)
				<nr> (4 bytes) amount of names (int)
				<string>
				<string>
			*/

		if (strncmp((const char*)m_dna, "SDNA", 4) == 0)
		{
			// skip ++ NAME
			intPtr++;
			intPtr++;
		}

		// Parse names
		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);

		dataLen = *intPtr;

		intPtr++;

		cp = (char*)intPtr;
		int i;
		for (i = 0; i < dataLen; i++)
		{
			while (*cp) cp++;
			cp++;
		}
		cp = btAlignPointer(cp, 4);

		/*
				TYPE (4 bytes)
				<nr> amount of types (int)
				<string>
				<string>
			*/

		intPtr = (int*)cp;
		btAssert(strncmp(cp, "TYPE", 4) == 0);
		intPtr++;

		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);

		dataLen = *intPtr;
		intPtr++;

		cp = (char*)intPtr;
		for (i = 0; i < dataLen; i++)
		{
			mTypes.push_back(cp);
			while (*cp) cp++;
			cp++;
		}

		cp = btAlignPointer(cp, 4);

		/*
				TLEN (4 bytes)
				<len> (short) the lengths of types
				<len>
			*/

		// Parse type lens
		intPtr = (int*)cp;
		btAssert(strncmp(cp, "TLEN", 4) == 0);
		intPtr++;

		dataLen = (int)mTypes.size();

		shtPtr = (short*)intPtr;
		for (i = 0; i < dataLen; i++, shtPtr++)
		{
			if (!littleEndian)
				shtPtr[0] = btSwapEndian(shtPtr[0]);
			mTlens.push_back(shtPtr[0]);
		}

		if (dataLen & 1) shtPtr++;

		/*
				STRC (4 bytes)
				<nr> amount of structs (int)
				<typenr>
				<nr_of_elems>
				<typenr>
				<namenr>
				<typenr>
				<namenr>
			*/

		intPtr = (int*)shtPtr;
		cp = (char*)intPtr;
		btAssert(strncmp(cp, "STRC", 4) == 0);
		intPtr++;

		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);
		dataLen = *intPtr;
		intPtr++;

		shtPtr = (short*)intPtr;
		for (i = 0; i < dataLen; i++)
		{
			mStructs.push_back(shtPtr);

			if (!littleEndian)
			{
				shtPtr[0] = btSwapEndian(shtPtr[0]);
				shtPtr[1] = btSwapEndian(shtPtr[1]);

				int len = shtPtr[1];
				shtPtr += 2;

				for (int a = 0; a < len; a++, shtPtr += 2)
				{
					shtPtr[0] = btSwapEndian(shtPtr[0]);
					shtPtr[1] = btSwapEndian(shtPtr[1]);
				}
			}
			else
			{
				shtPtr += (2 * shtPtr[1]) + 2;
			}
		}

		// build reverse lookups
		for (i = 0; i < (int)mStructs.size(); i++)
		{
			short* strc = mStructs.at(i);
			mStructReverse.insert(strc[0], i);
			mTypeLookup.insert(btHashString(mTypes[strc[0]]), i);
		}
	}

public:
	btHashMap<btHashPtr, void*> m_skipPointers;

	btDefaultSerializer(int totalSize = 0, unsigned char* buffer = 0)
		: m_uniqueIdGenerator(0),
		  m_totalSize(totalSize),
		  m_currentSize(0),
		  m_dna(0),
		  m_dnaLength(0),
		  m_serializationFlags(0)
	{
		if (buffer == 0)
		{
			m_buffer = m_totalSize ? (unsigned char*)btAlignedAlloc(totalSize, 16) : 0;
			m_ownsBuffer = true;
		}
		else
		{
			m_buffer = buffer;
			m_ownsBuffer = false;
		}

		const bool VOID_IS_8 = ((sizeof(void*) == 8));

#ifdef BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
		if (VOID_IS_8)
		{
#if _WIN64
			initDNA((const char*)sBulletDNAstr64, sBulletDNAlen64);
#else
			btAssert(0);
#endif
		}
		else
		{
#ifndef _WIN64
			initDNA((const char*)sBulletDNAstr, sBulletDNAlen);
#else
			btAssert(0);
#endif
		}

#else   //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
		if (VOID_IS_8)
		{
			initDNA((const char*)sBulletDNAstr64, sBulletDNAlen64);
		}
		else
		{
			initDNA((const char*)sBulletDNAstr, sBulletDNAlen);
		}
#endif  //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
	}

	virtual ~btDefaultSerializer()
	{
		if (m_buffer && m_ownsBuffer)
			btAlignedFree(m_buffer);
		if (m_dna)
			btAlignedFree(m_dna);
	}

	static int getMemoryDnaSizeInBytes()
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));

		if (VOID_IS_8)
		{
			return sBulletDNAlen64;
		}
		return sBulletDNAlen;
	}
	static const char* getMemoryDna()
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));
		if (VOID_IS_8)
		{
			return (const char*)sBulletDNAstr64;
		}
		return (const char*)sBulletDNAstr;
	}

	void insertHeader()
	{
		writeHeader(m_buffer);
		m_currentSize += BT_HEADER_LENGTH;
	}

	void writeHeader(unsigned char* buffer) const
	{
#ifdef BT_USE_DOUBLE_PRECISION
		memcpy(buffer, "BULLETd", 7);
#else
		memcpy(buffer, "BULLETf", 7);
#endif  //BT_USE_DOUBLE_PRECISION

		int littleEndian = 1;
		littleEndian = ((char*)&littleEndian)[0];

		if (sizeof(void*) == 8)
		{
			buffer[7] = '-';
		}
		else
		{
			buffer[7] = '_';
		}

		if (littleEndian)
		{
			buffer[8] = 'v';
		}
		else
		{
			buffer[8] = 'V';
		}

		buffer[9] = '3';
		buffer[10] = '2';
		buffer[11] = '6';
	}

	virtual void startSerialization()
	{
		m_uniqueIdGenerator = 1;
		if (m_totalSize)
		{
			unsigned char* buffer = internalAlloc(BT_HEADER_LENGTH);
			writeHeader(buffer);
		}
	}

	virtual void finishSerialization()
	{
		writeDNA();

		//if we didn't pre-allocate a buffer, we need to create a contiguous buffer now
		if (!m_totalSize)
		{
			if (m_buffer)
				btAlignedFree(m_buffer);

			m_currentSize += BT_HEADER_LENGTH;
			m_buffer = (unsigned char*)btAlignedAlloc(m_currentSize, 16);

			unsigned char* currentPtr = m_buffer;
			writeHeader(m_buffer);
			currentPtr += BT_HEADER_LENGTH;
			for (int i = 0; i < m_chunkPtrs.size(); i++)
			{
				int curLength = (int)sizeof(btChunk) + m_chunkPtrs[i]->m_length;
				memcpy(currentPtr, m_chunkPtrs[i], curLength);
				btAlignedFree(m_chunkPtrs[i]);
				currentPtr += curLength;
			}
		}

		mTypes.clear();
		mStructs.clear();
		mTlens.clear();
		mStructReverse.clear();
		mTypeLookup.clear();
		m_skipPointers.clear();
		m_chunkP.clear();
		m_nameMap.clear();
		m_uniquePointers.clear();
		m_chunkPtrs.clear();
	}

	virtual void* getUniquePointer(void* oldPtr)
	{
		btAssert(m_uniqueIdGenerator >= 0);
		if (!oldPtr)
			return 0;

		btPointerUid* uptr = (btPointerUid*)m_uniquePointers.find(oldPtr);
		if (uptr)
		{
			return uptr->m_ptr;
		}

		void** ptr2 = m_skipPointers[oldPtr];
		if (ptr2)
		{
			return 0;
		}

		m_uniqueIdGenerator++;

		btPointerUid uid;
		uid.m_uniqueIds[0] = m_uniqueIdGenerator;
		uid.m_uniqueIds[1] = m_uniqueIdGenerator;
		m_uniquePointers.insert(oldPtr, uid);
		return uid.m_ptr;
	}

	virtual const unsigned char* getBufferPointer() const
	{
		return m_buffer;
	}

	virtual int getCurrentBufferSize() const
	{
		return m_currentSize;
	}

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr)
	{
		if (!(m_serializationFlags & BT_SERIALIZE_NO_DUPLICATE_ASSERT))
		{
			btAssert(!findPointer(oldPtr));
		}

		chunk->m_dna_nr = getReverseType(structType);

		chunk->m_chunkCode = chunkCode;

		void* uniquePtr = getUniquePointer(oldPtr);

		m_chunkP.insert(oldPtr, uniquePtr);  //chunk->m_oldPtr);
		chunk->m_oldPtr = uniquePtr;         //oldPtr;
	}

	virtual unsigned char* internalAlloc(size_t size)
	{
		unsigned char* ptr = 0;

		if (m_totalSize)
		{
			ptr = m_buffer + m_currentSize;
			m_currentSize += int(size);
			btAssert(m_currentSize < m_totalSize);
		}
		else
		{
			ptr = (unsigned char*)btAlignedAlloc(size, 16);
			m_currentSize += int(size);
		}
		return ptr;
	}

	virtual btChunk* allocate(size_t size, int numElements)
	{
		unsigned char* ptr = internalAlloc(int(size) * numElements + sizeof(btChunk));

		unsigned char* data = ptr + sizeof(btChunk);

		btChunk* chunk = (btChunk*)ptr;
		chunk->m_chunkCode = 0;
		chunk->m_oldPtr = data;
		chunk->m_length = int(size) * numElements;
		chunk->m_number = numElements;

		m_chunkPtrs.push_back(chunk);

		return chunk;
	}

	virtual const char* findNameForPointer(const void* ptr) const
	{
		const char* const* namePtr = m_nameMap.find(ptr);
		if (namePtr && *namePtr)
			return *namePtr;
		return 0;
	}

	virtual void registerNameForPointer(const void* ptr, const char* name)
	{
		m_nameMap.insert(ptr, name);
	}

	virtual void serializeName(const char* name)
	{
		if (name)
		{
			//don't serialize name twice
			if (findPointer((void*)name))
				return;

			int len = btStrLen(name);
			if (len)
			{
				int newLen = len + 1;
				int padding = ((newLen + 3) & ~3) - newLen;
				newLen += padding;

				//serialize name string now
				btChunk* chunk = allocate(sizeof(char), newLen);
				char* destinationName = (char*)chunk->m_oldPtr;
				for (int i = 0; i < len; i++)
				{
					destinationName[i] = name[i];
				}
				destinationName[len] = 0;
				finalizeChunk(chunk, "char", BT_ARRAY_CODE, (void*)name);
			}
		}
	}

	virtual int getSerializationFlags() const
	{
		return m_serializationFlags;
	}

	virtual void setSerializationFlags(int flags)
	{
		m_serializationFlags = flags;
	}
	int getNumChunks() const
	{
		return m_chunkPtrs.size();
	}

	const btChunk* getChunk(int chunkIndex) const
	{
		return m_chunkPtrs[chunkIndex];
	}
};

///In general it is best to use btDefaultSerializer,
///in particular when writing the data to disk or sending it over the network.
///The btInMemorySerializer is experimental and only suitable in a few cases.
///The btInMemorySerializer takes a shortcut and can be useful to create a deep-copy
///of objects. There will be a demo on how to use the btInMemorySerializer.
#ifdef ENABLE_INMEMORY_SERIALIZER

struct btInMemorySerializer : public btDefaultSerializer
{
	btHashMap<btHashPtr, btChunk*> m_uid2ChunkPtr;
	btHashMap<btHashPtr, void*> m_orgPtr2UniqueDataPtr;
	btHashMap<btHashString, const void*> m_names2Ptr;

	btBulletSerializedArrays m_arrays;

	btInMemorySerializer(int totalSize = 0, unsigned char* buffer = 0)
		: btDefaultSerializer(totalSize, buffer)
	{
	}

	virtual void startSerialization()
	{
		m_uid2ChunkPtr.clear();
		//todo: m_arrays.clear();
		btDefaultSerializer::startSerialization();
	}

	btChunk* findChunkFromUniquePointer(void* uniquePointer)
	{
		btChunk** chkPtr = m_uid2ChunkPtr[uniquePointer];
		if (chkPtr)
		{
			return *chkPtr;
		}
		return 0;
	}

	virtual void registerNameForPointer(const void* ptr, const char* name)
	{
		btDefaultSerializer::registerNameForPointer(ptr, name);
		m_names2Ptr.insert(name, ptr);
	}

	virtual void finishSerialization()
	{
	}

	virtual void* getUniquePointer(void* oldPtr)
	{
		if (oldPtr == 0)
			return 0;

		// void* uniquePtr = getUniquePointer(oldPtr);
		btChunk* chunk = findChunkFromUniquePointer(oldPtr);
		if (chunk)
		{
			return chunk->m_oldPtr;
		}
		else
		{
			const char* n = (const char*)oldPtr;
			const void** ptr = m_names2Ptr[n];
			if (ptr)
			{
				return oldPtr;
			}
			else
			{
				void** ptr2 = m_skipPointers[oldPtr];
				if (ptr2)
				{
					return 0;
				}
				else
				{
					//If this assert hit, serialization happened in the wrong order
					// 'getUniquePointer'
					btAssert(0);
				}
			}
			return 0;
		}
		return oldPtr;
	}

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr)
	{
		if (!(m_serializationFlags & BT_SERIALIZE_NO_DUPLICATE_ASSERT))
		{
			btAssert(!findPointer(oldPtr));
		}

		chunk->m_dna_nr = getReverseType(structType);
		chunk->m_chunkCode = chunkCode;
		//void* uniquePtr = getUniquePointer(oldPtr);
		m_chunkP.insert(oldPtr, oldPtr);  //chunk->m_oldPtr);
		// chunk->m_oldPtr = uniquePtr;//oldPtr;

		void* uid = findPointer(oldPtr);
		m_uid2ChunkPtr.insert(uid, chunk);

		switch (chunk->m_chunkCode)
		{
			case BT_SOFTBODY_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_softBodyDoubleData.push_back((btSoftBodyDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_softBodyFloatData.push_back((btSoftBodyFloatData*)chunk->m_oldPtr);
#endif
				break;
			}
			case BT_COLLISIONOBJECT_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_collisionObjectDataDouble.push_back((btCollisionObjectDoubleData*)chunk->m_oldPtr);
#else   //BT_USE_DOUBLE_PRECISION
				m_arrays.m_collisionObjectDataFloat.push_back((btCollisionObjectFloatData*)chunk->m_oldPtr);
#endif  //BT_USE_DOUBLE_PRECISION
				break;
			}
			case BT_RIGIDBODY_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_rigidBodyDataDouble.push_back((btRigidBodyDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_rigidBodyDataFloat.push_back((btRigidBodyFloatData*)chunk->m_oldPtr);
#endif  //BT_USE_DOUBLE_PRECISION
				break;
			};
			case BT_CONSTRAINT_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_constraintDataDouble.push_back((btTypedConstraintDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_constraintDataFloat.push_back((btTypedConstraintFloatData*)chunk->m_oldPtr);
#endif
				break;
			}
			case BT_QUANTIZED_BVH_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_bvhsDouble.push_back((btQuantizedBvhDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_bvhsFloat.push_back((btQuantizedBvhFloatData*)chunk->m_oldPtr);
#endif
				break;
			}

			case BT_SHAPE_CODE:
			{
				btCollisionShapeData* shapeData = (btCollisionShapeData*)chunk->m_oldPtr;
				m_arrays.m_colShapeData.push_back(shapeData);
				break;
			}
			case BT_TRIANLGE_INFO_MAP:
			case BT_ARRAY_CODE:
			case BT_SBMATERIAL_CODE:
			case BT_SBNODE_CODE:
			case BT_DYNAMICSWORLD_CODE:
			case BT_DNA_CODE:
			{
				break;
			}
			default:
			{
			}
		};
	}

	int getNumChunks() const
	{
		return m_uid2ChunkPtr.size();
	}

	const btChunk* getChunk(int chunkIndex) const
	{
		return *m_uid2ChunkPtr.getAtIndex(chunkIndex);
	}
};
#endif  //ENABLE_INMEMORY_SERIALIZER

#endif  //BT_SERIALIZER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2010 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef _BT_TRIANGLE_INFO_MAP_H
#define _BT_TRIANGLE_INFO_MAP_H

#include "LinearMath/btHashMap.h"
#include "LinearMath/btSerializer.h"

///for btTriangleInfo m_flags
#define TRI_INFO_V0V1_CONVEX 1
#define TRI_INFO_V1V2_CONVEX 2
#define TRI_INFO_V2V0_CONVEX 4

#define TRI_INFO_V0V1_SWAP_NORMALB 8
#define TRI_INFO_V1V2_SWAP_NORMALB 16
#define TRI_INFO_V2V0_SWAP_NORMALB 32

///The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
///it can be generated using
struct btTriangleInfo
{
	btTriangleInfo()
	{
		m_edgeV0V1Angle = SIMD_2_PI;
		m_edgeV1V2Angle = SIMD_2_PI;
		m_edgeV2V0Angle = SIMD_2_PI;
		m_flags = 0;
	}

	int m_flags;

	btScalar m_edgeV0V1Angle;
	btScalar m_edgeV1V2Angle;
	btScalar m_edgeV2V0Angle;
};

typedef btHashMap<btHashInt, btTriangleInfo> btInternalTriangleInfoMap;

///The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
struct btTriangleInfoMap : public btInternalTriangleInfoMap
{
	btScalar m_convexEpsilon;          ///used to determine if an edge or contact normal is convex, using the dot product
	btScalar m_planarEpsilon;          ///used to determine if a triangle edge is planar with zero angle
	btScalar m_equalVertexThreshold;   ///used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared'
	btScalar m_edgeDistanceThreshold;  ///used to determine edge contacts: if the closest distance between a contact point and an edge is smaller than this distance threshold it is considered to "hit the edge"
	btScalar m_maxEdgeAngleThreshold;  //ignore edges that connect triangles at an angle larger than this m_maxEdgeAngleThreshold
	btScalar m_zeroAreaThreshold;      ///used to determine if a triangle is degenerate (length squared of cross product of 2 triangle edges < threshold)

	btTriangleInfoMap()
	{
		m_convexEpsilon = 0.00f;
		m_planarEpsilon = 0.0001f;
		m_equalVertexThreshold = btScalar(0.0001) * btScalar(0.0001);
		m_edgeDistanceThreshold = btScalar(0.1);
		m_zeroAreaThreshold = btScalar(0.0001) * btScalar(0.0001);
		m_maxEdgeAngleThreshold = SIMD_2_PI;
	}
	virtual ~btTriangleInfoMap() {}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	void deSerialize(struct btTriangleInfoMapData& data);
};

// clang-format off

///those fields have to be float and not btScalar for the serialization to work properly
struct	btTriangleInfoData
{
	int			m_flags;
	float	m_edgeV0V1Angle;
	float	m_edgeV1V2Angle;
	float	m_edgeV2V0Angle;
};

struct	btTriangleInfoMapData
{
	int					*m_hashTablePtr;
	int					*m_nextPtr;
	btTriangleInfoData	*m_valueArrayPtr;
	int					*m_keyArrayPtr;

	float	m_convexEpsilon;
	float	m_planarEpsilon;
	float	m_equalVertexThreshold; 
	float	m_edgeDistanceThreshold;
	float	m_zeroAreaThreshold;

	int		m_nextSize;
	int		m_hashTableSize;
	int		m_numValues;
	int		m_numKeys;
	char	m_padding[4];
};

// clang-format on

SIMD_FORCE_INLINE int btTriangleInfoMap::calculateSerializeBufferSize() const
{
	return sizeof(btTriangleInfoMapData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btTriangleInfoMap::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btTriangleInfoMapData* tmapData = (btTriangleInfoMapData*)dataBuffer;
	tmapData->m_convexEpsilon = (float)m_convexEpsilon;
	tmapData->m_planarEpsilon = (float)m_planarEpsilon;
	tmapData->m_equalVertexThreshold = (float)m_equalVertexThreshold;
	tmapData->m_edgeDistanceThreshold = (float)m_edgeDistanceThreshold;
	tmapData->m_zeroAreaThreshold = (float)m_zeroAreaThreshold;

	tmapData->m_hashTableSize = m_hashTable.size();

	tmapData->m_hashTablePtr = tmapData->m_hashTableSize ? (int*)serializer->getUniquePointer((void*)&m_hashTable[0]) : 0;
	if (tmapData->m_hashTablePtr)
	{
		//serialize an int buffer
		int sz = sizeof(int);
		int numElem = tmapData->m_hashTableSize;
		btChunk* chunk = serializer->allocate(sz, numElem);
		int* memPtr = (int*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			*memPtr = m_hashTable[i];
		}
		serializer->finalizeChunk(chunk, "int", BT_ARRAY_CODE, (void*)&m_hashTable[0]);
	}

	tmapData->m_nextSize = m_next.size();
	tmapData->m_nextPtr = tmapData->m_nextSize ? (int*)serializer->getUniquePointer((void*)&m_next[0]) : 0;
	if (tmapData->m_nextPtr)
	{
		int sz = sizeof(int);
		int numElem = tmapData->m_nextSize;
		btChunk* chunk = serializer->allocate(sz, numElem);
		int* memPtr = (int*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			*memPtr = m_next[i];
		}
		serializer->finalizeChunk(chunk, "int", BT_ARRAY_CODE, (void*)&m_next[0]);
	}

	tmapData->m_numValues = m_valueArray.size();
	tmapData->m_valueArrayPtr = tmapData->m_numValues ? (btTriangleInfoData*)serializer->getUniquePointer((void*)&m_valueArray[0]) : 0;
	if (tmapData->m_valueArrayPtr)
	{
		int sz = sizeof(btTriangleInfoData);
		int numElem = tmapData->m_numValues;
		btChunk* chunk = serializer->allocate(sz, numElem);
		btTriangleInfoData* memPtr = (btTriangleInfoData*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			memPtr->m_edgeV0V1Angle = (float)m_valueArray[i].m_edgeV0V1Angle;
			memPtr->m_edgeV1V2Angle = (float)m_valueArray[i].m_edgeV1V2Angle;
			memPtr->m_edgeV2V0Angle = (float)m_valueArray[i].m_edgeV2V0Angle;
			memPtr->m_flags = m_valueArray[i].m_flags;
		}
		serializer->finalizeChunk(chunk, "btTriangleInfoData", BT_ARRAY_CODE, (void*)&m_valueArray[0]);
	}

	tmapData->m_numKeys = m_keyArray.size();
	tmapData->m_keyArrayPtr = tmapData->m_numKeys ? (int*)serializer->getUniquePointer((void*)&m_keyArray[0]) : 0;
	if (tmapData->m_keyArrayPtr)
	{
		int sz = sizeof(int);
		int numElem = tmapData->m_numValues;
		btChunk* chunk = serializer->allocate(sz, numElem);
		int* memPtr = (int*)chunk->m_oldPtr;
		for (int i = 0; i < numElem; i++, memPtr++)
		{
			*memPtr = m_keyArray[i].getUid1();
		}
		serializer->finalizeChunk(chunk, "int", BT_ARRAY_CODE, (void*)&m_keyArray[0]);
	}

	// Fill padding with zeros to appease msan.
	tmapData->m_padding[0] = 0;
	tmapData->m_padding[1] = 0;
	tmapData->m_padding[2] = 0;
	tmapData->m_padding[3] = 0;

	return "btTriangleInfoMapData";
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE void btTriangleInfoMap::deSerialize(btTriangleInfoMapData& tmapData)
{
	m_convexEpsilon = tmapData.m_convexEpsilon;
	m_planarEpsilon = tmapData.m_planarEpsilon;
	m_equalVertexThreshold = tmapData.m_equalVertexThreshold;
	m_edgeDistanceThreshold = tmapData.m_edgeDistanceThreshold;
	m_zeroAreaThreshold = tmapData.m_zeroAreaThreshold;
	m_hashTable.resize(tmapData.m_hashTableSize);
	int i = 0;
	for (i = 0; i < tmapData.m_hashTableSize; i++)
	{
		m_hashTable[i] = tmapData.m_hashTablePtr[i];
	}
	m_next.resize(tmapData.m_nextSize);
	for (i = 0; i < tmapData.m_nextSize; i++)
	{
		m_next[i] = tmapData.m_nextPtr[i];
	}
	m_valueArray.resize(tmapData.m_numValues);
	for (i = 0; i < tmapData.m_numValues; i++)
	{
		m_valueArray[i].m_edgeV0V1Angle = tmapData.m_valueArrayPtr[i].m_edgeV0V1Angle;
		m_valueArray[i].m_edgeV1V2Angle = tmapData.m_valueArrayPtr[i].m_edgeV1V2Angle;
		m_valueArray[i].m_edgeV2V0Angle = tmapData.m_valueArrayPtr[i].m_edgeV2V0Angle;
		m_valueArray[i].m_flags = tmapData.m_valueArrayPtr[i].m_flags;
	}

	m_keyArray.resize(tmapData.m_numKeys, btHashInt(0));
	for (i = 0; i < tmapData.m_numKeys; i++)
	{
		m_keyArray[i].setUid1(tmapData.m_keyArrayPtr[i]);
	}
}

#endif  //_BT_TRIANGLE_INFO_MAP_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

//#define DISABLE_BVH

#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
#include "LinearMath/btSerializer.h"

///Bvh Concave triangle mesh is a static-triangle mesh shape with Bounding Volume Hierarchy optimization.
///Uses an interface to access the triangles to allow for sharing graphics/physics triangles.
btBvhTriangleMeshShape::btBvhTriangleMeshShape(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, bool buildBvh)
	: btTriangleMeshShape(meshInterface),
	  m_bvh(0),
	  m_triangleInfoMap(0),
	  m_useQuantizedAabbCompression(useQuantizedAabbCompression),
	  m_ownsBvh(false)
{
	m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
	//construct bvh from meshInterface
#ifndef DISABLE_BVH

	if (buildBvh)
	{
		buildOptimizedBvh();
	}

#endif  //DISABLE_BVH
}

btBvhTriangleMeshShape::btBvhTriangleMeshShape(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, bool buildBvh)
	: btTriangleMeshShape(meshInterface),
	  m_bvh(0),
	  m_triangleInfoMap(0),
	  m_useQuantizedAabbCompression(useQuantizedAabbCompression),
	  m_ownsBvh(false)
{
	m_shapeType = TRIANGLE_MESH_SHAPE_PROXYTYPE;
	//construct bvh from meshInterface
#ifndef DISABLE_BVH

	if (buildBvh)
	{
		void* mem = btAlignedAlloc(sizeof(btOptimizedBvh), 16);
		m_bvh = new (mem) btOptimizedBvh();

		m_bvh->build(meshInterface, m_useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
		m_ownsBvh = true;
	}

#endif  //DISABLE_BVH
}

void btBvhTriangleMeshShape::partialRefitTree(const btVector3& aabbMin, const btVector3& aabbMax)
{
	m_bvh->refitPartial(m_meshInterface, aabbMin, aabbMax);

	m_localAabbMin.setMin(aabbMin);
	m_localAabbMax.setMax(aabbMax);
}

void btBvhTriangleMeshShape::refitTree(const btVector3& aabbMin, const btVector3& aabbMax)
{
	m_bvh->refit(m_meshInterface, aabbMin, aabbMax);

	recalcLocalAabb();
}

btBvhTriangleMeshShape::~btBvhTriangleMeshShape()
{
	if (m_ownsBvh)
	{
		m_bvh->~btOptimizedBvh();
		btAlignedFree(m_bvh);
	}
}

void btBvhTriangleMeshShape::performRaycast(btTriangleCallback* callback, const btVector3& raySource, const btVector3& rayTarget)
{
	struct MyNodeOverlapCallback : public btNodeOverlapCallback
	{
		btStridingMeshInterface* m_meshInterface;
		btTriangleCallback* m_callback;

		MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
			: m_meshInterface(meshInterface),
			  m_callback(callback)
		{
		}

		virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
		{
			btVector3 m_triangle[3];
			const unsigned char* vertexbase;
			int numverts;
			PHY_ScalarType type;
			int stride;
			const unsigned char* indexbase;
			int indexstride;
			int numfaces;
			PHY_ScalarType indicestype;

			m_meshInterface->getLockedReadOnlyVertexIndexBase(
				&vertexbase,
				numverts,
				type,
				stride,
				&indexbase,
				indexstride,
				numfaces,
				indicestype,
				nodeSubPart);

			unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex * indexstride);

			const btVector3& meshScaling = m_meshInterface->getScaling();
			for (int j = 2; j >= 0; j--)
			{
				int graphicsindex;
                                switch (indicestype) {
                                        case PHY_INTEGER: graphicsindex = gfxbase[j]; break;
                                        case PHY_SHORT: graphicsindex = ((unsigned short*)gfxbase)[j]; break;
                                        case PHY_UCHAR: graphicsindex = ((unsigned char*)gfxbase)[j]; break;
                                        default: btAssert(0);
                                }

				if (type == PHY_FLOAT)
				{
					float* graphicsbase = (float*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
				}
				else
				{
					double* graphicsbase = (double*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(btScalar(graphicsbase[0]) * meshScaling.getX(), btScalar(graphicsbase[1]) * meshScaling.getY(), btScalar(graphicsbase[2]) * meshScaling.getZ());
				}
			}

			/* Perform ray vs. triangle collision here */
			m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
			m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
		}
	};

	MyNodeOverlapCallback myNodeCallback(callback, m_meshInterface);

	m_bvh->reportRayOverlappingNodex(&myNodeCallback, raySource, rayTarget);
}

void btBvhTriangleMeshShape::performConvexcast(btTriangleCallback* callback, const btVector3& raySource, const btVector3& rayTarget, const btVector3& aabbMin, const btVector3& aabbMax)
{
	struct MyNodeOverlapCallback : public btNodeOverlapCallback
	{
		btStridingMeshInterface* m_meshInterface;
		btTriangleCallback* m_callback;

		MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
			: m_meshInterface(meshInterface),
			  m_callback(callback)
		{
		}

		virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
		{
			btVector3 m_triangle[3];
			const unsigned char* vertexbase;
			int numverts;
			PHY_ScalarType type;
			int stride;
			const unsigned char* indexbase;
			int indexstride;
			int numfaces;
			PHY_ScalarType indicestype;

			m_meshInterface->getLockedReadOnlyVertexIndexBase(
				&vertexbase,
				numverts,
				type,
				stride,
				&indexbase,
				indexstride,
				numfaces,
				indicestype,
				nodeSubPart);

			unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex * indexstride);

			const btVector3& meshScaling = m_meshInterface->getScaling();
			for (int j = 2; j >= 0; j--)
			{
				int graphicsindex;
                                switch (indicestype) {
                                        case PHY_INTEGER: graphicsindex = gfxbase[j]; break;
                                        case PHY_SHORT: graphicsindex = ((unsigned short*)gfxbase)[j]; break;
                                        case PHY_UCHAR: graphicsindex = ((unsigned char*)gfxbase)[j]; break;
                                        default: btAssert(0);
                                }

				if (type == PHY_FLOAT)
				{
					float* graphicsbase = (float*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
				}
				else
				{
					double* graphicsbase = (double*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(btScalar(graphicsbase[0]) * meshScaling.getX(), btScalar(graphicsbase[1]) * meshScaling.getY(), btScalar(graphicsbase[2]) * meshScaling.getZ());
				}
			}

			/* Perform ray vs. triangle collision here */
			m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
			m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
		}
	};

	MyNodeOverlapCallback myNodeCallback(callback, m_meshInterface);

	m_bvh->reportBoxCastOverlappingNodex(&myNodeCallback, raySource, rayTarget, aabbMin, aabbMax);
}

//perform bvh tree traversal and report overlapping triangles to 'callback'
void btBvhTriangleMeshShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
#ifdef DISABLE_BVH
	//brute force traverse all triangles
	btTriangleMeshShape::processAllTriangles(callback, aabbMin, aabbMax);
#else

	//first get all the nodes

	struct MyNodeOverlapCallback : public btNodeOverlapCallback
	{
		btStridingMeshInterface* m_meshInterface;
		btTriangleCallback* m_callback;
		btVector3 m_triangle[3];
		int m_numOverlap;

		MyNodeOverlapCallback(btTriangleCallback* callback, btStridingMeshInterface* meshInterface)
			: m_meshInterface(meshInterface),
			  m_callback(callback),
			  m_numOverlap(0)
		{
		}

		virtual void processNode(int nodeSubPart, int nodeTriangleIndex)
		{
			m_numOverlap++;
			const unsigned char* vertexbase;
			int numverts;
			PHY_ScalarType type;
			int stride;
			const unsigned char* indexbase;
			int indexstride;
			int numfaces;
			PHY_ScalarType indicestype;

			m_meshInterface->getLockedReadOnlyVertexIndexBase(
				&vertexbase,
				numverts,
				type,
				stride,
				&indexbase,
				indexstride,
				numfaces,
				indicestype,
				nodeSubPart);

			unsigned int* gfxbase = (unsigned int*)(indexbase + nodeTriangleIndex * indexstride);
			btAssert(indicestype == PHY_INTEGER || indicestype == PHY_SHORT || indicestype == PHY_UCHAR);

			const btVector3& meshScaling = m_meshInterface->getScaling();
			for (int j = 2; j >= 0; j--)
			{
				int graphicsindex = indicestype == PHY_SHORT ? ((unsigned short*)gfxbase)[j] : indicestype == PHY_INTEGER ? gfxbase[j] : ((unsigned char*)gfxbase)[j];

#ifdef DEBUG_TRIANGLE_MESH
				printf("%d ,", graphicsindex);
#endif  //DEBUG_TRIANGLE_MESH
				if (type == PHY_FLOAT)
				{
					float* graphicsbase = (float*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(
						graphicsbase[0] * meshScaling.getX(),
						graphicsbase[1] * meshScaling.getY(),
						graphicsbase[2] * meshScaling.getZ());
				}
				else
				{
					double* graphicsbase = (double*)(vertexbase + graphicsindex * stride);

					m_triangle[j] = btVector3(
						btScalar(graphicsbase[0]) * meshScaling.getX(),
						btScalar(graphicsbase[1]) * meshScaling.getY(),
						btScalar(graphicsbase[2]) * meshScaling.getZ());
				}
#ifdef DEBUG_TRIANGLE_MESH
				printf("triangle vertices:%f,%f,%f\n", triangle[j].x(), triangle[j].y(), triangle[j].z());
#endif  //DEBUG_TRIANGLE_MESH
			}

			m_callback->processTriangle(m_triangle, nodeSubPart, nodeTriangleIndex);
			m_meshInterface->unLockReadOnlyVertexBase(nodeSubPart);
		}
	};

	MyNodeOverlapCallback myNodeCallback(callback, m_meshInterface);

	m_bvh->reportAabbOverlappingNodex(&myNodeCallback, aabbMin, aabbMax);

#endif  //DISABLE_BVH
}

void btBvhTriangleMeshShape::setLocalScaling(const btVector3& scaling)
{
	if ((getLocalScaling() - scaling).length2() > SIMD_EPSILON)
	{
		btTriangleMeshShape::setLocalScaling(scaling);
		buildOptimizedBvh();
	}
}

void btBvhTriangleMeshShape::buildOptimizedBvh()
{
	if (m_ownsBvh)
	{
		m_bvh->~btOptimizedBvh();
		btAlignedFree(m_bvh);
	}
	///m_localAabbMin/m_localAabbMax is already re-calculated in btTriangleMeshShape. We could just scale aabb, but this needs some more work
	void* mem = btAlignedAlloc(sizeof(btOptimizedBvh), 16);
	m_bvh = new (mem) btOptimizedBvh();
	//rebuild the bvh...
	m_bvh->build(m_meshInterface, m_useQuantizedAabbCompression, m_localAabbMin, m_localAabbMax);
	m_ownsBvh = true;
}

void btBvhTriangleMeshShape::setOptimizedBvh(btOptimizedBvh* bvh, const btVector3& scaling)
{
	btAssert(!m_bvh);
	btAssert(!m_ownsBvh);

	m_bvh = bvh;
	m_ownsBvh = false;
	// update the scaling without rebuilding the bvh
	if ((getLocalScaling() - scaling).length2() > SIMD_EPSILON)
	{
		btTriangleMeshShape::setLocalScaling(scaling);
	}
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btBvhTriangleMeshShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btTriangleMeshShapeData* trimeshData = (btTriangleMeshShapeData*)dataBuffer;

	btCollisionShape::serialize(&trimeshData->m_collisionShapeData, serializer);

	m_meshInterface->serialize(&trimeshData->m_meshInterface, serializer);

	trimeshData->m_collisionMargin = float(m_collisionMargin);

	if (m_bvh && !(serializer->getSerializationFlags() & BT_SERIALIZE_NO_BVH))
	{
		void* chunk = serializer->findPointer(m_bvh);
		if (chunk)
		{
#ifdef BT_USE_DOUBLE_PRECISION
			trimeshData->m_quantizedDoubleBvh = (btQuantizedBvhData*)chunk;
			trimeshData->m_quantizedFloatBvh = 0;
#else
			trimeshData->m_quantizedFloatBvh = (btQuantizedBvhData*)chunk;
			trimeshData->m_quantizedDoubleBvh = 0;
#endif  //BT_USE_DOUBLE_PRECISION
		}
		else
		{
#ifdef BT_USE_DOUBLE_PRECISION
			trimeshData->m_quantizedDoubleBvh = (btQuantizedBvhData*)serializer->getUniquePointer(m_bvh);
			trimeshData->m_quantizedFloatBvh = 0;
#else
			trimeshData->m_quantizedFloatBvh = (btQuantizedBvhData*)serializer->getUniquePointer(m_bvh);
			trimeshData->m_quantizedDoubleBvh = 0;
#endif  //BT_USE_DOUBLE_PRECISION

			int sz = m_bvh->calculateSerializeBufferSizeNew();
			btChunk* chunk = serializer->allocate(sz, 1);
			const char* structType = m_bvh->serialize(chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_QUANTIZED_BVH_CODE, m_bvh);
		}
	}
	else
	{
		trimeshData->m_quantizedFloatBvh = 0;
		trimeshData->m_quantizedDoubleBvh = 0;
	}

	if (m_triangleInfoMap && !(serializer->getSerializationFlags() & BT_SERIALIZE_NO_TRIANGLEINFOMAP))
	{
		void* chunk = serializer->findPointer(m_triangleInfoMap);
		if (chunk)
		{
			trimeshData->m_triangleInfoMap = (btTriangleInfoMapData*)chunk;
		}
		else
		{
			trimeshData->m_triangleInfoMap = (btTriangleInfoMapData*)serializer->getUniquePointer(m_triangleInfoMap);
			int sz = m_triangleInfoMap->calculateSerializeBufferSize();
			btChunk* chunk = serializer->allocate(sz, 1);
			const char* structType = m_triangleInfoMap->serialize(chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_TRIANLGE_INFO_MAP, m_triangleInfoMap);
		}
	}
	else
	{
		trimeshData->m_triangleInfoMap = 0;
	}

	// Fill padding with zeros to appease msan.
	memset(trimeshData->m_pad3, 0, sizeof(trimeshData->m_pad3));

	return "btTriangleMeshShapeData";
}

void btBvhTriangleMeshShape::serializeSingleBvh(btSerializer* serializer) const
{
	if (m_bvh)
	{
		int len = m_bvh->calculateSerializeBufferSizeNew();  //make sure not to use calculateSerializeBufferSize because it is used for in-place
		btChunk* chunk = serializer->allocate(len, 1);
		const char* structType = m_bvh->serialize(chunk->m_oldPtr, serializer);
		serializer->finalizeChunk(chunk, structType, BT_QUANTIZED_BVH_CODE, (void*)m_bvh);
	}
}

void btBvhTriangleMeshShape::serializeSingleTriangleInfoMap(btSerializer* serializer) const
{
	if (m_triangleInfoMap)
	{
		int len = m_triangleInfoMap->calculateSerializeBufferSize();
		btChunk* chunk = serializer->allocate(len, 1);
		const char* structType = m_triangleInfoMap->serialize(chunk->m_oldPtr, serializer);
		serializer->finalizeChunk(chunk, structType, BT_TRIANLGE_INFO_MAP, (void*)m_triangleInfoMap);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_BVH_TRIANGLE_MESH_SHAPE_H
#define BT_BVH_TRIANGLE_MESH_SHAPE_H

#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btOptimizedBvh.h"
#include "LinearMath/btAlignedAllocator.h"
#include "BulletCollision/CollisionShapes/btTriangleInfoMap.h"

///The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
///If you required moving concave triangle meshes, it is recommended to perform convex decomposition
///using HACD, see Bullet/Demos/ConvexDecompositionDemo.
///Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
///btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
///cache friendly traversal for PlayStation 3 Cell SPU.
///It is recommended to enable useQuantizedAabbCompression for better memory usage.
///It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
///Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
///See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
ATTRIBUTE_ALIGNED16(class)
btBvhTriangleMeshShape : public btTriangleMeshShape
{
	btOptimizedBvh* m_bvh;
	btTriangleInfoMap* m_triangleInfoMap;

	bool m_useQuantizedAabbCompression;
	bool m_ownsBvh;
#ifdef __clang__
	bool m_pad[11] __attribute__((unused));  ////need padding due to alignment
#else
	bool m_pad[11];  ////need padding due to alignment
#endif

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btBvhTriangleMeshShape(btStridingMeshInterface * meshInterface, bool useQuantizedAabbCompression, bool buildBvh = true);

	///optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
	btBvhTriangleMeshShape(btStridingMeshInterface * meshInterface, bool useQuantizedAabbCompression, const btVector3& bvhAabbMin, const btVector3& bvhAabbMax, bool buildBvh = true);

	virtual ~btBvhTriangleMeshShape();

	bool getOwnsBvh() const
	{
		return m_ownsBvh;
	}

	void performRaycast(btTriangleCallback * callback, const btVector3& raySource, const btVector3& rayTarget);
	void performConvexcast(btTriangleCallback * callback, const btVector3& boxSource, const btVector3& boxTarget, const btVector3& boxMin, const btVector3& boxMax);

	virtual void processAllTriangles(btTriangleCallback * callback, const btVector3& aabbMin, const btVector3& aabbMax) const;

	void refitTree(const btVector3& aabbMin, const btVector3& aabbMax);

	///for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks
	void partialRefitTree(const btVector3& aabbMin, const btVector3& aabbMax);

	//debugging
	virtual const char* getName() const { return "BVHTRIANGLEMESH"; }

	virtual void setLocalScaling(const btVector3& scaling);

	btOptimizedBvh* getOptimizedBvh()
	{
		return m_bvh;
	}

	void setOptimizedBvh(btOptimizedBvh * bvh, const btVector3& localScaling = btVector3(1, 1, 1));

	void buildOptimizedBvh();

	bool usesQuantizedAabbCompression() const
	{
		return m_useQuantizedAabbCompression;
	}

	void setTriangleInfoMap(btTriangleInfoMap * triangleInfoMap)
	{
		m_triangleInfoMap = triangleInfoMap;
	}

	const btTriangleInfoMap* getTriangleInfoMap() const
	{
		return m_triangleInfoMap;
	}

	btTriangleInfoMap* getTriangleInfoMap()
	{
		return m_triangleInfoMap;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	virtual void serializeSingleBvh(btSerializer * serializer) const;

	virtual void serializeSingleTriangleInfoMap(btSerializer * serializer) const;
};

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btTriangleMeshShapeData
{
	btCollisionShapeData	m_collisionShapeData;

	btStridingMeshInterfaceData m_meshInterface;

	btQuantizedBvhFloatData		*m_quantizedFloatBvh;
	btQuantizedBvhDoubleData	*m_quantizedDoubleBvh;

	btTriangleInfoMapData	*m_triangleInfoMap;
	
	float	m_collisionMargin;

	char m_pad3[4];
	
};

// clang-format on

SIMD_FORCE_INLINE int btBvhTriangleMeshShape::calculateSerializeBufferSize() const
{
	return sizeof(btTriangleMeshShapeData);
}

#endif  //BT_BVH_TRIANGLE_MESH_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "LinearMath/btTransformUtil.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"

btContinuousConvexCollision::btContinuousConvexCollision(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver)
	: m_simplexSolver(simplexSolver),
	  m_penetrationDepthSolver(penetrationDepthSolver),
	  m_convexA(convexA),
	  m_convexB1(convexB),
	  m_planeShape(0)
{
}

btContinuousConvexCollision::btContinuousConvexCollision(const btConvexShape* convexA, const btStaticPlaneShape* plane)
	: m_simplexSolver(0),
	  m_penetrationDepthSolver(0),
	  m_convexA(convexA),
	  m_convexB1(0),
	  m_planeShape(plane)
{
}

/// This maximum should not be necessary. It allows for untested/degenerate cases in production code.
/// You don't want your game ever to lock-up.
#define MAX_ITERATIONS2 64

void btContinuousConvexCollision::computeClosestPoints(const btTransform& transA, const btTransform& transB, btPointCollector& pointCollector)
{
	if (m_convexB1)
	{
		m_simplexSolver->reset();
		btGjkPairDetector gjk(m_convexA, m_convexB1, m_convexA->getShapeType(), m_convexB1->getShapeType(), m_convexA->getMargin(), m_convexB1->getMargin(), m_simplexSolver, m_penetrationDepthSolver);
		btGjkPairDetector::ClosestPointInput input;
		input.m_transformA = transA;
		input.m_transformB = transB;
		gjk.getClosestPoints(input, pointCollector, 0);
	}
	else
	{
		//convex versus plane
		const btConvexShape* convexShape = m_convexA;
		const btStaticPlaneShape* planeShape = m_planeShape;

		const btVector3& planeNormal = planeShape->getPlaneNormal();
		const btScalar& planeConstant = planeShape->getPlaneConstant();

		btTransform convexWorldTransform = transA;
		btTransform convexInPlaneTrans;
		convexInPlaneTrans = transB.inverse() * convexWorldTransform;
		btTransform planeInConvex;
		planeInConvex = convexWorldTransform.inverse() * transB;

		btVector3 vtx = convexShape->localGetSupportingVertex(planeInConvex.getBasis() * -planeNormal);

		btVector3 vtxInPlane = convexInPlaneTrans(vtx);
		btScalar distance = (planeNormal.dot(vtxInPlane) - planeConstant);

		btVector3 vtxInPlaneProjected = vtxInPlane - distance * planeNormal;
		btVector3 vtxInPlaneWorld = transB * vtxInPlaneProjected;
		btVector3 normalOnSurfaceB = transB.getBasis() * planeNormal;

		pointCollector.addContactPoint(
			normalOnSurfaceB,
			vtxInPlaneWorld,
			distance);
	}
}

bool btContinuousConvexCollision::calcTimeOfImpact(
	const btTransform& fromA,
	const btTransform& toA,
	const btTransform& fromB,
	const btTransform& toB,
	CastResult& result)
{
	/// compute linear and angular velocity for this interval, to interpolate
	btVector3 linVelA, angVelA, linVelB, angVelB;
	btTransformUtil::calculateVelocity(fromA, toA, btScalar(1.), linVelA, angVelA);
	btTransformUtil::calculateVelocity(fromB, toB, btScalar(1.), linVelB, angVelB);

	btScalar boundingRadiusA = m_convexA->getAngularMotionDisc();
	btScalar boundingRadiusB = m_convexB1 ? m_convexB1->getAngularMotionDisc() : 0.f;

	btScalar maxAngularProjectedVelocity = angVelA.length() * boundingRadiusA + angVelB.length() * boundingRadiusB;
	btVector3 relLinVel = (linVelB - linVelA);

	btScalar relLinVelocLength = (linVelB - linVelA).length();

	if ((relLinVelocLength + maxAngularProjectedVelocity) == 0.f)
		return false;

	btScalar lambda = btScalar(0.);

	btVector3 n;
	n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	bool hasResult = false;
	btVector3 c;

	btScalar lastLambda = lambda;
	//btScalar epsilon = btScalar(0.001);

	int numIter = 0;
	//first solution, using GJK

	btScalar radius = 0.001f;
	//	result.drawCoordSystem(sphereTr);

	btPointCollector pointCollector1;

	{
		computeClosestPoints(fromA, fromB, pointCollector1);

		hasResult = pointCollector1.m_hasResult;
		c = pointCollector1.m_pointInWorld;
	}

	if (hasResult)
	{
		btScalar dist;
		dist = pointCollector1.m_distance + result.m_allowedPenetration;
		n = pointCollector1.m_normalOnBInWorld;
		btScalar projectedLinearVelocity = relLinVel.dot(n);
		if ((projectedLinearVelocity + maxAngularProjectedVelocity) <= SIMD_EPSILON)
			return false;

		//not close enough
		while (dist > radius)
		{
			if (result.m_debugDrawer)
			{
				result.m_debugDrawer->drawSphere(c, 0.2f, btVector3(1, 1, 1));
			}
			btScalar dLambda = btScalar(0.);

			projectedLinearVelocity = relLinVel.dot(n);

			//don't report time of impact for motion away from the contact normal (or causes minor penetration)
			if ((projectedLinearVelocity + maxAngularProjectedVelocity) <= SIMD_EPSILON)
				return false;

			dLambda = dist / (projectedLinearVelocity + maxAngularProjectedVelocity);

			lambda += dLambda;

			if (lambda > btScalar(1.) || lambda < btScalar(0.))
				return false;

			//todo: next check with relative epsilon
			if (lambda <= lastLambda)
			{
				return false;
				//n.setValue(0,0,0);
				//break;
			}
			lastLambda = lambda;

			//interpolate to next lambda
			btTransform interpolatedTransA, interpolatedTransB, relativeTrans;

			btTransformUtil::integrateTransform(fromA, linVelA, angVelA, lambda, interpolatedTransA);
			btTransformUtil::integrateTransform(fromB, linVelB, angVelB, lambda, interpolatedTransB);
			relativeTrans = interpolatedTransB.inverseTimes(interpolatedTransA);

			if (result.m_debugDrawer)
			{
				result.m_debugDrawer->drawSphere(interpolatedTransA.getOrigin(), 0.2f, btVector3(1, 0, 0));
			}

			result.DebugDraw(lambda);

			btPointCollector pointCollector;
			computeClosestPoints(interpolatedTransA, interpolatedTransB, pointCollector);

			if (pointCollector.m_hasResult)
			{
				dist = pointCollector.m_distance + result.m_allowedPenetration;
				c = pointCollector.m_pointInWorld;
				n = pointCollector.m_normalOnBInWorld;
			}
			else
			{
				result.reportFailure(-1, numIter);
				return false;
			}

			numIter++;
			if (numIter > MAX_ITERATIONS2)
			{
				result.reportFailure(-2, numIter);
				return false;
			}
		}

		result.m_fraction = lambda;
		result.m_normal = n;
		result.m_hitPoint = c;
		return true;
	}

	return false;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONTINUOUS_COLLISION_CONVEX_CAST_H
#define BT_CONTINUOUS_COLLISION_CONVEX_CAST_H

#include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
class btConvexPenetrationDepthSolver;
class btConvexShape;
class btStaticPlaneShape;

/// btContinuousConvexCollision implements angular and linear time of impact for convex objects.
/// Based on Brian Mirtich's Conservative Advancement idea (PhD thesis).
/// Algorithm operates in worldspace, in order to keep in between motion globally consistent.
/// It uses GJK at the moment. Future improvement would use minkowski sum / supporting vertex, merging innerloops
class btContinuousConvexCollision : public btConvexCast
{
	btSimplexSolverInterface* m_simplexSolver;
	btConvexPenetrationDepthSolver* m_penetrationDepthSolver;
	const btConvexShape* m_convexA;
	//second object is either a convex or a plane (code sharing)
	const btConvexShape* m_convexB1;
	const btStaticPlaneShape* m_planeShape;

	void computeClosestPoints(const btTransform& transA, const btTransform& transB, struct btPointCollector& pointCollector);

public:
	btContinuousConvexCollision(const btConvexShape* shapeA, const btConvexShape* shapeB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);

	btContinuousConvexCollision(const btConvexShape* shapeA, const btStaticPlaneShape* plane);

	virtual bool calcTimeOfImpact(
		const btTransform& fromA,
		const btTransform& toA,
		const btTransform& fromB,
		const btTransform& toB,
		CastResult& result);
};

#endif  //BT_CONTINUOUS_COLLISION_CONVEX_CAST_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btGjkPairDetector.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"

#if defined(DEBUG) || defined(_DEBUG)
//#define TEST_NON_VIRTUAL 1
#ifdef __SPU__
#define printf spu_printf
#endif  //__SPU__
#endif

//must be above the machine epsilon
#ifdef BT_USE_DOUBLE_PRECISION
#define REL_ERROR2 btScalar(1.0e-12)
btScalar gGjkEpaPenetrationTolerance = 1.0e-12;
#else
#define REL_ERROR2 btScalar(1.0e-6)
btScalar gGjkEpaPenetrationTolerance = 0.001;
#endif


btGjkPairDetector::btGjkPairDetector(const btConvexShape *objectA, const btConvexShape *objectB, btSimplexSolverInterface *simplexSolver, btConvexPenetrationDepthSolver *penetrationDepthSolver)
	: m_cachedSeparatingAxis(btScalar(0.), btScalar(1.), btScalar(0.)),
	  m_penetrationDepthSolver(penetrationDepthSolver),
	  m_simplexSolver(simplexSolver),
	  m_minkowskiA(objectA),
	  m_minkowskiB(objectB),
	  m_shapeTypeA(objectA->getShapeType()),
	  m_shapeTypeB(objectB->getShapeType()),
	  m_marginA(objectA->getMargin()),
	  m_marginB(objectB->getMargin()),
	  m_ignoreMargin(false),
	  m_lastUsedMethod(-1),
	  m_catchDegeneracies(1),
	  m_fixContactNormalDirection(1)
{
}
btGjkPairDetector::btGjkPairDetector(const btConvexShape *objectA, const btConvexShape *objectB, int shapeTypeA, int shapeTypeB, btScalar marginA, btScalar marginB, btSimplexSolverInterface *simplexSolver, btConvexPenetrationDepthSolver *penetrationDepthSolver)
	: m_cachedSeparatingAxis(btScalar(0.), btScalar(1.), btScalar(0.)),
	  m_penetrationDepthSolver(penetrationDepthSolver),
	  m_simplexSolver(simplexSolver),
	  m_minkowskiA(objectA),
	  m_minkowskiB(objectB),
	  m_shapeTypeA(shapeTypeA),
	  m_shapeTypeB(shapeTypeB),
	  m_marginA(marginA),
	  m_marginB(marginB),
	  m_ignoreMargin(false),
	  m_lastUsedMethod(-1),
	  m_catchDegeneracies(1),
	  m_fixContactNormalDirection(1)
{
}

void btGjkPairDetector::getClosestPoints(const ClosestPointInput &input, Result &output, class btIDebugDraw *debugDraw, bool swapResults)
{
	(void)swapResults;

	getClosestPointsNonVirtual(input, output, debugDraw);
}

static void btComputeSupport(const btConvexShape *convexA, const btTransform &localTransA, const btConvexShape *convexB, const btTransform &localTransB, const btVector3 &dir, bool check2d, btVector3 &supAworld, btVector3 &supBworld, btVector3 &aMinb)
{
	btVector3 separatingAxisInA = (dir)*localTransA.getBasis();
	btVector3 separatingAxisInB = (-dir) * localTransB.getBasis();

	btVector3 pInANoMargin = convexA->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInA);
	btVector3 qInBNoMargin = convexB->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInB);

	btVector3 pInA = pInANoMargin;
	btVector3 qInB = qInBNoMargin;

	supAworld = localTransA(pInA);
	supBworld = localTransB(qInB);

	if (check2d)
	{
		supAworld[2] = 0.f;
		supBworld[2] = 0.f;
	}

	aMinb = supAworld - supBworld;
}

struct btSupportVector
{
	btVector3 v;   //!< Support point in minkowski sum
	btVector3 v1;  //!< Support point in obj1
	btVector3 v2;  //!< Support point in obj2
};

struct btSimplex
{
	btSupportVector ps[4];
	int last;  //!< index of last added point
};

static btVector3 ccd_vec3_origin(0, 0, 0);

inline void btSimplexInit(btSimplex *s)
{
	s->last = -1;
}

inline int btSimplexSize(const btSimplex *s)
{
	return s->last + 1;
}

inline const btSupportVector *btSimplexPoint(const btSimplex *s, int idx)
{
	// here is no check on boundaries
	return &s->ps[idx];
}
inline void btSupportCopy(btSupportVector *d, const btSupportVector *s)
{
	*d = *s;
}

inline void btVec3Copy(btVector3 *v, const btVector3 *w)
{
	*v = *w;
}

inline void ccdVec3Add(btVector3 *v, const btVector3 *w)
{
	v->m_floats[0] += w->m_floats[0];
	v->m_floats[1] += w->m_floats[1];
	v->m_floats[2] += w->m_floats[2];
}

inline void ccdVec3Sub(btVector3 *v, const btVector3 *w)
{
	*v -= *w;
}
inline void btVec3Sub2(btVector3 *d, const btVector3 *v, const btVector3 *w)
{
	*d = (*v) - (*w);
}
inline btScalar btVec3Dot(const btVector3 *a, const btVector3 *b)
{
	btScalar dot;
	dot = a->dot(*b);

	return dot;
}

inline btScalar ccdVec3Dist2(const btVector3 *a, const btVector3 *b)
{
	btVector3 ab;
	btVec3Sub2(&ab, a, b);
	return btVec3Dot(&ab, &ab);
}

inline void btVec3Scale(btVector3 *d, btScalar k)
{
	d->m_floats[0] *= k;
	d->m_floats[1] *= k;
	d->m_floats[2] *= k;
}

inline void btVec3Cross(btVector3 *d, const btVector3 *a, const btVector3 *b)
{
	d->m_floats[0] = (a->m_floats[1] * b->m_floats[2]) - (a->m_floats[2] * b->m_floats[1]);
	d->m_floats[1] = (a->m_floats[2] * b->m_floats[0]) - (a->m_floats[0] * b->m_floats[2]);
	d->m_floats[2] = (a->m_floats[0] * b->m_floats[1]) - (a->m_floats[1] * b->m_floats[0]);
}

inline void btTripleCross(const btVector3 *a, const btVector3 *b,
						  const btVector3 *c, btVector3 *d)
{
	btVector3 e;
	btVec3Cross(&e, a, b);
	btVec3Cross(d, &e, c);
}

inline int ccdEq(btScalar _a, btScalar _b)
{
	btScalar ab;
	btScalar a, b;

	ab = btFabs(_a - _b);
	if (btFabs(ab) < SIMD_EPSILON)
		return 1;

	a = btFabs(_a);
	b = btFabs(_b);
	if (b > a)
	{
		return ab < SIMD_EPSILON * b;
	}
	else
	{
		return ab < SIMD_EPSILON * a;
	}
}

btScalar ccdVec3X(const btVector3 *v)
{
	return v->x();
}

btScalar ccdVec3Y(const btVector3 *v)
{
	return v->y();
}

btScalar ccdVec3Z(const btVector3 *v)
{
	return v->z();
}
inline int btVec3Eq(const btVector3 *a, const btVector3 *b)
{
	return ccdEq(ccdVec3X(a), ccdVec3X(b)) && ccdEq(ccdVec3Y(a), ccdVec3Y(b)) && ccdEq(ccdVec3Z(a), ccdVec3Z(b));
}

inline void btSimplexAdd(btSimplex *s, const btSupportVector *v)
{
	// here is no check on boundaries in sake of speed
	++s->last;
	btSupportCopy(s->ps + s->last, v);
}

inline void btSimplexSet(btSimplex *s, size_t pos, const btSupportVector *a)
{
	btSupportCopy(s->ps + pos, a);
}

inline void btSimplexSetSize(btSimplex *s, int size)
{
	s->last = size - 1;
}

inline const btSupportVector *ccdSimplexLast(const btSimplex *s)
{
	return btSimplexPoint(s, s->last);
}

inline int ccdSign(btScalar val)
{
	if (btFuzzyZero(val))
	{
		return 0;
	}
	else if (val < btScalar(0))
	{
		return -1;
	}
	return 1;
}

inline btScalar btVec3PointSegmentDist2(const btVector3 *P,
										const btVector3 *x0,
										const btVector3 *b,
										btVector3 *witness)
{
	// The computation comes from solving equation of segment:
	//      S(t) = x0 + t.d
	//          where - x0 is initial point of segment
	//                - d is direction of segment from x0 (|d| > 0)
	//                - t belongs to <0, 1> interval
	//
	// Than, distance from a segment to some point P can be expressed:
	//      D(t) = |x0 + t.d - P|^2
	//          which is distance from any point on segment. Minimization
	//          of this function brings distance from P to segment.
	// Minimization of D(t) leads to simple quadratic equation that's
	// solving is straightforward.
	//
	// Bonus of this method is witness point for free.

	btScalar dist, t;
	btVector3 d, a;

	// direction of segment
	btVec3Sub2(&d, b, x0);

	// precompute vector from P to x0
	btVec3Sub2(&a, x0, P);

	t = -btScalar(1.) * btVec3Dot(&a, &d);
	t /= btVec3Dot(&d, &d);

	if (t < btScalar(0) || btFuzzyZero(t))
	{
		dist = ccdVec3Dist2(x0, P);
		if (witness)
			btVec3Copy(witness, x0);
	}
	else if (t > btScalar(1) || ccdEq(t, btScalar(1)))
	{
		dist = ccdVec3Dist2(b, P);
		if (witness)
			btVec3Copy(witness, b);
	}
	else
	{
		if (witness)
		{
			btVec3Copy(witness, &d);
			btVec3Scale(witness, t);
			ccdVec3Add(witness, x0);
			dist = ccdVec3Dist2(witness, P);
		}
		else
		{
			// recycling variables
			btVec3Scale(&d, t);
			ccdVec3Add(&d, &a);
			dist = btVec3Dot(&d, &d);
		}
	}

	return dist;
}

btScalar btVec3PointTriDist2(const btVector3 *P,
							 const btVector3 *x0, const btVector3 *B,
							 const btVector3 *C,
							 btVector3 *witness)
{
	// Computation comes from analytic expression for triangle (x0, B, C)
	//      T(s, t) = x0 + s.d1 + t.d2, where d1 = B - x0 and d2 = C - x0 and
	// Then equation for distance is:
	//      D(s, t) = | T(s, t) - P |^2
	// This leads to minimization of quadratic function of two variables.
	// The solution from is taken only if s is between 0 and 1, t is
	// between 0 and 1 and t + s < 1, otherwise distance from segment is
	// computed.

	btVector3 d1, d2, a;
	double u, v, w, p, q, r;
	double s, t, dist, dist2;
	btVector3 witness2;

	btVec3Sub2(&d1, B, x0);
	btVec3Sub2(&d2, C, x0);
	btVec3Sub2(&a, x0, P);

	u = btVec3Dot(&a, &a);
	v = btVec3Dot(&d1, &d1);
	w = btVec3Dot(&d2, &d2);
	p = btVec3Dot(&a, &d1);
	q = btVec3Dot(&a, &d2);
	r = btVec3Dot(&d1, &d2);

	s = (q * r - w * p) / (w * v - r * r);
	t = (-s * r - q) / w;

	if ((btFuzzyZero(s) || s > btScalar(0)) && (ccdEq(s, btScalar(1)) || s < btScalar(1)) && (btFuzzyZero(t) || t > btScalar(0)) && (ccdEq(t, btScalar(1)) || t < btScalar(1)) && (ccdEq(t + s, btScalar(1)) || t + s < btScalar(1)))
	{
		if (witness)
		{
			btVec3Scale(&d1, s);
			btVec3Scale(&d2, t);
			btVec3Copy(witness, x0);
			ccdVec3Add(witness, &d1);
			ccdVec3Add(witness, &d2);

			dist = ccdVec3Dist2(witness, P);
		}
		else
		{
			dist = s * s * v;
			dist += t * t * w;
			dist += btScalar(2.) * s * t * r;
			dist += btScalar(2.) * s * p;
			dist += btScalar(2.) * t * q;
			dist += u;
		}
	}
	else
	{
		dist = btVec3PointSegmentDist2(P, x0, B, witness);

		dist2 = btVec3PointSegmentDist2(P, x0, C, &witness2);
		if (dist2 < dist)
		{
			dist = dist2;
			if (witness)
				btVec3Copy(witness, &witness2);
		}

		dist2 = btVec3PointSegmentDist2(P, B, C, &witness2);
		if (dist2 < dist)
		{
			dist = dist2;
			if (witness)
				btVec3Copy(witness, &witness2);
		}
	}

	return dist;
}

static int btDoSimplex2(btSimplex *simplex, btVector3 *dir)
{
	const btSupportVector *A, *B;
	btVector3 AB, AO, tmp;
	btScalar dot;

	// get last added as A
	A = ccdSimplexLast(simplex);
	// get the other point
	B = btSimplexPoint(simplex, 0);
	// compute AB oriented segment
	btVec3Sub2(&AB, &B->v, &A->v);
	// compute AO vector
	btVec3Copy(&AO, &A->v);
	btVec3Scale(&AO, -btScalar(1));

	// dot product AB . AO
	dot = btVec3Dot(&AB, &AO);

	// check if origin doesn't lie on AB segment
	btVec3Cross(&tmp, &AB, &AO);
	if (btFuzzyZero(btVec3Dot(&tmp, &tmp)) && dot > btScalar(0))
	{
		return 1;
	}

	// check if origin is in area where AB segment is
	if (btFuzzyZero(dot) || dot < btScalar(0))
	{
		// origin is in outside are of A
		btSimplexSet(simplex, 0, A);
		btSimplexSetSize(simplex, 1);
		btVec3Copy(dir, &AO);
	}
	else
	{
		// origin is in area where AB segment is

		// keep simplex untouched and set direction to
		// AB x AO x AB
		btTripleCross(&AB, &AO, &AB, dir);
	}

	return 0;
}

static int btDoSimplex3(btSimplex *simplex, btVector3 *dir)
{
	const btSupportVector *A, *B, *C;
	btVector3 AO, AB, AC, ABC, tmp;
	btScalar dot, dist;

	// get last added as A
	A = ccdSimplexLast(simplex);
	// get the other points
	B = btSimplexPoint(simplex, 1);
	C = btSimplexPoint(simplex, 0);

	// check touching contact
	dist = btVec3PointTriDist2(&ccd_vec3_origin, &A->v, &B->v, &C->v, 0);
	if (btFuzzyZero(dist))
	{
		return 1;
	}

	// check if triangle is really triangle (has area > 0)
	// if not simplex can't be expanded and thus no itersection is found
	if (btVec3Eq(&A->v, &B->v) || btVec3Eq(&A->v, &C->v))
	{
		return -1;
	}

	// compute AO vector
	btVec3Copy(&AO, &A->v);
	btVec3Scale(&AO, -btScalar(1));

	// compute AB and AC segments and ABC vector (perpendircular to triangle)
	btVec3Sub2(&AB, &B->v, &A->v);
	btVec3Sub2(&AC, &C->v, &A->v);
	btVec3Cross(&ABC, &AB, &AC);

	btVec3Cross(&tmp, &ABC, &AC);
	dot = btVec3Dot(&tmp, &AO);
	if (btFuzzyZero(dot) || dot > btScalar(0))
	{
		dot = btVec3Dot(&AC, &AO);
		if (btFuzzyZero(dot) || dot > btScalar(0))
		{
			// C is already in place
			btSimplexSet(simplex, 1, A);
			btSimplexSetSize(simplex, 2);
			btTripleCross(&AC, &AO, &AC, dir);
		}
		else
		{
			dot = btVec3Dot(&AB, &AO);
			if (btFuzzyZero(dot) || dot > btScalar(0))
			{
				btSimplexSet(simplex, 0, B);
				btSimplexSet(simplex, 1, A);
				btSimplexSetSize(simplex, 2);
				btTripleCross(&AB, &AO, &AB, dir);
			}
			else
			{
				btSimplexSet(simplex, 0, A);
				btSimplexSetSize(simplex, 1);
				btVec3Copy(dir, &AO);
			}
		}
	}
	else
	{
		btVec3Cross(&tmp, &AB, &ABC);
		dot = btVec3Dot(&tmp, &AO);
		if (btFuzzyZero(dot) || dot > btScalar(0))
		{
			dot = btVec3Dot(&AB, &AO);
			if (btFuzzyZero(dot) || dot > btScalar(0))
			{
				btSimplexSet(simplex, 0, B);
				btSimplexSet(simplex, 1, A);
				btSimplexSetSize(simplex, 2);
				btTripleCross(&AB, &AO, &AB, dir);
			}
			else
			{
				btSimplexSet(simplex, 0, A);
				btSimplexSetSize(simplex, 1);
				btVec3Copy(dir, &AO);
			}
		}
		else
		{
			dot = btVec3Dot(&ABC, &AO);
			if (btFuzzyZero(dot) || dot > btScalar(0))
			{
				btVec3Copy(dir, &ABC);
			}
			else
			{
				btSupportVector tmp;
				btSupportCopy(&tmp, C);
				btSimplexSet(simplex, 0, B);
				btSimplexSet(simplex, 1, &tmp);

				btVec3Copy(dir, &ABC);
				btVec3Scale(dir, -btScalar(1));
			}
		}
	}

	return 0;
}

static int btDoSimplex4(btSimplex *simplex, btVector3 *dir)
{
	const btSupportVector *A, *B, *C, *D;
	btVector3 AO, AB, AC, AD, ABC, ACD, ADB;
	int B_on_ACD, C_on_ADB, D_on_ABC;
	int AB_O, AC_O, AD_O;
	btScalar dist;

	// get last added as A
	A = ccdSimplexLast(simplex);
	// get the other points
	B = btSimplexPoint(simplex, 2);
	C = btSimplexPoint(simplex, 1);
	D = btSimplexPoint(simplex, 0);

	// check if tetrahedron is really tetrahedron (has volume > 0)
	// if it is not simplex can't be expanded and thus no intersection is
	// found
	dist = btVec3PointTriDist2(&A->v, &B->v, &C->v, &D->v, 0);
	if (btFuzzyZero(dist))
	{
		return -1;
	}

	// check if origin lies on some of tetrahedron's face - if so objects
	// intersect
	dist = btVec3PointTriDist2(&ccd_vec3_origin, &A->v, &B->v, &C->v, 0);
	if (btFuzzyZero(dist))
		return 1;
	dist = btVec3PointTriDist2(&ccd_vec3_origin, &A->v, &C->v, &D->v, 0);
	if (btFuzzyZero(dist))
		return 1;
	dist = btVec3PointTriDist2(&ccd_vec3_origin, &A->v, &B->v, &D->v, 0);
	if (btFuzzyZero(dist))
		return 1;
	dist = btVec3PointTriDist2(&ccd_vec3_origin, &B->v, &C->v, &D->v, 0);
	if (btFuzzyZero(dist))
		return 1;

	// compute AO, AB, AC, AD segments and ABC, ACD, ADB normal vectors
	btVec3Copy(&AO, &A->v);
	btVec3Scale(&AO, -btScalar(1));
	btVec3Sub2(&AB, &B->v, &A->v);
	btVec3Sub2(&AC, &C->v, &A->v);
	btVec3Sub2(&AD, &D->v, &A->v);
	btVec3Cross(&ABC, &AB, &AC);
	btVec3Cross(&ACD, &AC, &AD);
	btVec3Cross(&ADB, &AD, &AB);

	// side (positive or negative) of B, C, D relative to planes ACD, ADB
	// and ABC respectively
	B_on_ACD = ccdSign(btVec3Dot(&ACD, &AB));
	C_on_ADB = ccdSign(btVec3Dot(&ADB, &AC));
	D_on_ABC = ccdSign(btVec3Dot(&ABC, &AD));

	// whether origin is on same side of ACD, ADB, ABC as B, C, D
	// respectively
	AB_O = ccdSign(btVec3Dot(&ACD, &AO)) == B_on_ACD;
	AC_O = ccdSign(btVec3Dot(&ADB, &AO)) == C_on_ADB;
	AD_O = ccdSign(btVec3Dot(&ABC, &AO)) == D_on_ABC;

	if (AB_O && AC_O && AD_O)
	{
		// origin is in tetrahedron
		return 1;
		// rearrange simplex to triangle and call btDoSimplex3()
	}
	else if (!AB_O)
	{
		// B is farthest from the origin among all of the tetrahedron's
		// points, so remove it from the list and go on with the triangle
		// case

		// D and C are in place
		btSimplexSet(simplex, 2, A);
		btSimplexSetSize(simplex, 3);
	}
	else if (!AC_O)
	{
		// C is farthest
		btSimplexSet(simplex, 1, D);
		btSimplexSet(simplex, 0, B);
		btSimplexSet(simplex, 2, A);
		btSimplexSetSize(simplex, 3);
	}
	else
	{  // (!AD_O)
		btSimplexSet(simplex, 0, C);
		btSimplexSet(simplex, 1, B);
		btSimplexSet(simplex, 2, A);
		btSimplexSetSize(simplex, 3);
	}

	return btDoSimplex3(simplex, dir);
}

static int btDoSimplex(btSimplex *simplex, btVector3 *dir)
{
	if (btSimplexSize(simplex) == 2)
	{
		// simplex contains segment only one segment
		return btDoSimplex2(simplex, dir);
	}
	else if (btSimplexSize(simplex) == 3)
	{
		// simplex contains triangle
		return btDoSimplex3(simplex, dir);
	}
	else
	{  // btSimplexSize(simplex) == 4
		// tetrahedron - this is the only shape which can encapsule origin
		// so btDoSimplex4() also contains test on it
		return btDoSimplex4(simplex, dir);
	}
}

#ifdef __SPU__
void btGjkPairDetector::getClosestPointsNonVirtual(const ClosestPointInput &input, Result &output, class btIDebugDraw *debugDraw)
#else
void btGjkPairDetector::getClosestPointsNonVirtual(const ClosestPointInput &input, Result &output, class btIDebugDraw *debugDraw)
#endif
{
	m_cachedSeparatingDistance = 0.f;

	btScalar distance = btScalar(0.);
	btVector3 normalInB(btScalar(0.), btScalar(0.), btScalar(0.));

	btVector3 pointOnA, pointOnB;
	btTransform localTransA = input.m_transformA;
	btTransform localTransB = input.m_transformB;
	btVector3 positionOffset = (localTransA.getOrigin() + localTransB.getOrigin()) * btScalar(0.5);
	localTransA.getOrigin() -= positionOffset;
	localTransB.getOrigin() -= positionOffset;

	bool check2d = m_minkowskiA->isConvex2d() && m_minkowskiB->isConvex2d();

	btScalar marginA = m_marginA;
	btScalar marginB = m_marginB;


	//for CCD we don't use margins
	if (m_ignoreMargin)
	{
		marginA = btScalar(0.);
		marginB = btScalar(0.);
	}

	m_curIter = 0;
	int gGjkMaxIter = 1000;  //this is to catch invalid input, perhaps check for #NaN?
	m_cachedSeparatingAxis.setValue(0, 1, 0);

	bool isValid = false;
	bool checkSimplex = false;
	bool checkPenetration = true;
	m_degenerateSimplex = 0;

	m_lastUsedMethod = -1;
	int status = -2;
	btVector3 orgNormalInB(0, 0, 0);
	btScalar margin = marginA + marginB;

	//we add a separate implementation to check if the convex shapes intersect
	//See also "Real-time Collision Detection with Implicit Objects" by Leif Olvang
	//Todo: integrate the simplex penetration check directly inside the Bullet btVoronoiSimplexSolver
	//and remove this temporary code from libCCD
	//this fixes issue https://github.com/bulletphysics/bullet3/issues/1703
	//note, for large differences in shapes, use double precision build!
	{
		btScalar squaredDistance = BT_LARGE_FLOAT;
		btScalar delta = btScalar(0.);

		btSimplex simplex1;
		btSimplex *simplex = &simplex1;
		btSimplexInit(simplex);

		btVector3 dir(1, 0, 0);

		{
			btVector3 lastSupV;
			btVector3 supAworld;
			btVector3 supBworld;
			btComputeSupport(m_minkowskiA, localTransA, m_minkowskiB, localTransB, dir, check2d, supAworld, supBworld, lastSupV);

			btSupportVector last;
			last.v = lastSupV;
			last.v1 = supAworld;
			last.v2 = supBworld;

			btSimplexAdd(simplex, &last);

			dir = -lastSupV;

			// start iterations
			for (int iterations = 0; iterations < gGjkMaxIter; iterations++)
			{
				// obtain support point
				btComputeSupport(m_minkowskiA, localTransA, m_minkowskiB, localTransB, dir, check2d, supAworld, supBworld, lastSupV);

				// check if farthest point in Minkowski difference in direction dir
				// isn't somewhere before origin (the test on negative dot product)
				// - because if it is, objects are not intersecting at all.
				btScalar delta = lastSupV.dot(dir);
				if (delta < 0)
				{
					//no intersection, besides margin
					status = -1;
					break;
				}

				// add last support vector to simplex
				last.v = lastSupV;
				last.v1 = supAworld;
				last.v2 = supBworld;

				btSimplexAdd(simplex, &last);

				// if btDoSimplex returns 1 if objects intersect, -1 if objects don't
				// intersect and 0 if algorithm should continue

				btVector3 newDir;
				int do_simplex_res = btDoSimplex(simplex, &dir);

				if (do_simplex_res == 1)
				{
					status = 0;  // intersection found
					break;
				}
				else if (do_simplex_res == -1)
				{
					// intersection not found
					status = -1;
					break;
				}

				if (btFuzzyZero(btVec3Dot(&dir, &dir)))
				{
					// intersection not found
					status = -1;
				}

				if (dir.length2() < SIMD_EPSILON)
				{
					//no intersection, besides margin
					status = -1;
					break;
				}

				if (dir.fuzzyZero())
				{
					// intersection not found
					status = -1;
					break;
				}
			}
		}

		m_simplexSolver->reset();
		if (status == 0)
		{
			//status = 0;
			//printf("Intersect!\n");
		}

		if (status == -1)
		{
			//printf("not intersect\n");
		}
		//printf("dir=%f,%f,%f\n",dir[0],dir[1],dir[2]);
		if (1)
		{
			for (;;)
			//while (true)
			{
				btVector3 separatingAxisInA = (-m_cachedSeparatingAxis) * localTransA.getBasis();
				btVector3 separatingAxisInB = m_cachedSeparatingAxis * localTransB.getBasis();

				btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInA);
				btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInB);

				btVector3 pWorld = localTransA(pInA);
				btVector3 qWorld = localTransB(qInB);

				if (check2d)
				{
					pWorld[2] = 0.f;
					qWorld[2] = 0.f;
				}

				btVector3 w = pWorld - qWorld;
				delta = m_cachedSeparatingAxis.dot(w);

				// potential exit, they don't overlap
				if ((delta > btScalar(0.0)) && (delta * delta > squaredDistance * input.m_maximumDistanceSquared))
				{
					m_degenerateSimplex = 10;
					checkSimplex = true;
					//checkPenetration = false;
					break;
				}

				//exit 0: the new point is already in the simplex, or we didn't come any closer
				if (m_simplexSolver->inSimplex(w))
				{
					m_degenerateSimplex = 1;
					checkSimplex = true;
					break;
				}
				// are we getting any closer ?
				btScalar f0 = squaredDistance - delta;
				btScalar f1 = squaredDistance * REL_ERROR2;

				if (f0 <= f1)
				{
					if (f0 <= btScalar(0.))
					{
						m_degenerateSimplex = 2;
					}
					else
					{
						m_degenerateSimplex = 11;
					}
					checkSimplex = true;
					break;
				}

				//add current vertex to simplex
				m_simplexSolver->addVertex(w, pWorld, qWorld);
				btVector3 newCachedSeparatingAxis;

				//calculate the closest point to the origin (update vector v)
				if (!m_simplexSolver->closest(newCachedSeparatingAxis))
				{
					m_degenerateSimplex = 3;
					checkSimplex = true;
					break;
				}

				if (newCachedSeparatingAxis.length2() < REL_ERROR2)
				{
					m_cachedSeparatingAxis = newCachedSeparatingAxis;
					m_degenerateSimplex = 6;
					checkSimplex = true;
					break;
				}

				btScalar previousSquaredDistance = squaredDistance;
				squaredDistance = newCachedSeparatingAxis.length2();
#if 0
				///warning: this termination condition leads to some problems in 2d test case see Bullet/Demos/Box2dDemo
				if (squaredDistance > previousSquaredDistance)
				{
					m_degenerateSimplex = 7;
					squaredDistance = previousSquaredDistance;
					checkSimplex = false;
					break;
				}
#endif  //

				//redundant m_simplexSolver->compute_points(pointOnA, pointOnB);

				//are we getting any closer ?
				if (previousSquaredDistance - squaredDistance <= SIMD_EPSILON * previousSquaredDistance)
				{
					//				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
					checkSimplex = true;
					m_degenerateSimplex = 12;

					break;
				}

				m_cachedSeparatingAxis = newCachedSeparatingAxis;

				//degeneracy, this is typically due to invalid/uninitialized worldtransforms for a btCollisionObject
				if (m_curIter++ > gGjkMaxIter)
				{
#if defined(DEBUG) || defined(_DEBUG)

					printf("btGjkPairDetector maxIter exceeded:%i\n", m_curIter);
					printf("sepAxis=(%f,%f,%f), squaredDistance = %f, shapeTypeA=%i,shapeTypeB=%i\n",
						   m_cachedSeparatingAxis.getX(),
						   m_cachedSeparatingAxis.getY(),
						   m_cachedSeparatingAxis.getZ(),
						   squaredDistance,
						   m_minkowskiA->getShapeType(),
						   m_minkowskiB->getShapeType());

#endif
					break;
				}

				bool check = (!m_simplexSolver->fullSimplex());
				//bool check = (!m_simplexSolver->fullSimplex() && squaredDistance > SIMD_EPSILON * m_simplexSolver->maxVertex());

				if (!check)
				{
					//do we need this backup_closest here ?
					//				m_simplexSolver->backup_closest(m_cachedSeparatingAxis);
					m_degenerateSimplex = 13;
					break;
				}
			}

			if (checkSimplex)
			{
				m_simplexSolver->compute_points(pointOnA, pointOnB);
				normalInB = m_cachedSeparatingAxis;

				btScalar lenSqr = m_cachedSeparatingAxis.length2();

				//valid normal
				if (lenSqr < REL_ERROR2)
				{
					m_degenerateSimplex = 5;
				}
				if (lenSqr > SIMD_EPSILON * SIMD_EPSILON)
				{
					btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
					normalInB *= rlen;  //normalize

					btScalar s = btSqrt(squaredDistance);

					btAssert(s > btScalar(0.0));
					pointOnA -= m_cachedSeparatingAxis * (marginA / s);
					pointOnB += m_cachedSeparatingAxis * (marginB / s);
					distance = ((btScalar(1.) / rlen) - margin);
					isValid = true;
					orgNormalInB = normalInB;

					m_lastUsedMethod = 1;
				}
				else
				{
					m_lastUsedMethod = 2;
				}
			}
		}

		bool catchDegeneratePenetrationCase =
			(m_catchDegeneracies && m_penetrationDepthSolver && m_degenerateSimplex && ((distance + margin) < gGjkEpaPenetrationTolerance));

		//if (checkPenetration && !isValid)
		if ((checkPenetration && (!isValid || catchDegeneratePenetrationCase)) || (status == 0))
		{
			//penetration case

			//if there is no way to handle penetrations, bail out
			if (m_penetrationDepthSolver)
			{
				// Penetration depth case.
				btVector3 tmpPointOnA, tmpPointOnB;

				m_cachedSeparatingAxis.setZero();

				bool isValid2 = m_penetrationDepthSolver->calcPenDepth(
					*m_simplexSolver,
					m_minkowskiA, m_minkowskiB,
					localTransA, localTransB,
					m_cachedSeparatingAxis, tmpPointOnA, tmpPointOnB,
					debugDraw);

				if (m_cachedSeparatingAxis.length2())
				{
					if (isValid2)
					{
						btVector3 tmpNormalInB = tmpPointOnB - tmpPointOnA;
						btScalar lenSqr = tmpNormalInB.length2();
						if (lenSqr <= (SIMD_EPSILON * SIMD_EPSILON))
						{
							tmpNormalInB = m_cachedSeparatingAxis;
							lenSqr = m_cachedSeparatingAxis.length2();
						}

						if (lenSqr > (SIMD_EPSILON * SIMD_EPSILON))
						{
							tmpNormalInB /= btSqrt(lenSqr);
							btScalar distance2 = -(tmpPointOnA - tmpPointOnB).length();
							m_lastUsedMethod = 3;
							//only replace valid penetrations when the result is deeper (check)
							if (!isValid || (distance2 < distance))
							{
								distance = distance2;
								pointOnA = tmpPointOnA;
								pointOnB = tmpPointOnB;
								normalInB = tmpNormalInB;
								isValid = true;
							}
							else
							{
								m_lastUsedMethod = 8;
							}
						}
						else
						{
							m_lastUsedMethod = 9;
						}
					}
					else

					{
						///this is another degenerate case, where the initial GJK calculation reports a degenerate case
						///EPA reports no penetration, and the second GJK (using the supporting vector without margin)
						///reports a valid positive distance. Use the results of the second GJK instead of failing.
						///thanks to Jacob.Langford for the reproduction case
						///http://code.google.com/p/bullet/issues/detail?id=250

						if (m_cachedSeparatingAxis.length2() > btScalar(0.))
						{
							btScalar distance2 = (tmpPointOnA - tmpPointOnB).length() - margin;
							//only replace valid distances when the distance is less
							if (!isValid || (distance2 < distance))
							{
								distance = distance2;
								pointOnA = tmpPointOnA;
								pointOnB = tmpPointOnB;
								pointOnA -= m_cachedSeparatingAxis * marginA;
								pointOnB += m_cachedSeparatingAxis * marginB;
								normalInB = m_cachedSeparatingAxis;
								normalInB.normalize();

								isValid = true;
								m_lastUsedMethod = 6;
							}
							else
							{
								m_lastUsedMethod = 5;
							}
						}
					}
				}
				else
				{
					//printf("EPA didn't return a valid value\n");
				}
			}
		}
	}

	if (isValid && ((distance < 0) || (distance * distance < input.m_maximumDistanceSquared)))
	{
		m_cachedSeparatingAxis = normalInB;
		m_cachedSeparatingDistance = distance;
		if (1)
		{
			///todo: need to track down this EPA penetration solver degeneracy
			///the penetration solver reports penetration but the contact normal
			///connecting the contact points is pointing in the opposite direction
			///until then, detect the issue and revert the normal

			btScalar d2 = 0.f;
			{
				btVector3 separatingAxisInA = (-orgNormalInB) * localTransA.getBasis();
				btVector3 separatingAxisInB = orgNormalInB * localTransB.getBasis();

				btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInA);
				btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInB);

				btVector3 pWorld = localTransA(pInA);
				btVector3 qWorld = localTransB(qInB);
				btVector3 w = pWorld - qWorld;
				d2 = orgNormalInB.dot(w) - margin;
			}

			btScalar d1 = 0;
			{
				btVector3 separatingAxisInA = (normalInB)*localTransA.getBasis();
				btVector3 separatingAxisInB = -normalInB * localTransB.getBasis();

				btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInA);
				btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInB);

				btVector3 pWorld = localTransA(pInA);
				btVector3 qWorld = localTransB(qInB);
				btVector3 w = pWorld - qWorld;
				d1 = (-normalInB).dot(w) - margin;
			}
			btScalar d0 = 0.f;
			{
				btVector3 separatingAxisInA = (-normalInB) * input.m_transformA.getBasis();
				btVector3 separatingAxisInB = normalInB * input.m_transformB.getBasis();

				btVector3 pInA = m_minkowskiA->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInA);
				btVector3 qInB = m_minkowskiB->localGetSupportVertexWithoutMarginNonVirtual(separatingAxisInB);

				btVector3 pWorld = localTransA(pInA);
				btVector3 qWorld = localTransB(qInB);
				btVector3 w = pWorld - qWorld;
				d0 = normalInB.dot(w) - margin;
			}

			if (d1 > d0)
			{
				m_lastUsedMethod = 10;
				normalInB *= -1;
			}

			if (orgNormalInB.length2())
			{
				if (d2 > d0 && d2 > d1 && d2 > distance)
				{
					normalInB = orgNormalInB;
					distance = d2;
				}
			}
		}

		output.addContactPoint(
			normalInB,
			pointOnB + positionOffset,
			distance);
	}
	else
	{
		//printf("invalid gjk query\n");
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GJK_PAIR_DETECTOR_H
#define BT_GJK_PAIR_DETECTOR_H

#include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

class btConvexShape;
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
class btConvexPenetrationDepthSolver;

/// btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface
class btGjkPairDetector : public btDiscreteCollisionDetectorInterface
{
	btVector3 m_cachedSeparatingAxis;
	btConvexPenetrationDepthSolver* m_penetrationDepthSolver;
	btSimplexSolverInterface* m_simplexSolver;
	const btConvexShape* m_minkowskiA;
	const btConvexShape* m_minkowskiB;
	int m_shapeTypeA;
	int m_shapeTypeB;
	btScalar m_marginA;
	btScalar m_marginB;

	bool m_ignoreMargin;
	btScalar m_cachedSeparatingDistance;

public:
	//some debugging to fix degeneracy problems
	int m_lastUsedMethod;
	int m_curIter;
	int m_degenerateSimplex;
	int m_catchDegeneracies;
	int m_fixContactNormalDirection;

	btGjkPairDetector(const btConvexShape* objectA, const btConvexShape* objectB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);
	btGjkPairDetector(const btConvexShape* objectA, const btConvexShape* objectB, int shapeTypeA, int shapeTypeB, btScalar marginA, btScalar marginB, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);
	virtual ~btGjkPairDetector(){};

	virtual void getClosestPoints(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw, bool swapResults = false);

	void getClosestPointsNonVirtual(const ClosestPointInput& input, Result& output, class btIDebugDraw* debugDraw);

	void setMinkowskiA(const btConvexShape* minkA)
	{
		m_minkowskiA = minkA;
	}

	void setMinkowskiB(const btConvexShape* minkB)
	{
		m_minkowskiB = minkB;
	}
	void setCachedSeparatingAxis(const btVector3& separatingAxis)
	{
		m_cachedSeparatingAxis = separatingAxis;
	}

	const btVector3& getCachedSeparatingAxis() const
	{
		return m_cachedSeparatingAxis;
	}
	btScalar getCachedSeparatingDistance() const
	{
		return m_cachedSeparatingDistance;
	}

	void setPenetrationDepthSolver(btConvexPenetrationDepthSolver* penetrationDepthSolver)
	{
		m_penetrationDepthSolver = penetrationDepthSolver;
	}

	///don't use setIgnoreMargin, it's for Bullet's internal use
	void setIgnoreMargin(bool ignoreMargin)
	{
		m_ignoreMargin = ignoreMargin;
	}
};

#endif  //BT_GJK_PAIR_DETECTOR_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"

#include "BulletCollision/CollisionShapes/btMinkowskiSumShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
#include "BulletCollision/NarrowPhaseCollision/btPointCollector.h"
#include "LinearMath/btTransformUtil.h"

btSubsimplexConvexCast::btSubsimplexConvexCast(const btConvexShape* convexA, const btConvexShape* convexB, btSimplexSolverInterface* simplexSolver)
	: m_simplexSolver(simplexSolver),
	  m_convexA(convexA),
	  m_convexB(convexB)
{
}


bool btSubsimplexConvexCast::calcTimeOfImpact(
	const btTransform& fromA,
	const btTransform& toA,
	const btTransform& fromB,
	const btTransform& toB,
	CastResult& result)
{
	m_simplexSolver->reset();

	btVector3 linVelA, linVelB;
	linVelA = toA.getOrigin() - fromA.getOrigin();
	linVelB = toB.getOrigin() - fromB.getOrigin();

	btScalar lambda = btScalar(0.);

	btTransform interpolatedTransA = fromA;
	btTransform interpolatedTransB = fromB;

	///take relative motion
	btVector3 r = (linVelA - linVelB);
	btVector3 v;

	btVector3 supVertexA = fromA(m_convexA->localGetSupportingVertex(-r * fromA.getBasis()));
	btVector3 supVertexB = fromB(m_convexB->localGetSupportingVertex(r * fromB.getBasis()));
	v = supVertexA - supVertexB;
	int maxIter = result.m_subSimplexCastMaxIterations;

	btVector3 n;
	n.setValue(btScalar(0.), btScalar(0.), btScalar(0.));

	btVector3 c;

	btScalar dist2 = v.length2();



	btVector3 w, p;
	btScalar VdotR;

	while ((dist2 > result.m_subSimplexCastEpsilon) && maxIter--)
	{
		supVertexA = interpolatedTransA(m_convexA->localGetSupportingVertex(-v * interpolatedTransA.getBasis()));
		supVertexB = interpolatedTransB(m_convexB->localGetSupportingVertex(v * interpolatedTransB.getBasis()));
		w = supVertexA - supVertexB;

		btScalar VdotW = v.dot(w);

		if (lambda > btScalar(1.0))
		{
			return false;
		}

		if (VdotW > btScalar(0.))
		{
			VdotR = v.dot(r);

			if (VdotR >= -(SIMD_EPSILON * SIMD_EPSILON))
				return false;
			else
			{
				lambda = lambda - VdotW / VdotR;
				//interpolate to next lambda
				//	x = s + lambda * r;
				interpolatedTransA.getOrigin().setInterpolate3(fromA.getOrigin(), toA.getOrigin(), lambda);
				interpolatedTransB.getOrigin().setInterpolate3(fromB.getOrigin(), toB.getOrigin(), lambda);
				//m_simplexSolver->reset();
				//check next line
				w = supVertexA - supVertexB;

				n = v;
			}
		}
		///Just like regular GJK only add the vertex if it isn't already (close) to current vertex, it would lead to divisions by zero and NaN etc.
		if (!m_simplexSolver->inSimplex(w))
			m_simplexSolver->addVertex(w, supVertexA, supVertexB);

		if (m_simplexSolver->closest(v))
		{
			dist2 = v.length2();

			//todo: check this normal for validity
			//n=v;
			//printf("V=%f , %f, %f\n",v[0],v[1],v[2]);
			//printf("DIST2=%f\n",dist2);
			//printf("numverts = %i\n",m_simplexSolver->numVertices());
		}
		else
		{
			dist2 = btScalar(0.);
		}
	}

	//int numiter = MAX_ITERATIONS - maxIter;
	//	printf("number of iterations: %d", numiter);

	//don't report a time of impact when moving 'away' from the hitnormal

	result.m_fraction = lambda;
	if (n.length2() >= (SIMD_EPSILON * SIMD_EPSILON))
		result.m_normal = n.normalized();
	else
		result.m_normal = btVector3(btScalar(0.0), btScalar(0.0), btScalar(0.0));

	//don't report time of impact for motion away from the contact normal (or causes minor penetration)
	if (result.m_normal.dot(r) >= -result.m_allowedPenetration)
		return false;

	btVector3 hitA, hitB;
	m_simplexSolver->compute_points(hitA, hitB);
	result.m_hitPoint = hitB;
	return true;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SUBSIMPLEX_CONVEX_CAST_H
#define BT_SUBSIMPLEX_CONVEX_CAST_H

#include "BulletCollision/NarrowPhaseCollision/btConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btSimplexSolverInterface.h"
class btConvexShape;

/// btSubsimplexConvexCast implements Gino van den Bergens' paper
///"Ray Casting against bteral Convex Objects with Application to Continuous Collision Detection"
/// GJK based Ray Cast, optimized version
/// Objects should not start in overlap, otherwise results are not defined.
class btSubsimplexConvexCast : public btConvexCast
{
	btSimplexSolverInterface* m_simplexSolver;
	const btConvexShape* m_convexA;
	const btConvexShape* m_convexB;

public:
	btSubsimplexConvexCast(const btConvexShape* shapeA, const btConvexShape* shapeB, btSimplexSolverInterface* simplexSolver);

	//virtual ~btSubsimplexConvexCast();
	///SimsimplexConvexCast calculateTimeOfImpact calculates the time of impact+normal for the linear cast (sweep) between two moving objects.
	///Precondition is that objects should not penetration/overlap at the start from the interval. Overlap can be tested using btGjkPairDetector.
	virtual bool calcTimeOfImpact(
		const btTransform& fromA,
		const btTransform& toA,
		const btTransform& fromB,
		const btTransform& toB,
		CastResult& result);
};

#endif  //BT_SUBSIMPLEX_CONVEX_CAST_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btStridingMeshInterface.h"
#include "LinearMath/btSerializer.h"

btStridingMeshInterface::~btStridingMeshInterface()
{
}

void btStridingMeshInterface::InternalProcessAllTriangles(btInternalTriangleIndexCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	(void)aabbMin;
	(void)aabbMax;
	int numtotalphysicsverts = 0;
	int part, graphicssubparts = getNumSubParts();
	const unsigned char* vertexbase;
	const unsigned char* indexbase;
	int indexstride;
	PHY_ScalarType type;
	PHY_ScalarType gfxindextype;
	int stride, numverts, numtriangles;
	int gfxindex;
	btVector3 triangle[3];

	btVector3 meshScaling = getScaling();

	///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
	for (part = 0; part < graphicssubparts; part++)
	{
		getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numtriangles, gfxindextype, part);
		numtotalphysicsverts += numtriangles * 3;  //upper bound

		///unlike that developers want to pass in double-precision meshes in single-precision Bullet build
		///so disable this feature by default
		///see patch http://code.google.com/p/bullet/issues/detail?id=213

		switch (type)
		{
			case PHY_FLOAT:
			{
				float* graphicsbase;

				switch (gfxindextype)
				{
					case PHY_INTEGER:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex * indexstride);
							graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					case PHY_SHORT:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex * indexstride);
							graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					case PHY_UCHAR:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex * indexstride);
							graphicsbase = (float*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (float*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue(graphicsbase[0] * meshScaling.getX(), graphicsbase[1] * meshScaling.getY(), graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					default:
						btAssert((gfxindextype == PHY_INTEGER) || (gfxindextype == PHY_SHORT));
				}
				break;
			}

			case PHY_DOUBLE:
			{
				double* graphicsbase;

				switch (gfxindextype)
				{
					case PHY_INTEGER:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex * indexstride);
							graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					case PHY_SHORT:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex * indexstride);
							graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					case PHY_UCHAR:
					{
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex * indexstride);
							graphicsbase = (double*)(vertexbase + tri_indices[0] * stride);
							triangle[0].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[1] * stride);
							triangle[1].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							graphicsbase = (double*)(vertexbase + tri_indices[2] * stride);
							triangle[2].setValue((btScalar)graphicsbase[0] * meshScaling.getX(), (btScalar)graphicsbase[1] * meshScaling.getY(), (btScalar)graphicsbase[2] * meshScaling.getZ());
							callback->internalProcessTriangleIndex(triangle, part, gfxindex);
						}
						break;
					}
					default:
						btAssert((gfxindextype == PHY_INTEGER) || (gfxindextype == PHY_SHORT));
				}
				break;
			}
			default:
				btAssert((type == PHY_FLOAT) || (type == PHY_DOUBLE));
		}

		unLockReadOnlyVertexBase(part);
	}
}

void btStridingMeshInterface::calculateAabbBruteForce(btVector3& aabbMin, btVector3& aabbMax)
{
	struct AabbCalculationCallback : public btInternalTriangleIndexCallback
	{
		btVector3 m_aabbMin;
		btVector3 m_aabbMax;

		AabbCalculationCallback()
		{
			m_aabbMin.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
			m_aabbMax.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
		}

		virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
		{
			(void)partId;
			(void)triangleIndex;

			m_aabbMin.setMin(triangle[0]);
			m_aabbMax.setMax(triangle[0]);
			m_aabbMin.setMin(triangle[1]);
			m_aabbMax.setMax(triangle[1]);
			m_aabbMin.setMin(triangle[2]);
			m_aabbMax.setMax(triangle[2]);
		}
	};

	//first calculate the total aabb for all triangles
	AabbCalculationCallback aabbCallback;
	aabbMin.setValue(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
	aabbMax.setValue(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
	InternalProcessAllTriangles(&aabbCallback, aabbMin, aabbMax);

	aabbMin = aabbCallback.m_aabbMin;
	aabbMax = aabbCallback.m_aabbMax;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btStridingMeshInterface::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btStridingMeshInterfaceData* trimeshData = (btStridingMeshInterfaceData*)dataBuffer;

	trimeshData->m_numMeshParts = getNumSubParts();

	//void* uniquePtr = 0;

	trimeshData->m_meshPartsPtr = 0;

	if (trimeshData->m_numMeshParts)
	{
		btChunk* chunk = serializer->allocate(sizeof(btMeshPartData), trimeshData->m_numMeshParts);
		btMeshPartData* memPtr = (btMeshPartData*)chunk->m_oldPtr;
		trimeshData->m_meshPartsPtr = (btMeshPartData*)serializer->getUniquePointer(memPtr);

		//	int numtotalphysicsverts = 0;
		int part, graphicssubparts = getNumSubParts();
		const unsigned char* vertexbase;
		const unsigned char* indexbase;
		int indexstride;
		PHY_ScalarType type;
		PHY_ScalarType gfxindextype;
		int stride, numverts, numtriangles;
		int gfxindex;
		//	btVector3 triangle[3];

		//	btVector3 meshScaling = getScaling();

		///if the number of parts is big, the performance might drop due to the innerloop switch on indextype
		for (part = 0; part < graphicssubparts; part++, memPtr++)
		{
			getLockedReadOnlyVertexIndexBase(&vertexbase, numverts, type, stride, &indexbase, indexstride, numtriangles, gfxindextype, part);
			memPtr->m_numTriangles = numtriangles;  //indices = 3*numtriangles
			memPtr->m_numVertices = numverts;
			memPtr->m_indices16 = 0;
			memPtr->m_indices32 = 0;
			memPtr->m_3indices16 = 0;
			memPtr->m_3indices8 = 0;
			memPtr->m_vertices3f = 0;
			memPtr->m_vertices3d = 0;

			switch (gfxindextype)
			{
				case PHY_INTEGER:
				{
					int numindices = numtriangles * 3;

					if (numindices)
					{
						btChunk* chunk = serializer->allocate(sizeof(btIntIndexData), numindices);
						btIntIndexData* tmpIndices = (btIntIndexData*)chunk->m_oldPtr;
						memPtr->m_indices32 = (btIntIndexData*)serializer->getUniquePointer(tmpIndices);
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned int* tri_indices = (unsigned int*)(indexbase + gfxindex * indexstride);
							tmpIndices[gfxindex * 3].m_value = tri_indices[0];
							tmpIndices[gfxindex * 3 + 1].m_value = tri_indices[1];
							tmpIndices[gfxindex * 3 + 2].m_value = tri_indices[2];
						}
						serializer->finalizeChunk(chunk, "btIntIndexData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
					}
					break;
				}
				case PHY_SHORT:
				{
					if (numtriangles)
					{
						btChunk* chunk = serializer->allocate(sizeof(btShortIntIndexTripletData), numtriangles);
						btShortIntIndexTripletData* tmpIndices = (btShortIntIndexTripletData*)chunk->m_oldPtr;
						memPtr->m_3indices16 = (btShortIntIndexTripletData*)serializer->getUniquePointer(tmpIndices);
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned short int* tri_indices = (unsigned short int*)(indexbase + gfxindex * indexstride);
							tmpIndices[gfxindex].m_values[0] = tri_indices[0];
							tmpIndices[gfxindex].m_values[1] = tri_indices[1];
							tmpIndices[gfxindex].m_values[2] = tri_indices[2];
							// Fill padding with zeros to appease msan.
							tmpIndices[gfxindex].m_pad[0] = 0;
							tmpIndices[gfxindex].m_pad[1] = 0;
						}
						serializer->finalizeChunk(chunk, "btShortIntIndexTripletData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
					}
					break;
				}
				case PHY_UCHAR:
				{
					if (numtriangles)
					{
						btChunk* chunk = serializer->allocate(sizeof(btCharIndexTripletData), numtriangles);
						btCharIndexTripletData* tmpIndices = (btCharIndexTripletData*)chunk->m_oldPtr;
						memPtr->m_3indices8 = (btCharIndexTripletData*)serializer->getUniquePointer(tmpIndices);
						for (gfxindex = 0; gfxindex < numtriangles; gfxindex++)
						{
							unsigned char* tri_indices = (unsigned char*)(indexbase + gfxindex * indexstride);
							tmpIndices[gfxindex].m_values[0] = tri_indices[0];
							tmpIndices[gfxindex].m_values[1] = tri_indices[1];
							tmpIndices[gfxindex].m_values[2] = tri_indices[2];
							// Fill padding with zeros to appease msan.
							tmpIndices[gfxindex].m_pad = 0;
						}
						serializer->finalizeChunk(chunk, "btCharIndexTripletData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
					}
					break;
				}
				default:
				{
					btAssert(0);
					//unknown index type
				}
			}

			switch (type)
			{
				case PHY_FLOAT:
				{
					float* graphicsbase;

					if (numverts)
					{
						btChunk* chunk = serializer->allocate(sizeof(btVector3FloatData), numverts);
						btVector3FloatData* tmpVertices = (btVector3FloatData*)chunk->m_oldPtr;
						memPtr->m_vertices3f = (btVector3FloatData*)serializer->getUniquePointer(tmpVertices);
						for (int i = 0; i < numverts; i++)
						{
							graphicsbase = (float*)(vertexbase + i * stride);
							tmpVertices[i].m_floats[0] = graphicsbase[0];
							tmpVertices[i].m_floats[1] = graphicsbase[1];
							tmpVertices[i].m_floats[2] = graphicsbase[2];
						}
						serializer->finalizeChunk(chunk, "btVector3FloatData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
					}
					break;
				}

				case PHY_DOUBLE:
				{
					if (numverts)
					{
						btChunk* chunk = serializer->allocate(sizeof(btVector3DoubleData), numverts);
						btVector3DoubleData* tmpVertices = (btVector3DoubleData*)chunk->m_oldPtr;
						memPtr->m_vertices3d = (btVector3DoubleData*)serializer->getUniquePointer(tmpVertices);
						for (int i = 0; i < numverts; i++)
						{
							double* graphicsbase = (double*)(vertexbase + i * stride);  //for now convert to float, might leave it at double
							tmpVertices[i].m_floats[0] = graphicsbase[0];
							tmpVertices[i].m_floats[1] = graphicsbase[1];
							tmpVertices[i].m_floats[2] = graphicsbase[2];
						}
						serializer->finalizeChunk(chunk, "btVector3DoubleData", BT_ARRAY_CODE, (void*)chunk->m_oldPtr);
					}
					break;
				}

				default:
					btAssert((type == PHY_FLOAT) || (type == PHY_DOUBLE));
			}

			unLockReadOnlyVertexBase(part);
		}

		serializer->finalizeChunk(chunk, "btMeshPartData", BT_ARRAY_CODE, chunk->m_oldPtr);
	}

	// Fill padding with zeros to appease msan.
	memset(trimeshData->m_padding, 0, sizeof(trimeshData->m_padding));

	m_scaling.serializeFloat(trimeshData->m_scaling);
	return "btStridingMeshInterfaceData";
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h"

#include "LinearMath/btTransformUtil.h"

btHeightfieldTerrainShape::btHeightfieldTerrainShape(
	int heightStickWidth, int heightStickLength,
	const float* heightfieldData, btScalar minHeight, btScalar maxHeight,
	int upAxis, bool flipQuadEdges)
	: m_userValue3(0), m_triangleInfoMap(0)
{
	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   /*heightScale=*/1, minHeight, maxHeight, upAxis, PHY_FLOAT,
			   flipQuadEdges);
}

btHeightfieldTerrainShape::btHeightfieldTerrainShape(
	int heightStickWidth, int heightStickLength, const double* heightfieldData,
	btScalar minHeight, btScalar maxHeight, int upAxis, bool flipQuadEdges)
	: m_userValue3(0), m_triangleInfoMap(0)
{
	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   /*heightScale=*/1, minHeight, maxHeight, upAxis, PHY_DOUBLE,
			   flipQuadEdges);
}

btHeightfieldTerrainShape::btHeightfieldTerrainShape(
	int heightStickWidth, int heightStickLength, const short* heightfieldData, btScalar heightScale,
	btScalar minHeight, btScalar maxHeight, int upAxis, bool flipQuadEdges)
	: m_userValue3(0), m_triangleInfoMap(0)
{
	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   heightScale, minHeight, maxHeight, upAxis, PHY_SHORT,
			   flipQuadEdges);
}

btHeightfieldTerrainShape::btHeightfieldTerrainShape(
	int heightStickWidth, int heightStickLength, const unsigned char* heightfieldData, btScalar heightScale,
	btScalar minHeight, btScalar maxHeight, int upAxis, bool flipQuadEdges)
	: m_userValue3(0), m_triangleInfoMap(0)
{
	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   heightScale, minHeight, maxHeight, upAxis, PHY_UCHAR,
			   flipQuadEdges);
}

btHeightfieldTerrainShape::btHeightfieldTerrainShape(
	int heightStickWidth, int heightStickLength, const void* heightfieldData,
	btScalar heightScale, btScalar minHeight, btScalar maxHeight, int upAxis,
	PHY_ScalarType hdt, bool flipQuadEdges)
	:m_userValue3(0),
	m_triangleInfoMap(0)
{
	// legacy constructor: Assumes PHY_FLOAT means btScalar.
#ifdef BT_USE_DOUBLE_PRECISION
	if (hdt == PHY_FLOAT) hdt = PHY_DOUBLE;
#endif
	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   heightScale, minHeight, maxHeight, upAxis, hdt,
			   flipQuadEdges);
}

btHeightfieldTerrainShape::btHeightfieldTerrainShape(int heightStickWidth, int heightStickLength, const void* heightfieldData, btScalar maxHeight, int upAxis, bool useFloatData, bool flipQuadEdges)
	:	m_userValue3(0),
	m_triangleInfoMap(0)
{
	// legacy constructor: support only btScalar or unsigned char data,
	// and min height is zero.
	PHY_ScalarType hdt = (useFloatData) ? PHY_FLOAT : PHY_UCHAR;
#ifdef BT_USE_DOUBLE_PRECISION
	if (hdt == PHY_FLOAT) hdt = PHY_DOUBLE;
#endif
	btScalar minHeight = 0.0f;

	// previously, height = uchar * maxHeight / 65535.
	// So to preserve legacy behavior, heightScale = maxHeight / 65535
	btScalar heightScale = maxHeight / 65535;

	initialize(heightStickWidth, heightStickLength, heightfieldData,
			   heightScale, minHeight, maxHeight, upAxis, hdt,
			   flipQuadEdges);
}

void btHeightfieldTerrainShape::initialize(
	int heightStickWidth, int heightStickLength, const void* heightfieldData,
	btScalar heightScale, btScalar minHeight, btScalar maxHeight, int upAxis,
	PHY_ScalarType hdt, bool flipQuadEdges)
{
	// validation
	btAssert(heightStickWidth > 1);   // && "bad width");
	btAssert(heightStickLength > 1);  // && "bad length");
	btAssert(heightfieldData);        // && "null heightfield data");
	// btAssert(heightScale) -- do we care?  Trust caller here
	btAssert(minHeight <= maxHeight);                                    // && "bad min/max height");
	btAssert(upAxis >= 0 && upAxis < 3);                                 // && "bad upAxis--should be in range [0,2]");
	btAssert(hdt != PHY_UCHAR || hdt != PHY_FLOAT || hdt != PHY_DOUBLE || hdt != PHY_SHORT);  // && "Bad height data type enum");

	// initialize member variables
	m_shapeType = TERRAIN_SHAPE_PROXYTYPE;
	m_heightStickWidth = heightStickWidth;
	m_heightStickLength = heightStickLength;
	m_minHeight = minHeight;
	m_maxHeight = maxHeight;
	m_width = (btScalar)(heightStickWidth - 1);
	m_length = (btScalar)(heightStickLength - 1);
	m_heightScale = heightScale;
	m_heightfieldDataUnknown = heightfieldData;
	m_heightDataType = hdt;
	m_flipQuadEdges = flipQuadEdges;
	m_useDiamondSubdivision = false;
	m_useZigzagSubdivision = false;
	m_flipTriangleWinding = false;
	m_upAxis = upAxis;
	m_localScaling.setValue(btScalar(1.), btScalar(1.), btScalar(1.));
	
	m_vboundsChunkSize = 0;
	m_vboundsGridWidth = 0;
	m_vboundsGridLength = 0;

	// determine min/max axis-aligned bounding box (aabb) values
	switch (m_upAxis)
	{
		case 0:
		{
			m_localAabbMin.setValue(m_minHeight, 0, 0);
			m_localAabbMax.setValue(m_maxHeight, m_width, m_length);
			break;
		}
		case 1:
		{
			m_localAabbMin.setValue(0, m_minHeight, 0);
			m_localAabbMax.setValue(m_width, m_maxHeight, m_length);
			break;
		};
		case 2:
		{
			m_localAabbMin.setValue(0, 0, m_minHeight);
			m_localAabbMax.setValue(m_width, m_length, m_maxHeight);
			break;
		}
		default:
		{
			//need to get valid m_upAxis
			btAssert(0);  // && "Bad m_upAxis");
		}
	}

	// remember origin (defined as exact middle of aabb)
	m_localOrigin = btScalar(0.5) * (m_localAabbMin + m_localAabbMax);
}

btHeightfieldTerrainShape::~btHeightfieldTerrainShape()
{
	clearAccelerator();
}

void btHeightfieldTerrainShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	btVector3 halfExtents = (m_localAabbMax - m_localAabbMin) * m_localScaling * btScalar(0.5);

	btVector3 localOrigin(0, 0, 0);
	localOrigin[m_upAxis] = (m_minHeight + m_maxHeight) * btScalar(0.5);
	localOrigin *= m_localScaling;

	btMatrix3x3 abs_b = t.getBasis().absolute();
	btVector3 center = t.getOrigin();
	btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
	extent += btVector3(getMargin(), getMargin(), getMargin());

	aabbMin = center - extent;
	aabbMax = center + extent;
}

/// This returns the "raw" (user's initial) height, not the actual height.
/// The actual height needs to be adjusted to be relative to the center
///   of the heightfield's AABB.
btScalar
btHeightfieldTerrainShape::getRawHeightFieldValue(int x, int y) const
{
	btScalar val = 0.f;
	switch (m_heightDataType)
	{
		case PHY_FLOAT:
		{
			val = m_heightfieldDataFloat[(y * m_heightStickWidth) + x];
			break;
		}

		case PHY_DOUBLE:
		{
			val = m_heightfieldDataDouble[(y * m_heightStickWidth) + x];
			break;
		}

		case PHY_UCHAR:
		{
			unsigned char heightFieldValue = m_heightfieldDataUnsignedChar[(y * m_heightStickWidth) + x];
			val = heightFieldValue * m_heightScale;
			break;
		}

		case PHY_SHORT:
		{
			short hfValue = m_heightfieldDataShort[(y * m_heightStickWidth) + x];
			val = hfValue * m_heightScale;
			break;
		}

		default:
		{
			btAssert(!"Bad m_heightDataType");
		}
	}

	return val;
}

/// this returns the vertex in bullet-local coordinates
void btHeightfieldTerrainShape::getVertex(int x, int y, btVector3& vertex) const
{
	btAssert(x >= 0);
	btAssert(y >= 0);
	btAssert(x < m_heightStickWidth);
	btAssert(y < m_heightStickLength);

	btScalar height = getRawHeightFieldValue(x, y);

	switch (m_upAxis)
	{
		case 0:
		{
			vertex.setValue(
				height - m_localOrigin.getX(),
				(-m_width / btScalar(2.0)) + x,
				(-m_length / btScalar(2.0)) + y);
			break;
		}
		case 1:
		{
			vertex.setValue(
				(-m_width / btScalar(2.0)) + x,
				height - m_localOrigin.getY(),
				(-m_length / btScalar(2.0)) + y);
			break;
		};
		case 2:
		{
			vertex.setValue(
				(-m_width / btScalar(2.0)) + x,
				(-m_length / btScalar(2.0)) + y,
				height - m_localOrigin.getZ());
			break;
		}
		default:
		{
			//need to get valid m_upAxis
			btAssert(0);
		}
	}

	vertex *= m_localScaling;
}

static inline int
getQuantized(
	btScalar x)
{
	if (x < 0.0)
	{
		return (int)(x - 0.5);
	}
	return (int)(x + 0.5);
}

// Equivalent to std::minmax({a, b, c}).
// Performs at most 3 comparisons.
static btHeightfieldTerrainShape::Range minmaxRange(btScalar a, btScalar b, btScalar c)
{
	if (a > b)
	{
		if (b > c)
			return btHeightfieldTerrainShape::Range(c, a);
		else if (a > c)
			return btHeightfieldTerrainShape::Range(b, a);
		else
			return btHeightfieldTerrainShape::Range(b, c);
	}
	else
	{
		if (a > c)
			return btHeightfieldTerrainShape::Range(c, b);
		else if (b > c)
			return btHeightfieldTerrainShape::Range(a, b);
		else
			return btHeightfieldTerrainShape::Range(a, c);
	}
}

/// given input vector, return quantized version
/**
  This routine is basically determining the gridpoint indices for a given
  input vector, answering the question: "which gridpoint is closest to the
  provided point?".

  "with clamp" means that we restrict the point to be in the heightfield's
  axis-aligned bounding box.
 */
void btHeightfieldTerrainShape::quantizeWithClamp(int* out, const btVector3& point, int /*isMax*/) const
{
	btVector3 clampedPoint(point);
	clampedPoint.setMax(m_localAabbMin);
	clampedPoint.setMin(m_localAabbMax);

	out[0] = getQuantized(clampedPoint.getX());
	out[1] = getQuantized(clampedPoint.getY());
	out[2] = getQuantized(clampedPoint.getZ());
}

/// process all triangles within the provided axis-aligned bounding box
/**
  basic algorithm:
    - convert input aabb to local coordinates (scale down and shift for local origin)
    - convert input aabb to a range of heightfield grid points (quantize)
    - iterate over all triangles in that subset of the grid
 */
void btHeightfieldTerrainShape::processAllTriangles(btTriangleCallback* callback, const btVector3& aabbMin, const btVector3& aabbMax) const
{
	// scale down the input aabb's so they are in local (non-scaled) coordinates
	btVector3 localAabbMin = aabbMin * btVector3(1.f / m_localScaling[0], 1.f / m_localScaling[1], 1.f / m_localScaling[2]);
	btVector3 localAabbMax = aabbMax * btVector3(1.f / m_localScaling[0], 1.f / m_localScaling[1], 1.f / m_localScaling[2]);

	// account for local origin
	localAabbMin += m_localOrigin;
	localAabbMax += m_localOrigin;

	//quantize the aabbMin and aabbMax, and adjust the start/end ranges
	int quantizedAabbMin[3];
	int quantizedAabbMax[3];
	quantizeWithClamp(quantizedAabbMin, localAabbMin, 0);
	quantizeWithClamp(quantizedAabbMax, localAabbMax, 1);

	// expand the min/max quantized values
	// this is to catch the case where the input aabb falls between grid points!
	for (int i = 0; i < 3; ++i)
	{
		quantizedAabbMin[i]--;
		quantizedAabbMax[i]++;
	}

	int startX = 0;
	int endX = m_heightStickWidth - 1;
	int startJ = 0;
	int endJ = m_heightStickLength - 1;

	switch (m_upAxis)
	{
		case 0:
		{
			if (quantizedAabbMin[1] > startX)
				startX = quantizedAabbMin[1];
			if (quantizedAabbMax[1] < endX)
				endX = quantizedAabbMax[1];
			if (quantizedAabbMin[2] > startJ)
				startJ = quantizedAabbMin[2];
			if (quantizedAabbMax[2] < endJ)
				endJ = quantizedAabbMax[2];
			break;
		}
		case 1:
		{
			if (quantizedAabbMin[0] > startX)
				startX = quantizedAabbMin[0];
			if (quantizedAabbMax[0] < endX)
				endX = quantizedAabbMax[0];
			if (quantizedAabbMin[2] > startJ)
				startJ = quantizedAabbMin[2];
			if (quantizedAabbMax[2] < endJ)
				endJ = quantizedAabbMax[2];
			break;
		};
		case 2:
		{
			if (quantizedAabbMin[0] > startX)
				startX = quantizedAabbMin[0];
			if (quantizedAabbMax[0] < endX)
				endX = quantizedAabbMax[0];
			if (quantizedAabbMin[1] > startJ)
				startJ = quantizedAabbMin[1];
			if (quantizedAabbMax[1] < endJ)
				endJ = quantizedAabbMax[1];
			break;
		}
		default:
		{
			//need to get valid m_upAxis
			btAssert(0);
		}
	}

	// TODO If m_vboundsGrid is available, use it to determine if we really need to process this area
	
	const Range aabbUpRange(aabbMin[m_upAxis], aabbMax[m_upAxis]);
	for (int j = startJ; j < endJ; j++)
	{
		for (int x = startX; x < endX; x++)
		{
			btVector3 vertices[3];
			int indices[3] = { 0, 1, 2 };
			if (m_flipTriangleWinding)
			{
				indices[0] = 2;
				indices[2] = 0;
			}

			if (m_flipQuadEdges || (m_useDiamondSubdivision && !((j + x) & 1)) || (m_useZigzagSubdivision && !(j & 1)))
			{
				getVertex(x, j, vertices[indices[0]]);
				getVertex(x, j + 1, vertices[indices[1]]);
				getVertex(x + 1, j + 1, vertices[indices[2]]);

				// Skip triangle processing if the triangle is out-of-AABB.
				Range upRange = minmaxRange(vertices[0][m_upAxis], vertices[1][m_upAxis], vertices[2][m_upAxis]);

				if (upRange.overlaps(aabbUpRange))
					callback->processTriangle(vertices, 2 * x, j);
			
				// already set: getVertex(x, j, vertices[indices[0]])

				// equivalent to: getVertex(x + 1, j + 1, vertices[indices[1]]);
				vertices[indices[1]] = vertices[indices[2]];

				getVertex(x + 1, j, vertices[indices[2]]);
				upRange.min = btMin(upRange.min, vertices[indices[2]][m_upAxis]);
				upRange.max = btMax(upRange.max, vertices[indices[2]][m_upAxis]);

				if (upRange.overlaps(aabbUpRange))
					callback->processTriangle(vertices, 2 * x + 1, j);
			}
			else
			{
				getVertex(x, j, vertices[indices[0]]);
				getVertex(x, j + 1, vertices[indices[1]]);
				getVertex(x + 1, j, vertices[indices[2]]);

				// Skip triangle processing if the triangle is out-of-AABB.
				Range upRange = minmaxRange(vertices[0][m_upAxis], vertices[1][m_upAxis], vertices[2][m_upAxis]);

				if (upRange.overlaps(aabbUpRange))
					callback->processTriangle(vertices, 2 * x, j);

				// already set: getVertex(x, j + 1, vertices[indices[1]]);

				// equivalent to: getVertex(x + 1, j, vertices[indices[0]]);
				vertices[indices[0]] = vertices[indices[2]];

				getVertex(x + 1, j + 1, vertices[indices[2]]);
				upRange.min = btMin(upRange.min, vertices[indices[2]][m_upAxis]);
				upRange.max = btMax(upRange.max, vertices[indices[2]][m_upAxis]);

				if (upRange.overlaps(aabbUpRange))
					callback->processTriangle(vertices, 2 * x + 1, j);
			}
		}
	}
}

void btHeightfieldTerrainShape::calculateLocalInertia(btScalar, btVector3& inertia) const
{
	//moving concave objects not supported

	inertia.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
}

void btHeightfieldTerrainShape::setLocalScaling(const btVector3& scaling)
{
	m_localScaling = scaling;
}
const btVector3& btHeightfieldTerrainShape::getLocalScaling() const
{
	return m_localScaling;
}

namespace
{
	struct GridRaycastState
	{
		int x;  // Next quad coords
		int z;
		int prev_x;  // Previous quad coords
		int prev_z;
		btScalar param;      // Exit param for previous quad
		btScalar prevParam;  // Enter param for previous quad
		btScalar maxDistanceFlat;
		btScalar maxDistance3d;
	};
}

// TODO Does it really need to take 3D vectors?
/// Iterates through a virtual 2D grid of unit-sized square cells,
/// and executes an action on each cell intersecting the given segment, ordered from begin to end.
/// Initially inspired by http://www.cse.yorku.ca/~amana/research/grid.pdf
template <typename Action_T>
void gridRaycast(Action_T& quadAction, const btVector3& beginPos, const btVector3& endPos, int indices[3])
{
	GridRaycastState rs;
	rs.maxDistance3d = beginPos.distance(endPos);
	if (rs.maxDistance3d < 0.0001)
	{
		// Consider the ray is too small to hit anything
		return;
	}
	

	btScalar rayDirectionFlatX = endPos[indices[0]] - beginPos[indices[0]];
	btScalar rayDirectionFlatZ = endPos[indices[2]] - beginPos[indices[2]];
	rs.maxDistanceFlat = btSqrt(rayDirectionFlatX * rayDirectionFlatX + rayDirectionFlatZ * rayDirectionFlatZ);

	if (rs.maxDistanceFlat < 0.0001)
	{
		// Consider the ray vertical
		rayDirectionFlatX = 0;
		rayDirectionFlatZ = 0;
	}
	else
	{
		rayDirectionFlatX /= rs.maxDistanceFlat;
		rayDirectionFlatZ /= rs.maxDistanceFlat;
	}

	const int xiStep = rayDirectionFlatX > 0 ? 1 : rayDirectionFlatX < 0 ? -1 : 0;
	const int ziStep = rayDirectionFlatZ > 0 ? 1 : rayDirectionFlatZ < 0 ? -1 : 0;

	const float infinite = 9999999;
	const btScalar paramDeltaX = xiStep != 0 ? 1.f / btFabs(rayDirectionFlatX) : infinite;
	const btScalar paramDeltaZ = ziStep != 0 ? 1.f / btFabs(rayDirectionFlatZ) : infinite;

	// pos = param * dir
	btScalar paramCrossX;  // At which value of `param` we will cross a x-axis lane?
	btScalar paramCrossZ;  // At which value of `param` we will cross a z-axis lane?

	// paramCrossX and paramCrossZ are initialized as being the first cross
	// X initialization
	if (xiStep != 0)
	{
		if (xiStep == 1)
		{
			paramCrossX = (ceil(beginPos[indices[0]]) - beginPos[indices[0]]) * paramDeltaX;
		}
		else
		{
			paramCrossX = (beginPos[indices[0]] - floor(beginPos[indices[0]])) * paramDeltaX;
		}
	}
	else
	{
		paramCrossX = infinite;  // Will never cross on X
	}

	// Z initialization
	if (ziStep != 0)
	{
		if (ziStep == 1)
		{
			paramCrossZ = (ceil(beginPos[indices[2]]) - beginPos[indices[2]]) * paramDeltaZ;
		}
		else
		{
			paramCrossZ = (beginPos[indices[2]] - floor(beginPos[indices[2]])) * paramDeltaZ;
		}
	}
	else
	{
		paramCrossZ = infinite;  // Will never cross on Z
	}

	rs.x = static_cast<int>(floor(beginPos[indices[0]]));
	rs.z = static_cast<int>(floor(beginPos[indices[2]]));

	// Workaround cases where the ray starts at an integer position
	if (paramCrossX == 0.0)
	{
		paramCrossX += paramDeltaX;
		// If going backwards, we should ignore the position we would get by the above flooring,
		// because the ray is not heading in that direction
		if (xiStep == -1)
		{
			rs.x -= 1;
		}
	}

	if (paramCrossZ == 0.0)
	{
		paramCrossZ += paramDeltaZ;
		if (ziStep == -1)
			rs.z -= 1;
	}

	rs.prev_x = rs.x;
	rs.prev_z = rs.z;
	rs.param = 0;

	while (true)
	{
		rs.prev_x = rs.x;
		rs.prev_z = rs.z;
		rs.prevParam = rs.param;

		if (paramCrossX < paramCrossZ)
		{
			// X lane
			rs.x += xiStep;
			// Assign before advancing the param,
			// to be in sync with the initialization step
			rs.param = paramCrossX;
			paramCrossX += paramDeltaX;
		}
		else
		{
			// Z lane
			rs.z += ziStep;
			rs.param = paramCrossZ;
			paramCrossZ += paramDeltaZ;
		}

		if (rs.param > rs.maxDistanceFlat)
		{
			rs.param = rs.maxDistanceFlat;
			quadAction(rs);
			break;
		}
		else
		{
			quadAction(rs);
		}
	}
}

struct ProcessTrianglesAction
{
	const btHeightfieldTerrainShape* shape;
	bool flipQuadEdges;
	bool useDiamondSubdivision;
	int width;
	int length;
	btTriangleCallback* callback;

	void exec(int x, int z) const
	{
		if (x < 0 || z < 0 || x >= width || z >= length)
		{
			return;
		}

		btVector3 vertices[3];

		// TODO Since this is for raycasts, we could greatly benefit from an early exit on the first hit

		// Check quad
		if (flipQuadEdges || (useDiamondSubdivision && (((z + x) & 1) > 0)))
		{
			// First triangle
			shape->getVertex(x, z, vertices[0]);
			shape->getVertex(x + 1, z, vertices[1]);
			shape->getVertex(x + 1, z + 1, vertices[2]);
			callback->processTriangle(vertices, x, z);

			// Second triangle
			shape->getVertex(x, z, vertices[0]);
			shape->getVertex(x + 1, z + 1, vertices[1]);
			shape->getVertex(x, z + 1, vertices[2]);
			callback->processTriangle(vertices, x, z);
		}
		else
		{
			// First triangle
			shape->getVertex(x, z, vertices[0]);
			shape->getVertex(x, z + 1, vertices[1]);
			shape->getVertex(x + 1, z, vertices[2]);
			callback->processTriangle(vertices, x, z);

			// Second triangle
			shape->getVertex(x + 1, z, vertices[0]);
			shape->getVertex(x, z + 1, vertices[1]);
			shape->getVertex(x + 1, z + 1, vertices[2]);
			callback->processTriangle(vertices, x, z);
		}
	}

	void operator()(const GridRaycastState& bs) const
	{
		exec(bs.prev_x, bs.prev_z);
	}
};

struct ProcessVBoundsAction
{
	const btAlignedObjectArray<btHeightfieldTerrainShape::Range>& vbounds;
	int width;
	int length;
	int chunkSize;

	btVector3 rayBegin;
	btVector3 rayEnd;
	btVector3 rayDir;

	int* m_indices;
	ProcessTrianglesAction processTriangles;

	ProcessVBoundsAction(const btAlignedObjectArray<btHeightfieldTerrainShape::Range>& bnd, int* indices)
		: vbounds(bnd),
		m_indices(indices)
	{
	}
	void operator()(const GridRaycastState& rs) const
	{
		int x = rs.prev_x;
		int z = rs.prev_z;

		if (x < 0 || z < 0 || x >= width || z >= length)
		{
			return;
		}

		const btHeightfieldTerrainShape::Range chunk = vbounds[x + z * width];

		btVector3 enterPos;
		btVector3 exitPos;

		if (rs.maxDistanceFlat > 0.0001)
		{
			btScalar flatTo3d = chunkSize * rs.maxDistance3d / rs.maxDistanceFlat;
			btScalar enterParam3d = rs.prevParam * flatTo3d;
			btScalar exitParam3d = rs.param * flatTo3d;
			enterPos = rayBegin + rayDir * enterParam3d;
			exitPos = rayBegin + rayDir * exitParam3d;

			// We did enter the flat projection of the AABB,
			// but we have to check if we intersect it on the vertical axis
			if (enterPos[1] > chunk.max && exitPos[m_indices[1]] > chunk.max)
			{
				return;
			}
			if (enterPos[1] < chunk.min && exitPos[m_indices[1]] < chunk.min)
			{
				return;
			}
		}
		else
		{
			// Consider the ray vertical
			// (though we shouldn't reach this often because there is an early check up-front)
			enterPos = rayBegin;
			exitPos = rayEnd;
		}

		gridRaycast(processTriangles, enterPos, exitPos, m_indices);
		// Note: it could be possible to have more than one grid at different levels,
		// to do this there would be a branch using a pointer to another ProcessVBoundsAction
	}
};

// TODO How do I interrupt the ray when there is a hit? `callback` does not return any result
/// Performs a raycast using a hierarchical Bresenham algorithm.
/// Does not allocate any memory by itself.
void btHeightfieldTerrainShape::performRaycast(btTriangleCallback* callback, const btVector3& raySource, const btVector3& rayTarget) const
{
	// Transform to cell-local
	btVector3 beginPos = raySource / m_localScaling;
	btVector3 endPos = rayTarget / m_localScaling;
	beginPos += m_localOrigin;
	endPos += m_localOrigin;

	ProcessTrianglesAction processTriangles;
	processTriangles.shape = this;
	processTriangles.flipQuadEdges = m_flipQuadEdges;
	processTriangles.useDiamondSubdivision = m_useDiamondSubdivision;
	processTriangles.callback = callback;
	processTriangles.width = m_heightStickWidth - 1;
	processTriangles.length = m_heightStickLength - 1;

	// TODO Transform vectors to account for m_upAxis
	int indices[3] = { 0, 1, 2 };
	if (m_upAxis == 2)
	{
		indices[1] = 2;
		indices[2] = 1;
	}
	int iBeginX = static_cast<int>(floor(beginPos[indices[0]]));
	int iBeginZ = static_cast<int>(floor(beginPos[indices[2]]));
	int iEndX = static_cast<int>(floor(endPos[indices[0]]));
	int iEndZ = static_cast<int>(floor(endPos[indices[2]]));

	if (iBeginX == iEndX && iBeginZ == iEndZ)
	{
		// The ray will never cross quads within the plane,
		// so directly process triangles within one quad
		// (typically, vertical rays should end up here)
		processTriangles.exec(iBeginX, iEndZ);
		return;
	}

	

	if (m_vboundsGrid.size()==0)
	{
		// Process all quads intersecting the flat projection of the ray
		gridRaycast(processTriangles, beginPos, endPos, &indices[0]);
	}
	else
	{
		btVector3 rayDiff = endPos - beginPos;
		btScalar flatDistance2 = rayDiff[indices[0]] * rayDiff[indices[0]] + rayDiff[indices[2]] * rayDiff[indices[2]];
		if (flatDistance2 < m_vboundsChunkSize * m_vboundsChunkSize)
		{
			// Don't use chunks, the ray is too short in the plane
			gridRaycast(processTriangles, beginPos, endPos, &indices[0]);
			return;
		}

		ProcessVBoundsAction processVBounds(m_vboundsGrid, &indices[0]);
		processVBounds.width = m_vboundsGridWidth;
		processVBounds.length = m_vboundsGridLength;
		processVBounds.rayBegin = beginPos;
		processVBounds.rayEnd = endPos;
		processVBounds.rayDir = rayDiff.normalized();
		processVBounds.processTriangles = processTriangles;
		processVBounds.chunkSize = m_vboundsChunkSize;
		// The ray is long, run raycast on a higher-level grid
		gridRaycast(processVBounds, beginPos / m_vboundsChunkSize, endPos / m_vboundsChunkSize, indices);
	}
}

/// Builds a grid data structure storing the min and max heights of the terrain in chunks.
/// if chunkSize is zero, that accelerator is removed.
/// If you modify the heights, you need to rebuild this accelerator.
void btHeightfieldTerrainShape::buildAccelerator(int chunkSize)
{
	if (chunkSize <= 0)
	{
		clearAccelerator();
		return;
	}

	m_vboundsChunkSize = chunkSize;
	int nChunksX = m_heightStickWidth / chunkSize;
	int nChunksZ = m_heightStickLength / chunkSize;

	if (m_heightStickWidth % chunkSize > 0)
	{
		++nChunksX;  // In case terrain size isn't dividable by chunk size
	}
	if (m_heightStickLength % chunkSize > 0)
	{
		++nChunksZ;
	}

	if (m_vboundsGridWidth != nChunksX || m_vboundsGridLength != nChunksZ)
	{
		clearAccelerator();
		m_vboundsGridWidth = nChunksX;
		m_vboundsGridLength = nChunksZ;
	}

	if (nChunksX == 0 || nChunksZ == 0)
	{
		return;
	}

	// This data structure is only reallocated if the required size changed
	m_vboundsGrid.resize(nChunksX * nChunksZ);
	
	// Compute min and max height for all chunks
	for (int cz = 0; cz < nChunksZ; ++cz)
	{
		int z0 = cz * chunkSize;

		for (int cx = 0; cx < nChunksX; ++cx)
		{
			int x0 = cx * chunkSize;

			Range r;

			r.min = getRawHeightFieldValue(x0, z0);
			r.max = r.min;

			// Compute min and max height for this chunk.
			// We have to include one extra cell to account for neighbors.
			// Here is why:
			// Say we have a flat terrain, and a plateau that fits a chunk perfectly.
			//
			//   Left        Right
			// 0---0---0---1---1---1
			// |   |   |   |   |   |
			// 0---0---0---1---1---1
			// |   |   |   |   |   |
			// 0---0---0---1---1---1
			//           x
			//
			// If the AABB for the Left chunk did not share vertices with the Right,
			// then we would fail collision tests at x due to a gap.
			//
			for (int z = z0; z < z0 + chunkSize + 1; ++z)
			{
				if (z >= m_heightStickLength)
				{
					continue;
				}

				for (int x = x0; x < x0 + chunkSize + 1; ++x)
				{
					if (x >= m_heightStickWidth)
					{
						continue;
					}

					btScalar height = getRawHeightFieldValue(x, z);

					if (height < r.min)
					{
						r.min = height;
					}
					else if (height > r.max)
					{
						r.max = height;
					}
				}
			}

			m_vboundsGrid[cx + cz * nChunksX] = r;
		}
	}
}

void btHeightfieldTerrainShape::clearAccelerator()
{
	m_vboundsGrid.clear();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_HEIGHTFIELD_TERRAIN_SHAPE_H
#define BT_HEIGHTFIELD_TERRAIN_SHAPE_H

#include "BulletCollision/CollisionShapes/btConcaveShape.h"
#include "LinearMath/btAlignedObjectArray.h"

///btHeightfieldTerrainShape simulates a 2D heightfield terrain
/**
  The caller is responsible for maintaining the heightfield array; this
  class does not make a copy.

  The heightfield can be dynamic so long as the min/max height values
  capture the extremes (heights must always be in that range).

  The local origin of the heightfield is assumed to be the exact
  center (as determined by width and length and height, with each
  axis multiplied by the localScaling).

  \b NOTE: be careful with coordinates.  If you have a heightfield with a local
  min height of -100m, and a max height of +500m, you may be tempted to place it
  at the origin (0,0) and expect the heights in world coordinates to be
  -100 to +500 meters.
  Actually, the heights will be -300 to +300m, because bullet will re-center
  the heightfield based on its AABB (which is determined by the min/max
  heights).  So keep in mind that once you create a btHeightfieldTerrainShape
  object, the heights will be adjusted relative to the center of the AABB.  This
  is different to the behavior of many rendering engines, but is useful for
  physics engines.

  Most (but not all) rendering and heightfield libraries assume upAxis = 1
  (that is, the y-axis is "up").  This class allows any of the 3 coordinates
  to be "up".  Make sure your choice of axis is consistent with your rendering
  system.

  The heightfield heights are determined from the data type used for the
  heightfieldData array.  

   - unsigned char: height at a point is the uchar value at the
       grid point, multipled by heightScale.  uchar isn't recommended
       because of its inability to deal with negative values, and
       low resolution (8-bit).

   - short: height at a point is the short int value at that grid
       point, multipled by heightScale.

   - float or dobule: height at a point is the value at that grid point.

  Whatever the caller specifies as minHeight and maxHeight will be honored.
  The class will not inspect the heightfield to discover the actual minimum
  or maximum heights.  These values are used to determine the heightfield's
  axis-aligned bounding box, multiplied by localScaling.

  For usage and testing see the TerrainDemo.
 */
ATTRIBUTE_ALIGNED16(class)
btHeightfieldTerrainShape : public btConcaveShape
{
public:
	struct Range
	{
		Range() {}
		Range(btScalar min, btScalar max) : min(min), max(max) {}

		bool overlaps(const Range& other) const
		{
			return !(min > other.max || max < other.min);
		}

		btScalar min;
		btScalar max;
	};

protected:
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	btVector3 m_localOrigin;

	///terrain data
	int m_heightStickWidth;
	int m_heightStickLength;
	btScalar m_minHeight;
	btScalar m_maxHeight;
	btScalar m_width;
	btScalar m_length;
	btScalar m_heightScale;
	union {
		const unsigned char* m_heightfieldDataUnsignedChar;
		const short* m_heightfieldDataShort;
		const float* m_heightfieldDataFloat;
		const double* m_heightfieldDataDouble;
		const void* m_heightfieldDataUnknown;
	};

	PHY_ScalarType m_heightDataType;
	bool m_flipQuadEdges;
	bool m_useDiamondSubdivision;
	bool m_useZigzagSubdivision;
	bool m_flipTriangleWinding;
	int m_upAxis;

	btVector3 m_localScaling;

	// Accelerator
	btAlignedObjectArray<Range> m_vboundsGrid;
	int m_vboundsGridWidth;
	int m_vboundsGridLength;
	int m_vboundsChunkSize;

	
	btScalar m_userValue3;

	struct btTriangleInfoMap* m_triangleInfoMap;

	virtual btScalar getRawHeightFieldValue(int x, int y) const;
	void quantizeWithClamp(int* out, const btVector3& point, int isMax) const;

	/// protected initialization
	/**
	  Handles the work of constructors so that public constructors can be
	  backwards-compatible without a lot of copy/paste.
	 */
	void initialize(int heightStickWidth, int heightStickLength,
					const void* heightfieldData, btScalar heightScale,
					btScalar minHeight, btScalar maxHeight, int upAxis,
					PHY_ScalarType heightDataType, bool flipQuadEdges);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	/// preferred constructors
	btHeightfieldTerrainShape(
		int heightStickWidth, int heightStickLength,
		const float* heightfieldData, btScalar minHeight, btScalar maxHeight,
		int upAxis, bool flipQuadEdges);
	btHeightfieldTerrainShape(
		int heightStickWidth, int heightStickLength,
		const double* heightfieldData, btScalar minHeight, btScalar maxHeight,
		int upAxis, bool flipQuadEdges);
	btHeightfieldTerrainShape(
		int heightStickWidth, int heightStickLength,
		const short* heightfieldData, btScalar heightScale, btScalar minHeight, btScalar maxHeight,
		int upAxis, bool flipQuadEdges);
	btHeightfieldTerrainShape(
		int heightStickWidth, int heightStickLength,
		const unsigned char* heightfieldData, btScalar heightScale, btScalar minHeight, btScalar maxHeight,
		int upAxis, bool flipQuadEdges);

	/// legacy constructor
	/**
	  This constructor supports a range of heightfield
	  data types, and allows for a non-zero minimum height value.
	  heightScale is needed for any integer-based heightfield data types.

	  This legacy constructor considers `PHY_FLOAT` to mean `btScalar`.
	  With `BT_USE_DOUBLE_PRECISION`, it will expect `heightfieldData`
	  to be double-precision.
	 */
	btHeightfieldTerrainShape(int heightStickWidth, int heightStickLength,
							  const void* heightfieldData, btScalar heightScale,
							  btScalar minHeight, btScalar maxHeight,
							  int upAxis, PHY_ScalarType heightDataType,
							  bool flipQuadEdges);

	/// legacy constructor
	/**
	  The legacy constructor assumes the heightfield has a minimum height
	  of zero.  Only unsigned char or btScalar data are supported.  For legacy
	  compatibility reasons, heightScale is calculated as maxHeight / 65535 
	  (and is only used when useFloatData = false).
 	 */
	btHeightfieldTerrainShape(int heightStickWidth, int heightStickLength, const void* heightfieldData, btScalar maxHeight, int upAxis, bool useFloatData, bool flipQuadEdges);

	virtual ~btHeightfieldTerrainShape();

	void setUseDiamondSubdivision(bool useDiamondSubdivision = true) { m_useDiamondSubdivision = useDiamondSubdivision; }

	///could help compatibility with Ogre heightfields. See https://code.google.com/p/bullet/issues/detail?id=625
	void setUseZigzagSubdivision(bool useZigzagSubdivision = true) { m_useZigzagSubdivision = useZigzagSubdivision; }

	void setFlipTriangleWinding(bool flipTriangleWinding)
	{
		m_flipTriangleWinding = flipTriangleWinding;
	}
	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void processAllTriangles(btTriangleCallback * callback, const btVector3& aabbMin, const btVector3& aabbMax) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void setLocalScaling(const btVector3& scaling);

	virtual const btVector3& getLocalScaling() const;

	void getVertex(int x, int y, btVector3& vertex) const;

	void performRaycast(btTriangleCallback * callback, const btVector3& raySource, const btVector3& rayTarget) const;

	void buildAccelerator(int chunkSize = 16);
	void clearAccelerator();

	int getUpAxis() const
	{
		return m_upAxis;
	}
	//debugging
	virtual const char* getName() const { return "HEIGHTFIELD"; }

	
	void setUserValue3(btScalar value)
	{
		m_userValue3 = value;
	}
	btScalar getUserValue3() const
	{
		return m_userValue3;
	}
	const struct btTriangleInfoMap* getTriangleInfoMap() const
	{
		return m_triangleInfoMap;
	}
	struct btTriangleInfoMap* getTriangleInfoMap()
	{
		return m_triangleInfoMap;
	}
	void setTriangleInfoMap(btTriangleInfoMap* map)
	{
		m_triangleInfoMap = map;
	}
	const unsigned char* getHeightfieldRawData() const
	{
		return m_heightfieldDataUnsignedChar;
	}
};

#endif  //BT_HEIGHTFIELD_TERRAIN_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

EPA Copyright (c) Ricardo Padrela 2006

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"

#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"

bool btGjkEpaPenetrationDepthSolver::calcPenDepth(btSimplexSolverInterface& simplexSolver,
												  const btConvexShape* pConvexA, const btConvexShape* pConvexB,
												  const btTransform& transformA, const btTransform& transformB,
												  btVector3& v, btVector3& wWitnessOnA, btVector3& wWitnessOnB,
												  class btIDebugDraw* debugDraw)
{
	(void)debugDraw;
	(void)v;
	(void)simplexSolver;

	btVector3 guessVectors[] = {
		btVector3(transformB.getOrigin() - transformA.getOrigin()).safeNormalize(),
		btVector3(transformA.getOrigin() - transformB.getOrigin()).safeNormalize(),
		btVector3(0, 0, 1),
		btVector3(0, 1, 0),
		btVector3(1, 0, 0),
		btVector3(1, 1, 0),
		btVector3(1, 1, 1),
		btVector3(0, 1, 1),
		btVector3(1, 0, 1),
	};

	int numVectors = sizeof(guessVectors) / sizeof(btVector3);

	for (int i = 0; i < numVectors; i++)
	{
		simplexSolver.reset();
		btVector3 guessVector = guessVectors[i];

		btGjkEpaSolver2::sResults results;

		if (btGjkEpaSolver2::Penetration(pConvexA, transformA,
										 pConvexB, transformB,
										 guessVector, results))

		{
			wWitnessOnA = results.witnesses[0];
			wWitnessOnB = results.witnesses[1];
			v = results.normal;
			return true;
		}
		else
		{
			if (btGjkEpaSolver2::Distance(pConvexA, transformA, pConvexB, transformB, guessVector, results))
			{
				wWitnessOnA = results.witnesses[0];
				wWitnessOnB = results.witnesses[1];
				v = results.normal;
				return false;
			}
		}
	}

	//failed to find a distance/penetration
	wWitnessOnA.setValue(0, 0, 0);
	wWitnessOnB.setValue(0, 0, 0);
	v.setValue(0, 0, 0);
	return false;
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

EPA Copyright (c) Ricardo Padrela 2006 

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#ifndef BT_GJP_EPA_PENETRATION_DEPTH_H
#define BT_GJP_EPA_PENETRATION_DEPTH_H

#include "BulletCollision/NarrowPhaseCollision/btConvexPenetrationDepthSolver.h"

///EpaPenetrationDepthSolver uses the Expanding Polytope Algorithm to
///calculate the penetration depth between two convex shapes.
class btGjkEpaPenetrationDepthSolver : public btConvexPenetrationDepthSolver
{
public:
	btGjkEpaPenetrationDepthSolver()
	{
	}

	bool calcPenDepth(btSimplexSolverInterface& simplexSolver,
					  const btConvexShape* pConvexA, const btConvexShape* pConvexB,
					  const btTransform& transformA, const btTransform& transformB,
					  btVector3& v, btVector3& wWitnessOnA, btVector3& wWitnessOnB,
					  class btIDebugDraw* debugDraw);

private:
};

#endif  // BT_GJP_EPA_PENETRATION_DEPTH_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software in a
product, an acknowledgment in the product documentation would be appreciated
but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
GJK-EPA collision solver by Nathanael Presson, 2008
*/
#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpa2.h"

#if defined(DEBUG) || defined(_DEBUG)
#ifdef __SPU__
#define printf spu_printf
#endif  //__SPU__
#endif

namespace gjkepa2_impl
{
// Config

/* GJK	*/
#define GJK_MAX_ITERATIONS 128

#ifdef BT_USE_DOUBLE_PRECISION
#define GJK_ACCURACY ((btScalar)1e-12)
#define GJK_MIN_DISTANCE ((btScalar)1e-12)
#define GJK_DUPLICATED_EPS ((btScalar)1e-12)
#else
#define GJK_ACCURACY ((btScalar)0.0001)
#define GJK_MIN_DISTANCE ((btScalar)0.0001)
#define GJK_DUPLICATED_EPS ((btScalar)0.0001)
#endif  //BT_USE_DOUBLE_PRECISION

#define GJK_SIMPLEX2_EPS ((btScalar)0.0)
#define GJK_SIMPLEX3_EPS ((btScalar)0.0)
#define GJK_SIMPLEX4_EPS ((btScalar)0.0)

/* EPA	*/
#define EPA_MAX_VERTICES 128
#define EPA_MAX_ITERATIONS 255

#ifdef BT_USE_DOUBLE_PRECISION
#define EPA_ACCURACY ((btScalar)1e-12)
#define EPA_PLANE_EPS ((btScalar)1e-14)
#define EPA_INSIDE_EPS ((btScalar)1e-9)
#else
#define EPA_ACCURACY ((btScalar)0.0001)
#define EPA_PLANE_EPS ((btScalar)0.00001)
#define EPA_INSIDE_EPS ((btScalar)0.01)
#endif

#define EPA_FALLBACK (10 * EPA_ACCURACY)
#define EPA_MAX_FACES (EPA_MAX_VERTICES * 2)

// Shorthands
typedef unsigned int U;
typedef unsigned char U1;

// MinkowskiDiff
struct MinkowskiDiff
{
	const btConvexShape* m_shapes[2];
	btMatrix3x3 m_toshape1;
	btTransform m_toshape0;
#ifdef __SPU__
	bool m_enableMargin;
#else
	btVector3 (btConvexShape::*Ls)(const btVector3&) const;
#endif  //__SPU__

	MinkowskiDiff()
	{
	}
#ifdef __SPU__
	void EnableMargin(bool enable)
	{
		m_enableMargin = enable;
	}
	inline btVector3 Support0(const btVector3& d) const
	{
		if (m_enableMargin)
		{
			return m_shapes[0]->localGetSupportVertexNonVirtual(d);
		}
		else
		{
			return m_shapes[0]->localGetSupportVertexWithoutMarginNonVirtual(d);
		}
	}
	inline btVector3 Support1(const btVector3& d) const
	{
		if (m_enableMargin)
		{
			return m_toshape0 * (m_shapes[1]->localGetSupportVertexNonVirtual(m_toshape1 * d));
		}
		else
		{
			return m_toshape0 * (m_shapes[1]->localGetSupportVertexWithoutMarginNonVirtual(m_toshape1 * d));
		}
	}
#else
	void EnableMargin(bool enable)
	{
		if (enable)
			Ls = &btConvexShape::localGetSupportVertexNonVirtual;
		else
			Ls = &btConvexShape::localGetSupportVertexWithoutMarginNonVirtual;
	}
	inline btVector3 Support0(const btVector3& d) const
	{
		return (((m_shapes[0])->*(Ls))(d));
	}
	inline btVector3 Support1(const btVector3& d) const
	{
		return (m_toshape0 * ((m_shapes[1])->*(Ls))(m_toshape1 * d));
	}
#endif  //__SPU__

	inline btVector3 Support(const btVector3& d) const
	{
		return (Support0(d) - Support1(-d));
	}
	btVector3 Support(const btVector3& d, U index) const
	{
		if (index)
			return (Support1(d));
		else
			return (Support0(d));
	}
};

typedef MinkowskiDiff tShape;

// GJK
struct GJK
{
	/* Types		*/
	struct sSV
	{
		btVector3 d, w;
	};
	struct sSimplex
	{
		sSV* c[4];
		btScalar p[4];
		U rank;
	};
	struct eStatus
	{
		enum _
		{
			Valid,
			Inside,
			Failed
		};
	};
	/* Fields		*/
	tShape m_shape;
	btVector3 m_ray;
	btScalar m_distance;
	sSimplex m_simplices[2];
	sSV m_store[4];
	sSV* m_free[4];
	U m_nfree;
	U m_current;
	sSimplex* m_simplex;
	eStatus::_ m_status;
	/* Methods		*/
	GJK()
	{
		Initialize();
	}
	void Initialize()
	{
		m_ray = btVector3(0, 0, 0);
		m_nfree = 0;
		m_status = eStatus::Failed;
		m_current = 0;
		m_distance = 0;
	}
	eStatus::_ Evaluate(const tShape& shapearg, const btVector3& guess)
	{
		U iterations = 0;
		btScalar sqdist = 0;
		btScalar alpha = 0;
		btVector3 lastw[4];
		U clastw = 0;
		/* Initialize solver		*/
		m_free[0] = &m_store[0];
		m_free[1] = &m_store[1];
		m_free[2] = &m_store[2];
		m_free[3] = &m_store[3];
		m_nfree = 4;
		m_current = 0;
		m_status = eStatus::Valid;
		m_shape = shapearg;
		m_distance = 0;
		/* Initialize simplex		*/
		m_simplices[0].rank = 0;
		m_ray = guess;
		const btScalar sqrl = m_ray.length2();
		appendvertice(m_simplices[0], sqrl > 0 ? -m_ray : btVector3(1, 0, 0));
		m_simplices[0].p[0] = 1;
		m_ray = m_simplices[0].c[0]->w;
		sqdist = sqrl;
		lastw[0] =
			lastw[1] =
				lastw[2] =
					lastw[3] = m_ray;
		/* Loop						*/
		do
		{
			const U next = 1 - m_current;
			sSimplex& cs = m_simplices[m_current];
			sSimplex& ns = m_simplices[next];
			/* Check zero							*/
			const btScalar rl = m_ray.length();
			if (rl < GJK_MIN_DISTANCE)
			{ /* Touching or inside				*/
				m_status = eStatus::Inside;
				break;
			}
			/* Append new vertice in -'v' direction	*/
			appendvertice(cs, -m_ray);
			const btVector3& w = cs.c[cs.rank - 1]->w;
			bool found = false;
			for (U i = 0; i < 4; ++i)
			{
				if ((w - lastw[i]).length2() < GJK_DUPLICATED_EPS)
				{
					found = true;
					break;
				}
			}
			if (found)
			{ /* Return old simplex				*/
				removevertice(m_simplices[m_current]);
				break;
			}
			else
			{ /* Update lastw					*/
				lastw[clastw = (clastw + 1) & 3] = w;
			}
			/* Check for termination				*/
			const btScalar omega = btDot(m_ray, w) / rl;
			alpha = btMax(omega, alpha);
			if (((rl - alpha) - (GJK_ACCURACY * rl)) <= 0)
			{ /* Return old simplex				*/
				removevertice(m_simplices[m_current]);
				break;
			}
			/* Reduce simplex						*/
			btScalar weights[4];
			U mask = 0;
			switch (cs.rank)
			{
				case 2:
					sqdist = projectorigin(cs.c[0]->w,
										   cs.c[1]->w,
										   weights, mask);
					break;
				case 3:
					sqdist = projectorigin(cs.c[0]->w,
										   cs.c[1]->w,
										   cs.c[2]->w,
										   weights, mask);
					break;
				case 4:
					sqdist = projectorigin(cs.c[0]->w,
										   cs.c[1]->w,
										   cs.c[2]->w,
										   cs.c[3]->w,
										   weights, mask);
					break;
			}
			if (sqdist >= 0)
			{ /* Valid	*/
				ns.rank = 0;
				m_ray = btVector3(0, 0, 0);
				m_current = next;
				for (U i = 0, ni = cs.rank; i < ni; ++i)
				{
					if (mask & (1 << i))
					{
						ns.c[ns.rank] = cs.c[i];
						ns.p[ns.rank++] = weights[i];
						m_ray += cs.c[i]->w * weights[i];
					}
					else
					{
						m_free[m_nfree++] = cs.c[i];
					}
				}
				if (mask == 15) m_status = eStatus::Inside;
			}
			else
			{ /* Return old simplex				*/
				removevertice(m_simplices[m_current]);
				break;
			}
			m_status = ((++iterations) < GJK_MAX_ITERATIONS) ? m_status : eStatus::Failed;
		} while (m_status == eStatus::Valid);
		m_simplex = &m_simplices[m_current];
		switch (m_status)
		{
			case eStatus::Valid:
				m_distance = m_ray.length();
				break;
			case eStatus::Inside:
				m_distance = 0;
				break;
			default:
			{
			}
		}
		return (m_status);
	}
	bool EncloseOrigin()
	{
		switch (m_simplex->rank)
		{
			case 1:
			{
				for (U i = 0; i < 3; ++i)
				{
					btVector3 axis = btVector3(0, 0, 0);
					axis[i] = 1;
					appendvertice(*m_simplex, axis);
					if (EncloseOrigin()) return (true);
					removevertice(*m_simplex);
					appendvertice(*m_simplex, -axis);
					if (EncloseOrigin()) return (true);
					removevertice(*m_simplex);
				}
			}
			break;
			case 2:
			{
				const btVector3 d = m_simplex->c[1]->w - m_simplex->c[0]->w;
				for (U i = 0; i < 3; ++i)
				{
					btVector3 axis = btVector3(0, 0, 0);
					axis[i] = 1;
					const btVector3 p = btCross(d, axis);
					if (p.length2() > 0)
					{
						appendvertice(*m_simplex, p);
						if (EncloseOrigin()) return (true);
						removevertice(*m_simplex);
						appendvertice(*m_simplex, -p);
						if (EncloseOrigin()) return (true);
						removevertice(*m_simplex);
					}
				}
			}
			break;
			case 3:
			{
				const btVector3 n = btCross(m_simplex->c[1]->w - m_simplex->c[0]->w,
											m_simplex->c[2]->w - m_simplex->c[0]->w);
				if (n.length2() > 0)
				{
					appendvertice(*m_simplex, n);
					if (EncloseOrigin()) return (true);
					removevertice(*m_simplex);
					appendvertice(*m_simplex, -n);
					if (EncloseOrigin()) return (true);
					removevertice(*m_simplex);
				}
			}
			break;
			case 4:
			{
				if (btFabs(det(m_simplex->c[0]->w - m_simplex->c[3]->w,
							   m_simplex->c[1]->w - m_simplex->c[3]->w,
							   m_simplex->c[2]->w - m_simplex->c[3]->w)) > 0)
					return (true);
			}
			break;
		}
		return (false);
	}
	/* Internals	*/
	void getsupport(const btVector3& d, sSV& sv) const
	{
		sv.d = d / d.length();
		sv.w = m_shape.Support(sv.d);
	}
	void removevertice(sSimplex& simplex)
	{
		m_free[m_nfree++] = simplex.c[--simplex.rank];
	}
	void appendvertice(sSimplex& simplex, const btVector3& v)
	{
		simplex.p[simplex.rank] = 0;
		simplex.c[simplex.rank] = m_free[--m_nfree];
		getsupport(v, *simplex.c[simplex.rank++]);
	}
	static btScalar det(const btVector3& a, const btVector3& b, const btVector3& c)
	{
		return (a.y() * b.z() * c.x() + a.z() * b.x() * c.y() -
				a.x() * b.z() * c.y() - a.y() * b.x() * c.z() +
				a.x() * b.y() * c.z() - a.z() * b.y() * c.x());
	}
	static btScalar projectorigin(const btVector3& a,
								  const btVector3& b,
								  btScalar* w, U& m)
	{
		const btVector3 d = b - a;
		const btScalar l = d.length2();
		if (l > GJK_SIMPLEX2_EPS)
		{
			const btScalar t(l > 0 ? -btDot(a, d) / l : 0);
			if (t >= 1)
			{
				w[0] = 0;
				w[1] = 1;
				m = 2;
				return (b.length2());
			}
			else if (t <= 0)
			{
				w[0] = 1;
				w[1] = 0;
				m = 1;
				return (a.length2());
			}
			else
			{
				w[0] = 1 - (w[1] = t);
				m = 3;
				return ((a + d * t).length2());
			}
		}
		return (-1);
	}
	static btScalar projectorigin(const btVector3& a,
								  const btVector3& b,
								  const btVector3& c,
								  btScalar* w, U& m)
	{
		static const U imd3[] = {1, 2, 0};
		const btVector3* vt[] = {&a, &b, &c};
		const btVector3 dl[] = {a - b, b - c, c - a};
		const btVector3 n = btCross(dl[0], dl[1]);
		const btScalar l = n.length2();
		if (l > GJK_SIMPLEX3_EPS)
		{
			btScalar mindist = -1;
			btScalar subw[2] = {0.f, 0.f};
			U subm(0);
			for (U i = 0; i < 3; ++i)
			{
				if (btDot(*vt[i], btCross(dl[i], n)) > 0)
				{
					const U j = imd3[i];
					const btScalar subd(projectorigin(*vt[i], *vt[j], subw, subm));
					if ((mindist < 0) || (subd < mindist))
					{
						mindist = subd;
						m = static_cast<U>(((subm & 1) ? 1 << i : 0) + ((subm & 2) ? 1 << j : 0));
						w[i] = subw[0];
						w[j] = subw[1];
						w[imd3[j]] = 0;
					}
				}
			}
			if (mindist < 0)
			{
				const btScalar d = btDot(a, n);
				const btScalar s = btSqrt(l);
				const btVector3 p = n * (d / l);
				mindist = p.length2();
				m = 7;
				w[0] = (btCross(dl[1], b - p)).length() / s;
				w[1] = (btCross(dl[2], c - p)).length() / s;
				w[2] = 1 - (w[0] + w[1]);
			}
			return (mindist);
		}
		return (-1);
	}
	static btScalar projectorigin(const btVector3& a,
								  const btVector3& b,
								  const btVector3& c,
								  const btVector3& d,
								  btScalar* w, U& m)
	{
		static const U imd3[] = {1, 2, 0};
		const btVector3* vt[] = {&a, &b, &c, &d};
		const btVector3 dl[] = {a - d, b - d, c - d};
		const btScalar vl = det(dl[0], dl[1], dl[2]);
		const bool ng = (vl * btDot(a, btCross(b - c, a - b))) <= 0;
		if (ng && (btFabs(vl) > GJK_SIMPLEX4_EPS))
		{
			btScalar mindist = -1;
			btScalar subw[3] = {0.f, 0.f, 0.f};
			U subm(0);
			for (U i = 0; i < 3; ++i)
			{
				const U j = imd3[i];
				const btScalar s = vl * btDot(d, btCross(dl[i], dl[j]));
				if (s > 0)
				{
					const btScalar subd = projectorigin(*vt[i], *vt[j], d, subw, subm);
					if ((mindist < 0) || (subd < mindist))
					{
						mindist = subd;
						m = static_cast<U>((subm & 1 ? 1 << i : 0) +
										   (subm & 2 ? 1 << j : 0) +
										   (subm & 4 ? 8 : 0));
						w[i] = subw[0];
						w[j] = subw[1];
						w[imd3[j]] = 0;
						w[3] = subw[2];
					}
				}
			}
			if (mindist < 0)
			{
				mindist = 0;
				m = 15;
				w[0] = det(c, b, d) / vl;
				w[1] = det(a, c, d) / vl;
				w[2] = det(b, a, d) / vl;
				w[3] = 1 - (w[0] + w[1] + w[2]);
			}
			return (mindist);
		}
		return (-1);
	}
};

// EPA
struct EPA
{
	/* Types		*/
	typedef GJK::sSV sSV;
	struct sFace
	{
		btVector3 n;
		btScalar d;
		sSV* c[3];
		sFace* f[3];
		sFace* l[2];
		U1 e[3];
		U1 pass;
	};
	struct sList
	{
		sFace* root;
		U count;
		sList() : root(0), count(0) {}
	};
	struct sHorizon
	{
		sFace* cf;
		sFace* ff;
		U nf;
		sHorizon() : cf(0), ff(0), nf(0) {}
	};
	struct eStatus
	{
		enum _
		{
			Valid,
			Touching,
			Degenerated,
			NonConvex,
			InvalidHull,
			OutOfFaces,
			OutOfVertices,
			AccuraryReached,
			FallBack,
			Failed
		};
	};
	/* Fields		*/
	eStatus::_ m_status;
	GJK::sSimplex m_result;
	btVector3 m_normal;
	btScalar m_depth;
	sSV m_sv_store[EPA_MAX_VERTICES];
	sFace m_fc_store[EPA_MAX_FACES];
	U m_nextsv;
	sList m_hull;
	sList m_stock;
	/* Methods		*/
	EPA()
	{
		Initialize();
	}

	static inline void bind(sFace* fa, U ea, sFace* fb, U eb)
	{
		fa->e[ea] = (U1)eb;
		fa->f[ea] = fb;
		fb->e[eb] = (U1)ea;
		fb->f[eb] = fa;
	}
	static inline void append(sList& list, sFace* face)
	{
		face->l[0] = 0;
		face->l[1] = list.root;
		if (list.root) list.root->l[0] = face;
		list.root = face;
		++list.count;
	}
	static inline void remove(sList& list, sFace* face)
	{
		if (face->l[1]) face->l[1]->l[0] = face->l[0];
		if (face->l[0]) face->l[0]->l[1] = face->l[1];
		if (face == list.root) list.root = face->l[1];
		--list.count;
	}

	void Initialize()
	{
		m_status = eStatus::Failed;
		m_normal = btVector3(0, 0, 0);
		m_depth = 0;
		m_nextsv = 0;
		for (U i = 0; i < EPA_MAX_FACES; ++i)
		{
			append(m_stock, &m_fc_store[EPA_MAX_FACES - i - 1]);
		}
	}
	eStatus::_ Evaluate(GJK& gjk, const btVector3& guess)
	{
		GJK::sSimplex& simplex = *gjk.m_simplex;
		if ((simplex.rank > 1) && gjk.EncloseOrigin())
		{
			/* Clean up				*/
			while (m_hull.root)
			{
				sFace* f = m_hull.root;
				remove(m_hull, f);
				append(m_stock, f);
			}
			m_status = eStatus::Valid;
			m_nextsv = 0;
			/* Orient simplex		*/
			if (gjk.det(simplex.c[0]->w - simplex.c[3]->w,
						simplex.c[1]->w - simplex.c[3]->w,
						simplex.c[2]->w - simplex.c[3]->w) < 0)
			{
				btSwap(simplex.c[0], simplex.c[1]);
				btSwap(simplex.p[0], simplex.p[1]);
			}
			/* Build initial hull	*/
			sFace* tetra[] = {newface(simplex.c[0], simplex.c[1], simplex.c[2], true),
							  newface(simplex.c[1], simplex.c[0], simplex.c[3], true),
							  newface(simplex.c[2], simplex.c[1], simplex.c[3], true),
							  newface(simplex.c[0], simplex.c[2], simplex.c[3], true)};
			if (m_hull.count == 4)
			{
				sFace* best = findbest();
				sFace outer = *best;
				U pass = 0;
				U iterations = 0;
				bind(tetra[0], 0, tetra[1], 0);
				bind(tetra[0], 1, tetra[2], 0);
				bind(tetra[0], 2, tetra[3], 0);
				bind(tetra[1], 1, tetra[3], 2);
				bind(tetra[1], 2, tetra[2], 1);
				bind(tetra[2], 2, tetra[3], 1);
				m_status = eStatus::Valid;
				for (; iterations < EPA_MAX_ITERATIONS; ++iterations)
				{
					if (m_nextsv < EPA_MAX_VERTICES)
					{
						sHorizon horizon;
						sSV* w = &m_sv_store[m_nextsv++];
						bool valid = true;
						best->pass = (U1)(++pass);
						gjk.getsupport(best->n, *w);
						const btScalar wdist = btDot(best->n, w->w) - best->d;
						if (wdist > EPA_ACCURACY)
						{
							for (U j = 0; (j < 3) && valid; ++j)
							{
								valid &= expand(pass, w,
												best->f[j], best->e[j],
												horizon);
							}
							if (valid && (horizon.nf >= 3))
							{
								bind(horizon.cf, 1, horizon.ff, 2);
								remove(m_hull, best);
								append(m_stock, best);
								best = findbest();
								outer = *best;
							}
							else
							{
								m_status = eStatus::InvalidHull;
								break;
							}
						}
						else
						{
							m_status = eStatus::AccuraryReached;
							break;
						}
					}
					else
					{
						m_status = eStatus::OutOfVertices;
						break;
					}
				}
				const btVector3 projection = outer.n * outer.d;
				m_normal = outer.n;
				m_depth = outer.d;
				m_result.rank = 3;
				m_result.c[0] = outer.c[0];
				m_result.c[1] = outer.c[1];
				m_result.c[2] = outer.c[2];
				m_result.p[0] = btCross(outer.c[1]->w - projection,
										outer.c[2]->w - projection)
									.length();
				m_result.p[1] = btCross(outer.c[2]->w - projection,
										outer.c[0]->w - projection)
									.length();
				m_result.p[2] = btCross(outer.c[0]->w - projection,
										outer.c[1]->w - projection)
									.length();
				const btScalar sum = m_result.p[0] + m_result.p[1] + m_result.p[2];
				m_result.p[0] /= sum;
				m_result.p[1] /= sum;
				m_result.p[2] /= sum;
				return (m_status);
			}
		}
		/* Fallback		*/
		m_status = eStatus::FallBack;
		m_normal = -guess;
		const btScalar nl = m_normal.length();
		if (nl > 0)
			m_normal = m_normal / nl;
		else
			m_normal = btVector3(1, 0, 0);
		m_depth = 0;
		m_result.rank = 1;
		m_result.c[0] = simplex.c[0];
		m_result.p[0] = 1;
		return (m_status);
	}
	bool getedgedist(sFace* face, sSV* a, sSV* b, btScalar& dist)
	{
		const btVector3 ba = b->w - a->w;
		const btVector3 n_ab = btCross(ba, face->n);   // Outward facing edge normal direction, on triangle plane
		const btScalar a_dot_nab = btDot(a->w, n_ab);  // Only care about the sign to determine inside/outside, so not normalization required

		if (a_dot_nab < 0)
		{
			// Outside of edge a->b

			const btScalar ba_l2 = ba.length2();
			const btScalar a_dot_ba = btDot(a->w, ba);
			const btScalar b_dot_ba = btDot(b->w, ba);

			if (a_dot_ba > 0)
			{
				// Pick distance vertex a
				dist = a->w.length();
			}
			else if (b_dot_ba < 0)
			{
				// Pick distance vertex b
				dist = b->w.length();
			}
			else
			{
				// Pick distance to edge a->b
				const btScalar a_dot_b = btDot(a->w, b->w);
				dist = btSqrt(btMax((a->w.length2() * b->w.length2() - a_dot_b * a_dot_b) / ba_l2, (btScalar)0));
			}

			return true;
		}

		return false;
	}
	sFace* newface(sSV* a, sSV* b, sSV* c, bool forced)
	{
		if (m_stock.root)
		{
			sFace* face = m_stock.root;
			remove(m_stock, face);
			append(m_hull, face);
			face->pass = 0;
			face->c[0] = a;
			face->c[1] = b;
			face->c[2] = c;
			face->n = btCross(b->w - a->w, c->w - a->w);
			const btScalar l = face->n.length();
			const bool v = l > EPA_ACCURACY;

			if (v)
			{
				if (!(getedgedist(face, a, b, face->d) ||
					  getedgedist(face, b, c, face->d) ||
					  getedgedist(face, c, a, face->d)))
				{
					// Origin projects to the interior of the triangle
					// Use distance to triangle plane
					face->d = btDot(a->w, face->n) / l;
				}

				face->n /= l;
				if (forced || (face->d >= -EPA_PLANE_EPS))
				{
					return face;
				}
				else
					m_status = eStatus::NonConvex;
			}
			else
				m_status = eStatus::Degenerated;

			remove(m_hull, face);
			append(m_stock, face);
			return 0;
		}
		m_status = m_stock.root ? eStatus::OutOfVertices : eStatus::OutOfFaces;
		return 0;
	}
	sFace* findbest()
	{
		sFace* minf = m_hull.root;
		btScalar mind = minf->d * minf->d;
		for (sFace* f = minf->l[1]; f; f = f->l[1])
		{
			const btScalar sqd = f->d * f->d;
			if (sqd < mind)
			{
				minf = f;
				mind = sqd;
			}
		}
		return (minf);
	}
	bool expand(U pass, sSV* w, sFace* f, U e, sHorizon& horizon)
	{
		static const U i1m3[] = {1, 2, 0};
		static const U i2m3[] = {2, 0, 1};
		if (f->pass != pass)
		{
			const U e1 = i1m3[e];
			if ((btDot(f->n, w->w) - f->d) < -EPA_PLANE_EPS)
			{
				sFace* nf = newface(f->c[e1], f->c[e], w, false);
				if (nf)
				{
					bind(nf, 0, f, e);
					if (horizon.cf)
						bind(horizon.cf, 1, nf, 2);
					else
						horizon.ff = nf;
					horizon.cf = nf;
					++horizon.nf;
					return (true);
				}
			}
			else
			{
				const U e2 = i2m3[e];
				f->pass = (U1)pass;
				if (expand(pass, w, f->f[e1], f->e[e1], horizon) &&
					expand(pass, w, f->f[e2], f->e[e2], horizon))
				{
					remove(m_hull, f);
					append(m_stock, f);
					return (true);
				}
			}
		}
		return (false);
	}
};

//
static void Initialize(const btConvexShape* shape0, const btTransform& wtrs0,
					   const btConvexShape* shape1, const btTransform& wtrs1,
					   btGjkEpaSolver2::sResults& results,
					   tShape& shape,
					   bool withmargins)
{
	/* Results		*/
	results.witnesses[0] =
		results.witnesses[1] = btVector3(0, 0, 0);
	results.status = btGjkEpaSolver2::sResults::Separated;
	/* Shape		*/
	shape.m_shapes[0] = shape0;
	shape.m_shapes[1] = shape1;
	shape.m_toshape1 = wtrs1.getBasis().transposeTimes(wtrs0.getBasis());
	shape.m_toshape0 = wtrs0.inverseTimes(wtrs1);
	shape.EnableMargin(withmargins);
}

}  // namespace gjkepa2_impl

//
// Api
//

using namespace gjkepa2_impl;

//
int btGjkEpaSolver2::StackSizeRequirement()
{
	return (sizeof(GJK) + sizeof(EPA));
}

//
bool btGjkEpaSolver2::Distance(const btConvexShape* shape0,
							   const btTransform& wtrs0,
							   const btConvexShape* shape1,
							   const btTransform& wtrs1,
							   const btVector3& guess,
							   sResults& results)
{
	tShape shape;
	Initialize(shape0, wtrs0, shape1, wtrs1, results, shape, false);
	GJK gjk;
	GJK::eStatus::_ gjk_status = gjk.Evaluate(shape, guess);
	if (gjk_status == GJK::eStatus::Valid)
	{
		btVector3 w0 = btVector3(0, 0, 0);
		btVector3 w1 = btVector3(0, 0, 0);
		for (U i = 0; i < gjk.m_simplex->rank; ++i)
		{
			const btScalar p = gjk.m_simplex->p[i];
			w0 += shape.Support(gjk.m_simplex->c[i]->d, 0) * p;
			w1 += shape.Support(-gjk.m_simplex->c[i]->d, 1) * p;
		}
		results.witnesses[0] = wtrs0 * w0;
		results.witnesses[1] = wtrs0 * w1;
		results.normal = w0 - w1;
		results.distance = results.normal.length();
		results.normal /= results.distance > GJK_MIN_DISTANCE ? results.distance : 1;
		return (true);
	}
	else
	{
		results.status = gjk_status == GJK::eStatus::Inside ? sResults::Penetrating : sResults::GJK_Failed;
		return (false);
	}
}

//
bool btGjkEpaSolver2::Penetration(const btConvexShape* shape0,
								  const btTransform& wtrs0,
								  const btConvexShape* shape1,
								  const btTransform& wtrs1,
								  const btVector3& guess,
								  sResults& results,
								  bool usemargins)
{
	tShape shape;
	Initialize(shape0, wtrs0, shape1, wtrs1, results, shape, usemargins);
	GJK gjk;
	GJK::eStatus::_ gjk_status = gjk.Evaluate(shape, -guess);
	switch (gjk_status)
	{
		case GJK::eStatus::Inside:
		{
			EPA epa;
			EPA::eStatus::_ epa_status = epa.Evaluate(gjk, -guess);
			if (epa_status != EPA::eStatus::Failed)
			{
				btVector3 w0 = btVector3(0, 0, 0);
				for (U i = 0; i < epa.m_result.rank; ++i)
				{
					w0 += shape.Support(epa.m_result.c[i]->d, 0) * epa.m_result.p[i];
				}
				results.status = sResults::Penetrating;
				results.witnesses[0] = wtrs0 * w0;
				results.witnesses[1] = wtrs0 * (w0 - epa.m_normal * epa.m_depth);
				results.normal = -epa.m_normal;
				results.distance = -epa.m_depth;
				return (true);
			}
			else
				results.status = sResults::EPA_Failed;
		}
		break;
		case GJK::eStatus::Failed:
			results.status = sResults::GJK_Failed;
			break;
		default:
		{
		}
	}
	return (false);
}

#ifndef __SPU__
//
btScalar btGjkEpaSolver2::SignedDistance(const btVector3& position,
										 btScalar margin,
										 const btConvexShape* shape0,
										 const btTransform& wtrs0,
										 sResults& results)
{
	tShape shape;
	btSphereShape shape1(margin);
	btTransform wtrs1(btQuaternion(0, 0, 0, 1), position);
	Initialize(shape0, wtrs0, &shape1, wtrs1, results, shape, false);
	GJK gjk;
	GJK::eStatus::_ gjk_status = gjk.Evaluate(shape, btVector3(1, 1, 1));
	if (gjk_status == GJK::eStatus::Valid)
	{
		btVector3 w0 = btVector3(0, 0, 0);
		btVector3 w1 = btVector3(0, 0, 0);
		for (U i = 0; i < gjk.m_simplex->rank; ++i)
		{
			const btScalar p = gjk.m_simplex->p[i];
			w0 += shape.Support(gjk.m_simplex->c[i]->d, 0) * p;
			w1 += shape.Support(-gjk.m_simplex->c[i]->d, 1) * p;
		}
		results.witnesses[0] = wtrs0 * w0;
		results.witnesses[1] = wtrs0 * w1;
		const btVector3 delta = results.witnesses[1] -
								results.witnesses[0];
		const btScalar margin = shape0->getMarginNonVirtual() +
								shape1.getMarginNonVirtual();
		const btScalar length = delta.length();
		results.normal = delta / length;
		results.witnesses[0] += results.normal * margin;
		results.distance = length - margin;
		return results.distance;
	}
	else
	{
		if (gjk_status == GJK::eStatus::Inside)
		{
			if (Penetration(shape0, wtrs0, &shape1, wtrs1, gjk.m_ray, results))
			{
				const btVector3 delta = results.witnesses[0] -
										results.witnesses[1];
				const btScalar length = delta.length();
				if (length >= SIMD_EPSILON)
					results.normal = delta / length;
				return (-length);
			}
		}
	}
	return (SIMD_INFINITY);
}

//
bool btGjkEpaSolver2::SignedDistance(const btConvexShape* shape0,
									 const btTransform& wtrs0,
									 const btConvexShape* shape1,
									 const btTransform& wtrs1,
									 const btVector3& guess,
									 sResults& results)
{
	if (!Distance(shape0, wtrs0, shape1, wtrs1, guess, results))
		return (Penetration(shape0, wtrs0, shape1, wtrs1, guess, results, false));
	else
		return (true);
}
#endif  //__SPU__

/* Symbols cleanup		*/

#undef GJK_MAX_ITERATIONS
#undef GJK_ACCURACY
#undef GJK_MIN_DISTANCE
#undef GJK_DUPLICATED_EPS
#undef GJK_SIMPLEX2_EPS
#undef GJK_SIMPLEX3_EPS
#undef GJK_SIMPLEX4_EPS

#undef EPA_MAX_VERTICES
#undef EPA_MAX_FACES
#undef EPA_MAX_ITERATIONS
#undef EPA_ACCURACY
#undef EPA_FALLBACK
#undef EPA_PLANE_EPS
#undef EPA_INSIDE_EPS





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software in a
product, an acknowledgment in the product documentation would be appreciated
but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
GJK-EPA collision solver by Nathanael Presson, 2008
*/
#ifndef BT_GJK_EPA2_H
#define BT_GJK_EPA2_H

#include "BulletCollision/CollisionShapes/btConvexShape.h"

///btGjkEpaSolver contributed under zlib by Nathanael Presson
struct btGjkEpaSolver2
{
	struct sResults
	{
		enum eStatus
		{
			Separated,   /* Shapes doesnt penetrate												*/
			Penetrating, /* Shapes are penetrating												*/
			GJK_Failed,  /* GJK phase fail, no big issue, shapes are probably just 'touching'	*/
			EPA_Failed   /* EPA phase fail, bigger problem, need to save parameters, and debug	*/
		} status;
		btVector3 witnesses[2];
		btVector3 normal;
		btScalar distance;
	};

	static int StackSizeRequirement();

	static bool Distance(const btConvexShape* shape0, const btTransform& wtrs0,
						 const btConvexShape* shape1, const btTransform& wtrs1,
						 const btVector3& guess,
						 sResults& results);

	static bool Penetration(const btConvexShape* shape0, const btTransform& wtrs0,
							const btConvexShape* shape1, const btTransform& wtrs1,
							const btVector3& guess,
							sResults& results,
							bool usemargins = true);
#ifndef __SPU__
	static btScalar SignedDistance(const btVector3& position,
								   btScalar margin,
								   const btConvexShape* shape,
								   const btTransform& wtrs,
								   sResults& results);

	static bool SignedDistance(const btConvexShape* shape0, const btTransform& wtrs0,
							   const btConvexShape* shape1, const btTransform& wtrs1,
							   const btVector3& guess,
							   sResults& results);
#endif  //__SPU__
};

#endif  //BT_GJK_EPA2_H



#ifdef __cplusplus
extern "C" {
#endif

void _wrap_Swig_free_mbt_c1af402c8cb9fdfb(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  Swig_free(arg1);
  
}


void *_wrap_Swig_malloc_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (void *)Swig_malloc(arg1);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetVersion_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetVersion();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsDoublePrecision_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btIsDoublePrecision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_0_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btInfMaskConverter *)new btInfMaskConverter(arg1);
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_1_mbt_c1af402c8cb9fdfb() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)new btInfMaskConverter();
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


void _wrap_delete_btInfMaskConverter_mbt_c1af402c8cb9fdfb(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btInfinityMask_set_mbt_c1af402c8cb9fdfb(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  btInfinityMask = *arg1;
  
}


btInfMaskConverter *_wrap_btInfinityMask_get_mbt_c1af402c8cb9fdfb() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)&btInfinityMask;
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetInfinityMask_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetInfinityMask();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSqrt_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSqrt(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFabs_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btFabs(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCos_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btCos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSin_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTan_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btTan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAcos_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAcos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAsin_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAsin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAtan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btExp_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btExp(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLog_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btLog(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPow_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btPow(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFmod_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btFmod(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2Fast_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2Fast(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btFuzzyZero_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (bool)btFuzzyZero(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btEqual_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGreaterEqual_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btGreaterEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsNegative_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (int)btIsNegative(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRadians_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btRadians(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDegrees_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btDegrees(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFsel_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btFsel(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btMachineIsLittleEndian_mbt_c1af402c8cb9fdfb() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)btMachineIsLittleEndian();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_0_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  
  result = (unsigned int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_1_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSelect__SWIG_2_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, float _swig_go_1, float _swig_go_2) {
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  arg3 = (float)_swig_go_2; 
  
  result = (float)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_0_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  unsigned int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_1_mbt_c1af402c8cb9fdfb(short _swig_go_0) {
  unsigned short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (unsigned short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_2_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_3_mbt_c1af402c8cb9fdfb(short _swig_go_0) {
  short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndianFloat_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  float arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (float)_swig_go_0; 
  
  result = (unsigned int)btSwapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btUnswapEndianFloat_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  unsigned int arg1 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (float)btUnswapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSwapEndianDouble_mbt_c1af402c8cb9fdfb(double _swig_go_0, char *_swig_go_1) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (double)_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  btSwapEndianDouble(arg1,arg2);
  
}


double _wrap_btUnswapEndianDouble_mbt_c1af402c8cb9fdfb(char *_swig_go_0) {
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(unsigned char **)&_swig_go_0; 
  
  result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLargeDot_mbt_c1af402c8cb9fdfb(float *_swig_go_0, float *_swig_go_1, intgo _swig_go_2) {
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btScalar **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btNormalizeAngle_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btNormalizeAngle(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedObject *_wrap_new_btTypedObject_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  btTypedObject *result = 0 ;
  btTypedObject *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btTypedObject *)new btTypedObject(arg1);
  *(btTypedObject **)&_swig_go_result = (btTypedObject *)result; 
  return _swig_go_result;
}


void _wrap_btTypedObject_m_objectType_set_mbt_c1af402c8cb9fdfb(btTypedObject *_swig_go_0, intgo _swig_go_1) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedObject_m_objectType_get_mbt_c1af402c8cb9fdfb(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedObject_getObjectType_mbt_c1af402c8cb9fdfb(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int)((btTypedObject const *)arg1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedObject_mbt_c1af402c8cb9fdfb(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void *_wrap_btAlignedAllocInternal_mbt_c1af402c8cb9fdfb(long long _swig_go_0, intgo _swig_go_1) {
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)btAlignedAllocInternal(SWIG_STD_MOVE(arg1),arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btAlignedFreeInternal_mbt_c1af402c8cb9fdfb(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btAlignedFreeInternal(arg1);
  
}


void _wrap_btAlignedAllocSetCustom_mbt_c1af402c8cb9fdfb(void* _swig_go_0, void* _swig_go_1) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  btFreeFunc *arg2 = (btFreeFunc *) 0 ;
  
  arg1 = *(btAllocFunc **)&_swig_go_0; 
  arg2 = *(btFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustom(arg1,arg2);
  
}


void _wrap_btAlignedAllocSetCustomAligned_mbt_c1af402c8cb9fdfb(void* _swig_go_0, void* _swig_go_1) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  btAlignedFreeFunc *arg2 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = *(btAlignedAllocFunc **)&_swig_go_0; 
  arg2 = *(btAlignedFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustomAligned(arg1,arg2);
  
}


void _wrap_btVector3_m_floats_set_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btVector3_m_floats_get_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  
  result = (btVector3 *)new btVector3();
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


float _wrap_btVector3_dot_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_norm_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_safeNorm_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_safeNormalize_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalize_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalized_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_rotate_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_angle_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_absolute_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_cross_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_triple_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_minAxis_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_maxAxis_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_furthestAxis_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_closestAxis_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_setInterpolate3_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector3_lerp_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_getX_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getY_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getZ_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setX_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btVector3_setY_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btVector3_setZ_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btVector3_setW_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btVector3_x_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_y_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_z_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_w_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setMax_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setMin_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setValue_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btVector3_getSkewSymmetricMatrix_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector3_setZero_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


bool _wrap_btVector3_isZero_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector3_fuzzyZero_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_serialize_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_0_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_1_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeFloat_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btVector3_deSerializeFloat_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeDouble_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btVector3_deSerializeDouble_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector3_maxDot_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector3_minDot_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_dot3_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_delete_btVector3_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btDot_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_0_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCross_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btTriple_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_lerp_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  
  result = (btVector4 *)new btVector4();
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_btVector4_absolute4_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  btVector4 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = ((btVector4 const *)arg1)->absolute4();
  *(btVector4 **)&_swig_go_result = new btVector4(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getW_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (btScalar)((btVector4 const *)arg1)->getW();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis4_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->maxAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis4_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->minAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis4_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->closestAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setValue_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_delete_btVector4_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtVector4_M_floats_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ;
  
}


float *_wrap_GetbtVector4_M_floats_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *)(btScalar *) ((swig_b0)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_dot_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length2_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_norm_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_safeNorm_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance2_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_safeNormalize_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalize_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalized_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_rotate_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_angle_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_absolute_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_cross_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_triple_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_furthestAxis_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setInterpolate3_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector4_lerp_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getX_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getY_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getZ_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setX_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btVector4_setY_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btVector4_setZ_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btVector4_setW_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btVector4_x_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_y_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_z_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_w_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setMax_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_setMin_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_getSkewSymmetricMatrix_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector4_setZero_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZero();
  
}


bool _wrap_btVector4_isZero_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector4_fuzzyZero_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_serialize_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serialize(*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_0_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_1_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeFloat_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeFloat(*arg2);
  
}


void _wrap_btVector4_deSerializeFloat_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeDouble_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeDouble(*arg2);
  
}


void _wrap_btVector4_deSerializeDouble_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector4_maxDot_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector4_minDot_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_dot3_mbt_c1af402c8cb9fdfb(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSwapScalarEndian_mbt_c1af402c8cb9fdfb(float _swig_go_0, float *_swig_go_1) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btSwapScalarEndian((float const &)*arg1,*arg2);
  
}


void _wrap_btSwapVector3Endian_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
  
}


void _wrap_btUnSwapVector3Endian_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  btUnSwapVector3Endian(*arg1);
  
}


void _wrap_btVector3FloatData_m_floats_set_mbt_c1af402c8cb9fdfb(btVector3FloatData *_swig_go_0, float *_swig_go_1) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btVector3FloatData_m_floats_get_mbt_c1af402c8cb9fdfb(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3FloatData *_wrap_new_btVector3FloatData_mbt_c1af402c8cb9fdfb() {
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  
  result = (btVector3FloatData *)new btVector3FloatData();
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3FloatData_mbt_c1af402c8cb9fdfb(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btVector3DoubleData_m_floats_set_mbt_c1af402c8cb9fdfb(btVector3DoubleData *_swig_go_0, double *_swig_go_1) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btVector3DoubleData_m_floats_get_mbt_c1af402c8cb9fdfb(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3DoubleData *_wrap_new_btVector3DoubleData_mbt_c1af402c8cb9fdfb() {
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  
  result = (btVector3DoubleData *)new btVector3DoubleData();
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3DoubleData_mbt_c1af402c8cb9fdfb(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuadWord_getX_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getY_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getZ_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setX_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btQuadWord_setY_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btQuadWord_setZ_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btQuadWord_setW_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btQuadWord_x_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_y_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_z_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_w_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setValue__SWIG_0_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuadWord_setValue__SWIG_1_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


btQuadWord *_wrap_new_btQuadWord__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  
  result = (btQuadWord *)new btQuadWord();
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_2_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setMax_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuadWord_setMin_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMin((btQuadWord const &)*arg2);
  
}


void _wrap_delete_btQuadWord_mbt_c1af402c8cb9fdfb(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  delete arg1;
  
}


btQuaternion *_wrap_new_btQuaternion__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *)new btQuaternion();
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  
  result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_3_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setRotation_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
  
}


void _wrap_btQuaternion_setEuler_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setEulerZYX_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_getEulerZYX_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btQuaternion const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


float _wrap_btQuaternion_dot_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length2_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_safeNormalize_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->safeNormalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalize_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->normalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalized_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->normalized();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


float _wrap_btQuaternion_angle_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_angleShortestPath_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngle_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngle();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngleShortestPath_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btQuaternion_getAxis_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->getAxis();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_inverse_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->inverse();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_farthest_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_nearest_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_slerp_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_getIdentity_mbt_c1af402c8cb9fdfb() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *) &btQuaternion::getIdentity();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getW_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuaternion const *)arg1)->getW();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_serialize_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serialize(*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_0_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_1_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeFloat_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btQuaternion_deSerializeFloat_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeDouble_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btQuaternion_deSerializeDouble_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_delete_btQuaternion_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuaternion_getX_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getY_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getZ_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setX_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btQuaternion_setY_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btQuaternion_setZ_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btQuaternion_setW_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btQuaternion_x_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_y_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_z_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_w_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setValue__SWIG_0_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setValue__SWIG_1_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_btQuaternion_setMax_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuaternion_setMin_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMin((btQuadWord const &)*arg2);
  
}


float _wrap_dot_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_length_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)length((btQuaternion const &)*arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_1_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_inverse_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = inverse((btQuaternion const &)*arg1);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_slerp_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btVector3 *_wrap_quatRotate_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuat_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuatNormalize2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuatNormalize2(*arg1,*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btQuaternionFloatData_m_floats_set_mbt_c1af402c8cb9fdfb(btQuaternionFloatData *_swig_go_0, float *_swig_go_1) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btQuaternionFloatData_m_floats_get_mbt_c1af402c8cb9fdfb(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionFloatData *_wrap_new_btQuaternionFloatData_mbt_c1af402c8cb9fdfb() {
  btQuaternionFloatData *result = 0 ;
  btQuaternionFloatData *_swig_go_result;
  
  
  result = (btQuaternionFloatData *)new btQuaternionFloatData();
  *(btQuaternionFloatData **)&_swig_go_result = (btQuaternionFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionFloatData_mbt_c1af402c8cb9fdfb(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuaternionDoubleData_m_floats_set_mbt_c1af402c8cb9fdfb(btQuaternionDoubleData *_swig_go_0, double *_swig_go_1) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btQuaternionDoubleData_m_floats_get_mbt_c1af402c8cb9fdfb(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionDoubleData *_wrap_new_btQuaternionDoubleData_mbt_c1af402c8cb9fdfb() {
  btQuaternionDoubleData *result = 0 ;
  btQuaternionDoubleData *_swig_go_result;
  
  
  result = (btQuaternionDoubleData *)new btQuaternionDoubleData();
  *(btQuaternionDoubleData **)&_swig_go_result = (btQuaternionDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionDoubleData_mbt_c1af402c8cb9fdfb(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *)new btMatrix3x3();
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_1_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_2_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_3_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_4_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getColumn_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getRow_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_setFromOpenGLSubMatrix_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
  
}


void _wrap_btMatrix3x3_setValue_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, float _swig_go_9) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  arg10 = (btScalar *)&_swig_go_9; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
  
}


void _wrap_btMatrix3x3_setRotation_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btMatrix3x3_setEulerYPR_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btMatrix3x3_setEulerZYX_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setEulerZYX(arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_setIdentity_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


void _wrap_btMatrix3x3_setZero_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


btMatrix3x3 *_wrap_btMatrix3x3_getIdentity_mbt_c1af402c8cb9fdfb() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_getOpenGLSubMatrix_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
  
}


void _wrap_btMatrix3x3_getRotation_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
  
}


void _wrap_btMatrix3x3_getEulerYPR_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_0_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = (unsigned int)_swig_go_4; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_1_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


btMatrix3x3 *_wrap_btMatrix3x3_scaled_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_determinant_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_adjoint_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->adjoint();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_absolute_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->absolute();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transpose_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->transpose();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_inverse_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->inverse();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_solve33_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->solve33((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotx_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdoty_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotz_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_extractRotation__SWIG_0_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->extractRotation(*arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_1_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->extractRotation(*arg2,arg3);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_2_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->extractRotation(*arg2);
  
}


void _wrap_btMatrix3x3_diagonalize_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->diagonalize(*arg2,arg3,arg4);
  
}


float _wrap_btMatrix3x3_cofac_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_serialize_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btMatrix3x3_serializeFloat_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btMatrix3x3_deSerialize_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeFloat_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeDouble_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
  
}


void _wrap_delete_btMatrix3x3_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3FloatData_m_el_set_mbt_c1af402c8cb9fdfb(btMatrix3x3FloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[3]) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btMatrix3x3FloatData_m_el_get_mbt_c1af402c8cb9fdfb(btMatrix3x3FloatData *_swig_go_0))[3] {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_el);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3FloatData *_wrap_new_btMatrix3x3FloatData_mbt_c1af402c8cb9fdfb() {
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  
  result = (btMatrix3x3FloatData *)new btMatrix3x3FloatData();
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3FloatData_mbt_c1af402c8cb9fdfb(btMatrix3x3FloatData *_swig_go_0) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3DoubleData_m_el_set_mbt_c1af402c8cb9fdfb(btMatrix3x3DoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[3]) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btMatrix3x3DoubleData_m_el_get_mbt_c1af402c8cb9fdfb(btMatrix3x3DoubleData *_swig_go_0))[3] {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_el);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3DoubleData *_wrap_new_btMatrix3x3DoubleData_mbt_c1af402c8cb9fdfb() {
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  
  result = (btMatrix3x3DoubleData *)new btMatrix3x3DoubleData();
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3DoubleData_mbt_c1af402c8cb9fdfb(btMatrix3x3DoubleData *_swig_go_0) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btTransform *_wrap_new_btTransform__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *)new btTransform();
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_1_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_2_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_3_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_4_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_5_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btTransform const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTransform_mult_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_0_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &(arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_1_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_0_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_1_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btTransform_getRotation_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->getRotation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setFromOpenGLMatrix_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
  
}


void _wrap_btTransform_getOpenGLMatrix_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
  
}


void _wrap_btTransform_setOrigin_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setOrigin((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btTransform_invXform_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setBasis_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  (arg1)->setBasis((btMatrix3x3 const &)*arg2);
  
}


void _wrap_btTransform_setRotation_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btQuaternion *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btTransform_setIdentity_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


btTransform *_wrap_btTransform_inverse_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->inverse();
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_inverseTimes_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_getIdentity_mbt_c1af402c8cb9fdfb() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *) &btTransform::getIdentity();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransform_serialize_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serialize(*arg2);
  
}


void _wrap_btTransform_serializeFloat_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btTransform_deSerialize_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btTransformFloatData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeDouble_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeFloat_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
  
}


void _wrap_delete_btTransform_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformFloatData_m_basis_set_mbt_c1af402c8cb9fdfb(btTransformFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btTransformFloatData_m_basis_get_mbt_c1af402c8cb9fdfb(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_basis);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformFloatData_m_origin_set_mbt_c1af402c8cb9fdfb(btTransformFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3FloatData *_wrap_btTransformFloatData_m_origin_get_mbt_c1af402c8cb9fdfb(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_origin);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


btTransformFloatData *_wrap_new_btTransformFloatData_mbt_c1af402c8cb9fdfb() {
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  
  result = (btTransformFloatData *)new btTransformFloatData();
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformFloatData_mbt_c1af402c8cb9fdfb(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformDoubleData_m_basis_set_mbt_c1af402c8cb9fdfb(btTransformDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btTransformDoubleData_m_basis_get_mbt_c1af402c8cb9fdfb(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_basis);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformDoubleData_m_origin_set_mbt_c1af402c8cb9fdfb(btTransformDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3DoubleData *_wrap_btTransformDoubleData_m_origin_get_mbt_c1af402c8cb9fdfb(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_origin);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


btTransformDoubleData *_wrap_new_btTransformDoubleData_mbt_c1af402c8cb9fdfb() {
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  
  result = (btTransformDoubleData *)new btTransformDoubleData();
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformDoubleData_mbt_c1af402c8cb9fdfb(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btMotionState_mbt_c1af402c8cb9fdfb(btMotionState *_swig_go_0) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMotionState_getWorldTransform_mbt_c1af402c8cb9fdfb(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btMotionState_setWorldTransform_mbt_c1af402c8cb9fdfb(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btDefaultMotionState_m_graphicsWorldTrans_set_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_graphicsWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_graphicsWorldTrans_get_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_graphicsWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_centerOfMassOffset_set_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_centerOfMassOffset = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_centerOfMassOffset_get_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_centerOfMassOffset);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_startWorldTrans_set_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_startWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_startWorldTrans_get_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_startWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_userPointer_set_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, void *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_userPointer = arg2;
  
}


void *_wrap_btDefaultMotionState_m_userPointer_get_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_userPointer);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_0_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1,(btTransform const &)*arg2);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_1_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_2_mbt_c1af402c8cb9fdfb() {
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  
  result = (btDefaultMotionState *)new btDefaultMotionState();
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_getWorldTransform_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btDefaultMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btDefaultMotionState_setWorldTransform_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_delete_btDefaultMotionState_mbt_c1af402c8cb9fdfb(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BOX_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TETRAHEDRAL_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TETRAHEDRAL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_HULL_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_HULL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_POLYHEDRAL_SHAPE_TYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_POLYHEDRAL_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_IMPLICIT_CONVEX_SHAPES_START_HERE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = IMPLICIT_CONVEX_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SPHERE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTI_SPHERE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTI_SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CAPSULE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CAPSULE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CYLINDER_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CYLINDER_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_UNIFORM_SCALING_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = UNIFORM_SCALING_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_SUM_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_SUM_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BOX_2D_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_2D_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONVEX_SHAPE_TYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONVEX_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_START_HERE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FAST_CONCAVE_MESH_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = FAST_CONCAVE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TERRAIN_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TERRAIN_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GIMPACT_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = GIMPACT_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_EMPTY_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = EMPTY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_STATIC_PLANE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = STATIC_PLANE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONCAVE_SHAPE_TYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONCAVE_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SDF_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SDF_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_END_HERE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_END_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_COMPOUND_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = COMPOUND_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOFTBODY_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SOFTBODY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_INVALID_SHAPE_PROXYTYPE_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = INVALID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_BROADPHASE_COLLISION_TYPES_mbt_c1af402c8cb9fdfb() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MAX_BROADPHASE_COLLISION_TYPES;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DefaultFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DefaultFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_StaticFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::StaticFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_KinematicFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::KinematicFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DebrisFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DebrisFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SensorTrigger_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::SensorTrigger;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CharacterFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::CharacterFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_AllFilter_btBroadphaseProxy_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::AllFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_clientObject_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, void *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_clientObject = arg2;
  
}


void *_wrap_btBroadphaseProxy_m_clientObject_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_clientObject);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterGroup_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterGroup_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterMask_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterMask_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_uniqueId_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_uniqueId_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMin_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMin = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMin_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMin);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMax_set_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMax = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMax_get_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMax);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


intgo _wrap_btBroadphaseProxy_getUid_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int)((btBroadphaseProxy const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_1_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, void *_swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  void *arg3 = (void *) 0 ;
  int arg4 ;
  int arg5 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isPolyhedral_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isPolyhedral(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isNonMoving_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isNonMoving(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConcave_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConcave(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isCompound_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isCompound(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isSoftBody_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isSoftBody(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isInfinite_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isInfinite(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex2d_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex2d(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseProxy_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  
  result = (btBroadphasePair *)new btBroadphasePair();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_1_mbt_c1af402c8cb9fdfb(btBroadphaseProxy *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphaseProxy *arg1 = 0 ;
  btBroadphaseProxy *arg2 = 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (btBroadphasePair *)new btBroadphasePair(*arg1,*arg2);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy0_set_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy0 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy0_get_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy0);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy1_set_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy1 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy1_get_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy1);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_algorithm_set_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0, btCollisionAlgorithm *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *arg2 = (btCollisionAlgorithm *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btCollisionAlgorithm **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_algorithm = arg2;
  
}


btCollisionAlgorithm *_wrap_btBroadphasePair_m_algorithm_get_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btCollisionAlgorithm *) ((arg1)->m_algorithm);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePair_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePairSortPredicate *_wrap_new_btBroadphasePairSortPredicate_mbt_c1af402c8cb9fdfb() {
  btBroadphasePairSortPredicate *result = 0 ;
  btBroadphasePairSortPredicate *_swig_go_result;
  
  
  result = (btBroadphasePairSortPredicate *)new btBroadphasePairSortPredicate();
  *(btBroadphasePairSortPredicate **)&_swig_go_result = (btBroadphasePairSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePairSortPredicate_mbt_c1af402c8cb9fdfb(btBroadphasePairSortPredicate *_swig_go_0) {
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  
  arg1 = *(btBroadphasePairSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBulletCollisionProbe_mbt_c1af402c8cb9fdfb() {
  btBulletCollisionProbe();
  
}


void _wrap_delete_btCollisionShape_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionShape_getAabb_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCollisionShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCollisionShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCollisionShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex2d_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isNonMoving_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConcave_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isCompound_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isSoftBody_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isInfinite_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btCollisionShape_getName_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (char *)((btCollisionShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_getShapeType_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setMargin_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btCollisionShape_getMargin_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserPointer_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, void *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void *_wrap_btCollisionShape_getUserPointer_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionShape_serialize_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btCollisionShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
  
}


void _wrap_btCollisionShapeData_m_name_set_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_name_get_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_shapeType_set_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0, intgo _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_shapeType = arg2;
  
}


intgo _wrap_btCollisionShapeData_m_shapeType_get_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_shapeType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_padding_set_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_padding_get_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCollisionShapeData *_wrap_new_btCollisionShapeData_mbt_c1af402c8cb9fdfb() {
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  
  result = (btCollisionShapeData *)new btCollisionShapeData();
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionShapeData_mbt_c1af402c8cb9fdfb(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_convexHullSupport_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = convexHullSupport((btVector3 const &)*arg1,(btVector3 const *)arg2,arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_delete_btConvexShape_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_project_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexShape_getAabb_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setMargin_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexShape_getMargin_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_btConvexShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex2d_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isNonMoving_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConcave_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isCompound_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isSoftBody_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isInfinite_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexShape_getName_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getShapeType_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = ((btCollisionShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserPointer_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, void *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void *_wrap_btConvexShape_getUserPointer_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (void *)((btCollisionShape const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexShape_serialize_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btConvexShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->serializeSingleShape(arg2);
  
}


void _wrap_AabbExpand_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  AabbExpand(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


bool _wrap_TestPointAgainstAabb2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestPointAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestAabbAgainstAabb2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (bool)TestAabbAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestTriangleAgainstAabb2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestTriangleAgainstAabb2((btVector3 const *)arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btOutcode_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (int)btOutcode((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo *_swig_go_2, btVector3 (*_swig_go_3)[2], float *_swig_go_4, float _swig_go_5, float _swig_go_6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int *arg3 = (unsigned int *) (unsigned int *)0 ;
  btVector3 *arg4 = (btVector3 *) (btVector3 *)0 ;
  btScalar *arg5 = 0 ;
  btScalar arg6 ;
  btScalar arg7 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(unsigned int **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  
  result = (bool)btRayAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(unsigned int const (*))arg3,(btVector3 const (*))arg4,*arg5,arg6,arg7);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  result = (bool)btRayAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransformAabb__SWIG_0_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  btTransformAabb((btVector3 const &)*arg1,arg2,(btTransform const &)*arg3,*arg4,*arg5);
  
}


void _wrap_btTransformAabb__SWIG_1_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  btTransformAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,*arg5,*arg6);
  
}


intgo _wrap_testQuantizedAabbAgainstQuantizedAabb_mbt_c1af402c8cb9fdfb(short *_swig_go_0, short *_swig_go_1, short *_swig_go_2, short *_swig_go_3) {
  unsigned short *arg1 = (unsigned short *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  unsigned short *arg3 = (unsigned short *) 0 ;
  unsigned short *arg4 = (unsigned short *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(unsigned short **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(unsigned short **)&_swig_go_2; 
  arg4 = *(unsigned short **)&_swig_go_3; 
  
  result = (unsigned int)testQuantizedAabbAgainstQuantizedAabb((unsigned short const *)arg1,(unsigned short const *)arg2,(unsigned short const *)arg3,(unsigned short const *)arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShape_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_getAabb_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexInternalShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setMargin_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexInternalShape_getMargin_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNV_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalShape_serialize_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = (btScalar)((btConvexShape const *)swig_b0)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_project_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex2d_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isNonMoving_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConcave_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isCompound_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isSoftBody_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isInfinite_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalShape_getName_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (char *)((btCollisionShape const *)swig_b1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getShapeType_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = ((btCollisionShape const *)swig_b1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserPointer_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalShape_getUserPointer_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (void *)((btCollisionShape const *)swig_b1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btConvexInternalShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->serializeSingleShape(arg2);
  
}


void _wrap_btConvexInternalShapeData_m_collisionShapeData_set_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShapeData = *arg2;
  
}


btCollisionShapeData *_wrap_btConvexInternalShapeData_m_collisionShapeData_get_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *)& ((arg1)->m_collisionShapeData);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_localScaling_set_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localScaling = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_localScaling_get_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_localScaling);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_implicitShapeDimensions_set_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_implicitShapeDimensions = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_implicitShapeDimensions_get_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_implicitShapeDimensions);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_collisionMargin_set_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0, float _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionMargin = arg2;
  
}


float _wrap_btConvexInternalShapeData_m_collisionMargin_get_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_collisionMargin);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_padding_set_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btConvexInternalShapeData_m_padding_get_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexInternalShapeData *_wrap_new_btConvexInternalShapeData_mbt_c1af402c8cb9fdfb() {
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  
  result = (btConvexInternalShapeData *)new btConvexInternalShapeData();
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShapeData_mbt_c1af402c8cb9fdfb(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexInternalAabbCachingShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabb_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btConvexInternalAabbCachingShape_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setMargin_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btConvexInternalAabbCachingShape_getMargin_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNV_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_serialize_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_project_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalAabbCachingShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalAabbCachingShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex2d_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isNonMoving_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConcave_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isCompound_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isSoftBody_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isInfinite_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_getName_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getShapeType_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserPointer_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalAabbCachingShape_getUserPointer_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btConvexInternalAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


btSphereShape *_wrap_new_btSphereShape_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  btSphereShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btSphereShape *)new btSphereShape(arg1);
  *(btSphereShape **)&_swig_go_result = (btSphereShape *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btSphereShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btSphereShape_getAabb_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


float _wrap_btSphereShape_getRadius_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUnscaledRadius_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setUnscaledRadius(arg2);
  
}


_gostring_ _wrap_btSphereShape_getName_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (char *)((btSphereShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setMargin_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btSphereShape_getMargin_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSphereShape_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btSphereShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btSphereShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNV_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btSphereShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btSphereShape_serialize_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_project_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btSphereShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btSphereShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btSphereShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex2d_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isNonMoving_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConcave_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isCompound_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isSoftBody_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isInfinite_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getShapeType_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserPointer_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, void *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btSphereShape_getUserPointer_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btSphereShape *_swig_go_0, btSerializer *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_delete_btPolyhedralConvexShape_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setPolyhedralFeatures_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  (arg1)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumVertices_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumEdges_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getEdge_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getVertex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumPlanes_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPlane_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexShape_isInside_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_getAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexShape_getMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNV_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_serialize_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_project_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex2d_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isNonMoving_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConcave_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isCompound_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isSoftBody_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isInfinite_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_getName_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getShapeType_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserPointer_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexShape_getUserPointer_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btPolyhedralConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btPolyhedralConvexAabbCachingShape_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_0_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_1_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setPolyhedralFeatures_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexAabbCachingShape_getConvexPolyhedron_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = ((btPolyhedralConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumVertices_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumEdges_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getEdge_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getVertex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPlanes_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPlane_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInside_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)((btPolyhedralConvexShape const *)swig_b0)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMargin_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNV_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_serialize_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_project_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex2d_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isNonMoving_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConcave_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isCompound_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isSoftBody_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInfinite_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_getName_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (char *)((btCollisionShape const *)swig_b3)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getShapeType_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserPointer_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexAabbCachingShape_getUserPointer_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btPolyhedralConvexAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


btBoxShape *_wrap_new_btBoxShape_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  btBoxShape *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
  *(btBoxShape **)&_swig_go_result = (btBoxShape *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btBoxShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabb_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlane_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


intgo _wrap_btBoxShape_getNumPlanes_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumVertices_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumEdges_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getVertex_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlaneEquation_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector4 *_swig_go_1, intgo _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector4 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
  
}


void _wrap_btBoxShape_getEdge_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


bool _wrap_btBoxShape_isInside_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_getName_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (char *)((btBoxShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_delete_btBoxShape_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_0_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_1_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setPolyhedralFeatures_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btBoxShape_getConvexPolyhedron_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btBoxShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMargin_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNV_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_serialize_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_project_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btBoxShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btBoxShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btBoxShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex2d_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isNonMoving_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConcave_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isCompound_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isSoftBody_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isInfinite_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getShapeType_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserPointer_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, void *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btBoxShape_getUserPointer_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btBoxShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


void _wrap_btFace_m_indices_set_mbt_c1af402c8cb9fdfb(btFace *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_indices = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btFace_m_indices_get_mbt_c1af402c8cb9fdfb(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->m_indices);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btFace_m_plane_set_mbt_c1af402c8cb9fdfb(btFace *_swig_go_0, float *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_plane;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btFace_m_plane_get_mbt_c1af402c8cb9fdfb(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_plane);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btFace *_wrap_new_btFace_mbt_c1af402c8cb9fdfb() {
  btFace *result = 0 ;
  btFace *_swig_go_result;
  
  
  result = (btFace *)new btFace();
  *(btFace **)&_swig_go_result = (btFace *)result; 
  return _swig_go_result;
}


void _wrap_delete_btFace_mbt_c1af402c8cb9fdfb(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  delete arg1;
  
}


btConvexPolyhedron *_wrap_new_btConvexPolyhedron_mbt_c1af402c8cb9fdfb() {
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  
  result = (btConvexPolyhedron *)new btConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexPolyhedron_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexPolyhedron_m_vertices_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_vertices_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_faces_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btFace > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *arg2 = (btAlignedObjectArray< btFace > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btFace > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_faces = *arg2;
  
}


btAlignedObjectArray< btFace > *_wrap_btConvexPolyhedron_m_faces_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *result = 0 ;
  btAlignedObjectArray< btFace > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btFace > *)& ((arg1)->m_faces);
  *(btAlignedObjectArray< btFace > **)&_swig_go_result = (btAlignedObjectArray< btFace > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_uniqueEdges_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueEdges = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_uniqueEdges_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_uniqueEdges);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_localCenter_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localCenter = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_localCenter_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_localCenter);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_extents_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_extents = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_extents_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_extents);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_radius_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, float _swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_radius = arg2;
  
}


float _wrap_btConvexPolyhedron_m_radius_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_radius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mC_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mC = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mC_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mC);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mE_set_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mE = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mE_get_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mE);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_initialize_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize();
  
}


void _wrap_btConvexPolyhedron_initialize2_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize2();
  
}


bool _wrap_btConvexPolyhedron_testContainment_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (bool)((btConvexPolyhedron const *)arg1)->testContainment();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_project_mbt_c1af402c8cb9fdfb(btConvexPolyhedron *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexPolyhedron const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btGeometryUtil_getPlaneEquationsFromVertices_mbt_c1af402c8cb9fdfb(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getPlaneEquationsFromVertices(*arg1,*arg2);
  
}


void _wrap_btGeometryUtil_getVerticesFromPlaneEquations_mbt_c1af402c8cb9fdfb(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getVerticesFromPlaneEquations((btAlignedObjectArray< btVector3 > const &)*arg1,*arg2);
  
}


bool _wrap_btGeometryUtil_isPointInsidePlanes_mbt_c1af402c8cb9fdfb(btAlignedObjectArray< btVector3 > *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::isPointInsidePlanes((btAlignedObjectArray< btVector3 > const &)*arg1,(btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeometryUtil_areVerticesBehindPlane_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::areVerticesBehindPlane((btVector3 const &)*arg1,(btAlignedObjectArray< btVector3 > const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeometryUtil *_wrap_new_btGeometryUtil_mbt_c1af402c8cb9fdfb() {
  btGeometryUtil *result = 0 ;
  btGeometryUtil *_swig_go_result;
  
  
  result = (btGeometryUtil *)new btGeometryUtil();
  *(btGeometryUtil **)&_swig_go_result = (btGeometryUtil *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeometryUtil_mbt_c1af402c8cb9fdfb(btGeometryUtil *_swig_go_0) {
  btGeometryUtil *arg1 = (btGeometryUtil *) 0 ;
  
  arg1 = *(btGeometryUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexHullInternal_vertexList_set_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertexList = arg2;
  
}


btConvexHullInternal::Vertex *_wrap_btConvexHullInternal_vertexList_get_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *result = 0 ;
  btConvexHullInternal::Vertex *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  result = (btConvexHullInternal::Vertex *) ((arg1)->vertexList);
  *(btConvexHullInternal::Vertex **)&_swig_go_result = (btConvexHullInternal::Vertex *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullInternal_compute_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0, void *_swig_go_1, bool _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  void *arg2 = (void *) 0 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  (arg1)->compute((void const *)arg2,arg3,arg4,arg5);
  
}


btVector3 *_wrap_btConvexHullInternal_getCoordinates_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  result = (arg1)->getCoordinates((btConvexHullInternal::Vertex const *)arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexHullInternal_shrink_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)(arg1)->shrink(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullInternal *_wrap_new_btConvexHullInternal_mbt_c1af402c8cb9fdfb() {
  btConvexHullInternal *result = 0 ;
  btConvexHullInternal *_swig_go_result;
  
  
  result = (btConvexHullInternal *)new btConvexHullInternal();
  *(btConvexHullInternal **)&_swig_go_result = (btConvexHullInternal *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullInternal_mbt_c1af402c8cb9fdfb(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  delete arg1;
  
}


pointCmp *_wrap_new_pointCmp_mbt_c1af402c8cb9fdfb() {
  pointCmp *result = 0 ;
  pointCmp *_swig_go_result;
  
  
  result = (pointCmp *)new pointCmp();
  *(pointCmp **)&_swig_go_result = (pointCmp *)result; 
  return _swig_go_result;
}


void _wrap_delete_pointCmp_mbt_c1af402c8cb9fdfb(pointCmp *_swig_go_0) {
  pointCmp *arg1 = (pointCmp *) 0 ;
  
  arg1 = *(pointCmp **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_getVertexCopy_mbt_c1af402c8cb9fdfb(btConvexHullInternal::Vertex *_swig_go_0, btAlignedObjectArray< btConvexHullInternal::Vertex * > *_swig_go_1) {
  btConvexHullInternal::Vertex *arg1 = (btConvexHullInternal::Vertex *) 0 ;
  btAlignedObjectArray< btConvexHullInternal::Vertex * > *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexHullInternal::Vertex **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullInternal::Vertex * > **)&_swig_go_1; 
  
  result = (int)getVertexCopy(arg1,*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_vertices_set_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexHullComputer_vertices_get_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_original_vertex_index_set_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->original_vertex_index = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_original_vertex_index_get_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->original_vertex_index);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_edges_set_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *arg2 = (btAlignedObjectArray< btConvexHullComputer::Edge > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_1; 
  
  if (arg1) (arg1)->edges = *arg2;
  
}


btAlignedObjectArray< btConvexHullComputer::Edge > *_wrap_btConvexHullComputer_edges_get_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *result = 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)& ((arg1)->edges);
  *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_faces_set_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->faces = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_faces_get_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->faces);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, float *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((float const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0, double *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((double const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullComputer *_wrap_new_btConvexHullComputer_mbt_c1af402c8cb9fdfb() {
  btConvexHullComputer *result = 0 ;
  btConvexHullComputer *_swig_go_result;
  
  
  result = (btConvexHullComputer *)new btConvexHullComputer();
  *(btConvexHullComputer **)&_swig_go_result = (btConvexHullComputer *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullComputer_mbt_c1af402c8cb9fdfb(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btHashString_m_string1_set_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0, std::string *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string arg2 ;
  std::string *argp2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  argp2 = (std::string *)_swig_go_1;
  if (argp2 == NULL) {
    _swig_gopanic("Attempt to dereference null std::string");
  }
  arg2 = (std::string)*argp2;
  
  
  if (arg1) (arg1)->m_string1 = arg2;
  
}


std::string *_wrap_btHashString_m_string1_get_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string result;
  std::string *_swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result =  ((arg1)->m_string1);
  *(std::string **)&_swig_go_result = new std::string(result); 
  return _swig_go_result;
}


void _wrap_btHashString_m_hash_set_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0, intgo _swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int arg2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hash = arg2;
  
}


intgo _wrap_btHashString_m_hash_get_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int) ((arg1)->m_hash);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashString_getHash_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int)((btHashString const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  result = (btHashString *)new btHashString();
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_1_mbt_c1af402c8cb9fdfb(_gostring_ _swig_go_0) {
  char *arg1 = (char *) 0 ;
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  result = (btHashString *)new btHashString((char const *)arg1);
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  free(arg1); 
  return _swig_go_result;
}


bool _wrap_btHashString_equals_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0, btHashString *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  btHashString *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = *(btHashString **)&_swig_go_1; 
  
  result = (bool)((btHashString const *)arg1)->equals((btHashString const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashString_mbt_c1af402c8cb9fdfb(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_HASH_NULL_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)(int)BT_HASH_NULL;
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  
  result = (btHashInt *)new btHashInt();
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_1_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btHashInt *)new btHashInt(arg1);
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getUid1_mbt_c1af402c8cb9fdfb(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (int)((btHashInt const *)arg1)->getUid1();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHashInt_setUid1_mbt_c1af402c8cb9fdfb(btHashInt *_swig_go_0, intgo _swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int arg2 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUid1(arg2);
  
}


bool _wrap_btHashInt_equals_mbt_c1af402c8cb9fdfb(btHashInt *_swig_go_0, btHashInt *_swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  btHashInt *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = *(btHashInt **)&_swig_go_1; 
  
  result = (bool)((btHashInt const *)arg1)->equals((btHashInt const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getHash_mbt_c1af402c8cb9fdfb(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (unsigned int)((btHashInt const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashInt_mbt_c1af402c8cb9fdfb(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  delete arg1;
  
}


btHashPtr *_wrap_new_btHashPtr__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  
  result = (btHashPtr *)new btHashPtr();
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


btHashPtr *_wrap_new_btHashPtr__SWIG_1_mbt_c1af402c8cb9fdfb(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  arg1 = *(void **)&_swig_go_0; 
  
  result = (btHashPtr *)new btHashPtr((void const *)arg1);
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


void *_wrap_btHashPtr_getPointer_mbt_c1af402c8cb9fdfb(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (void *)((btHashPtr const *)arg1)->getPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


bool _wrap_btHashPtr_equals_mbt_c1af402c8cb9fdfb(btHashPtr *_swig_go_0, btHashPtr *_swig_go_1) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  btHashPtr *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  arg2 = *(btHashPtr **)&_swig_go_1; 
  
  result = (bool)((btHashPtr const *)arg1)->equals((btHashPtr const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashPtr_getHash_mbt_c1af402c8cb9fdfb(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (unsigned int)((btHashPtr const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashPtr_mbt_c1af402c8cb9fdfb(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  delete arg1;
  
}


btCapsuleShape *_wrap_new_btCapsuleShape__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShape *result = 0 ;
  btCapsuleShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShape *)new btCapsuleShape(arg1,arg2);
  *(btCapsuleShape **)&_swig_go_result = (btCapsuleShape *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCapsuleShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btCapsuleShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShape_setMargin_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btCapsuleShape_getAabb_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


_gostring_ _wrap_btCapsuleShape_getName_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getUpAxis_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getRadius_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getHalfHeight_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = ((btCapsuleShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShape_serialize_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCapsuleShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_deSerializeFloat_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat(arg2);
  
}


void _wrap_delete_btCapsuleShape_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_getAabbSlow_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMargin_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNV_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShape_project_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex2d_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isNonMoving_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConcave_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isCompound_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isSoftBody_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isInfinite_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getShapeType_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, void *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShape_getUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btCapsuleShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


btCapsuleShapeX *_wrap_new_btCapsuleShapeX_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeX *result = 0 ;
  btCapsuleShapeX *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeX *)new btCapsuleShapeX(arg1,arg2);
  *(btCapsuleShapeX **)&_swig_go_result = (btCapsuleShapeX *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_getName_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeX const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeX_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeX_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeX_setMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_getAabb_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeX_getUpAxis_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getRadius_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getHalfHeight_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_serialize_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_deSerializeFloat_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_getAabbSlow_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNV_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeX_project_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeX_getBoundingSphere_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeX_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeX_isPolyhedral_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex2d_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isNonMoving_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConcave_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isCompound_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isSoftBody_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isInfinite_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getShapeType_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeX_getUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_serializeSingleShape_mbt_c1af402c8cb9fdfb(btCapsuleShapeX *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btCapsuleShapeZ *_wrap_new_btCapsuleShapeZ_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeZ *result = 0 ;
  btCapsuleShapeZ *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeZ *)new btCapsuleShapeZ(arg1,arg2);
  *(btCapsuleShapeZ **)&_swig_go_result = (btCapsuleShapeZ *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_getName_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeZ const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeZ_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeZ_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeZ_setMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabb_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeZ_getUpAxis_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getRadius_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getHalfHeight_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_serialize_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_deSerializeFloat_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setImplicitShapeDimensions_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_0_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_1_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_2_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_3_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabbSlow_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScaling_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScalingNV_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMargin_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNV_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getNumPreferredPenetrationDirections_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getPreferredPenetrationDirection_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexWithoutMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getAabbNonVirtual_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeZ_project_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeZ_getBoundingSphere_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeZ_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeZ_isPolyhedral_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex2d_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isNonMoving_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConcave_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isCompound_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isSoftBody_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isInfinite_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getShapeType_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeZ_getUserPointer_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex2_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_serializeSingleShape_mbt_c1af402c8cb9fdfb(btCapsuleShapeZ *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


void _wrap_btCapsuleShapeData_m_convexInternalShapeData_set_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0, btConvexInternalShapeData *_swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *arg2 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = *(btConvexInternalShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexInternalShapeData = *arg2;
  
}


btConvexInternalShapeData *_wrap_btCapsuleShapeData_m_convexInternalShapeData_get_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (btConvexInternalShapeData *)& ((arg1)->m_convexInternalShapeData);
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_upAxis_set_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_upAxis = arg2;
  
}


intgo _wrap_btCapsuleShapeData_m_upAxis_get_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_upAxis);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_padding_set_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCapsuleShapeData_m_padding_get_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCapsuleShapeData *_wrap_new_btCapsuleShapeData_mbt_c1af402c8cb9fdfb() {
  btCapsuleShapeData *result = 0 ;
  btCapsuleShapeData *_swig_go_result;
  
  
  result = (btCapsuleShapeData *)new btCapsuleShapeData();
  *(btCapsuleShapeData **)&_swig_go_result = (btCapsuleShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeData_mbt_c1af402c8cb9fdfb(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_CF_DYNAMIC_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DYNAMIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_STATIC_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_STATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_KINEMATIC_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_KINEMATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_NO_CONTACT_RESPONSE_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_NO_CONTACT_RESPONSE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CUSTOM_MATERIAL_CALLBACK_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CHARACTER_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CHARACTER_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_VISUALIZE_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_SPU_COLLISION_PROCESSING_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CONTACT_STIFFNESS_DAMPING_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_FRICTION_ANCHOR_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_FRICTION_ANCHOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_COLLISION_SOUND_TRIGGER_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_COLLISION_SOUND_TRIGGER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_COLLISION_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_COLLISION_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_RIGID_BODY_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_RIGID_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_GHOST_OBJECT_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_GHOST_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_SOFT_BODY_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_SOFT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_HF_FLUID_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_HF_FLUID;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_USER_TYPE_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_USER_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_FEATHERSTONE_LINK_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_FEATHERSTONE_LINK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_DISABLED_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION_DISABLED;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_ROLLING_FRICTION_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_mergesSimulationIslands_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getAnisotropicFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btCollisionObject_getContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticObject_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isKinematicObject_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticOrKinematicObject_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasContactResponse_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_new_btCollisionObject_mbt_c1af402c8cb9fdfb() {
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  
  result = (btCollisionObject *)new btCollisionObject();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObject_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObject_setCollisionShape_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionShape *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  (arg1)->setCollisionShape(arg2);
  
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIgnoreCollisionCheck_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btCollisionObject_getNumObjectsWithoutCollision_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btCollisionObject_getObjectWithoutCollision_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btCollisionObject *)(arg1)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWithOverride_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btCollisionObject_internalGetExtensionPointer_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_internalSetExtensionPointer_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btCollisionObject_getActivationState_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setActivationState_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->setActivationState(arg2);
  
}


void _wrap_btCollisionObject_setDeactivationTime_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDeactivationTime(arg2);
  
}


float _wrap_btCollisionObject_getDeactivationTime_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_forceActivationState_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->forceActivationState(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, bool _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->activate(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  ((btCollisionObject const *)arg1)->activate();
  
}


bool _wrap_btCollisionObject_isActive_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRestitution_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRestitution(arg2);
  
}


float _wrap_btCollisionObject_getRestitution_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setFriction(arg2);
  
}


float _wrap_btCollisionObject_getFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRollingFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRollingFriction(arg2);
  
}


float _wrap_btCollisionObject_getRollingFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setSpinningFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSpinningFriction(arg2);
  
}


float _wrap_btCollisionObject_getSpinningFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactStiffnessAndDamping_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btCollisionObject_getContactStiffness_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getContactDamping_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getInternalType_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldTransform_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setBroadphaseHandle_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setInterpolationWorldTransform_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationLinearVelocity_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationAngularVelocity_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getIslandTag_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIslandTag_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setIslandTag(arg2);
  
}


intgo _wrap_btCollisionObject_getCompanionId_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCompanionId_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCompanionId(arg2);
  
}


intgo _wrap_btCollisionObject_getWorldArrayIndex_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldArrayIndex_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setWorldArrayIndex(arg2);
  
}


float _wrap_btCollisionObject_getHitFraction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setHitFraction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setHitFraction(arg2);
  
}


intgo _wrap_btCollisionObject_getCollisionFlags_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCollisionFlags_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCollisionFlags(arg2);
  
}


float _wrap_btCollisionObject_getCcdSweptSphereRadius_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdSweptSphereRadius_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btCollisionObject_getCcdMotionThreshold_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getCcdSquareMotionThreshold_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdMotionThreshold_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btCollisionObject_getUserPointer_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex2_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex3_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setUserPointer_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex2_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex3_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex3(arg2);
  
}


intgo _wrap_btCollisionObject_getUpdateRevisionInternal_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCustomDebugColor_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_removeCustomDebugColor_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  (arg1)->removeCustomDebugColor();
  
}


bool _wrap_btCollisionObject_getCustomDebugColor_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWith_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionObject_serialize_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObject_serializeSingleObject_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
  
}


void _wrap_btCollisionObjectDoubleData_m_broadphaseHandle_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_broadphaseHandle_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionShape_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_collisionShape_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rootCollisionShape_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectDoubleData_m_rootCollisionShape_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_name_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectDoubleData_m_name_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_worldTransform_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_worldTransform_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_worldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_anisotropicFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_anisotropicFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_deactivationTime_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_deactivationTime_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_friction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_friction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rollingFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_rollingFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactDamping_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactDamping_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactStiffness_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactStiffness_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_restitution_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_restitution_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hitFraction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_hitFraction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFlags_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFlags_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_islandTag1_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_islandTag1_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_companionId_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_companionId_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_activationState1_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_activationState1_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_internalType_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_internalType_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_checkCollideWith_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_checkCollideWith_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_uniqueId_set_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_uniqueId_get_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectDoubleData *_wrap_new_btCollisionObjectDoubleData_mbt_c1af402c8cb9fdfb() {
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  
  result = (btCollisionObjectDoubleData *)new btCollisionObjectDoubleData();
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectDoubleData_mbt_c1af402c8cb9fdfb(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObjectFloatData_m_broadphaseHandle_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_broadphaseHandle_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionShape_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_collisionShape_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rootCollisionShape_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectFloatData_m_rootCollisionShape_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_name_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectFloatData_m_name_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_worldTransform_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_worldTransform_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_worldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_anisotropicFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_anisotropicFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_deactivationTime_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_deactivationTime_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_friction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_friction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rollingFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_rollingFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactDamping_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactDamping_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactStiffness_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactStiffness_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_restitution_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_restitution_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hitFraction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_hitFraction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFlags_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFlags_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_islandTag1_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_islandTag1_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_companionId_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_companionId_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_activationState1_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_activationState1_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_internalType_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_internalType_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_checkCollideWith_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_checkCollideWith_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterMask_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterMask_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_uniqueId_set_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_uniqueId_get_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectFloatData *_wrap_new_btCollisionObjectFloatData_mbt_c1af402c8cb9fdfb() {
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  
  result = (btCollisionObjectFloatData *)new btCollisionObjectFloatData();
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectFloatData_mbt_c1af402c8cb9fdfb(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gDeactivationTime_set_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  
  arg1 = (btScalar)_swig_go_0; 
  
  gDeactivationTime = arg1;
  
}


float _wrap_gDeactivationTime_get_mbt_c1af402c8cb9fdfb() {
  btScalar result;
  float _swig_go_result;
  
  
  result = (btScalar)gDeactivationTime;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gDisableDeactivation_set_mbt_c1af402c8cb9fdfb(bool _swig_go_0) {
  bool arg1 ;
  
  arg1 = (bool)_swig_go_0; 
  
  gDisableDeactivation = arg1;
  
}


bool _wrap_gDisableDeactivation_get_mbt_c1af402c8cb9fdfb() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)gDisableDeactivation;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_uniqueId_set_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  uniqueId = arg1;
  
}


intgo _wrap_uniqueId_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)uniqueId;
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_evalEulerEqn_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btMatrix3x3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btMatrix3x3 *arg5 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  
  result = evalEulerEqn((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,(btMatrix3x3 const &)*arg5);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_evalEulerEqnDeriv_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btMatrix3x3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btMatrix3x3 **)&_swig_go_3; 
  
  result = evalEulerEqnDeriv((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btMatrix3x3 const &)*arg4);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


intgo _wrap_BT_DISABLE_WORLD_GRAVITY_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_DISABLE_WORLD_GRAVITY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROPSCOPIC_FORCE_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROPSCOPIC_FORCE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody::btRigidBodyConstructionInfo *_swig_go_0) {
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btRigidBody::btRigidBodyConstructionInfo **)&_swig_go_0; 
  
  result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_1_mbt_c1af402c8cb9fdfb(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_2_mbt_c1af402c8cb9fdfb(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBody_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBody_proceedToTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->proceedToTransform((btTransform const &)*arg2);
  
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast(arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_predictIntegratedTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->predictIntegratedTransform(arg2,*arg3);
  
}


void _wrap_btRigidBody_saveKinematicState_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->saveKinematicState(arg2);
  
}


void _wrap_btRigidBody_applyGravity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->applyGravity();
  
}


void _wrap_btRigidBody_clearGravity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearGravity();
  
}


void _wrap_btRigidBody_setGravity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getGravity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getLinearDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getLinearSleepingThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularSleepingThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_applyDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->applyDamping(arg2);
  
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMassProps_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getLinearFactor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearFactor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearFactor((btVector3 const &)*arg2);
  
}


float _wrap_btRigidBody_getInvMass_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getMass_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_integrateVelocities_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->integrateVelocities(arg2);
  
}


void _wrap_btRigidBody_setCenterOfMassTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralForce_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralForce((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getTotalForce_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTotalTorque_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInvInertiaDiagLocal_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setSleepingThresholds_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSleepingThresholds(arg2,arg3);
  
}


void _wrap_btRigidBody_applyTorque_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorque((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyForce_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyCentralImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyPushImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyPushImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getPushVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTurnVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getTurnVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_setPushVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setPushVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setTurnVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setTurnVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralPushImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralPushImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueTurnImpulse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueTurnImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_clearForces_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btRigidBody_updateInertiaTensor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->updateInertiaTensor();
  
}


btVector3 *_wrap_btRigidBody_getCenterOfMassPosition_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btRigidBody_getOrientation_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getOrientation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getCenterOfMassTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLinearVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAngularVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getPushVelocityInLocalPoint_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_translate_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->translate((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_getAabb_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
  
}


float _wrap_btRigidBody_computeImpulseDenominator_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_computeAngularImpulseDenominator_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_updateDeactivation_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateDeactivation(arg2);
  
}


bool _wrap_btRigidBody_wantsSleeping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)(arg1)->wantsSleeping();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setNewBroadphaseProxy_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setNewBroadphaseProxy(arg2);
  
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)(arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMotionState_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btMotionState *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  
  (arg1)->setMotionState(arg2);
  
}


void _wrap_btRigidBody_m_contactSolverType_set_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_contactSolverType_get_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_contactSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_m_frictionSolverType_set_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_frictionSolverType_get_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_frictionSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAngularFactor__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularFactor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularFactor__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setAngularFactor(arg2);
  
}


btVector3 *_wrap_btRigidBody_getAngularFactor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isInWorld_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)((btRigidBody const *)arg1)->isInWorld();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_addConstraintRef_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraintRef(arg2);
  
}


void _wrap_btRigidBody_removeConstraintRef_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraintRef(arg2);
  
}


btTypedConstraint *_wrap_btRigidBody_getConstraintRef_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getNumConstraintRefs_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFlags_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setFlags(arg2);
  
}


intgo _wrap_btRigidBody_getFlags_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_World_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_World(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_Body_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_Body(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicForceExplicit_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicForceExplicit(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLocalInertia_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getLocalInertia();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btRigidBody_serialize_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btRigidBody_serializeSingleObject_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btSerializer *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
  
}


bool _wrap_btRigidBody_mergesSimulationIslands_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAnisotropicFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btRigidBody_getContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticObject_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isKinematicObject_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticOrKinematicObject_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasContactResponse_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionShape_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btCollisionShape *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionShape(arg2);
  
}


void _wrap_btRigidBody_setIgnoreCollisionCheck_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btRigidBody_getNumObjectsWithoutCollision_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btRigidBody_getObjectWithoutCollision_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btCollisionObject *)(swig_b0)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWithOverride_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btRigidBody_internalGetExtensionPointer_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_internalSetExtensionPointer_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btRigidBody_getActivationState_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setActivationState_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->setActivationState(arg2);
  
}


void _wrap_btRigidBody_setDeactivationTime_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setDeactivationTime(arg2);
  
}


float _wrap_btRigidBody_getDeactivationTime_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_forceActivationState_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->forceActivationState(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, bool _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate();
  
}


bool _wrap_btRigidBody_isActive_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRestitution_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRestitution(arg2);
  
}


float _wrap_btRigidBody_getRestitution_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setFriction(arg2);
  
}


float _wrap_btRigidBody_getFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRollingFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRollingFriction(arg2);
  
}


float _wrap_btRigidBody_getRollingFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setSpinningFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setSpinningFriction(arg2);
  
}


float _wrap_btRigidBody_getSpinningFriction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactStiffnessAndDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getContactStiffness_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getContactDamping_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getInternalType_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)(swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)((btCollisionObject const *)swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setBroadphaseHandle_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInterpolationWorldTransform_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationLinearVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationAngularVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getInterpolationLinearVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInterpolationAngularVelocity_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getIslandTag_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setIslandTag_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIslandTag(arg2);
  
}


intgo _wrap_btRigidBody_getCompanionId_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCompanionId_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCompanionId(arg2);
  
}


intgo _wrap_btRigidBody_getWorldArrayIndex_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldArrayIndex_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldArrayIndex(arg2);
  
}


float _wrap_btRigidBody_getHitFraction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setHitFraction_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setHitFraction(arg2);
  
}


intgo _wrap_btRigidBody_getCollisionFlags_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionFlags_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionFlags(arg2);
  
}


float _wrap_btRigidBody_getCcdSweptSphereRadius_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdSweptSphereRadius_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btRigidBody_getCcdMotionThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getCcdSquareMotionThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdMotionThreshold_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btRigidBody_getUserPointer_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex2_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex3_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setUserPointer_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void _wrap_btRigidBody_setUserIndex_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


void _wrap_btRigidBody_setUserIndex2_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


void _wrap_btRigidBody_setUserIndex3_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex3(arg2);
  
}


intgo _wrap_btRigidBody_getUpdateRevisionInternal_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCustomDebugColor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_removeCustomDebugColor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->removeCustomDebugColor();
  
}


bool _wrap_btRigidBody_getCustomDebugColor_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWith_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_collisionObjectData_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectFloatData *_wrap_btRigidBodyFloatData_m_collisionObjectData_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearVelocity_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearVelocity_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularVelocity_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularVelocity_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_acceleration_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_acceleration_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaLocal_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaLocal_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalForce_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalForce_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalForce);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalTorque_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalTorque_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalTorque);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_inverseMass_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_inverseMass_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDampingFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalDampingFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyFloatData_m_additionalDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


btRigidBodyFloatData *_wrap_new_btRigidBodyFloatData_mbt_c1af402c8cb9fdfb() {
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  
  result = (btRigidBodyFloatData *)new btRigidBodyFloatData();
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyFloatData_mbt_c1af402c8cb9fdfb(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBodyDoubleData_m_collisionObjectData_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectDoubleData *_wrap_btRigidBodyDoubleData_m_collisionObjectData_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearVelocity_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearVelocity_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularVelocity_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularVelocity_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_acceleration_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_acceleration_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaLocal_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaLocal_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalForce_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalForce_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalForce);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalTorque_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalTorque_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalTorque);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_inverseMass_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_inverseMass_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDamping_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyDoubleData_m_additionalDamping_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_padding_set_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btRigidBodyDoubleData_m_padding_get_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btRigidBodyDoubleData *_wrap_new_btRigidBodyDoubleData_mbt_c1af402c8cb9fdfb() {
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  
  result = (btRigidBodyDoubleData *)new btRigidBodyDoubleData();
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyDoubleData_mbt_c1af402c8cb9fdfb(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  
  result = (btJacobianEntry *)new btJacobianEntry();
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_1_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, float _swig_go_6, btVector3 *_swig_go_7, float _swig_go_8) {
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btVector3 *arg8 = 0 ;
  btScalar arg9 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,(btVector3 const &)*arg8,arg9);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_2_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btMatrix3x3 *_swig_go_1, btMatrix3x3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = *(btMatrix3x3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btMatrix3x3 const &)*arg2,(btMatrix3x3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_3_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


btJacobianEntry *_wrap_new_btJacobianEntry__SWIG_4_mbt_c1af402c8cb9fdfb(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, float _swig_go_5) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar arg6 ;
  btJacobianEntry *result = 0 ;
  btJacobianEntry *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btJacobianEntry *)new btJacobianEntry((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
  *(btJacobianEntry **)&_swig_go_result = (btJacobianEntry *)result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getDiagonal_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getDiagonal();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getNonDiagonal__SWIG_0_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btJacobianEntry *_swig_go_1, float _swig_go_2) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btJacobianEntry **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getNonDiagonal__SWIG_1_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btJacobianEntry *_swig_go_1, float _swig_go_2, float _swig_go_3) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btJacobianEntry *arg2 = 0 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btJacobianEntry **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (btScalar)((btJacobianEntry const *)arg1)->getNonDiagonal((btJacobianEntry const &)*arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btJacobianEntry_getRelativeVelocity_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  result = (btScalar)(arg1)->getRelativeVelocity((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_linearJointAxis_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearJointAxis = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_linearJointAxis_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearJointAxis);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_aJ_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aJ = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_aJ_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aJ);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_bJ_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bJ = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_bJ_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_bJ);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_0MinvJt_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_0MinvJt = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_0MinvJt_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_0MinvJt);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_1MinvJt_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, btVector3 *_swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_1MinvJt = *arg2;
  
}


btVector3 *_wrap_btJacobianEntry_m_1MinvJt_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_1MinvJt);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJacobianEntry_m_Adiag_set_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0, float _swig_go_1) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_Adiag = arg2;
  
}


float _wrap_btJacobianEntry_m_Adiag_get_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_Adiag);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btJacobianEntry_mbt_c1af402c8cb9fdfb(btJacobianEntry *_swig_go_0) {
  btJacobianEntry *arg1 = (btJacobianEntry *) 0 ;
  
  arg1 = *(btJacobianEntry **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btAabbSupport_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = btAabbSupport((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTransformUtil_integrateTransform_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btTransform *_swig_go_4) {
  btTransform *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btTransform *arg5 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  
  btTransformUtil::integrateTransform((btTransform const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,*arg5);
  
}


void _wrap_btTransformUtil_calculateVelocityQuaternion_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btQuaternion *_swig_go_2, btQuaternion *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion *arg3 = 0 ;
  btQuaternion *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btQuaternion **)&_swig_go_2; 
  arg4 = *(btQuaternion **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btTransformUtil::calculateVelocityQuaternion((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btQuaternion const &)*arg3,(btQuaternion const &)*arg4,arg5,*arg6,*arg7);
  
}


void _wrap_btTransformUtil_calculateDiffAxisAngleQuaternion_mbt_c1af402c8cb9fdfb(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btTransformUtil::calculateDiffAxisAngleQuaternion((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btTransformUtil_calculateVelocity_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, float _swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  btTransformUtil::calculateVelocity((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,*arg4,*arg5);
  
}


void _wrap_btTransformUtil_calculateDiffAxisAngle_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btTransformUtil::calculateDiffAxisAngle((btTransform const &)*arg1,(btTransform const &)*arg2,*arg3,*arg4);
  
}


btTransformUtil *_wrap_new_btTransformUtil_mbt_c1af402c8cb9fdfb() {
  btTransformUtil *result = 0 ;
  btTransformUtil *_swig_go_result;
  
  
  result = (btTransformUtil *)new btTransformUtil();
  *(btTransformUtil **)&_swig_go_result = (btTransformUtil *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformUtil_mbt_c1af402c8cb9fdfb(btTransformUtil *_swig_go_0) {
  btTransformUtil *arg1 = (btTransformUtil *) 0 ;
  
  arg1 = *(btTransformUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


btConvexSeparatingDistanceUtil *_wrap_new_btConvexSeparatingDistanceUtil_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btConvexSeparatingDistanceUtil *result = 0 ;
  btConvexSeparatingDistanceUtil *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btConvexSeparatingDistanceUtil *)new btConvexSeparatingDistanceUtil(arg1,arg2);
  *(btConvexSeparatingDistanceUtil **)&_swig_go_result = (btConvexSeparatingDistanceUtil *)result; 
  return _swig_go_result;
}


float _wrap_btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance_mbt_c1af402c8cb9fdfb(btConvexSeparatingDistanceUtil *_swig_go_0) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getConservativeSeparatingDistance();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexSeparatingDistanceUtil_updateSeparatingDistance_mbt_c1af402c8cb9fdfb(btConvexSeparatingDistanceUtil *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->updateSeparatingDistance((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btConvexSeparatingDistanceUtil_initSeparatingDistance_mbt_c1af402c8cb9fdfb(btConvexSeparatingDistanceUtil *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  
  (arg1)->initSeparatingDistance((btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,(btTransform const &)*arg5);
  
}


void _wrap_delete_btConvexSeparatingDistanceUtil_mbt_c1af402c8cb9fdfb(btConvexSeparatingDistanceUtil *_swig_go_0) {
  btConvexSeparatingDistanceUtil *arg1 = (btConvexSeparatingDistanceUtil *) 0 ;
  
  arg1 = *(btConvexSeparatingDistanceUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSolverBody_m_worldTransform_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btTransform *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransform *_wrap_btSolverBody_m_worldTransform_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_worldTransform);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_deltaLinearVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_deltaLinearVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_deltaLinearVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_deltaLinearVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_deltaAngularVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_deltaAngularVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_deltaAngularVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_deltaAngularVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_angularFactor_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_angularFactor_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularFactor);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_linearFactor_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_linearFactor_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearFactor);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_invMass_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invMass = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_invMass_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_invMass);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_pushVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pushVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_pushVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_pushVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_turnVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_turnVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_turnVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_turnVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_linearVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_linearVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_linearVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_angularVelocity_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_angularVelocity_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_externalForceImpulse_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_externalForceImpulse = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_externalForceImpulse_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_externalForceImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_externalTorqueImpulse_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_externalTorqueImpulse = *arg2;
  
}


btVector3 *_wrap_btSolverBody_m_externalTorqueImpulse_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_externalTorqueImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_m_originalBody_set_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btRigidBody *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_originalBody = arg2;
  
}


btRigidBody *_wrap_btSolverBody_m_originalBody_get_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btRigidBody *) ((arg1)->m_originalBody);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_setWorldTransform_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btTransform *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


btTransform *_wrap_btSolverBody_getWorldTransform_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btTransform *) &((btSolverBody const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_getVelocityInLocalPointNoDelta_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->getVelocityInLocalPointNoDelta((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_getVelocityInLocalPointObsolete_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->getVelocityInLocalPointObsolete((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_getAngularVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btSolverBody const *)arg1)->getAngularVelocity(*arg2);
  
}


void _wrap_btSolverBody_applyImpulse_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btSolverBody_internalApplyPushImpulse_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->internalApplyPushImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btSolverBody_getDeltaLinearVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getDeltaLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getDeltaAngularVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getDeltaAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getPushVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getPushVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_getTurnVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->getTurnVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetDeltaLinearVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetDeltaLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetDeltaAngularVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetDeltaAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetAngularFactor_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->internalGetAngularFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetInvMass_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btSolverBody const *)arg1)->internalGetInvMass();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_internalSetInvMass_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->internalSetInvMass((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btSolverBody_internalGetPushVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetPushVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSolverBody_internalGetTurnVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->internalGetTurnVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverBody_internalGetVelocityInLocalPointObsolete_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSolverBody const *)arg1)->internalGetVelocityInLocalPointObsolete((btVector3 const &)*arg2,*arg3);
  
}


void _wrap_btSolverBody_internalGetAngularVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btSolverBody const *)arg1)->internalGetAngularVelocity(*arg2);
  
}


void _wrap_btSolverBody_internalApplyImpulse_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->internalApplyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btSolverBody_writebackVelocity_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  (arg1)->writebackVelocity();
  
}


void _wrap_btSolverBody_writebackVelocityAndTransform_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->writebackVelocityAndTransform(arg2,arg3);
  
}


btSolverBody *_wrap_new_btSolverBody_mbt_c1af402c8cb9fdfb() {
  btSolverBody *result = 0 ;
  btSolverBody *_swig_go_result;
  
  
  result = (btSolverBody *)new btSolverBody();
  *(btSolverBody **)&_swig_go_result = (btSolverBody *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSolverBody_mbt_c1af402c8cb9fdfb(btSolverBody *_swig_go_0) {
  btSolverBody *arg1 = (btSolverBody *) 0 ;
  
  arg1 = *(btSolverBody **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSolverConstraint_m_relpos1CrossNormal_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_relpos1CrossNormal = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_relpos1CrossNormal_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_relpos1CrossNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_contactNormal1_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contactNormal1 = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_contactNormal1_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_contactNormal1);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_relpos2CrossNormal_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_relpos2CrossNormal = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_relpos2CrossNormal_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_relpos2CrossNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_contactNormal2_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contactNormal2 = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_contactNormal2_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_contactNormal2);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_angularComponentA_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularComponentA = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_angularComponentA_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularComponentA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_angularComponentB_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularComponentB = *arg2;
  
}


btVector3 *_wrap_btSolverConstraint_m_angularComponentB_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_angularComponentB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_appliedPushImpulse_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedPushImpulse = arg2;
  
}


float _wrap_btSolverConstraint_m_appliedPushImpulse_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedPushImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_appliedImpulse_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btSolverConstraint_m_appliedImpulse_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_friction_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btSolverConstraint_m_friction_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_jacDiagABInv_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_jacDiagABInv = arg2;
  
}


float _wrap_btSolverConstraint_m_jacDiagABInv_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_jacDiagABInv);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_rhs_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_rhs = arg2;
  
}


float _wrap_btSolverConstraint_m_rhs_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_rhs);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_cfm_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_cfm = arg2;
  
}


float _wrap_btSolverConstraint_m_cfm_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_cfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_lowerLimit_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_lowerLimit = arg2;
  
}


float _wrap_btSolverConstraint_m_lowerLimit_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_lowerLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_upperLimit_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_upperLimit = arg2;
  
}


float _wrap_btSolverConstraint_m_upperLimit_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_upperLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_rhsPenetration_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, float _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_rhsPenetration = arg2;
  
}


float _wrap_btSolverConstraint_m_rhsPenetration_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_rhsPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_overrideNumSolverIterations_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btSolverConstraint_m_overrideNumSolverIterations_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_frictionIndex_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionIndex = arg2;
  
}


intgo _wrap_btSolverConstraint_m_frictionIndex_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_frictionIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_solverBodyIdA_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverBodyIdA = arg2;
  
}


intgo _wrap_btSolverConstraint_m_solverBodyIdA_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverBodyIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSolverConstraint_m_solverBodyIdB_set_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0, intgo _swig_go_1) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverBodyIdB = arg2;
  
}


intgo _wrap_btSolverConstraint_m_solverBodyIdB_get_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverBodyIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOLVER_CONTACT_1D_btSolverConstraint_mbt_c1af402c8cb9fdfb() {
  btSolverConstraint::btSolverConstraintType result;
  intgo _swig_go_result;
  
  
  result = btSolverConstraint::BT_SOLVER_CONTACT_1D;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOLVER_FRICTION_1D_btSolverConstraint_mbt_c1af402c8cb9fdfb() {
  btSolverConstraint::btSolverConstraintType result;
  intgo _swig_go_result;
  
  
  result = btSolverConstraint::BT_SOLVER_FRICTION_1D;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btSolverConstraint *_wrap_new_btSolverConstraint_mbt_c1af402c8cb9fdfb() {
  btSolverConstraint *result = 0 ;
  btSolverConstraint *_swig_go_result;
  
  
  result = (btSolverConstraint *)new btSolverConstraint();
  *(btSolverConstraint **)&_swig_go_result = (btSolverConstraint *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSolverConstraint_mbt_c1af402c8cb9fdfb(btSolverConstraint *_swig_go_0) {
  btSolverConstraint *arg1 = (btSolverConstraint *) 0 ;
  
  arg1 = *(btSolverConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_POINT2POINT_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = POINT2POINT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HINGE_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = HINGE_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONETWIST_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONETWIST_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SLIDER_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = SLIDER_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONTACT_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONTACT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GEAR_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = GEAR_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FIXED_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = FIXED_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_2_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_2_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_CONSTRAINT_TYPE_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = MAX_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_ERP_mbt_c1af402c8cb9fdfb() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_ERP_mbt_c1af402c8cb9fdfb() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_CFM_mbt_c1af402c8cb9fdfb() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_CFM_mbt_c1af402c8cb9fdfb() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyA_set_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyA_get_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyA_set_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyA_get_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyB_set_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyB_get_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyB_set_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyB_get_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_new_btJointFeedback_mbt_c1af402c8cb9fdfb() {
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  
  result = (btJointFeedback *)new btJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


void _wrap_delete_btJointFeedback_mbt_c1af402c8cb9fdfb(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btTypedConstraint_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btTypedConstraint_getFixedBody_mbt_c1af402c8cb9fdfb() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btTypedConstraint_buildJacobian_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btTypedConstraint_setupSolverConstraint_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, btAlignedObjectArray< btSolverConstraint > *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btTypedConstraint_getInfo1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btTypedConstraint_getInfo2_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btTypedConstraint_internalSetAppliedImpulse_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btTypedConstraint_internalGetAppliedImpulse_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btTypedConstraint_isEnabled_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setEnabled_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setEnabled(arg2);
  
}


void _wrap_btTypedConstraint_solveConstraintObsolete_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUserConstraintType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintType(arg2);
  
}


void _wrap_btTypedConstraint_setUserConstraintId_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintId(arg2);
  
}


intgo _wrap_btTypedConstraint_getUserConstraintId_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintPtr_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, void *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btTypedConstraint_getUserConstraintPtr_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (void *)(arg1)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setJointFeedback_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  (arg1)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)(arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUid_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTypedConstraint_needsFeedback_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_enableFeedback_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->enableFeedback(arg2);
  
}


float _wrap_btTypedConstraint_getAppliedImpulse_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getConstraintType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setDbgDrawSize_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDbgDrawSize(arg2);
  
}


float _wrap_btTypedConstraint_getDbgDrawSize_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setParam__SWIG_0_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btTypedConstraint_setParam__SWIG_1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


float _wrap_btTypedConstraint_getParam__SWIG_0_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getParam__SWIG_1_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTypedConstraint_serialize_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_SetbtTypedConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  if (swig_b0) (swig_b0)->m_objectType = arg2;
  
}


intgo _wrap_GetbtTypedConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int) ((swig_b0)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getObjectType_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int)((btTypedObject const *)swig_b0)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAdjustAngleToLimits_mbt_c1af402c8cb9fdfb(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbA_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbA_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbA);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbB_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbB_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbB);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_name_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintFloatData_m_name_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_objectType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_objectType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintId_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintId_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_needsFeedback_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_needsFeedback_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_appliedImpulse_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_appliedImpulse_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_dbgDrawSize_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_dbgDrawSize_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_isEnabled_set_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_isEnabled_get_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintFloatData *_wrap_new_btTypedConstraintFloatData_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintFloatData *result = 0 ;
  btTypedConstraintFloatData *_swig_go_result;
  
  
  result = (btTypedConstraintFloatData *)new btTypedConstraintFloatData();
  *(btTypedConstraintFloatData **)&_swig_go_result = (btTypedConstraintFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintFloatData_mbt_c1af402c8cb9fdfb(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintData_m_rbA_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintData_m_rbA_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbA);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_rbB_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintData_m_rbB_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbB);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_name_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintData_m_name_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_objectType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_objectType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintId_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintId_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_needsFeedback_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_needsFeedback_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_appliedImpulse_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintData_m_appliedImpulse_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_dbgDrawSize_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintData_m_dbgDrawSize_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_overrideNumSolverIterations_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_overrideNumSolverIterations_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_breakingImpulseThreshold_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintData_m_breakingImpulseThreshold_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_isEnabled_set_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_isEnabled_get_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintData *_wrap_new_btTypedConstraintData_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  
  result = (btTypedConstraintData *)new btTypedConstraintData();
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintData_mbt_c1af402c8cb9fdfb(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintDoubleData_m_rbA_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbA_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbA);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_rbB_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbB_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbB);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_name_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_m_name_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_objectType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_objectType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintType_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintType_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintId_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintId_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_needsFeedback_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_needsFeedback_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_appliedImpulse_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_appliedImpulse_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_isEnabled_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_isEnabled_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_padding_set_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->padding, (const char *)arg2, 4-1);
      arg1->padding[4-1] = 0;
    } else {
      arg1->padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_padding_get_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btTypedConstraintDoubleData *_wrap_new_btTypedConstraintDoubleData_mbt_c1af402c8cb9fdfb() {
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  
  result = (btTypedConstraintDoubleData *)new btTypedConstraintDoubleData();
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintDoubleData_mbt_c1af402c8cb9fdfb(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btAngularLimit *_wrap_new_btAngularLimit_mbt_c1af402c8cb9fdfb() {
  btAngularLimit *result = 0 ;
  btAngularLimit *_swig_go_result;
  
  
  result = (btAngularLimit *)new btAngularLimit();
  *(btAngularLimit **)&_swig_go_result = (btAngularLimit *)result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_set__SWIG_0_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->set(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_btAngularLimit_set__SWIG_1_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->set(arg2,arg3,arg4,arg5);
  
}


void _wrap_btAngularLimit_set__SWIG_2_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->set(arg2,arg3,arg4);
  
}


void _wrap_btAngularLimit_set__SWIG_3_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->set(arg2,arg3);
  
}


void _wrap_btAngularLimit_test_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float _swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->test(arg2);
  
}


float _wrap_btAngularLimit_getSoftness_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getBiasFactor_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getRelaxationFactor_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getCorrection_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getSign_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSign();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHalfRange_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btAngularLimit_isLimit_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (bool)((btAngularLimit const *)arg1)->isLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_fit_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0, float *_swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btAngularLimit const *)arg1)->fit(*arg2);
  
}


float _wrap_btAngularLimit_getError_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getError();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getLow_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getLow();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHigh_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btAngularLimit_mbt_c1af402c8cb9fdfb(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_DISPATCH_DISCRETE_btDispatcherInfo_mbt_c1af402c8cb9fdfb() {
  btDispatcherInfo::DispatchFunc result;
  intgo _swig_go_result;
  
  
  result = btDispatcherInfo::DISPATCH_DISCRETE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DISPATCH_CONTINUOUS_btDispatcherInfo_mbt_c1af402c8cb9fdfb() {
  btDispatcherInfo::DispatchFunc result;
  intgo _swig_go_result;
  
  
  result = btDispatcherInfo::DISPATCH_CONTINUOUS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btDispatcherInfo *_wrap_new_btDispatcherInfo_mbt_c1af402c8cb9fdfb() {
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  
  result = (btDispatcherInfo *)new btDispatcherInfo();
  *(btDispatcherInfo **)&_swig_go_result = (btDispatcherInfo *)result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_timeStep_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, float _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_timeStep = arg2;
  
}


float _wrap_btDispatcherInfo_m_timeStep_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_timeStep);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_stepCount_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, intgo _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_stepCount = arg2;
  
}


intgo _wrap_btDispatcherInfo_m_stepCount_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_stepCount);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_dispatchFunc_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, intgo _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_dispatchFunc = arg2;
  
}


intgo _wrap_btDispatcherInfo_m_dispatchFunc_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_dispatchFunc);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_timeOfImpact_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, float _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_timeOfImpact = arg2;
  
}


float _wrap_btDispatcherInfo_m_timeOfImpact_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_timeOfImpact);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_useContinuous_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_useContinuous = arg2;
  
}


bool _wrap_btDispatcherInfo_m_useContinuous_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_useContinuous);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_debugDraw_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, btIDebugDraw *_swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_debugDraw = arg2;
  
}


btIDebugDraw *_wrap_btDispatcherInfo_m_debugDraw_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (btIDebugDraw *) ((arg1)->m_debugDraw);
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_enableSatConvex_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_enableSatConvex = arg2;
  
}


bool _wrap_btDispatcherInfo_m_enableSatConvex_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_enableSatConvex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_enableSPU_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_enableSPU = arg2;
  
}


bool _wrap_btDispatcherInfo_m_enableSPU_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_enableSPU);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_useEpa_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_useEpa = arg2;
  
}


bool _wrap_btDispatcherInfo_m_useEpa_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_useEpa);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_allowedCcdPenetration_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, float _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedCcdPenetration = arg2;
  
}


float _wrap_btDispatcherInfo_m_allowedCcdPenetration_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedCcdPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_useConvexConservativeDistanceUtil_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_useConvexConservativeDistanceUtil = arg2;
  
}


bool _wrap_btDispatcherInfo_m_useConvexConservativeDistanceUtil_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_useConvexConservativeDistanceUtil);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_convexConservativeDistanceThreshold_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, float _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_convexConservativeDistanceThreshold = arg2;
  
}


float _wrap_btDispatcherInfo_m_convexConservativeDistanceThreshold_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_convexConservativeDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcherInfo_m_deterministicOverlappingPairs_set_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, bool _swig_go_1) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_deterministicOverlappingPairs = arg2;
  
}


bool _wrap_btDispatcherInfo_m_deterministicOverlappingPairs_get_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_deterministicOverlappingPairs);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btDispatcherInfo_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0) {
  btDispatcherInfo *arg1 = (btDispatcherInfo *) 0 ;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_CONTACT_POINT_ALGORITHMS_mbt_c1af402c8cb9fdfb() {
  ebtDispatcherQueryType result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_POINT_ALGORITHMS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CLOSEST_POINT_ALGORITHMS_mbt_c1af402c8cb9fdfb() {
  ebtDispatcherQueryType result;
  intgo _swig_go_result;
  
  
  result = BT_CLOSEST_POINT_ALGORITHMS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btDispatcher_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  
  delete arg1;
  
}


btCollisionAlgorithm *_wrap_btDispatcher_findAlgorithm_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btCollisionObjectWrapper *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btPersistentManifold *_swig_go_3, intgo _swig_go_4) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  ebtDispatcherQueryType arg5 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btPersistentManifold **)&_swig_go_3; 
  arg5 = (ebtDispatcherQueryType)_swig_go_4; 
  
  result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4,arg5);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btDispatcher_getNewManifold_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btDispatcher_releaseManifold_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->releaseManifold(arg2);
  
}


void _wrap_btDispatcher_clearManifold_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->clearManifold(arg2);
  
}


bool _wrap_btDispatcher_needsCollision_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btDispatcher_needsResponse_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDispatcher_dispatchAllCollisionPairs_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btOverlappingPairCache *_swig_go_1, btDispatcherInfo *_swig_go_2, btDispatcher *_swig_go_3) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCache **)&_swig_go_1; 
  arg3 = *(btDispatcherInfo **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
  
}


intgo _wrap_btDispatcher_getNumManifolds_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  
  result = (int)((btDispatcher const *)arg1)->getNumManifolds();
  _swig_go_result = result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btDispatcher_getManifoldByIndexInternal_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, intgo _swig_go_1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold **_wrap_btDispatcher_getInternalManifoldPointer_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  btPersistentManifold **_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  
  result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
  *(btPersistentManifold ***)&_swig_go_result = (btPersistentManifold **)result; 
  return _swig_go_result;
}


btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_0_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  btPoolAllocator *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  
  result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
  *(btPoolAllocator **)&_swig_go_result = (btPoolAllocator *)result; 
  return _swig_go_result;
}


btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_1_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  btPoolAllocator *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  
  result = (btPoolAllocator *)((btDispatcher const *)arg1)->getInternalManifoldPool();
  *(btPoolAllocator **)&_swig_go_result = (btPoolAllocator *)result; 
  return _swig_go_result;
}


void *_wrap_btDispatcher_allocateCollisionAlgorithm_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, intgo _swig_go_1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btDispatcher_freeCollisionAlgorithm_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, void *_swig_go_1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->freeCollisionAlgorithm(arg2);
  
}


void _wrap_btConstraintRow_m_normal_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float *_swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_normal;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btConstraintRow_m_normal_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_normal);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintRow_m_rhs_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float _swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_rhs = arg2;
  
}


float _wrap_btConstraintRow_m_rhs_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_rhs);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintRow_m_jacDiagInv_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float _swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_jacDiagInv = arg2;
  
}


float _wrap_btConstraintRow_m_jacDiagInv_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_jacDiagInv);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintRow_m_lowerLimit_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float _swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_lowerLimit = arg2;
  
}


float _wrap_btConstraintRow_m_lowerLimit_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_lowerLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintRow_m_upperLimit_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float _swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_upperLimit = arg2;
  
}


float _wrap_btConstraintRow_m_upperLimit_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_upperLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintRow_m_accumImpulse_set_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0, float _swig_go_1) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_accumImpulse = arg2;
  
}


float _wrap_btConstraintRow_m_accumImpulse_get_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_accumImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConstraintRow *_wrap_new_btConstraintRow_mbt_c1af402c8cb9fdfb() {
  btConstraintRow *result = 0 ;
  btConstraintRow *_swig_go_result;
  
  
  result = (btConstraintRow *)new btConstraintRow();
  *(btConstraintRow **)&_swig_go_result = (btConstraintRow *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConstraintRow_mbt_c1af402c8cb9fdfb(btConstraintRow *_swig_go_0) {
  btConstraintRow *arg1 = (btConstraintRow *) 0 ;
  
  arg1 = *(btConstraintRow **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED_mbt_c1af402c8cb9fdfb() {
  btContactPointFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONTACT_FLAG_HAS_CONTACT_CFM_mbt_c1af402c8cb9fdfb() {
  btContactPointFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_FLAG_HAS_CONTACT_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONTACT_FLAG_HAS_CONTACT_ERP_mbt_c1af402c8cb9fdfb() {
  btContactPointFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_FLAG_HAS_CONTACT_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING_mbt_c1af402c8cb9fdfb() {
  btContactPointFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONTACT_FLAG_FRICTION_ANCHOR_mbt_c1af402c8cb9fdfb() {
  btContactPointFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONTACT_FLAG_FRICTION_ANCHOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btManifoldPoint *_wrap_new_btManifoldPoint__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  
  result = (btManifoldPoint *)new btManifoldPoint();
  *(btManifoldPoint **)&_swig_go_result = (btManifoldPoint *)result; 
  return _swig_go_result;
}


btManifoldPoint *_wrap_new_btManifoldPoint__SWIG_1_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (btManifoldPoint *)new btManifoldPoint((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  *(btManifoldPoint **)&_swig_go_result = (btManifoldPoint *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_localPointA_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localPointA = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_localPointA_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_localPointA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_localPointB_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localPointB = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_localPointB_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_localPointB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_positionWorldOnB_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_positionWorldOnB = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_positionWorldOnB_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_positionWorldOnB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_positionWorldOnA_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_positionWorldOnA = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_positionWorldOnA_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_positionWorldOnA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_normalWorldOnB_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_normalWorldOnB = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_normalWorldOnB_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_normalWorldOnB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_distance1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_distance1 = arg2;
  
}


float _wrap_btManifoldPoint_m_distance1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_distance1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_combinedFriction_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_combinedFriction = arg2;
  
}


float _wrap_btManifoldPoint_m_combinedFriction_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_combinedFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_combinedRollingFriction_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_combinedRollingFriction = arg2;
  
}


float _wrap_btManifoldPoint_m_combinedRollingFriction_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_combinedRollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_combinedSpinningFriction_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_combinedSpinningFriction = arg2;
  
}


float _wrap_btManifoldPoint_m_combinedSpinningFriction_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_combinedSpinningFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_combinedRestitution_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_combinedRestitution = arg2;
  
}


float _wrap_btManifoldPoint_m_combinedRestitution_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_combinedRestitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_partId0_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_partId0 = arg2;
  
}


intgo _wrap_btManifoldPoint_m_partId0_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_partId0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_partId1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_partId1 = arg2;
  
}


intgo _wrap_btManifoldPoint_m_partId1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_partId1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_index0_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index0 = arg2;
  
}


intgo _wrap_btManifoldPoint_m_index0_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_index1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1 = arg2;
  
}


intgo _wrap_btManifoldPoint_m_index1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_userPersistentData_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, void *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_userPersistentData = arg2;
  
}


void *_wrap_btManifoldPoint_m_userPersistentData_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_userPersistentData);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_contactPointFlags_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactPointFlags = arg2;
  
}


intgo _wrap_btManifoldPoint_m_contactPointFlags_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_contactPointFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_appliedImpulse_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btManifoldPoint_m_appliedImpulse_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_prevRHS_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_prevRHS = arg2;
  
}


float _wrap_btManifoldPoint_m_prevRHS_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_prevRHS);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_appliedImpulseLateral1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulseLateral1 = arg2;
  
}


float _wrap_btManifoldPoint_m_appliedImpulseLateral1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedImpulseLateral1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_appliedImpulseLateral2_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulseLateral2 = arg2;
  
}


float _wrap_btManifoldPoint_m_appliedImpulseLateral2_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_appliedImpulseLateral2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_contactMotion1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactMotion1 = arg2;
  
}


float _wrap_btManifoldPoint_m_contactMotion1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_contactMotion1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_contactMotion2_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactMotion2 = arg2;
  
}


float _wrap_btManifoldPoint_m_contactMotion2_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_contactMotion2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_frictionCFM_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionCFM = arg2;
  
}


float _wrap_btManifoldPoint_m_frictionCFM_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_frictionCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_lifeTime_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, intgo _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_lifeTime = arg2;
  
}


intgo _wrap_btManifoldPoint_m_lifeTime_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_lifeTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_lateralFrictionDir1_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_lateralFrictionDir1 = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_lateralFrictionDir1_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_lateralFrictionDir1);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_m_lateralFrictionDir2_set_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, btVector3 *_swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_lateralFrictionDir2 = *arg2;
  
}


btVector3 *_wrap_btManifoldPoint_m_lateralFrictionDir2_get_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_lateralFrictionDir2);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


float _wrap_btManifoldPoint_getDistance_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar)((btManifoldPoint const *)arg1)->getDistance();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btManifoldPoint_getLifeTime_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (int)((btManifoldPoint const *)arg1)->getLifeTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btManifoldPoint_getPositionWorldOnA_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *) &((btManifoldPoint const *)arg1)->getPositionWorldOnA();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btManifoldPoint_getPositionWorldOnB_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btVector3 *) &((btManifoldPoint const *)arg1)->getPositionWorldOnB();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btManifoldPoint_setDistance_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0, float _swig_go_1) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDistance(arg2);
  
}


float _wrap_btManifoldPoint_getAppliedImpulse_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  result = (btScalar)((btManifoldPoint const *)arg1)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btManifoldPoint_mbt_c1af402c8cb9fdfb(btManifoldPoint *_swig_go_0) {
  btManifoldPoint *arg1 = (btManifoldPoint *) 0 ;
  
  arg1 = *(btManifoldPoint **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gContactBreakingThreshold_set_mbt_c1af402c8cb9fdfb(float _swig_go_0) {
  btScalar arg1 ;
  
  arg1 = (btScalar)_swig_go_0; 
  
  gContactBreakingThreshold = arg1;
  
}


float _wrap_gContactBreakingThreshold_get_mbt_c1af402c8cb9fdfb() {
  btScalar result;
  float _swig_go_result;
  
  
  result = (btScalar)gContactBreakingThreshold;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gContactDestroyedCallback_set_mbt_c1af402c8cb9fdfb(ContactDestroyedCallback *_swig_go_0) {
  ContactDestroyedCallback arg1 ;
  ContactDestroyedCallback *argp1 ;
  
  
  argp1 = (ContactDestroyedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactDestroyedCallback");
  }
  arg1 = (ContactDestroyedCallback)*argp1;
  
  
  gContactDestroyedCallback = arg1;
  
}


ContactDestroyedCallback *_wrap_gContactDestroyedCallback_get_mbt_c1af402c8cb9fdfb() {
  ContactDestroyedCallback result;
  ContactDestroyedCallback *_swig_go_result;
  
  
  result = gContactDestroyedCallback;
  *(ContactDestroyedCallback **)&_swig_go_result = new ContactDestroyedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactProcessedCallback_set_mbt_c1af402c8cb9fdfb(ContactProcessedCallback *_swig_go_0) {
  ContactProcessedCallback arg1 ;
  ContactProcessedCallback *argp1 ;
  
  
  argp1 = (ContactProcessedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactProcessedCallback");
  }
  arg1 = (ContactProcessedCallback)*argp1;
  
  
  gContactProcessedCallback = arg1;
  
}


ContactProcessedCallback *_wrap_gContactProcessedCallback_get_mbt_c1af402c8cb9fdfb() {
  ContactProcessedCallback result;
  ContactProcessedCallback *_swig_go_result;
  
  
  result = gContactProcessedCallback;
  *(ContactProcessedCallback **)&_swig_go_result = new ContactProcessedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactStartedCallback_set_mbt_c1af402c8cb9fdfb(ContactStartedCallback *_swig_go_0) {
  ContactStartedCallback arg1 ;
  ContactStartedCallback *argp1 ;
  
  
  argp1 = (ContactStartedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactStartedCallback");
  }
  arg1 = (ContactStartedCallback)*argp1;
  
  
  gContactStartedCallback = arg1;
  
}


ContactStartedCallback *_wrap_gContactStartedCallback_get_mbt_c1af402c8cb9fdfb() {
  ContactStartedCallback result;
  ContactStartedCallback *_swig_go_result;
  
  
  result = gContactStartedCallback;
  *(ContactStartedCallback **)&_swig_go_result = new ContactStartedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactEndedCallback_set_mbt_c1af402c8cb9fdfb(ContactEndedCallback *_swig_go_0) {
  ContactEndedCallback arg1 ;
  ContactEndedCallback *argp1 ;
  
  
  argp1 = (ContactEndedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactEndedCallback");
  }
  arg1 = (ContactEndedCallback)*argp1;
  
  
  gContactEndedCallback = arg1;
  
}


ContactEndedCallback *_wrap_gContactEndedCallback_get_mbt_c1af402c8cb9fdfb() {
  ContactEndedCallback result;
  ContactEndedCallback *_swig_go_result;
  
  
  result = gContactEndedCallback;
  *(ContactEndedCallback **)&_swig_go_result = new ContactEndedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactCalcArea3Points_set_mbt_c1af402c8cb9fdfb(bool _swig_go_0) {
  bool arg1 ;
  
  arg1 = (bool)_swig_go_0; 
  
  gContactCalcArea3Points = arg1;
  
}


bool _wrap_gContactCalcArea3Points_get_mbt_c1af402c8cb9fdfb() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)gContactCalcArea3Points;
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_calcArea4Points_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btScalar)calcArea4Points((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_MIN_CONTACT_MANIFOLD_TYPE_mbt_c1af402c8cb9fdfb() {
  btContactManifoldTypes result;
  intgo _swig_go_result;
  
  
  result = MIN_CONTACT_MANIFOLD_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_PERSISTENT_MANIFOLD_TYPE_mbt_c1af402c8cb9fdfb() {
  btContactManifoldTypes result;
  intgo _swig_go_result;
  
  
  result = BT_PERSISTENT_MANIFOLD_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_companionIdA_set_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifold_m_companionIdA_get_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_companionIdB_set_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifold_m_companionIdB_get_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_index1a_set_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifold_m_index1a_get_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  
  result = (btPersistentManifold *)new btPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  result = (btPersistentManifold *)new btPersistentManifold((btCollisionObject const *)arg1,(btCollisionObject const *)arg2,arg3,arg4,arg5);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btPersistentManifold_getBody0_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody0();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btPersistentManifold_getBody1_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody1();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setBodies_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  (arg1)->setBodies((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  
}


void _wrap_btPersistentManifold_clearUserCache_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  (arg1)->clearUserCache(*arg2);
  
}


intgo _wrap_btPersistentManifold_getNumContacts_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int)((btPersistentManifold const *)arg1)->getNumContacts();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setNumContacts_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setNumContacts(arg2);
  
}


btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_0_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btManifoldPoint *) &((btPersistentManifold const *)arg1)->getContactPoint(arg2);
  *(btManifoldPoint **)&_swig_go_result = result; 
  return _swig_go_result;
}


btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_1_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btManifoldPoint *) &(arg1)->getContactPoint(arg2);
  *(btManifoldPoint **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPersistentManifold_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btScalar)((btPersistentManifold const *)arg1)->getContactBreakingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPersistentManifold_getContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btScalar)((btPersistentManifold const *)arg1)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, float _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactBreakingThreshold(arg2);
  
}


void _wrap_btPersistentManifold_setContactProcessingThreshold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, float _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactProcessingThreshold(arg2);
  
}


intgo _wrap_btPersistentManifold_getCacheEntry_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (int)((btPersistentManifold const *)arg1)->getCacheEntry((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_addManifoldPoint__SWIG_0_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1, bool _swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_addManifoldPoint__SWIG_1_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_removeContactPoint_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->removeContactPoint(arg2);
  
}


void _wrap_btPersistentManifold_replaceContactPoint_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1, intgo _swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->replaceContactPoint((btManifoldPoint const &)*arg2,arg3);
  
}


bool _wrap_btPersistentManifold_validContactDistance_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (bool)((btPersistentManifold const *)arg1)->validContactDistance((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_refreshContactPoints_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->refreshContactPoints((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btPersistentManifold_clearManifold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  (arg1)->clearManifold();
  
}


intgo _wrap_btPersistentManifold_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int)((btPersistentManifold const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPersistentManifold_serialize_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btPersistentManifold *_swig_go_1, void *_swig_go_2, btSerializer *_swig_go_3) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  void *arg3 = (void *) 0 ;
  btSerializer *arg4 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = *(btSerializer **)&_swig_go_3; 
  
  result = (char *)((btPersistentManifold const *)arg1)->serialize((btPersistentManifold const *)arg2,arg3,arg4);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_deSerialize__SWIG_0_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btPersistentManifoldDoubleData *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifoldDoubleData *arg2 = (btPersistentManifoldDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifoldDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btPersistentManifoldDoubleData const *)arg2);
  
}


void _wrap_btPersistentManifold_deSerialize__SWIG_1_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, btPersistentManifoldFloatData *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifoldFloatData *arg2 = (btPersistentManifoldFloatData *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifoldFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btPersistentManifoldFloatData const *)arg2);
  
}


void _wrap_delete_btPersistentManifold_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtPersistentManifold_M_objectType_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  if (swig_b0) (swig_b0)->m_objectType = arg2;
  
}


intgo _wrap_GetbtPersistentManifold_M_objectType_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int) ((swig_b0)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_getObjectType_mbt_c1af402c8cb9fdfb(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int)((btTypedObject const *)swig_b0)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLocalPointA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLocalPointA);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLocalPointB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLocalPointB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCachePositionWorldOnA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCachePositionWorldOnA);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCachePositionWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCachePositionWorldOnB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheNormalWorldOnB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheNormalWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheNormalWorldOnB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheNormalWorldOnB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLateralFrictionDir1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLateralFrictionDir1);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLateralFrictionDir2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLateralFrictionDir2);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheDistance_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheDistance;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheDistance_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheDistance);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulse_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulse;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulse_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulse);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePrevRHS_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCachePrevRHS;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCachePrevRHS_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCachePrevRHS);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRollingFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedRollingFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRollingFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedRollingFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedSpinningFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedSpinningFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedSpinningFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedSpinningFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRestitution_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedRestitution;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRestitution_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedRestitution);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePartId0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCachePartId0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePartId1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCachePartId1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheIndex0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheIndex0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheIndex1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheIndex1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactPointFlags_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheContactPointFlags;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactPointFlags_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheContactPointFlags);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulseLateral1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulseLateral1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulseLateral2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulseLateral2);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactMotion1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactMotion1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactMotion2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactMotion2);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactCFM_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactCFM_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactCFM);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactStiffness1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedContactStiffness1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactStiffness1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedContactStiffness1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactERP_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactERP;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactERP_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactERP);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactDamping1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedContactDamping1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactDamping1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedContactDamping1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheFrictionCFM_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheFrictionCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheFrictionCFM_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheFrictionCFM);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLifeTime_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheLifeTime;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheLifeTime_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheLifeTime);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_numCachedPoints_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numCachedPoints = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_numCachedPoints_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numCachedPoints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_companionIdA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_companionIdA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_companionIdB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_companionIdB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_index1a_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_index1a_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_objectType_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_objectType_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_contactBreakingThreshold_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactBreakingThreshold = arg2;
  
}


double _wrap_btPersistentManifoldDoubleData_m_contactBreakingThreshold_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactBreakingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_contactProcessingThreshold_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, double _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


double _wrap_btPersistentManifoldDoubleData_m_contactProcessingThreshold_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_padding_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_padding_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_body0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body0 = arg2;
  
}


btCollisionObjectDoubleData *_wrap_btPersistentManifoldDoubleData_m_body0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *) ((arg1)->m_body0);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_body1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body1 = arg2;
  
}


btCollisionObjectDoubleData *_wrap_btPersistentManifoldDoubleData_m_body1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *) ((arg1)->m_body1);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


btPersistentManifoldDoubleData *_wrap_new_btPersistentManifoldDoubleData_mbt_c1af402c8cb9fdfb() {
  btPersistentManifoldDoubleData *result = 0 ;
  btPersistentManifoldDoubleData *_swig_go_result;
  
  
  result = (btPersistentManifoldDoubleData *)new btPersistentManifoldDoubleData();
  *(btPersistentManifoldDoubleData **)&_swig_go_result = (btPersistentManifoldDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldDoubleData_mbt_c1af402c8cb9fdfb(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLocalPointA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLocalPointA);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLocalPointB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLocalPointB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCachePositionWorldOnA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCachePositionWorldOnA);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCachePositionWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCachePositionWorldOnB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheNormalWorldOnB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheNormalWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheNormalWorldOnB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheNormalWorldOnB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLateralFrictionDir1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLateralFrictionDir1);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLateralFrictionDir2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLateralFrictionDir2);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheDistance_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheDistance;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheDistance_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheDistance);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulse_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulse;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulse_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulse);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePrevRHS_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCachePrevRHS;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCachePrevRHS_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCachePrevRHS);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRollingFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedRollingFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRollingFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedRollingFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedSpinningFriction_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedSpinningFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedSpinningFriction_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedSpinningFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRestitution_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedRestitution;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRestitution_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedRestitution);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePartId0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCachePartId0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePartId1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCachePartId1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheIndex0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheIndex0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheIndex1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheIndex1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactPointFlags_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheContactPointFlags;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheContactPointFlags_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheContactPointFlags);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulseLateral1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulseLateral1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulseLateral2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulseLateral2);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactMotion1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactMotion1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion2_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactMotion2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion2_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactMotion2);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactCFM_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactCFM_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactCFM);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactStiffness1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedContactStiffness1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactStiffness1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedContactStiffness1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactERP_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactERP;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactERP_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactERP);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactDamping1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedContactDamping1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactDamping1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedContactDamping1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheFrictionCFM_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheFrictionCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheFrictionCFM_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheFrictionCFM);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLifeTime_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheLifeTime;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheLifeTime_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheLifeTime);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_numCachedPoints_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numCachedPoints = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_numCachedPoints_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numCachedPoints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_companionIdA_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_companionIdA_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_companionIdB_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_companionIdB_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_index1a_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_index1a_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_objectType_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_objectType_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_contactBreakingThreshold_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactBreakingThreshold = arg2;
  
}


float _wrap_btPersistentManifoldFloatData_m_contactBreakingThreshold_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactBreakingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_contactProcessingThreshold_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, float _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


float _wrap_btPersistentManifoldFloatData_m_contactProcessingThreshold_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_padding_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_padding_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_body0_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body0 = arg2;
  
}


btCollisionObjectFloatData *_wrap_btPersistentManifoldFloatData_m_body0_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *) ((arg1)->m_body0);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_body1_set_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body1 = arg2;
  
}


btCollisionObjectFloatData *_wrap_btPersistentManifoldFloatData_m_body1_get_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *) ((arg1)->m_body1);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


btPersistentManifoldFloatData *_wrap_new_btPersistentManifoldFloatData_mbt_c1af402c8cb9fdfb() {
  btPersistentManifoldFloatData *result = 0 ;
  btPersistentManifoldFloatData *_swig_go_result;
  
  
  result = (btPersistentManifoldFloatData *)new btPersistentManifoldFloatData();
  *(btPersistentManifoldFloatData **)&_swig_go_result = (btPersistentManifoldFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldFloatData_mbt_c1af402c8cb9fdfb(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btDiscreteCollisionDetectorInterface_mbt_c1af402c8cb9fdfb(btDiscreteCollisionDetectorInterface *_swig_go_0) {
  btDiscreteCollisionDetectorInterface *arg1 = (btDiscreteCollisionDetectorInterface *) 0 ;
  
  arg1 = *(btDiscreteCollisionDetectorInterface **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btDiscreteCollisionDetectorInterface_getClosestPoints__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteCollisionDetectorInterface *_swig_go_0, btDiscreteCollisionDetectorInterface::ClosestPointInput *_swig_go_1, btDiscreteCollisionDetectorInterface::Result *_swig_go_2, btIDebugDraw *_swig_go_3, bool _swig_go_4) {
  btDiscreteCollisionDetectorInterface *arg1 = (btDiscreteCollisionDetectorInterface *) 0 ;
  btDiscreteCollisionDetectorInterface::ClosestPointInput *arg2 = 0 ;
  btDiscreteCollisionDetectorInterface::Result *arg3 = 0 ;
  btIDebugDraw *arg4 = (btIDebugDraw *) 0 ;
  bool arg5 ;
  
  arg1 = *(btDiscreteCollisionDetectorInterface **)&_swig_go_0; 
  arg2 = *(btDiscreteCollisionDetectorInterface::ClosestPointInput **)&_swig_go_1; 
  arg3 = *(btDiscreteCollisionDetectorInterface::Result **)&_swig_go_2; 
  arg4 = *(btIDebugDraw **)&_swig_go_3; 
  arg5 = (bool)_swig_go_4; 
  
  (arg1)->getClosestPoints((btDiscreteCollisionDetectorInterface::ClosestPointInput const &)*arg2,*arg3,arg4,arg5);
  
}


void _wrap_btDiscreteCollisionDetectorInterface_getClosestPoints__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteCollisionDetectorInterface *_swig_go_0, btDiscreteCollisionDetectorInterface::ClosestPointInput *_swig_go_1, btDiscreteCollisionDetectorInterface::Result *_swig_go_2, btIDebugDraw *_swig_go_3) {
  btDiscreteCollisionDetectorInterface *arg1 = (btDiscreteCollisionDetectorInterface *) 0 ;
  btDiscreteCollisionDetectorInterface::ClosestPointInput *arg2 = 0 ;
  btDiscreteCollisionDetectorInterface::Result *arg3 = 0 ;
  btIDebugDraw *arg4 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btDiscreteCollisionDetectorInterface **)&_swig_go_0; 
  arg2 = *(btDiscreteCollisionDetectorInterface::ClosestPointInput **)&_swig_go_1; 
  arg3 = *(btDiscreteCollisionDetectorInterface::Result **)&_swig_go_2; 
  arg4 = *(btIDebugDraw **)&_swig_go_3; 
  
  (arg1)->getClosestPoints((btDiscreteCollisionDetectorInterface::ClosestPointInput const &)*arg2,*arg3,arg4);
  
}


void _wrap_btStorageResult_m_normalOnSurfaceB_set_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0, btVector3 *_swig_go_1) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_normalOnSurfaceB = *arg2;
  
}


btVector3 *_wrap_btStorageResult_m_normalOnSurfaceB_get_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_normalOnSurfaceB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btStorageResult_m_closestPointInB_set_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0, btVector3 *_swig_go_1) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_closestPointInB = *arg2;
  
}


btVector3 *_wrap_btStorageResult_m_closestPointInB_get_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_closestPointInB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btStorageResult_m_distance_set_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0, float _swig_go_1) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_distance = arg2;
  
}


float _wrap_btStorageResult_m_distance_get_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_distance);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btStorageResult_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btStorageResult_addContactPoint_mbt_c1af402c8cb9fdfb(btStorageResult *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btStorageResult *arg1 = (btStorageResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btStorageResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_gContactAddedCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  ContactAddedCallback arg1 = (ContactAddedCallback) 0 ;
  
  arg1 = *(ContactAddedCallback *)&_swig_go_0; 
  
  gContactAddedCallback = arg1;
  
}


void* _wrap_gContactAddedCallback_get_mbt_c1af402c8cb9fdfb() {
  ContactAddedCallback result;
  void* _swig_go_result;
  
  
  result = (ContactAddedCallback)gContactAddedCallback;
  *(ContactAddedCallback *)&_swig_go_result = (ContactAddedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedRestitutionCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedRestitutionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedRestitutionCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedRestitutionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedFrictionCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedFrictionCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedRollingFrictionCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedRollingFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedRollingFrictionCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedRollingFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedSpinningFrictionCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedSpinningFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedSpinningFrictionCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedSpinningFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedContactDampingCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedContactDampingCallback = arg1;
  
}


void* _wrap_gCalculateCombinedContactDampingCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedContactDampingCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedContactStiffnessCallback_set_mbt_c1af402c8cb9fdfb(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedContactStiffnessCallback = arg1;
  
}


void* _wrap_gCalculateCombinedContactStiffnessCallback_get_mbt_c1af402c8cb9fdfb() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedContactStiffnessCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


btManifoldResult *_wrap_new_btManifoldResult__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btManifoldResult *result = 0 ;
  btManifoldResult *_swig_go_result;
  
  
  result = (btManifoldResult *)new btManifoldResult();
  *(btManifoldResult **)&_swig_go_result = (btManifoldResult *)result; 
  return _swig_go_result;
}


btManifoldResult *_wrap_new_btManifoldResult__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionObjectWrapper *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btManifoldResult *result = 0 ;
  btManifoldResult *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  result = (btManifoldResult *)new btManifoldResult((btCollisionObjectWrapper const *)arg1,(btCollisionObjectWrapper const *)arg2);
  *(btManifoldResult **)&_swig_go_result = (btManifoldResult *)result; 
  return _swig_go_result;
}


void _wrap_delete_btManifoldResult_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btManifoldResult_setPersistentManifold_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->setPersistentManifold(arg2);
  
}


btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_0_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btPersistentManifold *)((btManifoldResult const *)arg1)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_1_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btPersistentManifold *)(arg1)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_setShapeIdentifiersA_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setShapeIdentifiersA(arg2,arg3);
  
}


void _wrap_btManifoldResult_setShapeIdentifiersB_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setShapeIdentifiersB(arg2,arg3);
  
}


void _wrap_btManifoldResult_addContactPoint_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btManifoldResult_refreshContactPoints_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  (arg1)->refreshContactPoints();
  
}


btCollisionObjectWrapper *_wrap_btManifoldResult_getBody0Wrap_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody0Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


btCollisionObjectWrapper *_wrap_btManifoldResult_getBody1Wrap_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody1Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_setBody0Wrap_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  (arg1)->setBody0Wrap((btCollisionObjectWrapper const *)arg2);
  
}


void _wrap_btManifoldResult_setBody1Wrap_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  (arg1)->setBody1Wrap((btCollisionObjectWrapper const *)arg2);
  
}


btCollisionObject *_wrap_btManifoldResult_getBody0Internal_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody0Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btManifoldResult_getBody1Internal_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody1Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_m_closestPointDistanceThreshold_set_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0, float _swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_closestPointDistanceThreshold = arg2;
  
}


float _wrap_btManifoldResult_m_closestPointDistanceThreshold_get_mbt_c1af402c8cb9fdfb(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_closestPointDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedRestitution_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRestitution((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedRollingFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRollingFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedSpinningFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedSpinningFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedContactDamping_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactDamping((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedContactStiffness_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactStiffness((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionAlgorithmCreateFunc_m_swapped_set_mbt_c1af402c8cb9fdfb(btCollisionAlgorithmCreateFunc *_swig_go_0, bool _swig_go_1) {
  btCollisionAlgorithmCreateFunc *arg1 = (btCollisionAlgorithmCreateFunc *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_swapped = arg2;
  
}


bool _wrap_btCollisionAlgorithmCreateFunc_m_swapped_get_mbt_c1af402c8cb9fdfb(btCollisionAlgorithmCreateFunc *_swig_go_0) {
  btCollisionAlgorithmCreateFunc *arg1 = (btCollisionAlgorithmCreateFunc *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_swapped);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionAlgorithmCreateFunc *_wrap_new_btCollisionAlgorithmCreateFunc_mbt_c1af402c8cb9fdfb() {
  btCollisionAlgorithmCreateFunc *result = 0 ;
  btCollisionAlgorithmCreateFunc *_swig_go_result;
  
  
  result = (btCollisionAlgorithmCreateFunc *)new btCollisionAlgorithmCreateFunc();
  *(btCollisionAlgorithmCreateFunc **)&_swig_go_result = (btCollisionAlgorithmCreateFunc *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionAlgorithmCreateFunc_mbt_c1af402c8cb9fdfb(btCollisionAlgorithmCreateFunc *_swig_go_0) {
  btCollisionAlgorithmCreateFunc *arg1 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_0; 
  
  delete arg1;
  
}


btCollisionAlgorithm *_wrap_btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm_mbt_c1af402c8cb9fdfb(btCollisionAlgorithmCreateFunc *_swig_go_0, btCollisionAlgorithmConstructionInfo *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btCollisionObjectWrapper *_swig_go_3) {
  btCollisionAlgorithmCreateFunc *arg1 = (btCollisionAlgorithmCreateFunc *) 0 ;
  btCollisionAlgorithmConstructionInfo *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_0; 
  arg2 = *(btCollisionAlgorithmConstructionInfo **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btCollisionObjectWrapper **)&_swig_go_3; 
  
  result = (btCollisionAlgorithm *)(arg1)->CreateCollisionAlgorithm(*arg2,(btCollisionObjectWrapper const *)arg3,(btCollisionObjectWrapper const *)arg4);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


btCollisionPairCallback *_wrap_new_btCollisionPairCallback_mbt_c1af402c8cb9fdfb(btDispatcherInfo *_swig_go_0, btCollisionDispatcher *_swig_go_1) {
  btDispatcherInfo *arg1 = 0 ;
  btCollisionDispatcher *arg2 = (btCollisionDispatcher *) 0 ;
  btCollisionPairCallback *result = 0 ;
  btCollisionPairCallback *_swig_go_result;
  
  arg1 = *(btDispatcherInfo **)&_swig_go_0; 
  arg2 = *(btCollisionDispatcher **)&_swig_go_1; 
  
  result = (btCollisionPairCallback *)new btCollisionPairCallback((btDispatcherInfo const &)*arg1,arg2);
  *(btCollisionPairCallback **)&_swig_go_result = (btCollisionPairCallback *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionPairCallback_mbt_c1af402c8cb9fdfb(btCollisionPairCallback *_swig_go_0) {
  btCollisionPairCallback *arg1 = (btCollisionPairCallback *) 0 ;
  
  arg1 = *(btCollisionPairCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btCollisionPairCallback_processOverlap_mbt_c1af402c8cb9fdfb(btCollisionPairCallback *_swig_go_0, btBroadphasePair *_swig_go_1) {
  btCollisionPairCallback *arg1 = (btCollisionPairCallback *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionPairCallback **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  
  result = (bool)(arg1)->processOverlap(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_CD_STATIC_STATIC_REPORTED_btCollisionDispatcher_mbt_c1af402c8cb9fdfb() {
  btCollisionDispatcher::DispatcherFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionDispatcher::CD_STATIC_STATIC_REPORTED;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD_btCollisionDispatcher_mbt_c1af402c8cb9fdfb() {
  btCollisionDispatcher::DispatcherFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION_btCollisionDispatcher_mbt_c1af402c8cb9fdfb() {
  btCollisionDispatcher::DispatcherFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionDispatcher::CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionDispatcher_getDispatcherFlags_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (int)((btCollisionDispatcher const *)arg1)->getDispatcherFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_setDispatcherFlags_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setDispatcherFlags(arg2);
  
}


void _wrap_btCollisionDispatcher_registerCollisionCreateFunc_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, btCollisionAlgorithmCreateFunc *_swig_go_3) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *arg4 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_3; 
  
  (arg1)->registerCollisionCreateFunc(arg2,arg3,arg4);
  
}


void _wrap_btCollisionDispatcher_registerClosestPointsCreateFunc_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, btCollisionAlgorithmCreateFunc *_swig_go_3) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *arg4 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btCollisionAlgorithmCreateFunc **)&_swig_go_3; 
  
  (arg1)->registerClosestPointsCreateFunc(arg2,arg3,arg4);
  
}


intgo _wrap_btCollisionDispatcher_getNumManifolds_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (int)((btCollisionDispatcher const *)arg1)->getNumManifolds();
  _swig_go_result = result; 
  return _swig_go_result;
}


btPersistentManifold **_wrap_btCollisionDispatcher_getInternalManifoldPointer_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  btPersistentManifold **_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
  *(btPersistentManifold ***)&_swig_go_result = (btPersistentManifold **)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btPersistentManifold *)((btCollisionDispatcher const *)arg1)->getManifoldByIndexInternal(arg2);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btCollisionDispatcher *_wrap_new_btCollisionDispatcher_mbt_c1af402c8cb9fdfb(btCollisionConfiguration *_swig_go_0) {
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btCollisionDispatcher *result = 0 ;
  btCollisionDispatcher *_swig_go_result;
  
  arg1 = *(btCollisionConfiguration **)&_swig_go_0; 
  
  result = (btCollisionDispatcher *)new btCollisionDispatcher(arg1);
  *(btCollisionDispatcher **)&_swig_go_result = (btCollisionDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionDispatcher_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  delete arg1;
  
}


btPersistentManifold *_wrap_btCollisionDispatcher_getNewManifold_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_releaseManifold_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->releaseManifold(arg2);
  
}


void _wrap_btCollisionDispatcher_clearManifold_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->clearManifold(arg2);
  
}


btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btCollisionObjectWrapper *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btPersistentManifold *_swig_go_3, intgo _swig_go_4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  ebtDispatcherQueryType arg5 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btPersistentManifold **)&_swig_go_3; 
  arg5 = (ebtDispatcherQueryType)_swig_go_4; 
  
  result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4,arg5);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionDispatcher_needsCollision_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionDispatcher_needsResponse_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_dispatchAllCollisionPairs_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btOverlappingPairCache *_swig_go_1, btDispatcherInfo *_swig_go_2, btDispatcher *_swig_go_3) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCache **)&_swig_go_1; 
  arg3 = *(btDispatcherInfo **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
  
}


void _wrap_btCollisionDispatcher_setNearCallback_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, void* _swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback arg2 = (btNearCallback) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btNearCallback *)&_swig_go_1; 
  
  (arg1)->setNearCallback(arg2);
  
}


void* _wrap_btCollisionDispatcher_getNearCallback_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback result;
  void* _swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btNearCallback)((btCollisionDispatcher const *)arg1)->getNearCallback();
  *(btNearCallback *)&_swig_go_result = (btNearCallback)result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_defaultNearCallback_mbt_c1af402c8cb9fdfb(btBroadphasePair *_swig_go_0, btCollisionDispatcher *_swig_go_1, btDispatcherInfo *_swig_go_2) {
  btBroadphasePair *arg1 = 0 ;
  btCollisionDispatcher *arg2 = 0 ;
  btDispatcherInfo *arg3 = 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btCollisionDispatcher **)&_swig_go_1; 
  arg3 = *(btDispatcherInfo **)&_swig_go_2; 
  
  btCollisionDispatcher::defaultNearCallback(*arg1,*arg2,(btDispatcherInfo const &)*arg3);
  
}


void *_wrap_btCollisionDispatcher_allocateCollisionAlgorithm_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, intgo _swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_freeCollisionAlgorithm_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, void *_swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->freeCollisionAlgorithm(arg2);
  
}


btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  btCollisionConfiguration *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btCollisionConfiguration *)(arg1)->getCollisionConfiguration();
  *(btCollisionConfiguration **)&_swig_go_result = (btCollisionConfiguration *)result; 
  return _swig_go_result;
}


btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  btCollisionConfiguration *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btCollisionConfiguration *)((btCollisionDispatcher const *)arg1)->getCollisionConfiguration();
  *(btCollisionConfiguration **)&_swig_go_result = (btCollisionConfiguration *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionDispatcher_setCollisionConfiguration_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0, btCollisionConfiguration *_swig_go_1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *arg2 = (btCollisionConfiguration *) 0 ;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  arg2 = *(btCollisionConfiguration **)&_swig_go_1; 
  
  (arg1)->setCollisionConfiguration(arg2);
  
}


btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  btPoolAllocator *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
  *(btPoolAllocator **)&_swig_go_result = (btPoolAllocator *)result; 
  return _swig_go_result;
}


btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionDispatcher *_swig_go_0) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  btPoolAllocator *_swig_go_result;
  
  arg1 = *(btCollisionDispatcher **)&_swig_go_0; 
  
  result = (btPoolAllocator *)((btCollisionDispatcher const *)arg1)->getInternalManifoldPool();
  *(btPoolAllocator **)&_swig_go_result = (btPoolAllocator *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseAabbCallback_mbt_c1af402c8cb9fdfb(btBroadphaseAabbCallback *_swig_go_0) {
  btBroadphaseAabbCallback *arg1 = (btBroadphaseAabbCallback *) 0 ;
  
  arg1 = *(btBroadphaseAabbCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBroadphaseAabbCallback_process_mbt_c1af402c8cb9fdfb(btBroadphaseAabbCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphaseAabbCallback *arg1 = (btBroadphaseAabbCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBroadphaseAabbCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseRayCallback_m_rayDirectionInverse_set_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayDirectionInverse = *arg2;
  
}


btVector3 *_wrap_btBroadphaseRayCallback_m_rayDirectionInverse_get_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_rayDirectionInverse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseRayCallback_m_signs_set_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0, intgo *_swig_go_1) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  unsigned int *arg2 = (unsigned int *) (unsigned int *)0 ;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  arg2 = *(unsigned int **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned int *b = (unsigned int *) arg1->m_signs;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned int *) arg2 + ii);
  }
  
}


intgo *_wrap_btBroadphaseRayCallback_m_signs_get_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  unsigned int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  
  result = (unsigned int *)(unsigned int *) ((arg1)->m_signs);
  *(unsigned int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseRayCallback_m_lambda_max_set_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0, float _swig_go_1) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_lambda_max = arg2;
  
}


float _wrap_btBroadphaseRayCallback_m_lambda_max_get_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_lambda_max);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseRayCallback_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBroadphaseRayCallback_process_mbt_c1af402c8cb9fdfb(btBroadphaseRayCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphaseRayCallback *arg1 = (btBroadphaseRayCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBroadphaseRayCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  btBroadphaseAabbCallback *swig_b0 = (btBroadphaseAabbCallback *)arg1;
  result = (bool)(swig_b0)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseInterface_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphaseProxy *_wrap_btBroadphaseInterface_createProxy_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3, void *_swig_go_4, intgo _swig_go_5, intgo _swig_go_6, btDispatcher *_swig_go_7) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  int arg6 ;
  int arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(void **)&_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  arg7 = (int)_swig_go_6; 
  arg8 = *(btDispatcher **)&_swig_go_7; 
  
  result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseInterface_destroyProxy_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->destroyProxy(arg2,arg3);
  
}


void _wrap_btBroadphaseInterface_setAabb_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btBroadphaseProxy *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btDispatcher *_swig_go_4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btDispatcher **)&_swig_go_4; 
  
  (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
  
}


void _wrap_btBroadphaseInterface_getAabb_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btBroadphaseProxy *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBroadphaseInterface const *)arg1)->getAabb(arg2,*arg3,*arg4);
  
}


void _wrap_btBroadphaseInterface_rayTest__SWIG_0_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btBroadphaseRayCallback *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btBroadphaseRayCallback **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btBroadphaseInterface_rayTest__SWIG_1_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btBroadphaseRayCallback *_swig_go_3, btVector3 *_swig_go_4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btBroadphaseRayCallback **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
  
}


void _wrap_btBroadphaseInterface_rayTest__SWIG_2_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btBroadphaseRayCallback *_swig_go_3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btBroadphaseRayCallback **)&_swig_go_3; 
  
  (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btBroadphaseInterface_aabbTest_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btBroadphaseAabbCallback *_swig_go_3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btBroadphaseAabbCallback **)&_swig_go_3; 
  
  (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btBroadphaseInterface_calculateOverlappingPairs_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btDispatcher *_swig_go_1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  (arg1)->calculateOverlappingPairs(arg2);
  
}


btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_0_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_1_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *)((btBroadphaseInterface const *)arg1)->getOverlappingPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseInterface_getBroadphaseAabb_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBroadphaseInterface const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
  
}


void _wrap_btBroadphaseInterface_resetPool_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0, btDispatcher *_swig_go_1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  (arg1)->resetPool(arg2);
  
}


void _wrap_btBroadphaseInterface_printStats_mbt_c1af402c8cb9fdfb(btBroadphaseInterface *_swig_go_0) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btBroadphaseInterface **)&_swig_go_0; 
  
  (arg1)->printStats();
  
}


void _wrap_delete_btOverlappingPairCallback_mbt_c1af402c8cb9fdfb(btOverlappingPairCallback *_swig_go_0) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = *(btOverlappingPairCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePair *_wrap_btOverlappingPairCallback_addOverlappingPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btOverlappingPairCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void *_wrap_btOverlappingPairCallback_removeOverlappingPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2, btDispatcher *_swig_go_3) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btOverlappingPairCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btOverlappingPairCallback_removeOverlappingPairsContainingProxy_mbt_c1af402c8cb9fdfb(btOverlappingPairCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btOverlappingPairCallback *arg1 = (btOverlappingPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
  
}


void _wrap_MyPairIndex_m_orgIndex_set_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0, intgo _swig_go_1) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int arg2 ;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_orgIndex = arg2;
  
}


intgo _wrap_MyPairIndex_m_orgIndex_get_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_orgIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_MyPairIndex_m_uidA0_set_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0, intgo _swig_go_1) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int arg2 ;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uidA0 = arg2;
  
}


intgo _wrap_MyPairIndex_m_uidA0_get_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uidA0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_MyPairIndex_m_uidA1_set_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0, intgo _swig_go_1) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int arg2 ;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uidA1 = arg2;
  
}


intgo _wrap_MyPairIndex_m_uidA1_get_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uidA1);
  _swig_go_result = result; 
  return _swig_go_result;
}


MyPairIndex *_wrap_new_MyPairIndex_mbt_c1af402c8cb9fdfb() {
  MyPairIndex *result = 0 ;
  MyPairIndex *_swig_go_result;
  
  
  result = (MyPairIndex *)new MyPairIndex();
  *(MyPairIndex **)&_swig_go_result = (MyPairIndex *)result; 
  return _swig_go_result;
}


void _wrap_delete_MyPairIndex_mbt_c1af402c8cb9fdfb(MyPairIndex *_swig_go_0) {
  MyPairIndex *arg1 = (MyPairIndex *) 0 ;
  
  arg1 = *(MyPairIndex **)&_swig_go_0; 
  
  delete arg1;
  
}


MyPairIndeSortPredicate *_wrap_new_MyPairIndeSortPredicate_mbt_c1af402c8cb9fdfb() {
  MyPairIndeSortPredicate *result = 0 ;
  MyPairIndeSortPredicate *_swig_go_result;
  
  
  result = (MyPairIndeSortPredicate *)new MyPairIndeSortPredicate();
  *(MyPairIndeSortPredicate **)&_swig_go_result = (MyPairIndeSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_MyPairIndeSortPredicate_mbt_c1af402c8cb9fdfb(MyPairIndeSortPredicate *_swig_go_0) {
  MyPairIndeSortPredicate *arg1 = (MyPairIndeSortPredicate *) 0 ;
  
  arg1 = *(MyPairIndeSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btOverlapCallback_mbt_c1af402c8cb9fdfb(btOverlapCallback *_swig_go_0) {
  btOverlapCallback *arg1 = (btOverlapCallback *) 0 ;
  
  arg1 = *(btOverlapCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btOverlapCallback_processOverlap_mbt_c1af402c8cb9fdfb(btOverlapCallback *_swig_go_0, btBroadphasePair *_swig_go_1) {
  btOverlapCallback *arg1 = (btOverlapCallback *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOverlapCallback **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  
  result = (bool)(arg1)->processOverlap(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btOverlapFilterCallback *_swig_go_0) {
  btOverlapFilterCallback *arg1 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = *(btOverlapFilterCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btOverlapFilterCallback_needBroadphaseCollision_mbt_c1af402c8cb9fdfb(btOverlapFilterCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btOverlapFilterCallback *arg1 = (btOverlapFilterCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOverlapFilterCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (bool)((btOverlapFilterCallback const *)arg1)->needBroadphaseCollision(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BT_NULL_PAIR_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)(int)BT_NULL_PAIR;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btOverlappingPairCache_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePair *_wrap_btOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)((btOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btOverlappingPairCache_getOverlappingPairArray_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOverlappingPairCache_cleanOverlappingPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphasePair *_swig_go_1, btDispatcher *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanOverlappingPair(*arg2,arg3);
  
}


intgo _wrap_btOverlappingPairCache_getNumOverlappingPairs_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (int)((btOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btOverlappingPairCache_needsBroadphaseCollision_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (bool)((btOverlappingPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btOverlapFilterCallback *_wrap_btOverlappingPairCache_getOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  btOverlapFilterCallback *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
  *(btOverlapFilterCallback **)&_swig_go_result = (btOverlapFilterCallback *)result; 
  return _swig_go_result;
}


void _wrap_btOverlappingPairCache_cleanProxyFromPairs_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanProxyFromPairs(arg2,arg3);
  
}


void _wrap_btOverlappingPairCache_setOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btOverlapFilterCallback *_swig_go_1) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapFilterCallback **)&_swig_go_1; 
  
  (arg1)->setOverlapFilterCallback(arg2);
  
}


void _wrap_btOverlappingPairCache_processAllOverlappingPairs__SWIG_0_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3);
  
}


void _wrap_btOverlappingPairCache_processAllOverlappingPairs__SWIG_1_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2, btDispatcherInfo *_swig_go_3) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  arg4 = *(btDispatcherInfo **)&_swig_go_3; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3,(btDispatcherInfo const &)*arg4);
  
}


btBroadphasePair *_wrap_btOverlappingPairCache_findPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


bool _wrap_btOverlappingPairCache_hasDeferredRemoval_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  
  result = (bool)(arg1)->hasDeferredRemoval();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOverlappingPairCache_setInternalGhostPairCallback_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btOverlappingPairCallback *_swig_go_1) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCallback **)&_swig_go_1; 
  
  (arg1)->setInternalGhostPairCallback(arg2);
  
}


void _wrap_btOverlappingPairCache_sortOverlappingPairs_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btDispatcher *_swig_go_1) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  (arg1)->sortOverlappingPairs(arg2);
  
}


btBroadphasePair *_wrap_btOverlappingPairCache_addOverlappingPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  btOverlappingPairCallback *swig_b0 = (btOverlappingPairCallback *)arg1;
  result = (btBroadphasePair *)(swig_b0)->addOverlappingPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void *_wrap_btOverlappingPairCache_removeOverlappingPair_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2, btDispatcher *_swig_go_3) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  btOverlappingPairCallback *swig_b0 = (btOverlappingPairCallback *)arg1;
  result = (void *)(swig_b0)->removeOverlappingPair(arg2,arg3,arg4);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btOverlappingPairCache_removeOverlappingPairsContainingProxy_mbt_c1af402c8cb9fdfb(btOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  btOverlappingPairCallback *swig_b0 = (btOverlappingPairCallback *)arg1;
  (swig_b0)->removeOverlappingPairsContainingProxy(arg2,arg3);
  
}


btHashedOverlappingPairCache *_wrap_new_btHashedOverlappingPairCache_mbt_c1af402c8cb9fdfb() {
  btHashedOverlappingPairCache *result = 0 ;
  btHashedOverlappingPairCache *_swig_go_result;
  
  
  result = (btHashedOverlappingPairCache *)new btHashedOverlappingPairCache();
  *(btHashedOverlappingPairCache **)&_swig_go_result = (btHashedOverlappingPairCache *)result; 
  return _swig_go_result;
}


void _wrap_delete_btHashedOverlappingPairCache_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btHashedOverlappingPairCache_removeOverlappingPairsContainingProxy_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
  
}


void *_wrap_btHashedOverlappingPairCache_removeOverlappingPair_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2, btDispatcher *_swig_go_3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


bool _wrap_btHashedOverlappingPairCache_needsBroadphaseCollision_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (bool)((btHashedOverlappingPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btHashedOverlappingPairCache_addOverlappingPair_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void _wrap_btHashedOverlappingPairCache_cleanProxyFromPairs_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanProxyFromPairs(arg2,arg3);
  
}


void _wrap_btHashedOverlappingPairCache_processAllOverlappingPairs__SWIG_0_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3);
  
}


void _wrap_btHashedOverlappingPairCache_processAllOverlappingPairs__SWIG_1_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2, btDispatcherInfo *_swig_go_3) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  btDispatcherInfo *arg4 = 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  arg4 = *(btDispatcherInfo **)&_swig_go_3; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3,(btDispatcherInfo const &)*arg4);
  
}


btBroadphasePair *_wrap_btHashedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btHashedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)((btHashedOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_0_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_1_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &((btHashedOverlappingPairCache const *)arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHashedOverlappingPairCache_cleanOverlappingPair_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphasePair *_swig_go_1, btDispatcher *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanOverlappingPair(*arg2,arg3);
  
}


btBroadphasePair *_wrap_btHashedOverlappingPairCache_findPair_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


intgo _wrap_btHashedOverlappingPairCache_GetCount_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (int)((btHashedOverlappingPairCache const *)arg1)->GetCount();
  _swig_go_result = result; 
  return _swig_go_result;
}


btOverlapFilterCallback *_wrap_btHashedOverlappingPairCache_getOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  btOverlapFilterCallback *_swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
  *(btOverlapFilterCallback **)&_swig_go_result = (btOverlapFilterCallback *)result; 
  return _swig_go_result;
}


void _wrap_btHashedOverlappingPairCache_setOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btOverlapFilterCallback *_swig_go_1) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapFilterCallback **)&_swig_go_1; 
  
  (arg1)->setOverlapFilterCallback(arg2);
  
}


intgo _wrap_btHashedOverlappingPairCache_getNumOverlappingPairs_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  result = (int)((btHashedOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHashedOverlappingPairCache_hasDeferredRemoval_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  
  btOverlappingPairCache *swig_b0 = (btOverlappingPairCache *)arg1;
  result = (bool)(swig_b0)->hasDeferredRemoval();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHashedOverlappingPairCache_setInternalGhostPairCallback_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btOverlappingPairCallback *_swig_go_1) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCallback **)&_swig_go_1; 
  
  btOverlappingPairCache *swig_b0 = (btOverlappingPairCache *)arg1;
  (swig_b0)->setInternalGhostPairCallback(arg2);
  
}


void _wrap_btHashedOverlappingPairCache_sortOverlappingPairs_mbt_c1af402c8cb9fdfb(btHashedOverlappingPairCache *_swig_go_0, btDispatcher *_swig_go_1) {
  btHashedOverlappingPairCache *arg1 = (btHashedOverlappingPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btHashedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  btOverlappingPairCache *swig_b0 = (btOverlappingPairCache *)arg1;
  (swig_b0)->sortOverlappingPairs(arg2);
  
}


btSortedOverlappingPairCache *_wrap_new_btSortedOverlappingPairCache_mbt_c1af402c8cb9fdfb() {
  btSortedOverlappingPairCache *result = 0 ;
  btSortedOverlappingPairCache *_swig_go_result;
  
  
  result = (btSortedOverlappingPairCache *)new btSortedOverlappingPairCache();
  *(btSortedOverlappingPairCache **)&_swig_go_result = (btSortedOverlappingPairCache *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSortedOverlappingPairCache_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSortedOverlappingPairCache_processAllOverlappingPairs_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3);
  
}


void *_wrap_btSortedOverlappingPairCache_removeOverlappingPair_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2, btDispatcher *_swig_go_3) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSortedOverlappingPairCache_cleanOverlappingPair_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphasePair *_swig_go_1, btDispatcher *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanOverlappingPair(*arg2,arg3);
  
}


btBroadphasePair *_wrap_btSortedOverlappingPairCache_addOverlappingPair_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btSortedOverlappingPairCache_findPair_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void _wrap_btSortedOverlappingPairCache_cleanProxyFromPairs_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanProxyFromPairs(arg2,arg3);
  
}


void _wrap_btSortedOverlappingPairCache_removeOverlappingPairsContainingProxy_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
  
}


bool _wrap_btSortedOverlappingPairCache_needsBroadphaseCollision_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (bool)((btSortedOverlappingPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_0_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_1_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &((btSortedOverlappingPairCache const *)arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btSortedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_0_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btSortedOverlappingPairCache_getOverlappingPairArrayPtr__SWIG_1_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)((btSortedOverlappingPairCache const *)arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


intgo _wrap_btSortedOverlappingPairCache_getNumOverlappingPairs_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (int)((btSortedOverlappingPairCache const *)arg1)->getNumOverlappingPairs();
  _swig_go_result = result; 
  return _swig_go_result;
}


btOverlapFilterCallback *_wrap_btSortedOverlappingPairCache_getOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  btOverlapFilterCallback *_swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
  *(btOverlapFilterCallback **)&_swig_go_result = (btOverlapFilterCallback *)result; 
  return _swig_go_result;
}


void _wrap_btSortedOverlappingPairCache_setOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btOverlapFilterCallback *_swig_go_1) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapFilterCallback **)&_swig_go_1; 
  
  (arg1)->setOverlapFilterCallback(arg2);
  
}


bool _wrap_btSortedOverlappingPairCache_hasDeferredRemoval_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  
  result = (bool)(arg1)->hasDeferredRemoval();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSortedOverlappingPairCache_setInternalGhostPairCallback_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btOverlappingPairCallback *_swig_go_1) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCallback **)&_swig_go_1; 
  
  (arg1)->setInternalGhostPairCallback(arg2);
  
}


void _wrap_btSortedOverlappingPairCache_sortOverlappingPairs_mbt_c1af402c8cb9fdfb(btSortedOverlappingPairCache *_swig_go_0, btDispatcher *_swig_go_1) {
  btSortedOverlappingPairCache *arg1 = (btSortedOverlappingPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btSortedOverlappingPairCache **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  (arg1)->sortOverlappingPairs(arg2);
  
}


btBroadphasePair *_wrap_btNullPairCache_getOverlappingPairArrayPtr__SWIG_0_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)(arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_btNullPairCache_getOverlappingPairArrayPtr__SWIG_1_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePair *)((btNullPairCache const *)arg1)->getOverlappingPairArrayPtr();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBroadphasePair > *_wrap_btNullPairCache_getOverlappingPairArray_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePairArray *result = 0 ;
  btAlignedObjectArray< btBroadphasePair > *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (btBroadphasePairArray *) &(arg1)->getOverlappingPairArray();
  *(btBroadphasePairArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btNullPairCache_cleanOverlappingPair_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphasePair *_swig_go_1, btDispatcher *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphasePair **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanOverlappingPair(*arg2,arg3);
  
}


intgo _wrap_btNullPairCache_getNumOverlappingPairs_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (int)((btNullPairCache const *)arg1)->getNumOverlappingPairs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btNullPairCache_cleanProxyFromPairs_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->cleanProxyFromPairs(arg2,arg3);
  
}


bool _wrap_btNullPairCache_needsBroadphaseCollision_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (bool)((btNullPairCache const *)arg1)->needsBroadphaseCollision(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btOverlapFilterCallback *_wrap_btNullPairCache_getOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlapFilterCallback *result = 0 ;
  btOverlapFilterCallback *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (btOverlapFilterCallback *)(arg1)->getOverlapFilterCallback();
  *(btOverlapFilterCallback **)&_swig_go_result = (btOverlapFilterCallback *)result; 
  return _swig_go_result;
}


void _wrap_btNullPairCache_setOverlapFilterCallback_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btOverlapFilterCallback *_swig_go_1) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlapFilterCallback *arg2 = (btOverlapFilterCallback *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapFilterCallback **)&_swig_go_1; 
  
  (arg1)->setOverlapFilterCallback(arg2);
  
}


void _wrap_btNullPairCache_processAllOverlappingPairs_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btOverlapCallback *_swig_go_1, btDispatcher *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlapCallback *arg2 = (btOverlapCallback *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btOverlapCallback **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->processAllOverlappingPairs(arg2,arg3);
  
}


btBroadphasePair *_wrap_btNullPairCache_findPair_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->findPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


bool _wrap_btNullPairCache_hasDeferredRemoval_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  result = (bool)(arg1)->hasDeferredRemoval();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btNullPairCache_setInternalGhostPairCallback_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btOverlappingPairCallback *_swig_go_1) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btOverlappingPairCallback *arg2 = (btOverlappingPairCallback *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCallback **)&_swig_go_1; 
  
  (arg1)->setInternalGhostPairCallback(arg2);
  
}


btBroadphasePair *_wrap_btNullPairCache_addOverlappingPair_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  
  result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void *_wrap_btNullPairCache_removeOverlappingPair_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btBroadphaseProxy *_swig_go_2, btDispatcher *_swig_go_3) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btBroadphaseProxy **)&_swig_go_2; 
  arg4 = *(btDispatcher **)&_swig_go_3; 
  
  result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btNullPairCache_removeOverlappingPairsContainingProxy_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btBroadphaseProxy *_swig_go_1, btDispatcher *_swig_go_2) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
  
}


void _wrap_btNullPairCache_sortOverlappingPairs_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0, btDispatcher *_swig_go_1) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  (arg1)->sortOverlappingPairs(arg2);
  
}


btNullPairCache *_wrap_new_btNullPairCache_mbt_c1af402c8cb9fdfb() {
  btNullPairCache *result = 0 ;
  btNullPairCache *_swig_go_result;
  
  
  result = (btNullPairCache *)new btNullPairCache();
  *(btNullPairCache **)&_swig_go_result = (btNullPairCache *)result; 
  return _swig_go_result;
}


void _wrap_delete_btNullPairCache_mbt_c1af402c8cb9fdfb(btNullPairCache *_swig_go_0) {
  btNullPairCache *arg1 = (btNullPairCache *) 0 ;
  
  arg1 = *(btNullPairCache **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSingleRayCallback_m_rayFromWorld_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayFromWorld = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_rayFromWorld_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_rayFromWorld);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayToWorld_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayToWorld = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_rayToWorld_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_rayToWorld);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayFromTrans_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayFromTrans = *arg2;
  
}


btTransform *_wrap_btSingleRayCallback_m_rayFromTrans_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_rayFromTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayToTrans_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayToTrans = *arg2;
  
}


btTransform *_wrap_btSingleRayCallback_m_rayToTrans_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_rayToTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_hitNormal_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_hitNormal = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_hitNormal_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_hitNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_world_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = (btCollisionWorld const *)arg2;
  
}


btCollisionWorld *_wrap_btSingleRayCallback_m_world_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_resultCallback_set_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btCollisionWorld::RayResultCallback *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld::RayResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::RayResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::RayResultCallback *_wrap_btSingleRayCallback_m_resultCallback_get_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld::RayResultCallback *result = 0 ;
  btCollisionWorld::RayResultCallback *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::RayResultCallback *) &(btCollisionWorld::RayResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::RayResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btSingleRayCallback *_wrap_new_btSingleRayCallback_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btCollisionWorld *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  btSingleRayCallback *result = 0 ;
  btSingleRayCallback *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  result = (btSingleRayCallback *)new btSingleRayCallback((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btCollisionWorld const *)arg3,*arg4);
  *(btSingleRayCallback **)&_swig_go_result = (btSingleRayCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleRayCallback_process_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleRayCallback_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtSingleRayCallback_M_rayDirectionInverse_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  if (swig_b0) (swig_b0)->m_rayDirectionInverse = *arg2;
  
}


btVector3 *_wrap_GetbtSingleRayCallback_M_rayDirectionInverse_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (btVector3 *)& ((swig_b0)->m_rayDirectionInverse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_SetbtSingleRayCallback_M_signs_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, intgo *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  unsigned int *arg2 = (unsigned int *) (unsigned int *)0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(unsigned int **)&_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  ;
  
}


intgo *_wrap_GetbtSingleRayCallback_M_signs_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  unsigned int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (unsigned int *)(unsigned int *) ((swig_b0)->m_signs);
  *(unsigned int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtSingleRayCallback_M_lambda_max_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0, float _swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  if (swig_b0) (swig_b0)->m_lambda_max = arg2;
  
}


float _wrap_GetbtSingleRayCallback_M_lambda_max_mbt_c1af402c8cb9fdfb(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (btScalar) ((swig_b0)->m_lambda_max);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_convexFromTrans_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexFromTrans = *arg2;
  
}


btTransform *_wrap_btSingleSweepCallback_m_convexFromTrans_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexFromTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_convexToTrans_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexToTrans = *arg2;
  
}


btTransform *_wrap_btSingleSweepCallback_m_convexToTrans_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexToTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_hitNormal_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_hitNormal = *arg2;
  
}


btVector3 *_wrap_btSingleSweepCallback_m_hitNormal_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_hitNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_world_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = (btCollisionWorld const *)arg2;
  
}


btCollisionWorld *_wrap_btSingleSweepCallback_m_world_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_resultCallback_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btCollisionWorld::ConvexResultCallback *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ConvexResultCallback *_wrap_btSingleSweepCallback_m_resultCallback_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld::ConvexResultCallback *result = 0 ;
  btCollisionWorld::ConvexResultCallback *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::ConvexResultCallback *) &(btCollisionWorld::ConvexResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ConvexResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_allowedCcdPenetration_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, float _swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedCcdPenetration = arg2;
  
}


float _wrap_btSingleSweepCallback_m_allowedCcdPenetration_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedCcdPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_castShape_set_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btConvexShape *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_castShape = (btConvexShape const *)arg2;
  
}


btConvexShape *_wrap_btSingleSweepCallback_m_castShape_get_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btConvexShape *result = 0 ;
  btConvexShape *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btConvexShape *) ((arg1)->m_castShape);
  *(btConvexShape **)&_swig_go_result = (btConvexShape *)result; 
  return _swig_go_result;
}


btSingleSweepCallback *_wrap_new_btSingleSweepCallback_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionWorld *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionWorld *arg4 = (btCollisionWorld *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  btSingleSweepCallback *result = 0 ;
  btSingleSweepCallback *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionWorld **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btSingleSweepCallback *)new btSingleSweepCallback((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionWorld const *)arg4,*arg5,arg6);
  *(btSingleSweepCallback **)&_swig_go_result = (btSingleSweepCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleSweepCallback_process_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleSweepCallback_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtSingleSweepCallback_M_rayDirectionInverse_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  if (swig_b0) (swig_b0)->m_rayDirectionInverse = *arg2;
  
}


btVector3 *_wrap_GetbtSingleSweepCallback_M_rayDirectionInverse_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (btVector3 *)& ((swig_b0)->m_rayDirectionInverse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_SetbtSingleSweepCallback_M_signs_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, intgo *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  unsigned int *arg2 = (unsigned int *) (unsigned int *)0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(unsigned int **)&_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  ;
  
}


intgo *_wrap_GetbtSingleSweepCallback_M_signs_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  unsigned int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (unsigned int *)(unsigned int *) ((swig_b0)->m_signs);
  *(unsigned int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtSingleSweepCallback_M_lambda_max_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0, float _swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  if (swig_b0) (swig_b0)->m_lambda_max = arg2;
  
}


float _wrap_GetbtSingleSweepCallback_M_lambda_max_mbt_c1af402c8cb9fdfb(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  btBroadphaseRayCallback *swig_b0 = (btBroadphaseRayCallback *)arg1;
  result = (btScalar) ((swig_b0)->m_lambda_max);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_m_resultCallback_set_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, btCollisionWorld::ContactResultCallback *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionWorld::ContactResultCallback *arg2 = 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ContactResultCallback *_wrap_btBridgedManifoldResult_m_resultCallback_get_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionWorld::ContactResultCallback *result = 0 ;
  btCollisionWorld::ContactResultCallback *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionWorld::ContactResultCallback *) &(btCollisionWorld::ContactResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ContactResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btBridgedManifoldResult *_wrap_new_btBridgedManifoldResult_mbt_c1af402c8cb9fdfb(btCollisionObjectWrapper *_swig_go_0, btCollisionObjectWrapper *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  btBridgedManifoldResult *result = 0 ;
  btBridgedManifoldResult *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  result = (btBridgedManifoldResult *)new btBridgedManifoldResult((btCollisionObjectWrapper const *)arg1,(btCollisionObjectWrapper const *)arg2,*arg3);
  *(btBridgedManifoldResult **)&_swig_go_result = (btBridgedManifoldResult *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_addContactPoint_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_delete_btBridgedManifoldResult_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBridgedManifoldResult_setPersistentManifold_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setPersistentManifold(arg2);
  
}


btPersistentManifold *_wrap_btBridgedManifoldResult_getPersistentManifold__SWIG_0_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btPersistentManifold *)((btManifoldResult const *)swig_b0)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btBridgedManifoldResult_getPersistentManifold__SWIG_1_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btPersistentManifold *)(swig_b0)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_setShapeIdentifiersA_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setShapeIdentifiersA(arg2,arg3);
  
}


void _wrap_btBridgedManifoldResult_setShapeIdentifiersB_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setShapeIdentifiersB(arg2,arg3);
  
}


void _wrap_btBridgedManifoldResult_refreshContactPoints_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->refreshContactPoints();
  
}


btCollisionObjectWrapper *_wrap_btBridgedManifoldResult_getBody0Wrap_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)swig_b0)->getBody0Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


btCollisionObjectWrapper *_wrap_btBridgedManifoldResult_getBody1Wrap_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)swig_b0)->getBody1Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_setBody0Wrap_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setBody0Wrap((btCollisionObjectWrapper const *)arg2);
  
}


void _wrap_btBridgedManifoldResult_setBody1Wrap_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setBody1Wrap((btCollisionObjectWrapper const *)arg2);
  
}


btCollisionObject *_wrap_btBridgedManifoldResult_getBody0Internal_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObject *)((btManifoldResult const *)swig_b0)->getBody0Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btBridgedManifoldResult_getBody1Internal_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObject *)((btManifoldResult const *)swig_b0)->getBody1Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_SetbtBridgedManifoldResult_M_closestPointDistanceThreshold_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0, float _swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  if (swig_b0) (swig_b0)->m_closestPointDistanceThreshold = arg2;
  
}


float _wrap_GetbtBridgedManifoldResult_M_closestPointDistanceThreshold_mbt_c1af402c8cb9fdfb(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btScalar) ((swig_b0)->m_closestPointDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedRestitution_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRestitution((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedRollingFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRollingFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedSpinningFriction_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedSpinningFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedContactDamping_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactDamping((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedContactStiffness_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactStiffness((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_collisionObject_set_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0, btCollisionObject *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObject = arg2;
  
}


btCollisionObject *_wrap_btSingleContactCallback_m_collisionObject_get_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionObject *) ((arg1)->m_collisionObject);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_world_set_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = arg2;
  
}


btCollisionWorld *_wrap_btSingleContactCallback_m_world_get_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_resultCallback_set_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0, btCollisionWorld::ContactResultCallback *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld::ContactResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ContactResultCallback *_wrap_btSingleContactCallback_m_resultCallback_get_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld::ContactResultCallback *result = 0 ;
  btCollisionWorld::ContactResultCallback *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::ContactResultCallback *) &(btCollisionWorld::ContactResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ContactResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btSingleContactCallback *_wrap_new_btSingleContactCallback_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btCollisionWorld *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  btSingleContactCallback *result = 0 ;
  btSingleContactCallback *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  result = (btSingleContactCallback *)new btSingleContactCallback(arg1,arg2,*arg3);
  *(btSingleContactCallback **)&_swig_go_result = (btSingleContactCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleContactCallback_process_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleContactCallback_mbt_c1af402c8cb9fdfb(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


DebugDrawcallback *_wrap_new_DebugDrawcallback_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  DebugDrawcallback *result = 0 ;
  DebugDrawcallback *_swig_go_result;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (DebugDrawcallback *)new DebugDrawcallback(arg1,(btTransform const &)*arg2,(btVector3 const &)*arg3);
  *(DebugDrawcallback **)&_swig_go_result = (DebugDrawcallback *)result; 
  return _swig_go_result;
}


void _wrap_DebugDrawcallback_internalProcessTriangleIndex_mbt_c1af402c8cb9fdfb(DebugDrawcallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->internalProcessTriangleIndex(arg2,arg3,arg4);
  
}


void _wrap_DebugDrawcallback_processTriangle_mbt_c1af402c8cb9fdfb(DebugDrawcallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


void _wrap_delete_DebugDrawcallback_mbt_c1af402c8cb9fdfb(DebugDrawcallback *_swig_go_0) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  
  delete arg1;
  
}


btCollisionWorld *_wrap_new_btCollisionWorld_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btBroadphaseInterface *_swig_go_1, btCollisionConfiguration *_swig_go_2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btCollisionConfiguration *arg3 = (btCollisionConfiguration *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  arg3 = *(btCollisionConfiguration **)&_swig_go_2; 
  
  result = (btCollisionWorld *)new btCollisionWorld(arg1,arg2,arg3);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionWorld_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionWorld_setBroadphase_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btBroadphaseInterface *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  
  (arg1)->setBroadphase(arg2);
  
}


btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btBroadphaseInterface *)((btCollisionWorld const *)arg1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btBroadphaseInterface *)(arg1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btOverlappingPairCache *_wrap_btCollisionWorld_getPairCache_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *)(arg1)->getPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcher *)(arg1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcher *)((btCollisionWorld const *)arg1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_updateSingleAabb_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->updateSingleAabb(arg2);
  
}


void _wrap_btCollisionWorld_updateAabbs_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->updateAabbs();
  
}


void _wrap_btCollisionWorld_computeOverlappingPairs_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->computeOverlappingPairs();
  
}


void _wrap_btCollisionWorld_setDebugDrawer_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btIDebugDraw *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  (arg1)->setDebugDrawer(arg2);
  
}


btIDebugDraw *_wrap_btCollisionWorld_getDebugDrawer_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btIDebugDraw *)(arg1)->getDebugDrawer();
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_debugDrawWorld_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->debugDrawWorld();
  
}


void _wrap_btCollisionWorld_debugDrawObject_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btTransform *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
  
}


intgo _wrap_btCollisionWorld_getNumCollisionObjects_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (int)((btCollisionWorld const *)arg1)->getNumCollisionObjects();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_rayTest_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  ((btCollisionWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btCollisionWorld_convexSweepTest__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
  
}


void _wrap_btCollisionWorld_convexSweepTest__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  
  ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
  
}


void _wrap_btCollisionWorld_contactTest_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  (arg1)->contactTest(arg2,*arg3);
  
}


void _wrap_btCollisionWorld_contactPairTest_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionWorld::ContactResultCallback *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_3; 
  
  (arg1)->contactPairTest(arg2,arg3,*arg4);
  
}


void _wrap_btCollisionWorld_rayTestSingle_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionShape *_swig_go_3, btTransform *_swig_go_4, btCollisionWorld::RayResultCallback *_swig_go_5) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionShape **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btCollisionWorld::RayResultCallback **)&_swig_go_5; 
  
  btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
  
}


void _wrap_btCollisionWorld_rayTestSingleInternal_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
  
}


void _wrap_btCollisionWorld_objectQuerySingle_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObject *_swig_go_3, btCollisionShape *_swig_go_4, btTransform *_swig_go_5, btCollisionWorld::ConvexResultCallback *_swig_go_6, float _swig_go_7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObject **)&_swig_go_3; 
  arg5 = *(btCollisionShape **)&_swig_go_4; 
  arg6 = *(btTransform **)&_swig_go_5; 
  arg7 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  
  btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
  
}


void _wrap_btCollisionWorld_objectQuerySingleInternal_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObjectWrapper *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObjectWrapper **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addCollisionObject(arg2,arg3,arg4);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->addCollisionObject(arg2,arg3);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_2_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->addCollisionObject(arg2);
  
}


void _wrap_btCollisionWorld_refreshBroadphaseProxy_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->refreshBroadphaseProxy(arg2);
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btCollisionObjectArray *) &(arg1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btCollisionObjectArray *) &((btCollisionWorld const *)arg1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_removeCollisionObject_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->removeCollisionObject(arg2);
  
}


void _wrap_btCollisionWorld_performDiscreteCollisionDetection_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->performDiscreteCollisionDetection();
  
}


btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_0_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcherInfo *) &(arg1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_1_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcherInfo *) &((btCollisionWorld const *)arg1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionWorld_getForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (bool)((btCollisionWorld const *)arg1)->getForceUpdateAllAabbs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_setForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, bool _swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setForceUpdateAllAabbs(arg2);
  
}


void _wrap_btCollisionWorld_serialize_mbt_c1af402c8cb9fdfb(btCollisionWorld *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  (arg1)->serialize(arg2);
  
}


intgo _wrap_SOLVER_RANDMIZE_ORDER_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_RANDMIZE_ORDER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_FRICTION_SEPARATE_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_FRICTION_SEPARATE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_USE_WARMSTARTING_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_USE_WARMSTARTING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_USE_2_FRICTION_DIRECTIONS_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_USE_2_FRICTION_DIRECTIONS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_CACHE_FRIENDLY_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_CACHE_FRIENDLY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_SIMD_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_SIMD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_DISABLE_IMPLICIT_CONE_FRICTION_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_DISABLE_IMPLICIT_CONE_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOLVER_USE_ARTICULATED_WARMSTARTING_mbt_c1af402c8cb9fdfb() {
  btSolverMode result;
  intgo _swig_go_result;
  
  
  result = SOLVER_USE_ARTICULATED_WARMSTARTING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_tau_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_tau = arg2;
  
}


float _wrap_btContactSolverInfoData_m_tau_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_tau);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_damping_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btContactSolverInfoData_m_damping_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_friction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btContactSolverInfoData_m_friction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_timeStep_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_timeStep = arg2;
  
}


float _wrap_btContactSolverInfoData_m_timeStep_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_timeStep);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_restitution_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btContactSolverInfoData_m_restitution_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_numIterations_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numIterations = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_numIterations_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_maxErrorReduction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxErrorReduction = arg2;
  
}


float _wrap_btContactSolverInfoData_m_maxErrorReduction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_sor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_sor = arg2;
  
}


float _wrap_btContactSolverInfoData_m_sor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_sor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_erp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp = arg2;
  
}


float _wrap_btContactSolverInfoData_m_erp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_erp2_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp2 = arg2;
  
}


float _wrap_btContactSolverInfoData_m_erp2_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_erp2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_deformable_erp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_deformable_erp = arg2;
  
}


float _wrap_btContactSolverInfoData_m_deformable_erp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_deformable_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_deformable_cfm_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_deformable_cfm = arg2;
  
}


float _wrap_btContactSolverInfoData_m_deformable_cfm_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_deformable_cfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_deformable_maxErrorReduction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_deformable_maxErrorReduction = arg2;
  
}


float _wrap_btContactSolverInfoData_m_deformable_maxErrorReduction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_deformable_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_globalCfm_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_globalCfm = arg2;
  
}


float _wrap_btContactSolverInfoData_m_globalCfm_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_globalCfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_frictionERP_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionERP = arg2;
  
}


float _wrap_btContactSolverInfoData_m_frictionERP_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_frictionERP);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_frictionCFM_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionCFM = arg2;
  
}


float _wrap_btContactSolverInfoData_m_frictionCFM_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_frictionCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_splitImpulse_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulse = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_splitImpulse_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_splitImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_splitImpulsePenetrationThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulsePenetrationThreshold = arg2;
  
}


float _wrap_btContactSolverInfoData_m_splitImpulsePenetrationThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_splitImpulsePenetrationThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_splitImpulseTurnErp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulseTurnErp = arg2;
  
}


float _wrap_btContactSolverInfoData_m_splitImpulseTurnErp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_splitImpulseTurnErp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_linearSlop_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSlop = arg2;
  
}


float _wrap_btContactSolverInfoData_m_linearSlop_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_linearSlop);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_warmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_warmstartingFactor = arg2;
  
}


float _wrap_btContactSolverInfoData_m_warmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_warmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_articulatedWarmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_articulatedWarmstartingFactor = arg2;
  
}


float _wrap_btContactSolverInfoData_m_articulatedWarmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_articulatedWarmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_solverMode_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverMode = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_solverMode_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_restingContactRestitutionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_restingContactRestitutionThreshold = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_restingContactRestitutionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_restingContactRestitutionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_minimumSolverBatchSize_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_minimumSolverBatchSize = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_minimumSolverBatchSize_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_minimumSolverBatchSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_maxGyroscopicForce_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxGyroscopicForce = arg2;
  
}


float _wrap_btContactSolverInfoData_m_maxGyroscopicForce_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxGyroscopicForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_singleAxisRollingFrictionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_singleAxisRollingFrictionThreshold = arg2;
  
}


float _wrap_btContactSolverInfoData_m_singleAxisRollingFrictionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_singleAxisRollingFrictionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_leastSquaresResidualThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_leastSquaresResidualThreshold = arg2;
  
}


float _wrap_btContactSolverInfoData_m_leastSquaresResidualThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_leastSquaresResidualThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_restitutionVelocityThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitutionVelocityThreshold = arg2;
  
}


float _wrap_btContactSolverInfoData_m_restitutionVelocityThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_restitutionVelocityThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_jointFeedbackInWorldSpace_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, bool _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  bool arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_jointFeedbackInWorldSpace = arg2;
  
}


bool _wrap_btContactSolverInfoData_m_jointFeedbackInWorldSpace_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_jointFeedbackInWorldSpace);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_jointFeedbackInJointFrame_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, bool _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  bool arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_jointFeedbackInJointFrame = arg2;
  
}


bool _wrap_btContactSolverInfoData_m_jointFeedbackInJointFrame_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_jointFeedbackInJointFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_reportSolverAnalytics_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_reportSolverAnalytics = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_reportSolverAnalytics_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_reportSolverAnalytics);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoData_m_numNonContactInnerIterations_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numNonContactInnerIterations = arg2;
  
}


intgo _wrap_btContactSolverInfoData_m_numNonContactInnerIterations_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numNonContactInnerIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


btContactSolverInfoData *_wrap_new_btContactSolverInfoData_mbt_c1af402c8cb9fdfb() {
  btContactSolverInfoData *result = 0 ;
  btContactSolverInfoData *_swig_go_result;
  
  
  result = (btContactSolverInfoData *)new btContactSolverInfoData();
  *(btContactSolverInfoData **)&_swig_go_result = (btContactSolverInfoData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btContactSolverInfoData_mbt_c1af402c8cb9fdfb(btContactSolverInfoData *_swig_go_0) {
  btContactSolverInfoData *arg1 = (btContactSolverInfoData *) 0 ;
  
  arg1 = *(btContactSolverInfoData **)&_swig_go_0; 
  
  delete arg1;
  
}


btContactSolverInfo *_wrap_new_btContactSolverInfo_mbt_c1af402c8cb9fdfb() {
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  
  result = (btContactSolverInfo *)new btContactSolverInfo();
  *(btContactSolverInfo **)&_swig_go_result = (btContactSolverInfo *)result; 
  return _swig_go_result;
}


void _wrap_delete_btContactSolverInfo_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtContactSolverInfo_M_tau_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_tau = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_tau_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_tau);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_damping_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_damping = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_damping_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_friction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_friction = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_friction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_timeStep_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_timeStep = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_timeStep_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_timeStep);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_restitution_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_restitution = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_restitution_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_numIterations_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_numIterations = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_numIterations_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_numIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_maxErrorReduction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_maxErrorReduction = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_maxErrorReduction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_sor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_sor = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_sor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_sor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_erp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_erp = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_erp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_erp2_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_erp2 = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_erp2_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_erp2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_deformable_erp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_deformable_erp = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_deformable_erp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_deformable_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_deformable_cfm_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_deformable_cfm = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_deformable_cfm_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_deformable_cfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_deformable_maxErrorReduction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_deformable_maxErrorReduction = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_deformable_maxErrorReduction_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_deformable_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_globalCfm_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_globalCfm = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_globalCfm_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_globalCfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_frictionERP_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_frictionERP = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_frictionERP_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_frictionERP);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_frictionCFM_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_frictionCFM = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_frictionCFM_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_frictionCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_splitImpulse_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_splitImpulse = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_splitImpulse_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_splitImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_splitImpulsePenetrationThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_splitImpulsePenetrationThreshold = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_splitImpulsePenetrationThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_splitImpulsePenetrationThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_splitImpulseTurnErp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_splitImpulseTurnErp = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_splitImpulseTurnErp_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_splitImpulseTurnErp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_linearSlop_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_linearSlop = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_linearSlop_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_linearSlop);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_warmstartingFactor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_warmstartingFactor = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_warmstartingFactor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_warmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_articulatedWarmstartingFactor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_articulatedWarmstartingFactor = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_articulatedWarmstartingFactor_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_articulatedWarmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_solverMode_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_solverMode = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_solverMode_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_solverMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_restingContactRestitutionThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_restingContactRestitutionThreshold = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_restingContactRestitutionThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_restingContactRestitutionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_minimumSolverBatchSize_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_minimumSolverBatchSize = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_minimumSolverBatchSize_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_minimumSolverBatchSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_maxGyroscopicForce_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_maxGyroscopicForce = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_maxGyroscopicForce_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_maxGyroscopicForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_singleAxisRollingFrictionThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_singleAxisRollingFrictionThreshold = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_singleAxisRollingFrictionThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_singleAxisRollingFrictionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_leastSquaresResidualThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_leastSquaresResidualThreshold = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_leastSquaresResidualThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_leastSquaresResidualThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_restitutionVelocityThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, float _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_restitutionVelocityThreshold = arg2;
  
}


float _wrap_GetbtContactSolverInfo_M_restitutionVelocityThreshold_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (btScalar) ((swig_b0)->m_restitutionVelocityThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_jointFeedbackInWorldSpace_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, bool _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_jointFeedbackInWorldSpace = arg2;
  
}


bool _wrap_GetbtContactSolverInfo_M_jointFeedbackInWorldSpace_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (bool) ((swig_b0)->m_jointFeedbackInWorldSpace);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_jointFeedbackInJointFrame_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, bool _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  bool arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_jointFeedbackInJointFrame = arg2;
  
}


bool _wrap_GetbtContactSolverInfo_M_jointFeedbackInJointFrame_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (bool) ((swig_b0)->m_jointFeedbackInJointFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_reportSolverAnalytics_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_reportSolverAnalytics = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_reportSolverAnalytics_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_reportSolverAnalytics);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtContactSolverInfo_M_numNonContactInnerIterations_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  if (swig_b0) (swig_b0)->m_numNonContactInnerIterations = arg2;
  
}


intgo _wrap_GetbtContactSolverInfo_M_numNonContactInnerIterations_mbt_c1af402c8cb9fdfb(btContactSolverInfo *_swig_go_0) {
  btContactSolverInfo *arg1 = (btContactSolverInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfo **)&_swig_go_0; 
  
  btContactSolverInfoData *swig_b0 = (btContactSolverInfoData *)arg1;
  result = (int) ((swig_b0)->m_numNonContactInnerIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_tau_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_tau = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_tau_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_tau);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_damping_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_damping_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_friction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_friction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_timeStep_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_timeStep = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_timeStep_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_timeStep);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_restitution_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_restitution_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_maxErrorReduction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxErrorReduction = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_maxErrorReduction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_sor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_sor = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_sor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_sor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_erp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_erp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_erp2_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp2 = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_erp2_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_erp2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_globalCfm_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_globalCfm = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_globalCfm_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_globalCfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_splitImpulsePenetrationThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulsePenetrationThreshold = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_splitImpulsePenetrationThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_splitImpulsePenetrationThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_splitImpulseTurnErp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulseTurnErp = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_splitImpulseTurnErp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_splitImpulseTurnErp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_linearSlop_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSlop = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_linearSlop_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearSlop);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_warmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_warmstartingFactor = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_warmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_warmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_articulatedWarmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_articulatedWarmstartingFactor = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_articulatedWarmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_articulatedWarmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_maxGyroscopicForce_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxGyroscopicForce = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_maxGyroscopicForce_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_maxGyroscopicForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_singleAxisRollingFrictionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, double _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_singleAxisRollingFrictionThreshold = arg2;
  
}


double _wrap_btContactSolverInfoDoubleData_m_singleAxisRollingFrictionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_singleAxisRollingFrictionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_numIterations_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numIterations = arg2;
  
}


intgo _wrap_btContactSolverInfoDoubleData_m_numIterations_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_solverMode_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverMode = arg2;
  
}


intgo _wrap_btContactSolverInfoDoubleData_m_solverMode_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_restingContactRestitutionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_restingContactRestitutionThreshold = arg2;
  
}


intgo _wrap_btContactSolverInfoDoubleData_m_restingContactRestitutionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_restingContactRestitutionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_minimumSolverBatchSize_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_minimumSolverBatchSize = arg2;
  
}


intgo _wrap_btContactSolverInfoDoubleData_m_minimumSolverBatchSize_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_minimumSolverBatchSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_splitImpulse_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulse = arg2;
  
}


intgo _wrap_btContactSolverInfoDoubleData_m_splitImpulse_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_splitImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoDoubleData_m_padding_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btContactSolverInfoDoubleData_m_padding_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btContactSolverInfoDoubleData *_wrap_new_btContactSolverInfoDoubleData_mbt_c1af402c8cb9fdfb() {
  btContactSolverInfoDoubleData *result = 0 ;
  btContactSolverInfoDoubleData *_swig_go_result;
  
  
  result = (btContactSolverInfoDoubleData *)new btContactSolverInfoDoubleData();
  *(btContactSolverInfoDoubleData **)&_swig_go_result = (btContactSolverInfoDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btContactSolverInfoDoubleData_mbt_c1af402c8cb9fdfb(btContactSolverInfoDoubleData *_swig_go_0) {
  btContactSolverInfoDoubleData *arg1 = (btContactSolverInfoDoubleData *) 0 ;
  
  arg1 = *(btContactSolverInfoDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btContactSolverInfoFloatData_m_tau_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_tau = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_tau_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_tau);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_damping_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_damping_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_friction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_friction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_timeStep_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_timeStep = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_timeStep_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_timeStep);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_restitution_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_restitution_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_maxErrorReduction_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxErrorReduction = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_maxErrorReduction_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_maxErrorReduction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_sor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_sor = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_sor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_sor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_erp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_erp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_erp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_erp2_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_erp2 = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_erp2_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_erp2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_globalCfm_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_globalCfm = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_globalCfm_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_globalCfm);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_splitImpulsePenetrationThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulsePenetrationThreshold = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_splitImpulsePenetrationThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_splitImpulsePenetrationThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_splitImpulseTurnErp_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulseTurnErp = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_splitImpulseTurnErp_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_splitImpulseTurnErp);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_linearSlop_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSlop = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_linearSlop_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearSlop);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_warmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_warmstartingFactor = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_warmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_warmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_articulatedWarmstartingFactor_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_articulatedWarmstartingFactor = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_articulatedWarmstartingFactor_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_articulatedWarmstartingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_maxGyroscopicForce_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxGyroscopicForce = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_maxGyroscopicForce_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_maxGyroscopicForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_singleAxisRollingFrictionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, float _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_singleAxisRollingFrictionThreshold = arg2;
  
}


float _wrap_btContactSolverInfoFloatData_m_singleAxisRollingFrictionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_singleAxisRollingFrictionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_numIterations_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numIterations = arg2;
  
}


intgo _wrap_btContactSolverInfoFloatData_m_numIterations_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_solverMode_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_solverMode = arg2;
  
}


intgo _wrap_btContactSolverInfoFloatData_m_solverMode_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_solverMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_restingContactRestitutionThreshold_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_restingContactRestitutionThreshold = arg2;
  
}


intgo _wrap_btContactSolverInfoFloatData_m_restingContactRestitutionThreshold_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_restingContactRestitutionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_minimumSolverBatchSize_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_minimumSolverBatchSize = arg2;
  
}


intgo _wrap_btContactSolverInfoFloatData_m_minimumSolverBatchSize_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_minimumSolverBatchSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btContactSolverInfoFloatData_m_splitImpulse_set_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0, intgo _swig_go_1) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_splitImpulse = arg2;
  
}


intgo _wrap_btContactSolverInfoFloatData_m_splitImpulse_get_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_splitImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


btContactSolverInfoFloatData *_wrap_new_btContactSolverInfoFloatData_mbt_c1af402c8cb9fdfb() {
  btContactSolverInfoFloatData *result = 0 ;
  btContactSolverInfoFloatData *_swig_go_result;
  
  
  result = (btContactSolverInfoFloatData *)new btContactSolverInfoFloatData();
  *(btContactSolverInfoFloatData **)&_swig_go_result = (btContactSolverInfoFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btContactSolverInfoFloatData_mbt_c1af402c8cb9fdfb(btContactSolverInfoFloatData *_swig_go_0) {
  btContactSolverInfoFloatData *arg1 = (btContactSolverInfoFloatData *) 0 ;
  
  arg1 = *(btContactSolverInfoFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_SIMPLE_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_SIMPLE_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_DISCRETE_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_DISCRETE_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONTINUOUS_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_CONTINUOUS_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOFT_RIGID_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_SOFT_RIGID_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_GPU_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_GPU_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SOFT_MULTIBODY_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_SOFT_MULTIBODY_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_DEFORMABLE_MULTIBODY_DYNAMICS_WORLD_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  
  result = BT_DEFORMABLE_MULTIBODY_DYNAMICS_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btDynamicsWorld_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btDynamicsWorld_stepSimulation__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2, float _swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDynamicsWorld_stepSimulation__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDynamicsWorld_stepSimulation__SWIG_2_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, float _swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (int)(arg1)->stepSimulation(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_debugDrawWorld_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->debugDrawWorld();
  
}


void _wrap_btDynamicsWorld_addConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1, bool _swig_go_2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->addConstraint(arg2,arg3);
  
}


void _wrap_btDynamicsWorld_addConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraint(arg2);
  
}


void _wrap_btDynamicsWorld_removeConstraint_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraint(arg2);
  
}


void _wrap_btDynamicsWorld_addAction_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addAction(arg2);
  
}


void _wrap_btDynamicsWorld_removeAction_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeAction(arg2);
  
}


void _wrap_btDynamicsWorld_setGravity_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btVector3 *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btDynamicsWorld_getGravity_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = ((btDynamicsWorld const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_synchronizeMotionStates_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->synchronizeMotionStates();
  
}


void _wrap_btDynamicsWorld_addRigidBody__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->addRigidBody(arg2);
  
}


void _wrap_btDynamicsWorld_addRigidBody__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addRigidBody(arg2,arg3,arg4);
  
}


void _wrap_btDynamicsWorld_removeRigidBody_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->removeRigidBody(arg2);
  
}


void _wrap_btDynamicsWorld_setConstraintSolver_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btConstraintSolver *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConstraintSolver **)&_swig_go_1; 
  
  (arg1)->setConstraintSolver(arg2);
  
}


btConstraintSolver *_wrap_btDynamicsWorld_getConstraintSolver_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  btConstraintSolver *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (btConstraintSolver *)(arg1)->getConstraintSolver();
  *(btConstraintSolver **)&_swig_go_result = (btConstraintSolver *)result; 
  return _swig_go_result;
}


intgo _wrap_btDynamicsWorld_getNumConstraints_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (int)((btDynamicsWorld const *)arg1)->getNumConstraints();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)((btDynamicsWorld const *)arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


intgo _wrap_btDynamicsWorld_getWorldType_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (btDynamicsWorldType)((btDynamicsWorld const *)arg1)->getWorldType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_clearForces_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, void* _swig_go_1, void *_swig_go_2, bool _swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  bool arg4 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (bool)_swig_go_3; 
  
  (arg1)->setInternalTickCallback(arg2,arg3,arg4);
  
}


void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, void* _swig_go_1, void *_swig_go_2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  
  (arg1)->setInternalTickCallback(arg2,arg3);
  
}


void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_2_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, void* _swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  
  (arg1)->setInternalTickCallback(arg2);
  
}


void _wrap_btDynamicsWorld_setWorldUserInfo_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, void *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setWorldUserInfo(arg2);
  
}


void *_wrap_btDynamicsWorld_getWorldUserInfo_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (void *)((btDynamicsWorld const *)arg1)->getWorldUserInfo();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btContactSolverInfo *_wrap_btDynamicsWorld_getSolverInfo__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (btContactSolverInfo *) &(arg1)->getSolverInfo();
  *(btContactSolverInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btContactSolverInfo *_wrap_btDynamicsWorld_getSolverInfo__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  result = (btContactSolverInfo *) &((btDynamicsWorld const *)arg1)->getSolverInfo();
  *(btContactSolverInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_addVehicle_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addVehicle(arg2);
  
}


void _wrap_btDynamicsWorld_removeVehicle_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeVehicle(arg2);
  
}


void _wrap_btDynamicsWorld_addCharacter_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addCharacter(arg2);
  
}


void _wrap_btDynamicsWorld_removeCharacter_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeCharacter(arg2);
  
}


void _wrap_btDynamicsWorld_setBroadphase_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btBroadphaseInterface *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->setBroadphase(arg2);
  
}


btBroadphaseInterface *_wrap_btDynamicsWorld_getBroadphase__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btBroadphaseInterface *)((btCollisionWorld const *)swig_b0)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btBroadphaseInterface *_wrap_btDynamicsWorld_getBroadphase__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btBroadphaseInterface *)(swig_b0)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btOverlappingPairCache *_wrap_btDynamicsWorld_getPairCache_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btOverlappingPairCache *)(swig_b0)->getPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btDynamicsWorld_getDispatcher__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btDispatcher *)(swig_b0)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btDynamicsWorld_getDispatcher__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btDispatcher *)((btCollisionWorld const *)swig_b0)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_updateSingleAabb_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->updateSingleAabb(arg2);
  
}


void _wrap_btDynamicsWorld_updateAabbs_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->updateAabbs();
  
}


void _wrap_btDynamicsWorld_computeOverlappingPairs_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->computeOverlappingPairs();
  
}


void _wrap_btDynamicsWorld_setDebugDrawer_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btIDebugDraw *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->setDebugDrawer(arg2);
  
}


btIDebugDraw *_wrap_btDynamicsWorld_getDebugDrawer_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btIDebugDraw *)(swig_b0)->getDebugDrawer();
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_debugDrawObject_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btTransform *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
  
}


intgo _wrap_btDynamicsWorld_getNumCollisionObjects_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (int)((btCollisionWorld const *)swig_b0)->getNumCollisionObjects();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_rayTest_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  ((btCollisionWorld const *)swig_b0)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btDynamicsWorld_convexSweepTest__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  ((btCollisionWorld const *)swig_b0)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
  
}


void _wrap_btDynamicsWorld_convexSweepTest__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  ((btCollisionWorld const *)swig_b0)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
  
}


void _wrap_btDynamicsWorld_contactTest_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->contactTest(arg2,*arg3);
  
}


void _wrap_btDynamicsWorld_contactPairTest_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionWorld::ContactResultCallback *_swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_3; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->contactPairTest(arg2,arg3,*arg4);
  
}


void _wrap_btDynamicsWorld_rayTestSingle_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionShape *_swig_go_3, btTransform *_swig_go_4, btCollisionWorld::RayResultCallback *_swig_go_5) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionShape **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btCollisionWorld::RayResultCallback **)&_swig_go_5; 
  
  btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
  
}


void _wrap_btDynamicsWorld_rayTestSingleInternal_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
  
}


void _wrap_btDynamicsWorld_objectQuerySingle_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObject *_swig_go_3, btCollisionShape *_swig_go_4, btTransform *_swig_go_5, btCollisionWorld::ConvexResultCallback *_swig_go_6, float _swig_go_7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObject **)&_swig_go_3; 
  arg5 = *(btCollisionShape **)&_swig_go_4; 
  arg6 = *(btTransform **)&_swig_go_5; 
  arg7 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  
  btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
  
}


void _wrap_btDynamicsWorld_objectQuerySingleInternal_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObjectWrapper *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObjectWrapper **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
  
}


void _wrap_btDynamicsWorld_addCollisionObject__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->addCollisionObject(arg2,arg3,arg4);
  
}


void _wrap_btDynamicsWorld_addCollisionObject__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->addCollisionObject(arg2,arg3);
  
}


void _wrap_btDynamicsWorld_addCollisionObject__SWIG_2_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->addCollisionObject(arg2);
  
}


void _wrap_btDynamicsWorld_refreshBroadphaseProxy_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->refreshBroadphaseProxy(arg2);
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btDynamicsWorld_getCollisionObjectArray__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btCollisionObjectArray *) &(swig_b0)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btDynamicsWorld_getCollisionObjectArray__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btCollisionObjectArray *) &((btCollisionWorld const *)swig_b0)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_removeCollisionObject_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->removeCollisionObject(arg2);
  
}


void _wrap_btDynamicsWorld_performDiscreteCollisionDetection_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->performDiscreteCollisionDetection();
  
}


btDispatcherInfo *_wrap_btDynamicsWorld_getDispatchInfo__SWIG_0_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btDispatcherInfo *) &(swig_b0)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btDispatcherInfo *_wrap_btDynamicsWorld_getDispatchInfo__SWIG_1_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (btDispatcherInfo *) &((btCollisionWorld const *)swig_b0)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btDynamicsWorld_getForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  result = (bool)((btCollisionWorld const *)swig_b0)->getForceUpdateAllAabbs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorld_setForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->setForceUpdateAllAabbs(arg2);
  
}


void _wrap_btDynamicsWorld_serialize_mbt_c1af402c8cb9fdfb(btDynamicsWorld *_swig_go_0, btSerializer *_swig_go_1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCollisionWorld *swig_b0 = (btCollisionWorld *)arg1;
  (swig_b0)->serialize(arg2);
  
}


void _wrap_btDynamicsWorldDoubleData_m_solverInfo_set_mbt_c1af402c8cb9fdfb(btDynamicsWorldDoubleData *_swig_go_0, btContactSolverInfoDoubleData *_swig_go_1) {
  btDynamicsWorldDoubleData *arg1 = (btDynamicsWorldDoubleData *) 0 ;
  btContactSolverInfoDoubleData *arg2 = (btContactSolverInfoDoubleData *) 0 ;
  
  arg1 = *(btDynamicsWorldDoubleData **)&_swig_go_0; 
  arg2 = *(btContactSolverInfoDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solverInfo = *arg2;
  
}


btContactSolverInfoDoubleData *_wrap_btDynamicsWorldDoubleData_m_solverInfo_get_mbt_c1af402c8cb9fdfb(btDynamicsWorldDoubleData *_swig_go_0) {
  btDynamicsWorldDoubleData *arg1 = (btDynamicsWorldDoubleData *) 0 ;
  btContactSolverInfoDoubleData *result = 0 ;
  btContactSolverInfoDoubleData *_swig_go_result;
  
  arg1 = *(btDynamicsWorldDoubleData **)&_swig_go_0; 
  
  result = (btContactSolverInfoDoubleData *)& ((arg1)->m_solverInfo);
  *(btContactSolverInfoDoubleData **)&_swig_go_result = (btContactSolverInfoDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorldDoubleData_m_gravity_set_mbt_c1af402c8cb9fdfb(btDynamicsWorldDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btDynamicsWorldDoubleData *arg1 = (btDynamicsWorldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btDynamicsWorldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3DoubleData *_wrap_btDynamicsWorldDoubleData_m_gravity_get_mbt_c1af402c8cb9fdfb(btDynamicsWorldDoubleData *_swig_go_0) {
  btDynamicsWorldDoubleData *arg1 = (btDynamicsWorldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btDynamicsWorldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


btDynamicsWorldDoubleData *_wrap_new_btDynamicsWorldDoubleData_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldDoubleData *result = 0 ;
  btDynamicsWorldDoubleData *_swig_go_result;
  
  
  result = (btDynamicsWorldDoubleData *)new btDynamicsWorldDoubleData();
  *(btDynamicsWorldDoubleData **)&_swig_go_result = (btDynamicsWorldDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDynamicsWorldDoubleData_mbt_c1af402c8cb9fdfb(btDynamicsWorldDoubleData *_swig_go_0) {
  btDynamicsWorldDoubleData *arg1 = (btDynamicsWorldDoubleData *) 0 ;
  
  arg1 = *(btDynamicsWorldDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btDynamicsWorldFloatData_m_solverInfo_set_mbt_c1af402c8cb9fdfb(btDynamicsWorldFloatData *_swig_go_0, btContactSolverInfoFloatData *_swig_go_1) {
  btDynamicsWorldFloatData *arg1 = (btDynamicsWorldFloatData *) 0 ;
  btContactSolverInfoFloatData *arg2 = (btContactSolverInfoFloatData *) 0 ;
  
  arg1 = *(btDynamicsWorldFloatData **)&_swig_go_0; 
  arg2 = *(btContactSolverInfoFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solverInfo = *arg2;
  
}


btContactSolverInfoFloatData *_wrap_btDynamicsWorldFloatData_m_solverInfo_get_mbt_c1af402c8cb9fdfb(btDynamicsWorldFloatData *_swig_go_0) {
  btDynamicsWorldFloatData *arg1 = (btDynamicsWorldFloatData *) 0 ;
  btContactSolverInfoFloatData *result = 0 ;
  btContactSolverInfoFloatData *_swig_go_result;
  
  arg1 = *(btDynamicsWorldFloatData **)&_swig_go_0; 
  
  result = (btContactSolverInfoFloatData *)& ((arg1)->m_solverInfo);
  *(btContactSolverInfoFloatData **)&_swig_go_result = (btContactSolverInfoFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btDynamicsWorldFloatData_m_gravity_set_mbt_c1af402c8cb9fdfb(btDynamicsWorldFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btDynamicsWorldFloatData *arg1 = (btDynamicsWorldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btDynamicsWorldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3FloatData *_wrap_btDynamicsWorldFloatData_m_gravity_get_mbt_c1af402c8cb9fdfb(btDynamicsWorldFloatData *_swig_go_0) {
  btDynamicsWorldFloatData *arg1 = (btDynamicsWorldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btDynamicsWorldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


btDynamicsWorldFloatData *_wrap_new_btDynamicsWorldFloatData_mbt_c1af402c8cb9fdfb() {
  btDynamicsWorldFloatData *result = 0 ;
  btDynamicsWorldFloatData *_swig_go_result;
  
  
  result = (btDynamicsWorldFloatData *)new btDynamicsWorldFloatData();
  *(btDynamicsWorldFloatData **)&_swig_go_result = (btDynamicsWorldFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDynamicsWorldFloatData_mbt_c1af402c8cb9fdfb(btDynamicsWorldFloatData *_swig_go_0) {
  btDynamicsWorldFloatData *arg1 = (btDynamicsWorldFloatData *) 0 ;
  
  arg1 = *(btDynamicsWorldFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btGetConstraintIslandId_mbt_c1af402c8cb9fdfb(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)btGetConstraintIslandId((btTypedConstraint const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btSortConstraintOnIslandPredicate *_wrap_new_btSortConstraintOnIslandPredicate_mbt_c1af402c8cb9fdfb() {
  btSortConstraintOnIslandPredicate *result = 0 ;
  btSortConstraintOnIslandPredicate *_swig_go_result;
  
  
  result = (btSortConstraintOnIslandPredicate *)new btSortConstraintOnIslandPredicate();
  *(btSortConstraintOnIslandPredicate **)&_swig_go_result = (btSortConstraintOnIslandPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSortConstraintOnIslandPredicate_mbt_c1af402c8cb9fdfb(btSortConstraintOnIslandPredicate *_swig_go_0) {
  btSortConstraintOnIslandPredicate *arg1 = (btSortConstraintOnIslandPredicate *) 0 ;
  
  arg1 = *(btSortConstraintOnIslandPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_InplaceSolverIslandCallback_m_solverInfo_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btContactSolverInfo *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *arg2 = (btContactSolverInfo *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solverInfo = arg2;
  
}


btContactSolverInfo *_wrap_InplaceSolverIslandCallback_m_solverInfo_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btContactSolverInfo *) ((arg1)->m_solverInfo);
  *(btContactSolverInfo **)&_swig_go_result = (btContactSolverInfo *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_solver_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btConstraintSolver *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btConstraintSolver **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solver = arg2;
  
}


btConstraintSolver *_wrap_InplaceSolverIslandCallback_m_solver_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btConstraintSolver *result = 0 ;
  btConstraintSolver *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btConstraintSolver *) ((arg1)->m_solver);
  *(btConstraintSolver **)&_swig_go_result = (btConstraintSolver *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_sortedConstraints_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btTypedConstraint **_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btTypedConstraint **arg2 = (btTypedConstraint **) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btTypedConstraint ***)&_swig_go_1; 
  
  if (arg1) (arg1)->m_sortedConstraints = arg2;
  
}


btTypedConstraint **_wrap_InplaceSolverIslandCallback_m_sortedConstraints_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btTypedConstraint **result = 0 ;
  btTypedConstraint **_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btTypedConstraint **) ((arg1)->m_sortedConstraints);
  *(btTypedConstraint ***)&_swig_go_result = (btTypedConstraint **)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_numConstraints_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, intgo _swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  int arg2 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numConstraints = arg2;
  
}


intgo _wrap_InplaceSolverIslandCallback_m_numConstraints_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numConstraints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_debugDrawer_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btIDebugDraw *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_debugDrawer = arg2;
  
}


btIDebugDraw *_wrap_InplaceSolverIslandCallback_m_debugDrawer_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btIDebugDraw *) ((arg1)->m_debugDrawer);
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_dispatcher_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btDispatcher *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dispatcher = arg2;
  
}


btDispatcher *_wrap_InplaceSolverIslandCallback_m_dispatcher_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btDispatcher *) ((arg1)->m_dispatcher);
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_bodies_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btCollisionObject * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btCollisionObject * > *arg2 = (btAlignedObjectArray< btCollisionObject * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObject * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bodies = *arg2;
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_InplaceSolverIslandCallback_m_bodies_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btCollisionObject * > *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObject * > *)& ((arg1)->m_bodies);
  *(btAlignedObjectArray< btCollisionObject * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObject * > *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_manifolds_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btPersistentManifold * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btPersistentManifold * > *arg2 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btPersistentManifold * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_manifolds = *arg2;
  
}


btAlignedObjectArray< btPersistentManifold * > *_wrap_InplaceSolverIslandCallback_m_manifolds_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btPersistentManifold * > *result = 0 ;
  btAlignedObjectArray< btPersistentManifold * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btPersistentManifold * > *)& ((arg1)->m_manifolds);
  *(btAlignedObjectArray< btPersistentManifold * > **)&_swig_go_result = (btAlignedObjectArray< btPersistentManifold * > *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_constraints_set_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btTypedConstraint * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btTypedConstraint * > *arg2 = (btAlignedObjectArray< btTypedConstraint * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraint * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraints = *arg2;
  
}


btAlignedObjectArray< btTypedConstraint * > *_wrap_InplaceSolverIslandCallback_m_constraints_get_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btTypedConstraint * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraint * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraint * > *)& ((arg1)->m_constraints);
  *(btAlignedObjectArray< btTypedConstraint * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraint * > *)result; 
  return _swig_go_result;
}


InplaceSolverIslandCallback *_wrap_new_InplaceSolverIslandCallback_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0, btStackAlloc *_swig_go_1, btDispatcher *_swig_go_2) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btStackAlloc *arg2 = (btStackAlloc *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  InplaceSolverIslandCallback *result = 0 ;
  InplaceSolverIslandCallback *_swig_go_result;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  arg2 = *(btStackAlloc **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  result = (InplaceSolverIslandCallback *)new InplaceSolverIslandCallback(arg1,arg2,arg3);
  *(InplaceSolverIslandCallback **)&_swig_go_result = (InplaceSolverIslandCallback *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_setup_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btContactSolverInfo *_swig_go_1, btTypedConstraint **_swig_go_2, intgo _swig_go_3, btIDebugDraw *_swig_go_4) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *arg2 = (btContactSolverInfo *) 0 ;
  btTypedConstraint **arg3 = (btTypedConstraint **) 0 ;
  int arg4 ;
  btIDebugDraw *arg5 = (btIDebugDraw *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  arg3 = *(btTypedConstraint ***)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(btIDebugDraw **)&_swig_go_4; 
  
  (arg1)->setup(arg2,arg3,arg4,arg5);
  
}


void _wrap_InplaceSolverIslandCallback_processIsland_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0, btCollisionObject **_swig_go_1, intgo _swig_go_2, btPersistentManifold **_swig_go_3, intgo _swig_go_4, intgo _swig_go_5) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  int arg6 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject ***)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btPersistentManifold ***)&_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  
  (arg1)->processIsland(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_InplaceSolverIslandCallback_processConstraints_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  (arg1)->processConstraints();
  
}


void _wrap_delete_InplaceSolverIslandCallback_mbt_c1af402c8cb9fdfb(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btClosestNotMeConvexResultCallback_m_me_set_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, btCollisionObject *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_me = arg2;
  
}


btCollisionObject *_wrap_btClosestNotMeConvexResultCallback_m_me_get_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btCollisionObject *) ((arg1)->m_me);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_allowedPenetration_set_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, float _swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedPenetration = arg2;
  
}


float _wrap_btClosestNotMeConvexResultCallback_m_allowedPenetration_get_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_pairCache_set_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, btOverlappingPairCache *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCache **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pairCache = arg2;
  
}


btOverlappingPairCache *_wrap_btClosestNotMeConvexResultCallback_m_pairCache_get_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *) ((arg1)->m_pairCache);
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_dispatcher_set_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, btDispatcher *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dispatcher = arg2;
  
}


btDispatcher *_wrap_btClosestNotMeConvexResultCallback_m_dispatcher_get_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btDispatcher *) ((arg1)->m_dispatcher);
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btClosestNotMeConvexResultCallback *_wrap_new_btClosestNotMeConvexResultCallback_mbt_c1af402c8cb9fdfb(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btOverlappingPairCache *_swig_go_3, btDispatcher *_swig_go_4) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  btClosestNotMeConvexResultCallback *result = 0 ;
  btClosestNotMeConvexResultCallback *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btOverlappingPairCache **)&_swig_go_3; 
  arg5 = *(btDispatcher **)&_swig_go_4; 
  
  result = (btClosestNotMeConvexResultCallback *)new btClosestNotMeConvexResultCallback(arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5);
  *(btClosestNotMeConvexResultCallback **)&_swig_go_result = (btClosestNotMeConvexResultCallback *)result; 
  return _swig_go_result;
}


float _wrap_btClosestNotMeConvexResultCallback_addSingleResult_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, btCollisionWorld::LocalConvexResult *_swig_go_1, bool _swig_go_2) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionWorld::LocalConvexResult *arg2 = 0 ;
  bool arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::LocalConvexResult **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btScalar)(arg1)->addSingleResult(*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btClosestNotMeConvexResultCallback_needsCollision_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)((btClosestNotMeConvexResultCallback const *)arg1)->needsCollision(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btClosestNotMeConvexResultCallback_mbt_c1af402c8cb9fdfb(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gNumClampedCcdMotions_set_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  gNumClampedCcdMotions = arg1;
  
}


intgo _wrap_gNumClampedCcdMotions_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)gNumClampedCcdMotions;
  _swig_go_result = result; 
  return _swig_go_result;
}


btDiscreteDynamicsWorld *_wrap_new_btDiscreteDynamicsWorld_mbt_c1af402c8cb9fdfb(btDispatcher *_swig_go_0, btBroadphaseInterface *_swig_go_1, btConstraintSolver *_swig_go_2, btCollisionConfiguration *_swig_go_3) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btDiscreteDynamicsWorld *result = 0 ;
  btDiscreteDynamicsWorld *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  arg3 = *(btConstraintSolver **)&_swig_go_2; 
  arg4 = *(btCollisionConfiguration **)&_swig_go_3; 
  
  result = (btDiscreteDynamicsWorld *)new btDiscreteDynamicsWorld(arg1,arg2,arg3,arg4);
  *(btDiscreteDynamicsWorld **)&_swig_go_result = (btDiscreteDynamicsWorld *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDiscreteDynamicsWorld_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2, float _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_2_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (int)(arg1)->stepSimulation(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_solveConstraints_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btContactSolverInfo *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  
  (arg1)->solveConstraints(*arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_synchronizeMotionStates_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->synchronizeMotionStates();
  
}


void _wrap_btDiscreteDynamicsWorld_synchronizeSingleMotionState_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->synchronizeSingleMotionState(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1, bool _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->addConstraint(arg2,arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeConstraint_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addAction_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addAction(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeAction_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeAction(arg2);
  
}


btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btSimulationIslandManager *)(arg1)->getSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btSimulationIslandManager *)((btDiscreteDynamicsWorld const *)arg1)->getSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


btCollisionWorld *_wrap_btDiscreteDynamicsWorld_getCollisionWorld_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btCollisionWorld *)(arg1)->getCollisionWorld();
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setGravity_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btVector3 *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btDiscreteDynamicsWorld_getGravity_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = ((btDiscreteDynamicsWorld const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addCollisionObject(arg2,arg3,arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->addCollisionObject(arg2,arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_2_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->addCollisionObject(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->addRigidBody(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addRigidBody(arg2,arg3,arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_removeRigidBody_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->removeRigidBody(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeCollisionObject_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->removeCollisionObject(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_debugDrawConstraint_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->debugDrawConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_debugDrawWorld_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->debugDrawWorld();
  
}


void _wrap_btDiscreteDynamicsWorld_setConstraintSolver_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btConstraintSolver *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConstraintSolver **)&_swig_go_1; 
  
  (arg1)->setConstraintSolver(arg2);
  
}


btConstraintSolver *_wrap_btDiscreteDynamicsWorld_getConstraintSolver_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  btConstraintSolver *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btConstraintSolver *)(arg1)->getConstraintSolver();
  *(btConstraintSolver **)&_swig_go_result = (btConstraintSolver *)result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_getNumConstraints_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (int)((btDiscreteDynamicsWorld const *)arg1)->getNumConstraints();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)((btDiscreteDynamicsWorld const *)arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_getWorldType_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btDynamicsWorldType)((btDiscreteDynamicsWorld const *)arg1)->getWorldType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_clearForces_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btDiscreteDynamicsWorld_applyGravity_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->applyGravity();
  
}


void _wrap_btDiscreteDynamicsWorld_setNumTasks_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setNumTasks(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_updateVehicles_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateVehicles(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addVehicle_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addVehicle(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeVehicle_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeVehicle(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addCharacter_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addCharacter(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeCharacter_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeCharacter(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_setSynchronizeAllMotionStates_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setSynchronizeAllMotionStates(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getSynchronizeAllMotionStates_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getSynchronizeAllMotionStates();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setApplySpeculativeContactRestitution(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getApplySpeculativeContactRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_serialize_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btSerializer *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  (arg1)->serialize(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setLatencyMotionStateInterpolation(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getLatencyMotionStateInterpolation();
  _swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btRigidBody * > *_wrap_btDiscreteDynamicsWorld_getNonStaticRigidBodies__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btAlignedObjectArray< btRigidBody * > *result = 0 ;
  btAlignedObjectArray< btRigidBody * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBody * > *) &(arg1)->getNonStaticRigidBodies();
  *(btAlignedObjectArray< btRigidBody * > **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btRigidBody * > *_wrap_btDiscreteDynamicsWorld_getNonStaticRigidBodies__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btAlignedObjectArray< btRigidBody * > *result = 0 ;
  btAlignedObjectArray< btRigidBody * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBody * > *) &((btDiscreteDynamicsWorld const *)arg1)->getNonStaticRigidBodies();
  *(btAlignedObjectArray< btRigidBody * > **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setInternalTickCallback__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, void* _swig_go_1, void *_swig_go_2, bool _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  bool arg4 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (bool)_swig_go_3; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  (swig_b0)->setInternalTickCallback(arg2,arg3,arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_setInternalTickCallback__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, void* _swig_go_1, void *_swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  (swig_b0)->setInternalTickCallback(arg2,arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_setInternalTickCallback__SWIG_2_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, void* _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btInternalTickCallback *)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  (swig_b0)->setInternalTickCallback(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_setWorldUserInfo_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, void *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  (swig_b0)->setWorldUserInfo(arg2);
  
}


void *_wrap_btDiscreteDynamicsWorld_getWorldUserInfo_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  result = (void *)((btDynamicsWorld const *)swig_b0)->getWorldUserInfo();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btContactSolverInfo *_wrap_btDiscreteDynamicsWorld_getSolverInfo__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  result = (btContactSolverInfo *) &(swig_b0)->getSolverInfo();
  *(btContactSolverInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btContactSolverInfo *_wrap_btDiscreteDynamicsWorld_getSolverInfo__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  result = (btContactSolverInfo *) &((btDynamicsWorld const *)swig_b0)->getSolverInfo();
  *(btContactSolverInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setBroadphase_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btBroadphaseInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->setBroadphase(arg2);
  
}


btBroadphaseInterface *_wrap_btDiscreteDynamicsWorld_getBroadphase__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btBroadphaseInterface *)((btCollisionWorld const *)swig_b1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btBroadphaseInterface *_wrap_btDiscreteDynamicsWorld_getBroadphase__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btBroadphaseInterface *)(swig_b1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btOverlappingPairCache *_wrap_btDiscreteDynamicsWorld_getPairCache_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btOverlappingPairCache *)(swig_b1)->getPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btDiscreteDynamicsWorld_getDispatcher__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btDispatcher *)(swig_b1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btDiscreteDynamicsWorld_getDispatcher__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btDispatcher *)((btCollisionWorld const *)swig_b1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_updateSingleAabb_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->updateSingleAabb(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_updateAabbs_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->updateAabbs();
  
}


void _wrap_btDiscreteDynamicsWorld_computeOverlappingPairs_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->computeOverlappingPairs();
  
}


void _wrap_btDiscreteDynamicsWorld_setDebugDrawer_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btIDebugDraw *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->setDebugDrawer(arg2);
  
}


btIDebugDraw *_wrap_btDiscreteDynamicsWorld_getDebugDrawer_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btIDebugDraw *)(swig_b1)->getDebugDrawer();
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_debugDrawObject_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btTransform *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
  
}


intgo _wrap_btDiscreteDynamicsWorld_getNumCollisionObjects_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (int)((btCollisionWorld const *)swig_b1)->getNumCollisionObjects();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_rayTest_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  ((btCollisionWorld const *)swig_b1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_convexSweepTest__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  ((btCollisionWorld const *)swig_b1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
  
}


void _wrap_btDiscreteDynamicsWorld_convexSweepTest__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  ((btCollisionWorld const *)swig_b1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
  
}


void _wrap_btDiscreteDynamicsWorld_contactTest_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->contactTest(arg2,*arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_contactPairTest_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionWorld::ContactResultCallback *_swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_3; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->contactPairTest(arg2,arg3,*arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_rayTestSingle_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionShape *_swig_go_3, btTransform *_swig_go_4, btCollisionWorld::RayResultCallback *_swig_go_5) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionShape **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btCollisionWorld::RayResultCallback **)&_swig_go_5; 
  
  btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
  
}


void _wrap_btDiscreteDynamicsWorld_rayTestSingleInternal_mbt_c1af402c8cb9fdfb(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_objectQuerySingle_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObject *_swig_go_3, btCollisionShape *_swig_go_4, btTransform *_swig_go_5, btCollisionWorld::ConvexResultCallback *_swig_go_6, float _swig_go_7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObject **)&_swig_go_3; 
  arg5 = *(btCollisionShape **)&_swig_go_4; 
  arg6 = *(btTransform **)&_swig_go_5; 
  arg7 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  
  btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
  
}


void _wrap_btDiscreteDynamicsWorld_objectQuerySingleInternal_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObjectWrapper *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObjectWrapper **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
  
}


void _wrap_btDiscreteDynamicsWorld_refreshBroadphaseProxy_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->refreshBroadphaseProxy(arg2);
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btDiscreteDynamicsWorld_getCollisionObjectArray__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btCollisionObjectArray *) &(swig_b1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btDiscreteDynamicsWorld_getCollisionObjectArray__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btCollisionObjectArray *) &((btCollisionWorld const *)swig_b1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_performDiscreteCollisionDetection_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->performDiscreteCollisionDetection();
  
}


btDispatcherInfo *_wrap_btDiscreteDynamicsWorld_getDispatchInfo__SWIG_0_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btDispatcherInfo *) &(swig_b1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btDispatcherInfo *_wrap_btDiscreteDynamicsWorld_getDispatchInfo__SWIG_1_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (btDispatcherInfo *) &((btCollisionWorld const *)swig_b1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btDiscreteDynamicsWorld_getForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  result = (bool)((btCollisionWorld const *)swig_b1)->getForceUpdateAllAabbs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setForceUpdateAllAabbs_mbt_c1af402c8cb9fdfb(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btDynamicsWorld *swig_b0 = (btDynamicsWorld *)arg1;
  btCollisionWorld *swig_b1 = (btCollisionWorld *)swig_b0;
  (swig_b1)->setForceUpdateAllAabbs(arg2);
  
}


void _wrap_delete_btTriangleCallback_mbt_c1af402c8cb9fdfb(btTriangleCallback *_swig_go_0) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  
  arg1 = *(btTriangleCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTriangleCallback_processTriangle_mbt_c1af402c8cb9fdfb(btTriangleCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btTriangleCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


void _wrap_delete_btInternalTriangleIndexCallback_mbt_c1af402c8cb9fdfb(btInternalTriangleIndexCallback *_swig_go_0) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  
  arg1 = *(btInternalTriangleIndexCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btInternalTriangleIndexCallback_internalProcessTriangleIndex_mbt_c1af402c8cb9fdfb(btInternalTriangleIndexCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btInternalTriangleIndexCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->internalProcessTriangleIndex(arg2,arg3,arg4);
  
}


void _wrap_btTriangleRaycastCallback_m_from_set_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_from = *arg2;
  
}


btVector3 *_wrap_btTriangleRaycastCallback_m_from_get_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_from);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleRaycastCallback_m_to_set_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_to = *arg2;
  
}


btVector3 *_wrap_btTriangleRaycastCallback_m_to_get_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_to);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


intgo _wrap_kF_None_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_None;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_FilterBackfaces_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_FilterBackfaces;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_KeepUnflippedNormal_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_KeepUnflippedNormal;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_UseSubSimplexConvexCastRaytest_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_UseSubSimplexConvexCastRaytest;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_UseGjkConvexCastRaytest_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_UseGjkConvexCastRaytest;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_DisableHeightfieldAccelerator_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_DisableHeightfieldAccelerator;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_kF_Terminator_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb() {
  btTriangleRaycastCallback::EFlags result;
  intgo _swig_go_result;
  
  
  result = btTriangleRaycastCallback::kF_Terminator;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btTriangleRaycastCallback_m_flags_set_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, intgo _swig_go_1) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  unsigned int arg2 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  
  if (arg1) (arg1)->m_flags = arg2;
  
}


intgo _wrap_btTriangleRaycastCallback_m_flags_get_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  
  result = (unsigned int) ((arg1)->m_flags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleRaycastCallback_m_hitFraction_set_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, float _swig_go_1) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


float _wrap_btTriangleRaycastCallback_m_hitFraction_get_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleRaycastCallback_processTriangle_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


float _wrap_btTriangleRaycastCallback_reportHit_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btScalar)(arg1)->reportHit((btVector3 const &)*arg2,arg3,arg4,arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleRaycastCallback_mbt_c1af402c8cb9fdfb(btTriangleRaycastCallback *_swig_go_0) {
  btTriangleRaycastCallback *arg1 = (btTriangleRaycastCallback *) 0 ;
  
  arg1 = *(btTriangleRaycastCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTriangleConvexcastCallback_m_convexShape_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btConvexShape *_swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexShape = (btConvexShape const *)arg2;
  
}


btConvexShape *_wrap_btTriangleConvexcastCallback_m_convexShape_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btConvexShape *result = 0 ;
  btConvexShape *_swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btConvexShape *) ((arg1)->m_convexShape);
  *(btConvexShape **)&_swig_go_result = (btConvexShape *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_convexShapeFrom_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btTransform *_swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexShapeFrom = *arg2;
  
}


btTransform *_wrap_btTriangleConvexcastCallback_m_convexShapeFrom_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexShapeFrom);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_convexShapeTo_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btTransform *_swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexShapeTo = *arg2;
  
}


btTransform *_wrap_btTriangleConvexcastCallback_m_convexShapeTo_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexShapeTo);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_triangleToWorld_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btTransform *_swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleToWorld = *arg2;
  
}


btTransform *_wrap_btTriangleConvexcastCallback_m_triangleToWorld_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_triangleToWorld);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_hitFraction_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, float _swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


float _wrap_btTriangleConvexcastCallback_m_hitFraction_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_triangleCollisionMargin_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, float _swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleCollisionMargin = arg2;
  
}


float _wrap_btTriangleConvexcastCallback_m_triangleCollisionMargin_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_triangleCollisionMargin);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_m_allowedPenetration_set_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, float _swig_go_1) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedPenetration = arg2;
  
}


float _wrap_btTriangleConvexcastCallback_m_allowedPenetration_get_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleConvexcastCallback_processTriangle_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


float _wrap_btTriangleConvexcastCallback_reportHit_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, intgo _swig_go_4, intgo _swig_go_5) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  int arg5 ;
  int arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  
  result = (btScalar)(arg1)->reportHit((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleConvexcastCallback_mbt_c1af402c8cb9fdfb(btTriangleConvexcastCallback *_swig_go_0) {
  btTriangleConvexcastCallback *arg1 = (btTriangleConvexcastCallback *) 0 ;
  
  arg1 = *(btTriangleConvexcastCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRotationalLimitMotor_m_loLimit_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_loLimit = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_loLimit_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_loLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_hiLimit_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_hiLimit = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_hiLimit_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_hiLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_targetVelocity_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_targetVelocity = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_targetVelocity_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_targetVelocity);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_maxMotorForce_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxMotorForce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_maxMotorForce_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxMotorForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_maxLimitForce_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxLimitForce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_maxLimitForce_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxLimitForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_damping_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_damping_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_limitSoftness_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_limitSoftness_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_normalCFM_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_normalCFM = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_normalCFM_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_normalCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_stopERP_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_stopERP = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_stopERP_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_stopERP);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_stopCFM_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_stopCFM = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_stopCFM_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_stopCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_bounce_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_bounce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_bounce_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_bounce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_enableMotor_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, bool _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_enableMotor = arg2;
  
}


bool _wrap_btRotationalLimitMotor_m_enableMotor_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_enableMotor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentLimitError_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimitError = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_currentLimitError_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_currentLimitError);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentPosition_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentPosition = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_currentPosition_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_currentPosition);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentLimit_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimit = arg2;
  
}


intgo _wrap_btRotationalLimitMotor_m_currentLimit_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_currentLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_accumulatedImpulse_set_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_accumulatedImpulse = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_accumulatedImpulse_get_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_accumulatedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  
  result = (btRotationalLimitMotor *)new btRotationalLimitMotor();
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_1_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = 0 ;
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btRotationalLimitMotor *)new btRotationalLimitMotor((btRotationalLimitMotor const &)*arg1);
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


bool _wrap_btRotationalLimitMotor_isLimited_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool)((btRotationalLimitMotor const *)arg1)->isLimited();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRotationalLimitMotor_needApplyTorques_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool)((btRotationalLimitMotor const *)arg1)->needApplyTorques();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRotationalLimitMotor_testLimitValue_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (int)(arg1)->testLimitValue(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRotationalLimitMotor_solveAngularLimits_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btRigidBody *_swig_go_4, btRigidBody *_swig_go_5) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btRigidBody *arg5 = (btRigidBody *) 0 ;
  btRigidBody *arg6 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btRigidBody **)&_swig_go_4; 
  arg6 = *(btRigidBody **)&_swig_go_5; 
  
  result = (btScalar)(arg1)->solveAngularLimits(arg2,*arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btRotationalLimitMotor_mbt_c1af402c8cb9fdfb(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTranslationalLimitMotor_m_lowerLimit_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_lowerLimit = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_lowerLimit_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_lowerLimit);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_upperLimit_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_upperLimit = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_upperLimit_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_upperLimit);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_accumulatedImpulse_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_accumulatedImpulse = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_accumulatedImpulse_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_accumulatedImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_limitSoftness_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_limitSoftness_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_damping_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_damping_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_restitution_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_restitution_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_normalCFM_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_normalCFM = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_normalCFM_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_normalCFM);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_stopERP_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_stopERP = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_stopERP_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_stopERP);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_stopCFM_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_stopCFM = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_stopCFM_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_stopCFM);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_enableMotor_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, bool *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *arg2 = (bool *) (bool *)0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(bool **)&_swig_go_1; 
  
  {
    size_t ii;
    bool *b = (bool *) arg1->m_enableMotor;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((bool *) arg2 + ii);
  }
  
}


bool *_wrap_btTranslationalLimitMotor_m_enableMotor_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *result = 0 ;
  bool *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (bool *)(bool *) ((arg1)->m_enableMotor);
  *(bool **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_targetVelocity_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_targetVelocity = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_targetVelocity_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_targetVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_maxMotorForce_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_maxMotorForce = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_maxMotorForce_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_maxMotorForce);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLimitError_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimitError = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_currentLimitError_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_currentLimitError);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLinearDiff_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLinearDiff = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_currentLinearDiff_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_currentLinearDiff);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLimit_set_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, intgo *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_currentLimit;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btTranslationalLimitMotor_m_currentLimit_get_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_currentLimit);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_0_mbt_c1af402c8cb9fdfb() {
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  
  result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor();
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_1_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = 0 ;
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor((btTranslationalLimitMotor const &)*arg1);
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


bool _wrap_btTranslationalLimitMotor_isLimited_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btTranslationalLimitMotor const *)arg1)->isLimited(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTranslationalLimitMotor_needApplyForce_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btTranslationalLimitMotor const *)arg1)->needApplyForce(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTranslationalLimitMotor_testLimitValue_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (int)(arg1)->testLimitValue(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTranslationalLimitMotor_solveLinearAxis_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1, float _swig_go_2, btRigidBody *_swig_go_3, btVector3 *_swig_go_4, btRigidBody *_swig_go_5, btVector3 *_swig_go_6, intgo _swig_go_7, btVector3 *_swig_go_8, btVector3 *_swig_go_9) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btRigidBody *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btRigidBody *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  int arg8 ;
  btVector3 *arg9 = 0 ;
  btVector3 *arg10 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btRigidBody **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btRigidBody **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = (int)_swig_go_7; 
  arg9 = *(btVector3 **)&_swig_go_8; 
  arg10 = *(btVector3 **)&_swig_go_9; 
  
  result = (btScalar)(arg1)->solveLinearAxis(arg2,arg3,*arg4,(btVector3 const &)*arg5,*arg6,(btVector3 const &)*arg7,arg8,(btVector3 const &)*arg9,(btVector3 const &)*arg10);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTranslationalLimitMotor_mbt_c1af402c8cb9fdfb(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_6DOF_FLAGS_CFM_NORM_mbt_c1af402c8cb9fdfb() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_CFM_NORM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_6DOF_FLAGS_CFM_STOP_mbt_c1af402c8cb9fdfb() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_CFM_STOP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_6DOF_FLAGS_ERP_STOP_mbt_c1af402c8cb9fdfb() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_ERP_STOP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
  
}


bool _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_useSolveConstraintObsolete);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btRigidBody *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, bool _swig_go_4) {
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofConstraint *result = 0 ;
  btGeneric6DofConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = (bool)_swig_go_4; 
  
  result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
  *(btGeneric6DofConstraint **)&_swig_go_result = (btGeneric6DofConstraint *)result; 
  return _swig_go_result;
}


btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1, bool _swig_go_2) {
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofConstraint *result = 0 ;
  btGeneric6DofConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,(btTransform const &)*arg2,arg3);
  *(btGeneric6DofConstraint **)&_swig_go_result = (btGeneric6DofConstraint *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->calculateTransforms();
  
}


btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformA_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformB_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_buildJacobian_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btGeneric6DofConstraint_getInfo1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo1NonVirtual_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1NonVirtual(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo2_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo2NonVirtual_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  
  (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8);
  
}


void _wrap_btGeneric6DofConstraint_updateRHS_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateRHS(arg2);
  
}


btVector3 *_wrap_btGeneric6DofConstraint_getAxis_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = ((btGeneric6DofConstraint const *)arg1)->getAxis(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getAngle_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getAngle(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getRelativePivotPosition_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getRelativePivotPosition(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setFrames_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


bool _wrap_btGeneric6DofConstraint_testAngularLimitMotor_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)(arg1)->testAngularLimitMotor(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setLinearLowerLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearLowerLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getLinearLowerLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getLinearLowerLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setLinearUpperLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearUpperLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getLinearUpperLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getLinearUpperLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setAngularLowerLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularLowerLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getAngularLowerLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getAngularLowerLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setAngularUpperLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularUpperLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getAngularUpperLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getAngularUpperLimit(*arg2);
  
}


btRotationalLimitMotor *_wrap_btGeneric6DofConstraint_getRotationalLimitMotor_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btRotationalLimitMotor *)(arg1)->getRotationalLimitMotor(arg2);
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_btGeneric6DofConstraint_getTranslationalLimitMotor_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTranslationalLimitMotor *)(arg1)->getTranslationalLimitMotor();
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setLimit_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setLimit(arg2,arg3,arg4);
  
}


bool _wrap_btGeneric6DofConstraint_isLimited_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->isLimited(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_calcAnchorPos_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->calcAnchorPos();
  
}


intgo _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btRotationalLimitMotor *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, btTypedConstraint::btConstraintInfo2 *_swig_go_8, intgo _swig_go_9, btVector3 *_swig_go_10, intgo _swig_go_11, intgo _swig_go_12) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int arg13 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btRotationalLimitMotor **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  arg11 = *(btVector3 **)&_swig_go_10; 
  arg12 = (int)_swig_go_11; 
  arg13 = (int)_swig_go_12; 
  
  result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12,arg13);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btRotationalLimitMotor *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, btTypedConstraint::btConstraintInfo2 *_swig_go_8, intgo _swig_go_9, btVector3 *_swig_go_10, intgo _swig_go_11) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btRotationalLimitMotor **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  arg11 = *(btVector3 **)&_swig_go_10; 
  arg12 = (int)_swig_go_11; 
  
  result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeneric6DofConstraint_getUseFrameOffset_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->getUseFrameOffset();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUseFrameOffset_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseFrameOffset(arg2);
  
}


bool _wrap_btGeneric6DofConstraint_getUseLinearReferenceFrameA_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->getUseLinearReferenceFrameA();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUseLinearReferenceFrameA_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseLinearReferenceFrameA(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setParam__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btGeneric6DofConstraint_setParam__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


float _wrap_btGeneric6DofConstraint_getParam__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getParam__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setAxis_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


intgo _wrap_btGeneric6DofConstraint_getFlags_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (int)((btGeneric6DofConstraint const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (int)((btGeneric6DofConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btGeneric6DofConstraint_serialize_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btGeneric6DofConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraint_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btGeneric6DofConstraint_getFixedBody_mbt_c1af402c8cb9fdfb() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setupSolverConstraint_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btAlignedObjectArray< btSolverConstraint > *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btGeneric6DofConstraint_internalSetAppliedImpulse_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btGeneric6DofConstraint_internalGetAppliedImpulse_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btGeneric6DofConstraint_isEnabled_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setEnabled_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setEnabled(arg2);
  
}


void _wrap_btGeneric6DofConstraint_solveConstraintObsolete_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyA__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &((btTypedConstraint const *)swig_b0)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyA__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &(swig_b0)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyB__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &((btTypedConstraint const *)swig_b0)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyB__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &(swig_b0)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getUserConstraintType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUserConstraintType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintType(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setUserConstraintId_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintId(arg2);
  
}


intgo _wrap_btGeneric6DofConstraint_getUserConstraintId_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUserConstraintPtr_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, void *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btGeneric6DofConstraint_getUserConstraintPtr_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (void *)(swig_b0)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setJointFeedback_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btGeneric6DofConstraint_getJointFeedback__SWIG_0_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)((btTypedConstraint const *)swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btGeneric6DofConstraint_getJointFeedback__SWIG_1_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)(swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getUid_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeneric6DofConstraint_needsFeedback_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_enableFeedback_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->enableFeedback(arg2);
  
}


float _wrap_btGeneric6DofConstraint_getAppliedImpulse_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getConstraintType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btTypedConstraintType)((btTypedConstraint const *)swig_b0)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setDbgDrawSize_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setDbgDrawSize(arg2);
  
}


float _wrap_btGeneric6DofConstraint_getDbgDrawSize_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtGeneric6DofConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  if (swig_b1) (swig_b1)->m_objectType = arg2;
  
}


intgo _wrap_GetbtGeneric6DofConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int) ((swig_b1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getObjectType_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int)((btTypedObject const *)swig_b1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_typeConstraintData_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btTypedConstraintData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTypedConstraintData *arg2 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintData *_wrap_btGeneric6DofConstraintData_m_typeConstraintData_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTypedConstraintData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_rbAFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformFloatData *_wrap_btGeneric6DofConstraintData_m_rbAFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbAFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_rbBFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformFloatData *_wrap_btGeneric6DofConstraintData_m_rbBFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbBFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_linearUpperLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearUpperLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_linearUpperLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearUpperLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_linearLowerLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearLowerLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_linearLowerLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearLowerLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_angularUpperLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularUpperLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_angularUpperLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularUpperLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_angularLowerLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularLowerLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_angularLowerLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularLowerLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_useLinearReferenceFrameA_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useLinearReferenceFrameA = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintData_m_useLinearReferenceFrameA_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useLinearReferenceFrameA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useOffsetForConstraintFrame = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useOffsetForConstraintFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraintData *_wrap_new_btGeneric6DofConstraintData_mbt_c1af402c8cb9fdfb() {
  btGeneric6DofConstraintData *result = 0 ;
  btGeneric6DofConstraintData *_swig_go_result;
  
  
  result = (btGeneric6DofConstraintData *)new btGeneric6DofConstraintData();
  *(btGeneric6DofConstraintData **)&_swig_go_result = (btGeneric6DofConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraintData_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_typeConstraintData_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTypedConstraintDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTypedConstraintDoubleData *arg2 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTypedConstraintDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_typeConstraintData_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTypedConstraintDoubleData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_rbAFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_rbAFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbAFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_rbBFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_rbBFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbBFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_linearUpperLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearUpperLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_linearUpperLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearUpperLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_linearLowerLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearLowerLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_linearLowerLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearLowerLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_angularUpperLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularUpperLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_angularUpperLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularUpperLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_angularLowerLimit_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularLowerLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_angularLowerLimit_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularLowerLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_useLinearReferenceFrameA_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useLinearReferenceFrameA = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintDoubleData2_m_useLinearReferenceFrameA_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useLinearReferenceFrameA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_useOffsetForConstraintFrame_set_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useOffsetForConstraintFrame = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintDoubleData2_m_useOffsetForConstraintFrame_get_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useOffsetForConstraintFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraintDoubleData2 *_wrap_new_btGeneric6DofConstraintDoubleData2_mbt_c1af402c8cb9fdfb() {
  btGeneric6DofConstraintDoubleData2 *result = 0 ;
  btGeneric6DofConstraintDoubleData2 *_swig_go_result;
  
  
  result = (btGeneric6DofConstraintDoubleData2 *)new btGeneric6DofConstraintDoubleData2();
  *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_result = (btGeneric6DofConstraintDoubleData2 *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraintDoubleData2_mbt_c1af402c8cb9fdfb(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_CONETWIST_FLAGS_LIN_CFM_mbt_c1af402c8cb9fdfb() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_LIN_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONETWIST_FLAGS_LIN_ERP_mbt_c1af402c8cb9fdfb() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_LIN_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONETWIST_FLAGS_ANG_CFM_mbt_c1af402c8cb9fdfb() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_ANG_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_0_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btRigidBody *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3) {
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btConeTwistConstraint *result = 0 ;
  btConeTwistConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  
  result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
  *(btConeTwistConstraint **)&_swig_go_result = (btConeTwistConstraint *)result; 
  return _swig_go_result;
}


btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_1_mbt_c1af402c8cb9fdfb(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btConeTwistConstraint *result = 0 ;
  btConeTwistConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,(btTransform const &)*arg2);
  *(btConeTwistConstraint **)&_swig_go_result = (btConeTwistConstraint *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_buildJacobian_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btConeTwistConstraint_getInfo1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo1NonVirtual_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1NonVirtual(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo2_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo2NonVirtual_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btMatrix3x3 *_swig_go_4, btMatrix3x3 *_swig_go_5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  btMatrix3x3 *arg6 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  arg6 = *(btMatrix3x3 **)&_swig_go_5; 
  
  (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btMatrix3x3 const &)*arg5,(btMatrix3x3 const &)*arg6);
  
}


void _wrap_btConeTwistConstraint_solveConstraintObsolete_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


void _wrap_btConeTwistConstraint_updateRHS_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateRHS(arg2);
  
}


btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyA_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyB_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setAngularOnly_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setAngularOnly(arg2);
  
}


bool _wrap_btConeTwistConstraint_getAngularOnly_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->getAngularOnly();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_0_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setLimit(arg2,arg3);
  
}


float _wrap_btConeTwistConstraint_getLimit_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getLimit(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6,arg7);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_2_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_3_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_4_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setLimit(arg2,arg3,arg4);
  
}


btTransform *_wrap_btConeTwistConstraint_getAFrame_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getAFrame();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btConeTwistConstraint_getBFrame_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getBFrame();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getSolveTwistLimit_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)(arg1)->getSolveTwistLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getSolveSwingLimit_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)(arg1)->getSolveSwingLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistLimitSign_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getTwistLimitSign();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_calcAngleInfo_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  (arg1)->calcAngleInfo();
  
}


void _wrap_btConeTwistConstraint_calcAngleInfo2_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btMatrix3x3 *_swig_go_3, btMatrix3x3 *_swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btMatrix3x3 **)&_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  
  (arg1)->calcAngleInfo2((btTransform const &)*arg2,(btTransform const &)*arg3,(btMatrix3x3 const &)*arg4,(btMatrix3x3 const &)*arg5);
  
}


float _wrap_btConeTwistConstraint_getSwingSpan1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getSwingSpan1();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getSwingSpan2_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getSwingSpan2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistSpan_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getTwistSpan();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getLimitSoftness_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getLimitSoftness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getBiasFactor_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getBiasFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getRelaxationFactor_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getRelaxationFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistAngle_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getTwistAngle();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_isPastSwingLimit_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)(arg1)->isPastSwingLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getDamping_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setDamping_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDamping(arg2);
  
}


void _wrap_btConeTwistConstraint_enableMotor_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->enableMotor(arg2);
  
}


bool _wrap_btConeTwistConstraint_isMotorEnabled_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->isMotorEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getMaxMotorImpulse_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getMaxMotorImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_isMaxMotorImpulseNormalized_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->isMaxMotorImpulseNormalized();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setMaxMotorImpulse_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMaxMotorImpulse(arg2);
  
}


void _wrap_btConeTwistConstraint_setMaxMotorImpulseNormalized_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMaxMotorImpulseNormalized(arg2);
  
}


float _wrap_btConeTwistConstraint_getFixThresh_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getFixThresh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setFixThresh_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setFixThresh(arg2);
  
}


void _wrap_btConeTwistConstraint_setMotorTarget_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btQuaternion *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setMotorTarget((btQuaternion const &)*arg2);
  
}


btQuaternion *_wrap_btConeTwistConstraint_getMotorTarget_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btQuaternion *) &((btConeTwistConstraint const *)arg1)->getMotorTarget();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setMotorTargetInConstraintSpace_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btQuaternion *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setMotorTargetInConstraintSpace((btQuaternion const &)*arg2);
  
}


btVector3 *_wrap_btConeTwistConstraint_GetPointForAngle_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = ((btConeTwistConstraint const *)arg1)->GetPointForAngle(arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setParam__SWIG_0_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btConeTwistConstraint_setParam__SWIG_1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


void _wrap_btConeTwistConstraint_setFrames_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


btTransform *_wrap_btConeTwistConstraint_getFrameOffsetA_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btConeTwistConstraint_getFrameOffsetB_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getParam__SWIG_0_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getParam__SWIG_1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getFlags_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)((btConeTwistConstraint const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)((btConeTwistConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConeTwistConstraint_serialize_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btConeTwistConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraint_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btConeTwistConstraint_getFixedBody_mbt_c1af402c8cb9fdfb() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setOverrideNumSolverIterations_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btConeTwistConstraint_setupSolverConstraint_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btAlignedObjectArray< btSolverConstraint > *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btConeTwistConstraint_internalSetAppliedImpulse_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btConeTwistConstraint_internalGetAppliedImpulse_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setBreakingImpulseThreshold_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btConeTwistConstraint_isEnabled_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setEnabled_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setEnabled(arg2);
  
}


intgo _wrap_btConeTwistConstraint_getUserConstraintType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setUserConstraintType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintType(arg2);
  
}


void _wrap_btConeTwistConstraint_setUserConstraintId_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintId(arg2);
  
}


intgo _wrap_btConeTwistConstraint_getUserConstraintId_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setUserConstraintPtr_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, void *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btConeTwistConstraint_getUserConstraintPtr_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (void *)(swig_b0)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setJointFeedback_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btConeTwistConstraint_getJointFeedback__SWIG_0_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)((btTypedConstraint const *)swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btConeTwistConstraint_getJointFeedback__SWIG_1_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)(swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getUid_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_needsFeedback_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_enableFeedback_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->enableFeedback(arg2);
  
}


float _wrap_btConeTwistConstraint_getAppliedImpulse_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getConstraintType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btTypedConstraintType)((btTypedConstraint const *)swig_b0)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setDbgDrawSize_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setDbgDrawSize(arg2);
  
}


float _wrap_btConeTwistConstraint_getDbgDrawSize_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtConeTwistConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  if (swig_b1) (swig_b1)->m_objectType = arg2;
  
}


intgo _wrap_GetbtConeTwistConstraint_M_objectType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int) ((swig_b1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getObjectType_mbt_c1af402c8cb9fdfb(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int)((btTypedObject const *)swig_b1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_typeConstraintData_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, btTypedConstraintDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTypedConstraintDoubleData *arg2 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintDoubleData *_wrap_btConeTwistConstraintDoubleData_m_typeConstraintData_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTypedConstraintDoubleData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_rbAFrame_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btConeTwistConstraintDoubleData_m_rbAFrame_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbAFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_rbBFrame_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btConeTwistConstraintDoubleData_m_rbBFrame_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbBFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_swingSpan1_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan1 = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_swingSpan1_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_swingSpan1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_swingSpan2_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan2 = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_swingSpan2_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_swingSpan2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_twistSpan_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_twistSpan = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_twistSpan_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_twistSpan);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_limitSoftness_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_limitSoftness_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_biasFactor_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_biasFactor = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_biasFactor_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_biasFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_relaxationFactor_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_relaxationFactor = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_relaxationFactor_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_relaxationFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_damping_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_damping_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConeTwistConstraintDoubleData *_wrap_new_btConeTwistConstraintDoubleData_mbt_c1af402c8cb9fdfb() {
  btConeTwistConstraintDoubleData *result = 0 ;
  btConeTwistConstraintDoubleData *_swig_go_result;
  
  
  result = (btConeTwistConstraintDoubleData *)new btConeTwistConstraintDoubleData();
  *(btConeTwistConstraintDoubleData **)&_swig_go_result = (btConeTwistConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraintDoubleData_mbt_c1af402c8cb9fdfb(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConeTwistConstraintData_m_typeConstraintData_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, btTypedConstraintData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTypedConstraintData *arg2 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintData *_wrap_btConeTwistConstraintData_m_typeConstraintData_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTypedConstraintData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_rbAFrame_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformFloatData *_wrap_btConeTwistConstraintData_m_rbAFrame_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbAFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_rbBFrame_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformFloatData *_wrap_btConeTwistConstraintData_m_rbBFrame_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbBFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_swingSpan1_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan1 = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_swingSpan1_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_swingSpan1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_swingSpan2_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan2 = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_swingSpan2_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_swingSpan2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_twistSpan_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_twistSpan = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_twistSpan_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_twistSpan);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_limitSoftness_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_limitSoftness_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_biasFactor_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_biasFactor = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_biasFactor_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_biasFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_relaxationFactor_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_relaxationFactor = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_relaxationFactor_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_relaxationFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_damping_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_damping_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_pad_set_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0, _gostring_ _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 4-1);
      arg1->m_pad[4-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btConeTwistConstraintData_m_pad_get_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btConeTwistConstraintData *_wrap_new_btConeTwistConstraintData_mbt_c1af402c8cb9fdfb() {
  btConeTwistConstraintData *result = 0 ;
  btConeTwistConstraintData *_swig_go_result;
  
  
  result = (btConeTwistConstraintData *)new btConeTwistConstraintData();
  *(btConeTwistConstraintData **)&_swig_go_result = (btConeTwistConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraintData_mbt_c1af402c8cb9fdfb(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btElement_m_id_set_mbt_c1af402c8cb9fdfb(btElement *_swig_go_0, intgo _swig_go_1) {
  btElement *arg1 = (btElement *) 0 ;
  int arg2 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_id = arg2;
  
}


intgo _wrap_btElement_m_id_get_mbt_c1af402c8cb9fdfb(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_id);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btElement_m_sz_set_mbt_c1af402c8cb9fdfb(btElement *_swig_go_0, intgo _swig_go_1) {
  btElement *arg1 = (btElement *) 0 ;
  int arg2 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_sz = arg2;
  
}


intgo _wrap_btElement_m_sz_get_mbt_c1af402c8cb9fdfb(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_sz);
  _swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_new_btElement_mbt_c1af402c8cb9fdfb() {
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  
  result = (btElement *)new btElement();
  *(btElement **)&_swig_go_result = (btElement *)result; 
  return _swig_go_result;
}


void _wrap_delete_btElement_mbt_c1af402c8cb9fdfb(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  delete arg1;
  
}


btUnionFind *_wrap_new_btUnionFind_mbt_c1af402c8cb9fdfb() {
  btUnionFind *result = 0 ;
  btUnionFind *_swig_go_result;
  
  
  result = (btUnionFind *)new btUnionFind();
  *(btUnionFind **)&_swig_go_result = (btUnionFind *)result; 
  return _swig_go_result;
}


void _wrap_delete_btUnionFind_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btUnionFind_sortIslands_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  (arg1)->sortIslands();
  
}


void _wrap_btUnionFind_reset_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->reset(arg2);
  
}


intgo _wrap_btUnionFind_getNumElements_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  result = (int)((btUnionFind const *)arg1)->getNumElements();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btUnionFind_isRoot_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btUnionFind const *)arg1)->isRoot(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_btUnionFind_getElement__SWIG_0_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btElement *) &(arg1)->getElement(arg2);
  *(btElement **)&_swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_btUnionFind_getElement__SWIG_1_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btElement *) &((btUnionFind const *)arg1)->getElement(arg2);
  *(btElement **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUnionFind_allocate_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->allocate(arg2);
  
}


void _wrap_btUnionFind_Free_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  (arg1)->Free();
  
}


intgo _wrap_btUnionFind_find__SWIG_0_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)(arg1)->find(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUnionFind_unite_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->unite(arg2,arg3);
  
}


intgo _wrap_btUnionFind_find__SWIG_1_mbt_c1af402c8cb9fdfb(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (int)(arg1)->find(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btSimulationIslandManager *_wrap_new_btSimulationIslandManager_mbt_c1af402c8cb9fdfb() {
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  
  result = (btSimulationIslandManager *)new btSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSimulationIslandManager_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSimulationIslandManager_initUnionFind_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, intgo _swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  int arg2 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->initUnionFind(arg2);
  
}


btUnionFind *_wrap_btSimulationIslandManager_getUnionFind_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btUnionFind *result = 0 ;
  btUnionFind *_swig_go_result;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  result = (btUnionFind *) &(arg1)->getUnionFind();
  *(btUnionFind **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSimulationIslandManager_updateActivationState_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btCollisionWorld *_swig_go_1, btDispatcher *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->updateActivationState(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_storeIslandActivationState_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  (arg1)->storeIslandActivationState(arg2);
  
}


void _wrap_btSimulationIslandManager_findUnions_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  
  (arg1)->findUnions(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_buildAndProcessIslands_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2, btSimulationIslandManager::IslandCallback *_swig_go_3) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btSimulationIslandManager::IslandCallback *arg4 = (btSimulationIslandManager::IslandCallback *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btSimulationIslandManager::IslandCallback **)&_swig_go_3; 
  
  (arg1)->buildAndProcessIslands(arg2,arg3,arg4);
  
}


void _wrap_btSimulationIslandManager_buildIslands_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  
  (arg1)->buildIslands(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_processIslands_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2, btSimulationIslandManager::IslandCallback *_swig_go_3) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btSimulationIslandManager::IslandCallback *arg4 = (btSimulationIslandManager::IslandCallback *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btSimulationIslandManager::IslandCallback **)&_swig_go_3; 
  
  (arg1)->processIslands(arg2,arg3,arg4);
  
}


bool _wrap_btSimulationIslandManager_getSplitIslands_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  result = (bool)(arg1)->getSplitIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSimulationIslandManager_setSplitIslands_mbt_c1af402c8cb9fdfb(btSimulationIslandManager *_swig_go_0, bool _swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  bool arg2 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setSplitIslands(arg2);
  
}


intgo _wrap_BT_SEQUENTIAL_IMPULSE_SOLVER_mbt_c1af402c8cb9fdfb() {
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  
  result = BT_SEQUENTIAL_IMPULSE_SOLVER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_MLCP_SOLVER_mbt_c1af402c8cb9fdfb() {
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  
  result = BT_MLCP_SOLVER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_NNCG_SOLVER_mbt_c1af402c8cb9fdfb() {
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  
  result = BT_NNCG_SOLVER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_MULTIBODY_SOLVER_mbt_c1af402c8cb9fdfb() {
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  
  result = BT_MULTIBODY_SOLVER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_BLOCK_SOLVER_mbt_c1af402c8cb9fdfb() {
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  
  result = BT_BLOCK_SOLVER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btConstraintSolver_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConstraintSolver_prepareSolve_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->prepareSolve(arg2,arg3);
  
}


float _wrap_btConstraintSolver_solveGroup_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0, btCollisionObject **_swig_go_1, intgo _swig_go_2, btPersistentManifold **_swig_go_3, intgo _swig_go_4, btTypedConstraint **_swig_go_5, intgo _swig_go_6, btContactSolverInfo *_swig_go_7, btIDebugDraw *_swig_go_8, btDispatcher *_swig_go_9) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  arg2 = *(btCollisionObject ***)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btPersistentManifold ***)&_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = *(btTypedConstraint ***)&_swig_go_5; 
  arg7 = (int)_swig_go_6; 
  arg8 = *(btContactSolverInfo **)&_swig_go_7; 
  arg9 = *(btIDebugDraw **)&_swig_go_8; 
  arg10 = *(btDispatcher **)&_swig_go_9; 
  
  result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConstraintSolver_allSolved_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0, btContactSolverInfo *_swig_go_1, btIDebugDraw *_swig_go_2) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  btIDebugDraw *arg3 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  arg3 = *(btIDebugDraw **)&_swig_go_2; 
  
  (arg1)->allSolved((btContactSolverInfo const &)*arg2,arg3);
  
}


void _wrap_btConstraintSolver_reset_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  
  (arg1)->reset();
  
}


intgo _wrap_btConstraintSolver_getSolverType_mbt_c1af402c8cb9fdfb(btConstraintSolver *_swig_go_0) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btConstraintSolverType result;
  intgo _swig_go_result;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  
  result = (btConstraintSolverType)((btConstraintSolver const *)arg1)->getSolverType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_NoDebug_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_NoDebug;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawWireframe_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawWireframe;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawAabb_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawAabb;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawFeaturesText_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawFeaturesText;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawContactPoints_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawContactPoints;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_NoDeactivation_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_NoDeactivation;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_NoHelpText_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_NoHelpText;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawText_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawText;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_ProfileTimings_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_ProfileTimings;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_EnableSatComparison_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_EnableSatComparison;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DisableBulletLCP_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DisableBulletLCP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_EnableCCD_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_EnableCCD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawConstraints_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawConstraints;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawConstraintLimits_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawConstraintLimits;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_FastWireframe_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_FastWireframe;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawNormals_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawNormals;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_DrawFrames_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_DrawFrames;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DBG_MAX_DEBUG_DRAW_MODE_btIDebugDraw_mbt_c1af402c8cb9fdfb() {
  btIDebugDraw::DebugDrawModes result;
  intgo _swig_go_result;
  
  
  result = btIDebugDraw::DBG_MAX_DEBUG_DRAW_MODE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btIDebugDraw_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  delete arg1;
  
}


btIDebugDraw::DefaultColors *_wrap_btIDebugDraw_getDefaultColors_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btIDebugDraw::DefaultColors result;
  btIDebugDraw::DefaultColors *_swig_go_result;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  result = ((btIDebugDraw const *)arg1)->getDefaultColors();
  *(btIDebugDraw::DefaultColors **)&_swig_go_result = new btIDebugDraw::DefaultColors(result); 
  return _swig_go_result;
}


void _wrap_btIDebugDraw_setDefaultColors_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btIDebugDraw::DefaultColors *_swig_go_1) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btIDebugDraw::DefaultColors *arg2 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btIDebugDraw::DefaultColors **)&_swig_go_1; 
  
  (arg1)->setDefaultColors((btIDebugDraw::DefaultColors const &)*arg2);
  
}


void _wrap_btIDebugDraw_drawLine__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->drawLine((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btIDebugDraw_drawLine__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  (arg1)->drawLine((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  
}


void _wrap_btIDebugDraw_drawSphere__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2, btVector3 *_swig_go_3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->drawSphere(arg2,(btTransform const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btIDebugDraw_drawSphere__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btVector3 *_swig_go_3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->drawSphere((btVector3 const &)*arg2,arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btIDebugDraw_drawTriangle__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, float _swig_go_8) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btScalar arg9 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  
  (arg1)->drawTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9);
  
}


void _wrap_btIDebugDraw_drawTriangle__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, float _swig_go_5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->drawTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
  
}


void _wrap_btIDebugDraw_drawContactPoint_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, intgo _swig_go_4, btVector3 *_swig_go_5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  int arg5 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->drawContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btIDebugDraw_reportErrorWarning_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, _gostring_ _swig_go_1) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  (arg1)->reportErrorWarning((char const *)arg2);
  
  free(arg2); 
}


void _wrap_btIDebugDraw_draw3dText_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, _gostring_ _swig_go_2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  
  (arg1)->draw3dText((btVector3 const &)*arg2,(char const *)arg3);
  
  free(arg3); 
}


void _wrap_btIDebugDraw_setDebugMode_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, intgo _swig_go_1) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  int arg2 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setDebugMode(arg2);
  
}


intgo _wrap_btIDebugDraw_getDebugMode_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  result = (int)((btIDebugDraw const *)arg1)->getDebugMode();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btIDebugDraw_drawAabb_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->drawAabb((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btIDebugDraw_drawTransform_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btTransform *_swig_go_1, float _swig_go_2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btTransform *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->drawTransform((btTransform const &)*arg2,arg3);
  
}


void _wrap_btIDebugDraw_drawArc__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, btVector3 *_swig_go_8, bool _swig_go_9, float _swig_go_10) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btVector3 *arg9 = 0 ;
  bool arg10 ;
  btScalar arg11 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  arg9 = *(btVector3 **)&_swig_go_8; 
  arg10 = (bool)_swig_go_9; 
  arg11 = (btScalar)_swig_go_10; 
  
  (arg1)->drawArc((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,(btVector3 const &)*arg9,arg10,arg11);
  
}


void _wrap_btIDebugDraw_drawArc__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, btVector3 *_swig_go_8, bool _swig_go_9) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btVector3 *arg9 = 0 ;
  bool arg10 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  arg9 = *(btVector3 **)&_swig_go_8; 
  arg10 = (bool)_swig_go_9; 
  
  (arg1)->drawArc((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,(btVector3 const &)*arg9,arg10);
  
}


void _wrap_btIDebugDraw_drawSpherePatch__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, btVector3 *_swig_go_9, float _swig_go_10, bool _swig_go_11) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  btScalar arg11 ;
  bool arg12 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  arg10 = *(btVector3 **)&_swig_go_9; 
  arg11 = (btScalar)_swig_go_10; 
  arg12 = (bool)_swig_go_11; 
  
  (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10,arg11,arg12);
  
}


void _wrap_btIDebugDraw_drawSpherePatch__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, btVector3 *_swig_go_9, float _swig_go_10) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  btScalar arg11 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  arg10 = *(btVector3 **)&_swig_go_9; 
  arg11 = (btScalar)_swig_go_10; 
  
  (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10,arg11);
  
}


void _wrap_btIDebugDraw_drawSpherePatch__SWIG_2_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, btVector3 *_swig_go_9) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  btScalar arg8 ;
  btScalar arg9 ;
  btVector3 *arg10 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  arg9 = (btScalar)_swig_go_8; 
  arg10 = *(btVector3 **)&_swig_go_9; 
  
  (arg1)->drawSpherePatch((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,arg6,arg7,arg8,arg9,(btVector3 const &)*arg10);
  
}


void _wrap_btIDebugDraw_drawBox__SWIG_0_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->drawBox((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btIDebugDraw_drawBox__SWIG_1_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  (arg1)->drawBox((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5);
  
}


void _wrap_btIDebugDraw_drawCapsule_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, float _swig_go_1, float _swig_go_2, intgo _swig_go_3, btTransform *_swig_go_4, btVector3 *_swig_go_5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->drawCapsule(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btIDebugDraw_drawCylinder_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, float _swig_go_1, float _swig_go_2, intgo _swig_go_3, btTransform *_swig_go_4, btVector3 *_swig_go_5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->drawCylinder(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btIDebugDraw_drawCone_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, float _swig_go_1, float _swig_go_2, intgo _swig_go_3, btTransform *_swig_go_4, btVector3 *_swig_go_5) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  int arg4 ;
  btTransform *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->drawCone(arg2,arg3,arg4,(btTransform const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btIDebugDraw_drawPlane_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  (arg1)->drawPlane((btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5);
  
}


void _wrap_btIDebugDraw_clearLines_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  (arg1)->clearLines();
  
}


void _wrap_btIDebugDraw_flushLines_mbt_c1af402c8cb9fdfb(btIDebugDraw *_swig_go_0) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  
  (arg1)->flushLines();
  
}


void _wrap_delete_btConvexCast_mbt_c1af402c8cb9fdfb(btConvexCast *_swig_go_0) {
  btConvexCast *arg1 = (btConvexCast *) 0 ;
  
  arg1 = *(btConvexCast **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btConvexCast_calcTimeOfImpact_mbt_c1af402c8cb9fdfb(btConvexCast *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4, btConvexCast::CastResult *_swig_go_5) {
  btConvexCast *arg1 = (btConvexCast *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  btConvexCast::CastResult *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexCast **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btConvexCast::CastResult **)&_swig_go_5; 
  
  result = (bool)(arg1)->calcTimeOfImpact((btTransform const &)*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btTransform const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btUsageBitfield *_wrap_new_btUsageBitfield_mbt_c1af402c8cb9fdfb() {
  btUsageBitfield *result = 0 ;
  btUsageBitfield *_swig_go_result;
  
  
  result = (btUsageBitfield *)new btUsageBitfield();
  *(btUsageBitfield **)&_swig_go_result = (btUsageBitfield *)result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_reset_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  (arg1)->reset();
  
}


void _wrap_btUsageBitfield_usedVertexA_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->usedVertexA = arg2;
  
}


short _wrap_btUsageBitfield_usedVertexA_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->usedVertexA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_usedVertexB_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->usedVertexB = arg2;
  
}


short _wrap_btUsageBitfield_usedVertexB_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->usedVertexB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_usedVertexC_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->usedVertexC = arg2;
  
}


short _wrap_btUsageBitfield_usedVertexC_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->usedVertexC);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_usedVertexD_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->usedVertexD = arg2;
  
}


short _wrap_btUsageBitfield_usedVertexD_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->usedVertexD);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_unused1_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->unused1 = arg2;
  
}


short _wrap_btUsageBitfield_unused1_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->unused1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_unused2_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->unused2 = arg2;
  
}


short _wrap_btUsageBitfield_unused2_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->unused2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_unused3_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->unused3 = arg2;
  
}


short _wrap_btUsageBitfield_unused3_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->unused3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUsageBitfield_unused4_set_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0, short _swig_go_1) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short arg2 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  arg2 = (unsigned short)_swig_go_1; 
  
  if (arg1) (arg1)->unused4 = arg2;
  
}


short _wrap_btUsageBitfield_unused4_get_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  result = (unsigned short) ((arg1)->unused4);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btUsageBitfield_mbt_c1af402c8cb9fdfb(btUsageBitfield *_swig_go_0) {
  btUsageBitfield *arg1 = (btUsageBitfield *) 0 ;
  
  arg1 = *(btUsageBitfield **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSubSimplexClosestResult_m_closestPointOnSimplex_set_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, btVector3 *_swig_go_1) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_closestPointOnSimplex = *arg2;
  
}


btVector3 *_wrap_btSubSimplexClosestResult_m_closestPointOnSimplex_get_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_closestPointOnSimplex);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSubSimplexClosestResult_m_usedVertices_set_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, btUsageBitfield *_swig_go_1) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btUsageBitfield *arg2 = (btUsageBitfield *) 0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = *(btUsageBitfield **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_usedVertices = *arg2;
  
}


btUsageBitfield *_wrap_btSubSimplexClosestResult_m_usedVertices_get_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btUsageBitfield *result = 0 ;
  btUsageBitfield *_swig_go_result;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  result = (btUsageBitfield *)& ((arg1)->m_usedVertices);
  *(btUsageBitfield **)&_swig_go_result = (btUsageBitfield *)result; 
  return _swig_go_result;
}


void _wrap_btSubSimplexClosestResult_m_barycentricCoords_set_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, float *_swig_go_1) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_barycentricCoords;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btSubSimplexClosestResult_m_barycentricCoords_get_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_barycentricCoords);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSubSimplexClosestResult_m_degenerate_set_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, bool _swig_go_1) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  bool arg2 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_degenerate = arg2;
  
}


bool _wrap_btSubSimplexClosestResult_m_degenerate_get_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_degenerate);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSubSimplexClosestResult_reset_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  (arg1)->reset();
  
}


bool _wrap_btSubSimplexClosestResult_isValid_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  result = (bool)(arg1)->isValid();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSubSimplexClosestResult_setBarycentricCoordinates__SWIG_0_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setBarycentricCoordinates(arg2,arg3,arg4,arg5);
  
}


void _wrap_btSubSimplexClosestResult_setBarycentricCoordinates__SWIG_1_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setBarycentricCoordinates(arg2,arg3,arg4);
  
}


void _wrap_btSubSimplexClosestResult_setBarycentricCoordinates__SWIG_2_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setBarycentricCoordinates(arg2,arg3);
  
}


void _wrap_btSubSimplexClosestResult_setBarycentricCoordinates__SWIG_3_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0, float _swig_go_1) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setBarycentricCoordinates(arg2);
  
}


void _wrap_btSubSimplexClosestResult_setBarycentricCoordinates__SWIG_4_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  (arg1)->setBarycentricCoordinates();
  
}


btSubSimplexClosestResult *_wrap_new_btSubSimplexClosestResult_mbt_c1af402c8cb9fdfb() {
  btSubSimplexClosestResult *result = 0 ;
  btSubSimplexClosestResult *_swig_go_result;
  
  
  result = (btSubSimplexClosestResult *)new btSubSimplexClosestResult();
  *(btSubSimplexClosestResult **)&_swig_go_result = (btSubSimplexClosestResult *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSubSimplexClosestResult_mbt_c1af402c8cb9fdfb(btSubSimplexClosestResult *_swig_go_0) {
  btSubSimplexClosestResult *arg1 = (btSubSimplexClosestResult *) 0 ;
  
  arg1 = *(btSubSimplexClosestResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btVoronoiSimplexSolver_m_numVertices_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, intgo _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  int arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numVertices = arg2;
  
}


intgo _wrap_btVoronoiSimplexSolver_m_numVertices_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numVertices);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_simplexVectorW_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 (*_swig_go_1)[5]) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) (btVector3 *)0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3 *b = (btVector3 *) arg1->m_simplexVectorW;
    for (ii = 0; ii < (size_t)5; ii++) b[ii] = *((btVector3 *) arg2 + ii);
  }
  
}


btVector3 (*_wrap_btVoronoiSimplexSolver_m_simplexVectorW_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0))[5] {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 (*_swig_go_result)[5];
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)(btVector3 *) ((arg1)->m_simplexVectorW);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_simplexPointsP_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 (*_swig_go_1)[5]) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) (btVector3 *)0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3 *b = (btVector3 *) arg1->m_simplexPointsP;
    for (ii = 0; ii < (size_t)5; ii++) b[ii] = *((btVector3 *) arg2 + ii);
  }
  
}


btVector3 (*_wrap_btVoronoiSimplexSolver_m_simplexPointsP_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0))[5] {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 (*_swig_go_result)[5];
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)(btVector3 *) ((arg1)->m_simplexPointsP);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_simplexPointsQ_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 (*_swig_go_1)[5]) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) (btVector3 *)0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3 *b = (btVector3 *) arg1->m_simplexPointsQ;
    for (ii = 0; ii < (size_t)5; ii++) b[ii] = *((btVector3 *) arg2 + ii);
  }
  
}


btVector3 (*_wrap_btVoronoiSimplexSolver_m_simplexPointsQ_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0))[5] {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 (*_swig_go_result)[5];
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)(btVector3 *) ((arg1)->m_simplexPointsQ);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_cachedP1_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_cachedP1 = *arg2;
  
}


btVector3 *_wrap_btVoronoiSimplexSolver_m_cachedP1_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_cachedP1);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_cachedP2_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_cachedP2 = *arg2;
  
}


btVector3 *_wrap_btVoronoiSimplexSolver_m_cachedP2_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_cachedP2);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_cachedV_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_cachedV = *arg2;
  
}


btVector3 *_wrap_btVoronoiSimplexSolver_m_cachedV_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_cachedV);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_lastW_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_lastW = *arg2;
  
}


btVector3 *_wrap_btVoronoiSimplexSolver_m_lastW_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_lastW);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_equalVertexThreshold_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, float _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_equalVertexThreshold = arg2;
  
}


float _wrap_btVoronoiSimplexSolver_m_equalVertexThreshold_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_equalVertexThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_cachedValidClosest_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, bool _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_cachedValidClosest = arg2;
  
}


bool _wrap_btVoronoiSimplexSolver_m_cachedValidClosest_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_cachedValidClosest);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_cachedBC_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btSubSimplexClosestResult *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btSubSimplexClosestResult *arg2 = (btSubSimplexClosestResult *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btSubSimplexClosestResult **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_cachedBC = *arg2;
  
}


btSubSimplexClosestResult *_wrap_btVoronoiSimplexSolver_m_cachedBC_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btSubSimplexClosestResult *result = 0 ;
  btSubSimplexClosestResult *_swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btSubSimplexClosestResult *)& ((arg1)->m_cachedBC);
  *(btSubSimplexClosestResult **)&_swig_go_result = (btSubSimplexClosestResult *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_m_needsUpdate_set_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, bool _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsUpdate = arg2;
  
}


bool _wrap_btVoronoiSimplexSolver_m_needsUpdate_get_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_needsUpdate);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_removeVertex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, intgo _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  int arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->removeVertex(arg2);
  
}


void _wrap_btVoronoiSimplexSolver_reduceVertices_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btUsageBitfield *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btUsageBitfield *arg2 = 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btUsageBitfield **)&_swig_go_1; 
  
  (arg1)->reduceVertices((btUsageBitfield const &)*arg2);
  
}


bool _wrap_btVoronoiSimplexSolver_updateClosestVectorAndPoints_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (bool)(arg1)->updateClosestVectorAndPoints();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVoronoiSimplexSolver_closestPtPointTetrahedron_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btSubSimplexClosestResult *_swig_go_6) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btSubSimplexClosestResult *arg7 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btSubSimplexClosestResult **)&_swig_go_6; 
  
  result = (bool)(arg1)->closestPtPointTetrahedron((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,*arg7);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVoronoiSimplexSolver_pointOutsideOfPlane_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  result = (int)(arg1)->pointOutsideOfPlane((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVoronoiSimplexSolver_closestPtPointTriangle_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btSubSimplexClosestResult *_swig_go_5) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btSubSimplexClosestResult *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btSubSimplexClosestResult **)&_swig_go_5; 
  
  result = (bool)(arg1)->closestPtPointTriangle((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVoronoiSimplexSolver *_wrap_new_btVoronoiSimplexSolver_mbt_c1af402c8cb9fdfb() {
  btVoronoiSimplexSolver *result = 0 ;
  btVoronoiSimplexSolver *_swig_go_result;
  
  
  result = (btVoronoiSimplexSolver *)new btVoronoiSimplexSolver();
  *(btVoronoiSimplexSolver **)&_swig_go_result = (btVoronoiSimplexSolver *)result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_reset_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  (arg1)->reset();
  
}


void _wrap_btVoronoiSimplexSolver_addVertex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->addVertex((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btVoronoiSimplexSolver_setEqualVertexThreshold_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, float _swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setEqualVertexThreshold(arg2);
  
}


float _wrap_btVoronoiSimplexSolver_getEqualVertexThreshold_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btScalar)((btVoronoiSimplexSolver const *)arg1)->getEqualVertexThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVoronoiSimplexSolver_closest_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)(arg1)->closest(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVoronoiSimplexSolver_maxVertex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->maxVertex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVoronoiSimplexSolver_fullSimplex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (bool)((btVoronoiSimplexSolver const *)arg1)->fullSimplex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVoronoiSimplexSolver_getSimplex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (int)((btVoronoiSimplexSolver const *)arg1)->getSimplex(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVoronoiSimplexSolver_inSimplex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)(arg1)->inSimplex((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_backup_closest_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->backup_closest(*arg2);
  
}


bool _wrap_btVoronoiSimplexSolver_emptySimplex_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (bool)((btVoronoiSimplexSolver const *)arg1)->emptySimplex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVoronoiSimplexSolver_compute_points_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->compute_points(*arg2,*arg3);
  
}


intgo _wrap_btVoronoiSimplexSolver_numVertices_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  result = (int)((btVoronoiSimplexSolver const *)arg1)->numVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btVoronoiSimplexSolver_mbt_c1af402c8cb9fdfb(btVoronoiSimplexSolver *_swig_go_0) {
  btVoronoiSimplexSolver *arg1 = (btVoronoiSimplexSolver *) 0 ;
  
  arg1 = *(btVoronoiSimplexSolver **)&_swig_go_0; 
  
  delete arg1;
  
}


btGjkConvexCast *_wrap_new_btGjkConvexCast_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btConvexShape *_swig_go_1, btVoronoiSimplexSolver *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btVoronoiSimplexSolver *arg3 = (btVoronoiSimplexSolver *) 0 ;
  btGjkConvexCast *result = 0 ;
  btGjkConvexCast *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btVoronoiSimplexSolver **)&_swig_go_2; 
  
  result = (btGjkConvexCast *)new btGjkConvexCast((btConvexShape const *)arg1,(btConvexShape const *)arg2,arg3);
  *(btGjkConvexCast **)&_swig_go_result = (btGjkConvexCast *)result; 
  return _swig_go_result;
}


bool _wrap_btGjkConvexCast_calcTimeOfImpact_mbt_c1af402c8cb9fdfb(btGjkConvexCast *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4, btConvexCast::CastResult *_swig_go_5) {
  btGjkConvexCast *arg1 = (btGjkConvexCast *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  btConvexCast::CastResult *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGjkConvexCast **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btConvexCast::CastResult **)&_swig_go_5; 
  
  result = (bool)(arg1)->calcTimeOfImpact((btTransform const &)*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btTransform const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btGjkConvexCast_mbt_c1af402c8cb9fdfb(btGjkConvexCast *_swig_go_0) {
  btGjkConvexCast *arg1 = (btGjkConvexCast *) 0 ;
  
  arg1 = *(btGjkConvexCast **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_PHY_FLOAT_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_FLOAT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_PHY_DOUBLE_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_DOUBLE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_PHY_INTEGER_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_INTEGER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_PHY_SHORT_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_SHORT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_PHY_FIXEDPOINT88_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_FIXEDPOINT88;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_PHY_UCHAR_mbt_c1af402c8cb9fdfb() {
  PHY_ScalarType result;
  intgo _swig_go_result;
  
  
  result = PHY_UCHAR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btConcaveShape_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConcaveShape_processAllTriangles_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConcaveShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


float _wrap_btConcaveShape_getMargin_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  result = (btScalar)((btConcaveShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_setMargin_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, float _swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btConcaveShape_getAabb_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConcaveShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConcaveShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConcaveShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, float _swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConcaveShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isConvex2d_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isConvex_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isNonMoving_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isConcave_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isCompound_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isSoftBody_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConcaveShape_isInfinite_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConcaveShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btVector3 *) &((btCollisionShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConcaveShape_getName_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConcaveShape_getShapeType_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConcaveShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = ((btCollisionShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConcaveShape_setUserPointer_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, void *_swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void *_wrap_btConcaveShape_getUserPointer_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (void *)((btCollisionShape const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_setUserIndex_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, intgo _swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


intgo _wrap_btConcaveShape_getUserIndex_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConcaveShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, intgo _swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


intgo _wrap_btConcaveShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConcaveShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConcaveShape_serialize_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btConcaveShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btConcaveShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConcaveShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->serializeSingleShape(arg2);
  
}


void _wrap_delete_btStridingMeshInterface_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btStridingMeshInterface_InternalProcessAllTriangles_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, btInternalTriangleIndexCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btInternalTriangleIndexCallback *arg2 = (btInternalTriangleIndexCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(btInternalTriangleIndexCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btStridingMeshInterface const *)arg1)->InternalProcessAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btStridingMeshInterface_calculateAabbBruteForce_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->calculateAabbBruteForce(*arg2,*arg3);
  
}


void _wrap_btStridingMeshInterface_getLockedVertexIndexBase__SWIG_0_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, char **_swig_go_1, intgo *_swig_go_2, PHY_ScalarType *_swig_go_3, intgo *_swig_go_4, char **_swig_go_5, intgo *_swig_go_6, intgo *_swig_go_7, PHY_ScalarType *_swig_go_8, intgo _swig_go_9) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  int e3 ;
  int e5 ;
  int e7 ;
  int e8 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(unsigned char ***)&_swig_go_1; 
  
  e3 = (int)*_swig_go_2;
  arg3 = &e3;
  
  arg4 = *(PHY_ScalarType **)&_swig_go_3; 
  
  e5 = (int)*_swig_go_4;
  arg5 = &e5;
  
  arg6 = *(unsigned char ***)&_swig_go_5; 
  
  e7 = (int)*_swig_go_6;
  arg7 = &e7;
  
  
  e8 = (int)*_swig_go_7;
  arg8 = &e8;
  
  arg9 = *(PHY_ScalarType **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  
  (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9,arg10);
  
  *_swig_go_2 = (intgo)e3; 
  *_swig_go_4 = (intgo)e5; 
  *_swig_go_6 = (intgo)e7; 
  *_swig_go_7 = (intgo)e8; 
}


void _wrap_btStridingMeshInterface_getLockedVertexIndexBase__SWIG_1_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, char **_swig_go_1, intgo *_swig_go_2, PHY_ScalarType *_swig_go_3, intgo *_swig_go_4, char **_swig_go_5, intgo *_swig_go_6, intgo *_swig_go_7, PHY_ScalarType *_swig_go_8) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int e3 ;
  int e5 ;
  int e7 ;
  int e8 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(unsigned char ***)&_swig_go_1; 
  
  e3 = (int)*_swig_go_2;
  arg3 = &e3;
  
  arg4 = *(PHY_ScalarType **)&_swig_go_3; 
  
  e5 = (int)*_swig_go_4;
  arg5 = &e5;
  
  arg6 = *(unsigned char ***)&_swig_go_5; 
  
  e7 = (int)*_swig_go_6;
  arg7 = &e7;
  
  
  e8 = (int)*_swig_go_7;
  arg8 = &e8;
  
  arg9 = *(PHY_ScalarType **)&_swig_go_8; 
  
  (arg1)->getLockedVertexIndexBase(arg2,*arg3,*arg4,*arg5,arg6,*arg7,*arg8,*arg9);
  
  *_swig_go_2 = (intgo)e3; 
  *_swig_go_4 = (intgo)e5; 
  *_swig_go_6 = (intgo)e7; 
  *_swig_go_7 = (intgo)e8; 
}


void _wrap_btStridingMeshInterface_getLockedReadOnlyVertexIndexBase__SWIG_0_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, char **_swig_go_1, intgo *_swig_go_2, PHY_ScalarType *_swig_go_3, intgo *_swig_go_4, char **_swig_go_5, intgo *_swig_go_6, intgo *_swig_go_7, PHY_ScalarType *_swig_go_8, intgo _swig_go_9) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int arg10 ;
  int e3 ;
  int e5 ;
  int e7 ;
  int e8 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(unsigned char ***)&_swig_go_1; 
  
  e3 = (int)*_swig_go_2;
  arg3 = &e3;
  
  arg4 = *(PHY_ScalarType **)&_swig_go_3; 
  
  e5 = (int)*_swig_go_4;
  arg5 = &e5;
  
  arg6 = *(unsigned char ***)&_swig_go_5; 
  
  e7 = (int)*_swig_go_6;
  arg7 = &e7;
  
  
  e8 = (int)*_swig_go_7;
  arg8 = &e8;
  
  arg9 = *(PHY_ScalarType **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  
  ((btStridingMeshInterface const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9,arg10);
  
  *_swig_go_2 = (intgo)e3; 
  *_swig_go_4 = (intgo)e5; 
  *_swig_go_6 = (intgo)e7; 
  *_swig_go_7 = (intgo)e8; 
}


void _wrap_btStridingMeshInterface_getLockedReadOnlyVertexIndexBase__SWIG_1_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, char **_swig_go_1, intgo *_swig_go_2, PHY_ScalarType *_swig_go_3, intgo *_swig_go_4, char **_swig_go_5, intgo *_swig_go_6, intgo *_swig_go_7, PHY_ScalarType *_swig_go_8) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  unsigned char **arg2 = (unsigned char **) 0 ;
  int *arg3 = 0 ;
  PHY_ScalarType *arg4 = 0 ;
  int *arg5 = 0 ;
  unsigned char **arg6 = (unsigned char **) 0 ;
  int *arg7 = 0 ;
  int *arg8 = 0 ;
  PHY_ScalarType *arg9 = 0 ;
  int e3 ;
  int e5 ;
  int e7 ;
  int e8 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(unsigned char ***)&_swig_go_1; 
  
  e3 = (int)*_swig_go_2;
  arg3 = &e3;
  
  arg4 = *(PHY_ScalarType **)&_swig_go_3; 
  
  e5 = (int)*_swig_go_4;
  arg5 = &e5;
  
  arg6 = *(unsigned char ***)&_swig_go_5; 
  
  e7 = (int)*_swig_go_6;
  arg7 = &e7;
  
  
  e8 = (int)*_swig_go_7;
  arg8 = &e8;
  
  arg9 = *(PHY_ScalarType **)&_swig_go_8; 
  
  ((btStridingMeshInterface const *)arg1)->getLockedReadOnlyVertexIndexBase((unsigned char const **)arg2,*arg3,*arg4,*arg5,(unsigned char const **)arg6,*arg7,*arg8,*arg9);
  
  *_swig_go_2 = (intgo)e3; 
  *_swig_go_4 = (intgo)e5; 
  *_swig_go_6 = (intgo)e7; 
  *_swig_go_7 = (intgo)e8; 
}


void _wrap_btStridingMeshInterface_unLockVertexBase_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, intgo _swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->unLockVertexBase(arg2);
  
}


void _wrap_btStridingMeshInterface_unLockReadOnlyVertexBase_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, intgo _swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btStridingMeshInterface const *)arg1)->unLockReadOnlyVertexBase(arg2);
  
}


intgo _wrap_btStridingMeshInterface_getNumSubParts_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  
  result = (int)((btStridingMeshInterface const *)arg1)->getNumSubParts();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterface_preallocateVertices_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, intgo _swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->preallocateVertices(arg2);
  
}


void _wrap_btStridingMeshInterface_preallocateIndices_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, intgo _swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int arg2 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->preallocateIndices(arg2);
  
}


bool _wrap_btStridingMeshInterface_hasPremadeAabb_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  
  result = (bool)((btStridingMeshInterface const *)arg1)->hasPremadeAabb();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterface_setPremadeAabb_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btStridingMeshInterface const *)arg1)->setPremadeAabb((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btStridingMeshInterface_getPremadeAabb_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btStridingMeshInterface const *)arg1)->getPremadeAabb(arg2,arg3);
  
}


btVector3 *_wrap_btStridingMeshInterface_getScaling_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  
  result = (btVector3 *) &((btStridingMeshInterface const *)arg1)->getScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterface_setScaling_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, btVector3 *_swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setScaling((btVector3 const &)*arg2);
  
}


intgo _wrap_btStridingMeshInterface_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  
  result = (int)((btStridingMeshInterface const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btStridingMeshInterface_serialize_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btStridingMeshInterface const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btIntIndexData_m_value_set_mbt_c1af402c8cb9fdfb(btIntIndexData *_swig_go_0, intgo _swig_go_1) {
  btIntIndexData *arg1 = (btIntIndexData *) 0 ;
  int arg2 ;
  
  arg1 = *(btIntIndexData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_value = arg2;
  
}


intgo _wrap_btIntIndexData_m_value_get_mbt_c1af402c8cb9fdfb(btIntIndexData *_swig_go_0) {
  btIntIndexData *arg1 = (btIntIndexData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btIntIndexData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_value);
  _swig_go_result = result; 
  return _swig_go_result;
}


btIntIndexData *_wrap_new_btIntIndexData_mbt_c1af402c8cb9fdfb() {
  btIntIndexData *result = 0 ;
  btIntIndexData *_swig_go_result;
  
  
  result = (btIntIndexData *)new btIntIndexData();
  *(btIntIndexData **)&_swig_go_result = (btIntIndexData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btIntIndexData_mbt_c1af402c8cb9fdfb(btIntIndexData *_swig_go_0) {
  btIntIndexData *arg1 = (btIntIndexData *) 0 ;
  
  arg1 = *(btIntIndexData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btShortIntIndexData_m_value_set_mbt_c1af402c8cb9fdfb(btShortIntIndexData *_swig_go_0, short _swig_go_1) {
  btShortIntIndexData *arg1 = (btShortIntIndexData *) 0 ;
  short arg2 ;
  
  arg1 = *(btShortIntIndexData **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_value = arg2;
  
}


short _wrap_btShortIntIndexData_m_value_get_mbt_c1af402c8cb9fdfb(btShortIntIndexData *_swig_go_0) {
  btShortIntIndexData *arg1 = (btShortIntIndexData *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btShortIntIndexData **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_value);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btShortIntIndexData_m_pad_set_mbt_c1af402c8cb9fdfb(btShortIntIndexData *_swig_go_0, _gostring_ _swig_go_1) {
  btShortIntIndexData *arg1 = (btShortIntIndexData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btShortIntIndexData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 2-1);
      arg1->m_pad[2-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btShortIntIndexData_m_pad_get_mbt_c1af402c8cb9fdfb(btShortIntIndexData *_swig_go_0) {
  btShortIntIndexData *arg1 = (btShortIntIndexData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btShortIntIndexData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btShortIntIndexData *_wrap_new_btShortIntIndexData_mbt_c1af402c8cb9fdfb() {
  btShortIntIndexData *result = 0 ;
  btShortIntIndexData *_swig_go_result;
  
  
  result = (btShortIntIndexData *)new btShortIntIndexData();
  *(btShortIntIndexData **)&_swig_go_result = (btShortIntIndexData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btShortIntIndexData_mbt_c1af402c8cb9fdfb(btShortIntIndexData *_swig_go_0) {
  btShortIntIndexData *arg1 = (btShortIntIndexData *) 0 ;
  
  arg1 = *(btShortIntIndexData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btShortIntIndexTripletData_m_values_set_mbt_c1af402c8cb9fdfb(btShortIntIndexTripletData *_swig_go_0, short *_swig_go_1) {
  btShortIntIndexTripletData *arg1 = (btShortIntIndexTripletData *) 0 ;
  short *arg2 = (short *) (short *)0 ;
  
  arg1 = *(btShortIntIndexTripletData **)&_swig_go_0; 
  arg2 = *(short **)&_swig_go_1; 
  
  {
    size_t ii;
    short *b = (short *) arg1->m_values;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((short *) arg2 + ii);
  }
  
}


short *_wrap_btShortIntIndexTripletData_m_values_get_mbt_c1af402c8cb9fdfb(btShortIntIndexTripletData *_swig_go_0) {
  btShortIntIndexTripletData *arg1 = (btShortIntIndexTripletData *) 0 ;
  short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btShortIntIndexTripletData **)&_swig_go_0; 
  
  result = (short *)(short *) ((arg1)->m_values);
  *(short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btShortIntIndexTripletData_m_pad_set_mbt_c1af402c8cb9fdfb(btShortIntIndexTripletData *_swig_go_0, _gostring_ _swig_go_1) {
  btShortIntIndexTripletData *arg1 = (btShortIntIndexTripletData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btShortIntIndexTripletData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 2-1);
      arg1->m_pad[2-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btShortIntIndexTripletData_m_pad_get_mbt_c1af402c8cb9fdfb(btShortIntIndexTripletData *_swig_go_0) {
  btShortIntIndexTripletData *arg1 = (btShortIntIndexTripletData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btShortIntIndexTripletData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btShortIntIndexTripletData *_wrap_new_btShortIntIndexTripletData_mbt_c1af402c8cb9fdfb() {
  btShortIntIndexTripletData *result = 0 ;
  btShortIntIndexTripletData *_swig_go_result;
  
  
  result = (btShortIntIndexTripletData *)new btShortIntIndexTripletData();
  *(btShortIntIndexTripletData **)&_swig_go_result = (btShortIntIndexTripletData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btShortIntIndexTripletData_mbt_c1af402c8cb9fdfb(btShortIntIndexTripletData *_swig_go_0) {
  btShortIntIndexTripletData *arg1 = (btShortIntIndexTripletData *) 0 ;
  
  arg1 = *(btShortIntIndexTripletData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCharIndexTripletData_m_values_set_mbt_c1af402c8cb9fdfb(btCharIndexTripletData *_swig_go_0, char *_swig_go_1) {
  btCharIndexTripletData *arg1 = (btCharIndexTripletData *) 0 ;
  unsigned char *arg2 = (unsigned char *) (unsigned char *)0 ;
  
  arg1 = *(btCharIndexTripletData **)&_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned char *b = (unsigned char *) arg1->m_values;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned char *) arg2 + ii);
  }
  
}


char *_wrap_btCharIndexTripletData_m_values_get_mbt_c1af402c8cb9fdfb(btCharIndexTripletData *_swig_go_0) {
  btCharIndexTripletData *arg1 = (btCharIndexTripletData *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btCharIndexTripletData **)&_swig_go_0; 
  
  result = (unsigned char *)(unsigned char *) ((arg1)->m_values);
  *(unsigned char **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCharIndexTripletData_m_pad_set_mbt_c1af402c8cb9fdfb(btCharIndexTripletData *_swig_go_0, char _swig_go_1) {
  btCharIndexTripletData *arg1 = (btCharIndexTripletData *) 0 ;
  char arg2 ;
  
  arg1 = *(btCharIndexTripletData **)&_swig_go_0; 
  arg2 = (char)_swig_go_1; 
  
  if (arg1) (arg1)->m_pad = arg2;
  
}


char _wrap_btCharIndexTripletData_m_pad_get_mbt_c1af402c8cb9fdfb(btCharIndexTripletData *_swig_go_0) {
  btCharIndexTripletData *arg1 = (btCharIndexTripletData *) 0 ;
  char result;
  char _swig_go_result;
  
  arg1 = *(btCharIndexTripletData **)&_swig_go_0; 
  
  result = (char) ((arg1)->m_pad);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCharIndexTripletData *_wrap_new_btCharIndexTripletData_mbt_c1af402c8cb9fdfb() {
  btCharIndexTripletData *result = 0 ;
  btCharIndexTripletData *_swig_go_result;
  
  
  result = (btCharIndexTripletData *)new btCharIndexTripletData();
  *(btCharIndexTripletData **)&_swig_go_result = (btCharIndexTripletData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCharIndexTripletData_mbt_c1af402c8cb9fdfb(btCharIndexTripletData *_swig_go_0) {
  btCharIndexTripletData *arg1 = (btCharIndexTripletData *) 0 ;
  
  arg1 = *(btCharIndexTripletData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMeshPartData_m_vertices3f_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_vertices3f = arg2;
  
}


btVector3FloatData *_wrap_btMeshPartData_m_vertices3f_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btVector3FloatData *) ((arg1)->m_vertices3f);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_vertices3d_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_vertices3d = arg2;
  
}


btVector3DoubleData *_wrap_btMeshPartData_m_vertices3d_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *) ((arg1)->m_vertices3d);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_indices32_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btIntIndexData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btIntIndexData *arg2 = (btIntIndexData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btIntIndexData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_indices32 = arg2;
  
}


btIntIndexData *_wrap_btMeshPartData_m_indices32_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btIntIndexData *result = 0 ;
  btIntIndexData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btIntIndexData *) ((arg1)->m_indices32);
  *(btIntIndexData **)&_swig_go_result = (btIntIndexData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_3indices16_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btShortIntIndexTripletData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btShortIntIndexTripletData *arg2 = (btShortIntIndexTripletData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btShortIntIndexTripletData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_3indices16 = arg2;
  
}


btShortIntIndexTripletData *_wrap_btMeshPartData_m_3indices16_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btShortIntIndexTripletData *result = 0 ;
  btShortIntIndexTripletData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btShortIntIndexTripletData *) ((arg1)->m_3indices16);
  *(btShortIntIndexTripletData **)&_swig_go_result = (btShortIntIndexTripletData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_3indices8_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btCharIndexTripletData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btCharIndexTripletData *arg2 = (btCharIndexTripletData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btCharIndexTripletData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_3indices8 = arg2;
  
}


btCharIndexTripletData *_wrap_btMeshPartData_m_3indices8_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btCharIndexTripletData *result = 0 ;
  btCharIndexTripletData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btCharIndexTripletData *) ((arg1)->m_3indices8);
  *(btCharIndexTripletData **)&_swig_go_result = (btCharIndexTripletData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_indices16_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, btShortIntIndexData *_swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btShortIntIndexData *arg2 = (btShortIntIndexData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = *(btShortIntIndexData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_indices16 = arg2;
  
}


btShortIntIndexData *_wrap_btMeshPartData_m_indices16_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  btShortIntIndexData *result = 0 ;
  btShortIntIndexData *_swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (btShortIntIndexData *) ((arg1)->m_indices16);
  *(btShortIntIndexData **)&_swig_go_result = (btShortIntIndexData *)result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_numTriangles_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, intgo _swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  int arg2 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numTriangles = arg2;
  
}


intgo _wrap_btMeshPartData_m_numTriangles_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numTriangles);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMeshPartData_m_numVertices_set_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0, intgo _swig_go_1) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  int arg2 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numVertices = arg2;
  
}


intgo _wrap_btMeshPartData_m_numVertices_get_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numVertices);
  _swig_go_result = result; 
  return _swig_go_result;
}


btMeshPartData *_wrap_new_btMeshPartData_mbt_c1af402c8cb9fdfb() {
  btMeshPartData *result = 0 ;
  btMeshPartData *_swig_go_result;
  
  
  result = (btMeshPartData *)new btMeshPartData();
  *(btMeshPartData **)&_swig_go_result = (btMeshPartData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMeshPartData_mbt_c1af402c8cb9fdfb(btMeshPartData *_swig_go_0) {
  btMeshPartData *arg1 = (btMeshPartData *) 0 ;
  
  arg1 = *(btMeshPartData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btStridingMeshInterfaceData_m_meshPartsPtr_set_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0, btMeshPartData *_swig_go_1) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  btMeshPartData *arg2 = (btMeshPartData *) 0 ;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  arg2 = *(btMeshPartData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_meshPartsPtr = arg2;
  
}


btMeshPartData *_wrap_btStridingMeshInterfaceData_m_meshPartsPtr_get_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  btMeshPartData *result = 0 ;
  btMeshPartData *_swig_go_result;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  result = (btMeshPartData *) ((arg1)->m_meshPartsPtr);
  *(btMeshPartData **)&_swig_go_result = (btMeshPartData *)result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterfaceData_m_scaling_set_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_scaling = *arg2;
  
}


btVector3FloatData *_wrap_btStridingMeshInterfaceData_m_scaling_get_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_scaling);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterfaceData_m_numMeshParts_set_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0, intgo _swig_go_1) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  int arg2 ;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numMeshParts = arg2;
  
}


intgo _wrap_btStridingMeshInterfaceData_m_numMeshParts_get_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numMeshParts);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btStridingMeshInterfaceData_m_padding_set_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0, _gostring_ _swig_go_1) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btStridingMeshInterfaceData_m_padding_get_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btStridingMeshInterfaceData *_wrap_new_btStridingMeshInterfaceData_mbt_c1af402c8cb9fdfb() {
  btStridingMeshInterfaceData *result = 0 ;
  btStridingMeshInterfaceData *_swig_go_result;
  
  
  result = (btStridingMeshInterfaceData *)new btStridingMeshInterfaceData();
  *(btStridingMeshInterfaceData **)&_swig_go_result = (btStridingMeshInterfaceData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btStridingMeshInterfaceData_mbt_c1af402c8cb9fdfb(btStridingMeshInterfaceData *_swig_go_0) {
  btStridingMeshInterfaceData *arg1 = (btStridingMeshInterfaceData *) 0 ;
  
  arg1 = *(btStridingMeshInterfaceData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btTriangleMeshShape_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btTriangleMeshShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btTriangleMeshShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btTriangleMeshShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btTriangleMeshShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_recalcLocalAabb_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_btTriangleMeshShape_getAabb_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btTriangleMeshShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btTriangleMeshShape_processAllTriangles_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btTriangleMeshShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btTriangleMeshShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btTriangleMeshShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btTriangleMeshShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btTriangleMeshShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btStridingMeshInterface *_wrap_btTriangleMeshShape_getMeshInterface__SWIG_0_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  btStridingMeshInterface *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (btStridingMeshInterface *)(arg1)->getMeshInterface();
  *(btStridingMeshInterface **)&_swig_go_result = (btStridingMeshInterface *)result; 
  return _swig_go_result;
}


btStridingMeshInterface *_wrap_btTriangleMeshShape_getMeshInterface__SWIG_1_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  btStridingMeshInterface *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (btStridingMeshInterface *)((btTriangleMeshShape const *)arg1)->getMeshInterface();
  *(btStridingMeshInterface **)&_swig_go_result = (btStridingMeshInterface *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTriangleMeshShape_getLocalAabbMin_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalAabbMin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTriangleMeshShape_getLocalAabbMax_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTriangleMeshShape const *)arg1)->getLocalAabbMax();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTriangleMeshShape_getName_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  result = (char *)((btTriangleMeshShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


float _wrap_btTriangleMeshShape_getMargin_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  result = (btScalar)((btConcaveShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_setMargin_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, float _swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btTriangleMeshShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btTriangleMeshShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTriangleMeshShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, float _swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btTriangleMeshShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isConvex2d_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isConvex_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isNonMoving_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isConcave_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isCompound_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isSoftBody_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTriangleMeshShape_isInfinite_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTriangleMeshShape_getShapeType_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTriangleMeshShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = ((btCollisionShape const *)swig_b1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_setUserPointer_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, void *_swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserPointer(arg2);
  
}


void *_wrap_btTriangleMeshShape_getUserPointer_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (void *)((btCollisionShape const *)swig_b1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_setUserIndex_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, intgo _swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex(arg2);
  
}


intgo _wrap_btTriangleMeshShape_getUserIndex_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, intgo _swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex2(arg2);
  
}


intgo _wrap_btTriangleMeshShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTriangleMeshShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTriangleMeshShape_serialize_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (char *)((btCollisionShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btTriangleMeshShape *_swig_go_0, btSerializer *_swig_go_1) {
  btTriangleMeshShape *arg1 = (btTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->serializeSingleShape(arg2);
  
}


void _wrap_btQuantizedBvhNode_m_quantizedAabbMin_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0, short *_swig_go_1) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btQuantizedBvhNode_m_quantizedAabbMin_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhNode_m_quantizedAabbMax_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0, short *_swig_go_1) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btQuantizedBvhNode_m_quantizedAabbMax_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_escapeIndexOrTriangleIndex = arg2;
  
}


intgo _wrap_btQuantizedBvhNode_m_escapeIndexOrTriangleIndex_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_escapeIndexOrTriangleIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btQuantizedBvhNode_isLeafNode_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (bool)((btQuantizedBvhNode const *)arg1)->isLeafNode();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvhNode_getEscapeIndex_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (int)((btQuantizedBvhNode const *)arg1)->getEscapeIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvhNode_getTriangleIndex_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (int)((btQuantizedBvhNode const *)arg1)->getTriangleIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvhNode_getPartId_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  result = (int)((btQuantizedBvhNode const *)arg1)->getPartId();
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuantizedBvhNode *_wrap_new_btQuantizedBvhNode_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvhNode *result = 0 ;
  btQuantizedBvhNode *_swig_go_result;
  
  
  result = (btQuantizedBvhNode *)new btQuantizedBvhNode();
  *(btQuantizedBvhNode **)&_swig_go_result = (btQuantizedBvhNode *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuantizedBvhNode_mbt_c1af402c8cb9fdfb(btQuantizedBvhNode *_swig_go_0) {
  btQuantizedBvhNode *arg1 = (btQuantizedBvhNode *) 0 ;
  
  arg1 = *(btQuantizedBvhNode **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btOptimizedBvhNode_m_aabbMinOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, btVector3 *_swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMinOrg = *arg2;
  
}


btVector3 *_wrap_btOptimizedBvhNode_m_aabbMinOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMinOrg);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNode_m_aabbMaxOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, btVector3 *_swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMaxOrg = *arg2;
  
}


btVector3 *_wrap_btOptimizedBvhNode_m_aabbMaxOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMaxOrg);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNode_m_escapeIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_escapeIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNode_m_escapeIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_escapeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNode_m_subPart_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_subPart = arg2;
  
}


intgo _wrap_btOptimizedBvhNode_m_subPart_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_subPart);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNode_m_triangleIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNode_m_triangleIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_triangleIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNode_m_padding_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0, _gostring_ _swig_go_1) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 20-1);
      arg1->m_padding[20-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btOptimizedBvhNode_m_padding_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btOptimizedBvhNode *_wrap_new_btOptimizedBvhNode_mbt_c1af402c8cb9fdfb() {
  btOptimizedBvhNode *result = 0 ;
  btOptimizedBvhNode *_swig_go_result;
  
  
  result = (btOptimizedBvhNode *)new btOptimizedBvhNode();
  *(btOptimizedBvhNode **)&_swig_go_result = (btOptimizedBvhNode *)result; 
  return _swig_go_result;
}


void _wrap_delete_btOptimizedBvhNode_mbt_c1af402c8cb9fdfb(btOptimizedBvhNode *_swig_go_0) {
  btOptimizedBvhNode *arg1 = (btOptimizedBvhNode *) 0 ;
  
  arg1 = *(btOptimizedBvhNode **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBvhSubtreeInfo_m_quantizedAabbMin_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, short *_swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btBvhSubtreeInfo_m_quantizedAabbMin_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfo_m_quantizedAabbMax_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, short *_swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btBvhSubtreeInfo_m_quantizedAabbMax_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfo_m_rootNodeIndex_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, intgo _swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_rootNodeIndex = arg2;
  
}


intgo _wrap_btBvhSubtreeInfo_m_rootNodeIndex_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_rootNodeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfo_m_subtreeSize_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, intgo _swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_subtreeSize = arg2;
  
}


intgo _wrap_btBvhSubtreeInfo_m_subtreeSize_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_subtreeSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfo_m_padding_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, intgo *_swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_padding;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btBvhSubtreeInfo_m_padding_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_padding);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


btBvhSubtreeInfo *_wrap_new_btBvhSubtreeInfo_mbt_c1af402c8cb9fdfb() {
  btBvhSubtreeInfo *result = 0 ;
  btBvhSubtreeInfo *_swig_go_result;
  
  
  result = (btBvhSubtreeInfo *)new btBvhSubtreeInfo();
  *(btBvhSubtreeInfo **)&_swig_go_result = (btBvhSubtreeInfo *)result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfo_setAabbFromQuantizeNode_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0, btQuantizedBvhNode *_swig_go_1) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  btQuantizedBvhNode *arg2 = 0 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhNode **)&_swig_go_1; 
  
  (arg1)->setAabbFromQuantizeNode((btQuantizedBvhNode const &)*arg2);
  
}


void _wrap_delete_btBvhSubtreeInfo_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfo *_swig_go_0) {
  btBvhSubtreeInfo *arg1 = (btBvhSubtreeInfo *) 0 ;
  
  arg1 = *(btBvhSubtreeInfo **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btNodeOverlapCallback_mbt_c1af402c8cb9fdfb(btNodeOverlapCallback *_swig_go_0) {
  btNodeOverlapCallback *arg1 = (btNodeOverlapCallback *) 0 ;
  
  arg1 = *(btNodeOverlapCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btNodeOverlapCallback_processNode_mbt_c1af402c8cb9fdfb(btNodeOverlapCallback *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btNodeOverlapCallback *arg1 = (btNodeOverlapCallback *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btNodeOverlapCallback **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->processNode(arg2,arg3);
  
}


intgo _wrap_TRAVERSAL_STACKLESS_btQuantizedBvh_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvh::btTraversalMode result;
  intgo _swig_go_result;
  
  
  result = btQuantizedBvh::TRAVERSAL_STACKLESS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRAVERSAL_STACKLESS_CACHE_FRIENDLY_btQuantizedBvh_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvh::btTraversalMode result;
  intgo _swig_go_result;
  
  
  result = btQuantizedBvh::TRAVERSAL_STACKLESS_CACHE_FRIENDLY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRAVERSAL_RECURSIVE_btQuantizedBvh_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvh::btTraversalMode result;
  intgo _swig_go_result;
  
  
  result = btQuantizedBvh::TRAVERSAL_RECURSIVE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btQuantizedBvh *_wrap_new_btQuantizedBvh_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvh *result = 0 ;
  btQuantizedBvh *_swig_go_result;
  
  
  result = (btQuantizedBvh *)new btQuantizedBvh();
  *(btQuantizedBvh **)&_swig_go_result = (btQuantizedBvh *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuantizedBvh_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuantizedBvh_setQuantizationValues__SWIG_0_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btQuantizedBvh_setQuantizationValues__SWIG_1_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


btAlignedObjectArray< btQuantizedBvhNode > *_wrap_btQuantizedBvh_getLeafNodeArray_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhNode > *_swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (QuantizedNodeArray *) &(arg1)->getLeafNodeArray();
  *(QuantizedNodeArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvh_buildInternal_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  (arg1)->buildInternal();
  
}


void _wrap_btQuantizedBvh_reportAabbOverlappingNodex_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btQuantizedBvh const *)arg1)->reportAabbOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btQuantizedBvh_reportRayOverlappingNodex_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btQuantizedBvh const *)arg1)->reportRayOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btQuantizedBvh_reportBoxCastOverlappingNodex_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  ((btQuantizedBvh const *)arg1)->reportBoxCastOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btQuantizedBvh_quantize_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, short *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btQuantizedBvh const *)arg1)->quantize(arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btQuantizedBvh_quantizeWithClamp_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, short *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btQuantizedBvh const *)arg1)->quantizeWithClamp(arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btQuantizedBvh_unQuantize_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, short *_swig_go_1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  result = ((btQuantizedBvh const *)arg1)->unQuantize((unsigned short const *)arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btQuantizedBvh_setTraversalMode_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvh::btTraversalMode arg2 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = (btQuantizedBvh::btTraversalMode)_swig_go_1; 
  
  (arg1)->setTraversalMode(arg2);
  
}


btAlignedObjectArray< btQuantizedBvhNode > *_wrap_btQuantizedBvh_getQuantizedNodeArray_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhNode > *_swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (QuantizedNodeArray *) &(arg1)->getQuantizedNodeArray();
  *(QuantizedNodeArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBvhSubtreeInfo > *_wrap_btQuantizedBvh_getSubtreeInfoArray_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  BvhSubtreeInfoArray *result = 0 ;
  btAlignedObjectArray< btBvhSubtreeInfo > *_swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (BvhSubtreeInfoArray *) &(arg1)->getSubtreeInfoArray();
  *(BvhSubtreeInfoArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvh_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (unsigned int)((btQuantizedBvh const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btQuantizedBvh_serialize__SWIG_0_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, void *_swig_go_1, intgo _swig_go_2, bool _swig_go_3) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  unsigned int arg3 ;
  bool arg4 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  arg4 = (bool)_swig_go_3; 
  
  result = (bool)((btQuantizedBvh const *)arg1)->serialize(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuantizedBvh *_wrap_btQuantizedBvh_deSerializeInPlace_mbt_c1af402c8cb9fdfb(void *_swig_go_0, intgo _swig_go_1, bool _swig_go_2) {
  void *arg1 = (void *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  btQuantizedBvh *result = 0 ;
  btQuantizedBvh *_swig_go_result;
  
  arg1 = *(void **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btQuantizedBvh *)btQuantizedBvh::deSerializeInPlace(arg1,arg2,arg3);
  *(btQuantizedBvh **)&_swig_go_result = (btQuantizedBvh *)result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvh_getAlignmentSerializationPadding_mbt_c1af402c8cb9fdfb() {
  unsigned int result;
  intgo _swig_go_result;
  
  
  result = (unsigned int)btQuantizedBvh::getAlignmentSerializationPadding();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuantizedBvh_calculateSerializeBufferSizeNew_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (int)((btQuantizedBvh const *)arg1)->calculateSerializeBufferSizeNew();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btQuantizedBvh_serialize__SWIG_1_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btQuantizedBvh const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btQuantizedBvh_deSerializeFloat_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btQuantizedBvhFloatData *_swig_go_1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvhFloatData *arg2 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat(*arg2);
  
}


void _wrap_btQuantizedBvh_deSerializeDouble_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0, btQuantizedBvhDoubleData *_swig_go_1) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  btQuantizedBvhDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble(*arg2);
  
}


bool _wrap_btQuantizedBvh_isQuantized_mbt_c1af402c8cb9fdfb(btQuantizedBvh *_swig_go_0) {
  btQuantizedBvh *arg1 = (btQuantizedBvh *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btQuantizedBvh **)&_swig_go_0; 
  
  result = (bool)(arg1)->isQuantized();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfoData_m_rootNodeIndex_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0, intgo _swig_go_1) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_rootNodeIndex = arg2;
  
}


intgo _wrap_btBvhSubtreeInfoData_m_rootNodeIndex_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_rootNodeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfoData_m_subtreeSize_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0, intgo _swig_go_1) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_subtreeSize = arg2;
  
}


intgo _wrap_btBvhSubtreeInfoData_m_subtreeSize_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_subtreeSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfoData_m_quantizedAabbMin_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0, short *_swig_go_1) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btBvhSubtreeInfoData_m_quantizedAabbMin_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhSubtreeInfoData_m_quantizedAabbMax_set_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0, short *_swig_go_1) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btBvhSubtreeInfoData_m_quantizedAabbMax_get_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


btBvhSubtreeInfoData *_wrap_new_btBvhSubtreeInfoData_mbt_c1af402c8cb9fdfb() {
  btBvhSubtreeInfoData *result = 0 ;
  btBvhSubtreeInfoData *_swig_go_result;
  
  
  result = (btBvhSubtreeInfoData *)new btBvhSubtreeInfoData();
  *(btBvhSubtreeInfoData **)&_swig_go_result = (btBvhSubtreeInfoData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBvhSubtreeInfoData_mbt_c1af402c8cb9fdfb(btBvhSubtreeInfoData *_swig_go_0) {
  btBvhSubtreeInfoData *arg1 = (btBvhSubtreeInfoData *) 0 ;
  
  arg1 = *(btBvhSubtreeInfoData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btOptimizedBvhNodeFloatData_m_aabbMinOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMinOrg = *arg2;
  
}


btVector3FloatData *_wrap_btOptimizedBvhNodeFloatData_m_aabbMinOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_aabbMinOrg);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeFloatData_m_aabbMaxOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMaxOrg = *arg2;
  
}


btVector3FloatData *_wrap_btOptimizedBvhNodeFloatData_m_aabbMaxOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_aabbMaxOrg);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeFloatData_m_escapeIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_escapeIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeFloatData_m_escapeIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_escapeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeFloatData_m_subPart_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_subPart = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeFloatData_m_subPart_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_subPart);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeFloatData_m_triangleIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeFloatData_m_triangleIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_triangleIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeFloatData_m_pad_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 4-1);
      arg1->m_pad[4-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btOptimizedBvhNodeFloatData_m_pad_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btOptimizedBvhNodeFloatData *_wrap_new_btOptimizedBvhNodeFloatData_mbt_c1af402c8cb9fdfb() {
  btOptimizedBvhNodeFloatData *result = 0 ;
  btOptimizedBvhNodeFloatData *_swig_go_result;
  
  
  result = (btOptimizedBvhNodeFloatData *)new btOptimizedBvhNodeFloatData();
  *(btOptimizedBvhNodeFloatData **)&_swig_go_result = (btOptimizedBvhNodeFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btOptimizedBvhNodeFloatData_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeFloatData *_swig_go_0) {
  btOptimizedBvhNodeFloatData *arg1 = (btOptimizedBvhNodeFloatData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btOptimizedBvhNodeDoubleData_m_aabbMinOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMinOrg = *arg2;
  
}


btVector3DoubleData *_wrap_btOptimizedBvhNodeDoubleData_m_aabbMinOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_aabbMinOrg);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMaxOrg = *arg2;
  
}


btVector3DoubleData *_wrap_btOptimizedBvhNodeDoubleData_m_aabbMaxOrg_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_aabbMaxOrg);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeDoubleData_m_escapeIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_escapeIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeDoubleData_m_escapeIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_escapeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeDoubleData_m_subPart_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_subPart = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeDoubleData_m_subPart_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_subPart);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeDoubleData_m_triangleIndex_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleIndex = arg2;
  
}


intgo _wrap_btOptimizedBvhNodeDoubleData_m_triangleIndex_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_triangleIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvhNodeDoubleData_m_pad_set_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 4-1);
      arg1->m_pad[4-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btOptimizedBvhNodeDoubleData_m_pad_get_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btOptimizedBvhNodeDoubleData *_wrap_new_btOptimizedBvhNodeDoubleData_mbt_c1af402c8cb9fdfb() {
  btOptimizedBvhNodeDoubleData *result = 0 ;
  btOptimizedBvhNodeDoubleData *_swig_go_result;
  
  
  result = (btOptimizedBvhNodeDoubleData *)new btOptimizedBvhNodeDoubleData();
  *(btOptimizedBvhNodeDoubleData **)&_swig_go_result = (btOptimizedBvhNodeDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btOptimizedBvhNodeDoubleData_mbt_c1af402c8cb9fdfb(btOptimizedBvhNodeDoubleData *_swig_go_0) {
  btOptimizedBvhNodeDoubleData *arg1 = (btOptimizedBvhNodeDoubleData *) 0 ;
  
  arg1 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuantizedBvhNodeData_m_quantizedAabbMin_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0, short *_swig_go_1) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btQuantizedBvhNodeData_m_quantizedAabbMin_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhNodeData_m_quantizedAabbMax_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0, short *_swig_go_1) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  unsigned short *arg2 = (unsigned short *) (unsigned short *)0 ;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  {
    size_t ii;
    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
  }
  
}


short *_wrap_btQuantizedBvhNodeData_m_quantizedAabbMax_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  unsigned short *result = 0 ;
  short *_swig_go_result;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  
  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
  *(unsigned short **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_escapeIndexOrTriangleIndex = arg2;
  
}


intgo _wrap_btQuantizedBvhNodeData_m_escapeIndexOrTriangleIndex_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_escapeIndexOrTriangleIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuantizedBvhNodeData *_wrap_new_btQuantizedBvhNodeData_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvhNodeData *result = 0 ;
  btQuantizedBvhNodeData *_swig_go_result;
  
  
  result = (btQuantizedBvhNodeData *)new btQuantizedBvhNodeData();
  *(btQuantizedBvhNodeData **)&_swig_go_result = (btQuantizedBvhNodeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuantizedBvhNodeData_mbt_c1af402c8cb9fdfb(btQuantizedBvhNodeData *_swig_go_0) {
  btQuantizedBvhNodeData *arg1 = (btQuantizedBvhNodeData *) 0 ;
  
  arg1 = *(btQuantizedBvhNodeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuantizedBvhFloatData_m_bvhAabbMin_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhAabbMin = *arg2;
  
}


btVector3FloatData *_wrap_btQuantizedBvhFloatData_m_bvhAabbMin_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_bvhAabbMin);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_bvhAabbMax_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhAabbMax = *arg2;
  
}


btVector3FloatData *_wrap_btQuantizedBvhFloatData_m_bvhAabbMax_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_bvhAabbMax);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_bvhQuantization_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhQuantization = *arg2;
  
}


btVector3FloatData *_wrap_btQuantizedBvhFloatData_m_bvhQuantization_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_bvhQuantization);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_curNodeIndex_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_curNodeIndex = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_curNodeIndex_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_curNodeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_useQuantization_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useQuantization = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_useQuantization_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useQuantization);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_numContiguousLeafNodes_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numContiguousLeafNodes = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_numContiguousLeafNodes_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numContiguousLeafNodes);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numQuantizedContiguousNodes = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_numQuantizedContiguousNodes_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numQuantizedContiguousNodes);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_contiguousNodesPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btOptimizedBvhNodeFloatData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btOptimizedBvhNodeFloatData *arg2 = (btOptimizedBvhNodeFloatData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btOptimizedBvhNodeFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contiguousNodesPtr = arg2;
  
}


btOptimizedBvhNodeFloatData *_wrap_btQuantizedBvhFloatData_m_contiguousNodesPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btOptimizedBvhNodeFloatData *result = 0 ;
  btOptimizedBvhNodeFloatData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btOptimizedBvhNodeFloatData *) ((arg1)->m_contiguousNodesPtr);
  *(btOptimizedBvhNodeFloatData **)&_swig_go_result = (btOptimizedBvhNodeFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btQuantizedBvhNodeData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btQuantizedBvhNodeData *arg2 = (btQuantizedBvhNodeData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhNodeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_quantizedContiguousNodesPtr = arg2;
  
}


btQuantizedBvhNodeData *_wrap_btQuantizedBvhFloatData_m_quantizedContiguousNodesPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btQuantizedBvhNodeData *result = 0 ;
  btQuantizedBvhNodeData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btQuantizedBvhNodeData *) ((arg1)->m_quantizedContiguousNodesPtr);
  *(btQuantizedBvhNodeData **)&_swig_go_result = (btQuantizedBvhNodeData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_subTreeInfoPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, btBvhSubtreeInfoData *_swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btBvhSubtreeInfoData *arg2 = (btBvhSubtreeInfoData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = *(btBvhSubtreeInfoData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_subTreeInfoPtr = arg2;
  
}


btBvhSubtreeInfoData *_wrap_btQuantizedBvhFloatData_m_subTreeInfoPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  btBvhSubtreeInfoData *result = 0 ;
  btBvhSubtreeInfoData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (btBvhSubtreeInfoData *) ((arg1)->m_subTreeInfoPtr);
  *(btBvhSubtreeInfoData **)&_swig_go_result = (btBvhSubtreeInfoData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_traversalMode_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_traversalMode = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_traversalMode_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_traversalMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhFloatData_m_numSubtreeHeaders_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numSubtreeHeaders = arg2;
  
}


intgo _wrap_btQuantizedBvhFloatData_m_numSubtreeHeaders_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numSubtreeHeaders);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuantizedBvhFloatData *_wrap_new_btQuantizedBvhFloatData_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvhFloatData *result = 0 ;
  btQuantizedBvhFloatData *_swig_go_result;
  
  
  result = (btQuantizedBvhFloatData *)new btQuantizedBvhFloatData();
  *(btQuantizedBvhFloatData **)&_swig_go_result = (btQuantizedBvhFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuantizedBvhFloatData_mbt_c1af402c8cb9fdfb(btQuantizedBvhFloatData *_swig_go_0) {
  btQuantizedBvhFloatData *arg1 = (btQuantizedBvhFloatData *) 0 ;
  
  arg1 = *(btQuantizedBvhFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuantizedBvhDoubleData_m_bvhAabbMin_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhAabbMin = *arg2;
  
}


btVector3DoubleData *_wrap_btQuantizedBvhDoubleData_m_bvhAabbMin_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_bvhAabbMin);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_bvhAabbMax_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhAabbMax = *arg2;
  
}


btVector3DoubleData *_wrap_btQuantizedBvhDoubleData_m_bvhAabbMax_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_bvhAabbMax);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_bvhQuantization_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhQuantization = *arg2;
  
}


btVector3DoubleData *_wrap_btQuantizedBvhDoubleData_m_bvhQuantization_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_bvhQuantization);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_curNodeIndex_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_curNodeIndex = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_curNodeIndex_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_curNodeIndex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_useQuantization_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useQuantization = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_useQuantization_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useQuantization);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_numContiguousLeafNodes_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numContiguousLeafNodes = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_numContiguousLeafNodes_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numContiguousLeafNodes);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numQuantizedContiguousNodes = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_numQuantizedContiguousNodes_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numQuantizedContiguousNodes);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_contiguousNodesPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btOptimizedBvhNodeDoubleData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btOptimizedBvhNodeDoubleData *arg2 = (btOptimizedBvhNodeDoubleData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btOptimizedBvhNodeDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_contiguousNodesPtr = arg2;
  
}


btOptimizedBvhNodeDoubleData *_wrap_btQuantizedBvhDoubleData_m_contiguousNodesPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btOptimizedBvhNodeDoubleData *result = 0 ;
  btOptimizedBvhNodeDoubleData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btOptimizedBvhNodeDoubleData *) ((arg1)->m_contiguousNodesPtr);
  *(btOptimizedBvhNodeDoubleData **)&_swig_go_result = (btOptimizedBvhNodeDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btQuantizedBvhNodeData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btQuantizedBvhNodeData *arg2 = (btQuantizedBvhNodeData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhNodeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_quantizedContiguousNodesPtr = arg2;
  
}


btQuantizedBvhNodeData *_wrap_btQuantizedBvhDoubleData_m_quantizedContiguousNodesPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btQuantizedBvhNodeData *result = 0 ;
  btQuantizedBvhNodeData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btQuantizedBvhNodeData *) ((arg1)->m_quantizedContiguousNodesPtr);
  *(btQuantizedBvhNodeData **)&_swig_go_result = (btQuantizedBvhNodeData *)result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_traversalMode_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_traversalMode = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_traversalMode_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_traversalMode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_numSubtreeHeaders_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, intgo _swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numSubtreeHeaders = arg2;
  
}


intgo _wrap_btQuantizedBvhDoubleData_m_numSubtreeHeaders_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numSubtreeHeaders);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btQuantizedBvhDoubleData_m_subTreeInfoPtr_set_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0, btBvhSubtreeInfoData *_swig_go_1) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btBvhSubtreeInfoData *arg2 = (btBvhSubtreeInfoData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  arg2 = *(btBvhSubtreeInfoData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_subTreeInfoPtr = arg2;
  
}


btBvhSubtreeInfoData *_wrap_btQuantizedBvhDoubleData_m_subTreeInfoPtr_get_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  btBvhSubtreeInfoData *result = 0 ;
  btBvhSubtreeInfoData *_swig_go_result;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  result = (btBvhSubtreeInfoData *) ((arg1)->m_subTreeInfoPtr);
  *(btBvhSubtreeInfoData **)&_swig_go_result = (btBvhSubtreeInfoData *)result; 
  return _swig_go_result;
}


btQuantizedBvhDoubleData *_wrap_new_btQuantizedBvhDoubleData_mbt_c1af402c8cb9fdfb() {
  btQuantizedBvhDoubleData *result = 0 ;
  btQuantizedBvhDoubleData *_swig_go_result;
  
  
  result = (btQuantizedBvhDoubleData *)new btQuantizedBvhDoubleData();
  *(btQuantizedBvhDoubleData **)&_swig_go_result = (btQuantizedBvhDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuantizedBvhDoubleData_mbt_c1af402c8cb9fdfb(btQuantizedBvhDoubleData *_swig_go_0) {
  btQuantizedBvhDoubleData *arg1 = (btQuantizedBvhDoubleData *) 0 ;
  
  arg1 = *(btQuantizedBvhDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btOptimizedBvh *_wrap_new_btOptimizedBvh_mbt_c1af402c8cb9fdfb() {
  btOptimizedBvh *result = 0 ;
  btOptimizedBvh *_swig_go_result;
  
  
  result = (btOptimizedBvh *)new btOptimizedBvh();
  *(btOptimizedBvh **)&_swig_go_result = (btOptimizedBvh *)result; 
  return _swig_go_result;
}


void _wrap_delete_btOptimizedBvh_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btOptimizedBvh_build_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btStridingMeshInterface *_swig_go_1, bool _swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  bool arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btStridingMeshInterface **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  (arg1)->build(arg2,arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
  
}


void _wrap_btOptimizedBvh_refit_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btStridingMeshInterface *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btStridingMeshInterface **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->refit(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btOptimizedBvh_refitPartial_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btStridingMeshInterface *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btStridingMeshInterface **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->refitPartial(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btOptimizedBvh_updateBvhNodes_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btStridingMeshInterface *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btStridingMeshInterface **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  (arg1)->updateBvhNodes(arg2,arg3,arg4,arg5);
  
}


bool _wrap_btOptimizedBvh_serializeInPlace_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, void *_swig_go_1, intgo _swig_go_2, bool _swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  unsigned int arg3 ;
  bool arg4 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  arg4 = (bool)_swig_go_3; 
  
  result = (bool)((btOptimizedBvh const *)arg1)->serializeInPlace(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btOptimizedBvh *_wrap_btOptimizedBvh_deSerializeInPlace_mbt_c1af402c8cb9fdfb(void *_swig_go_0, intgo _swig_go_1, bool _swig_go_2) {
  void *arg1 = (void *) 0 ;
  unsigned int arg2 ;
  bool arg3 ;
  btOptimizedBvh *result = 0 ;
  btOptimizedBvh *_swig_go_result;
  
  arg1 = *(void **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btOptimizedBvh *)btOptimizedBvh::deSerializeInPlace(arg1,arg2,arg3);
  *(btOptimizedBvh **)&_swig_go_result = (btOptimizedBvh *)result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvh_setQuantizationValues__SWIG_0_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btOptimizedBvh_setQuantizationValues__SWIG_1_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->setQuantizationValues((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


btAlignedObjectArray< btQuantizedBvhNode > *_wrap_btOptimizedBvh_getLeafNodeArray_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhNode > *_swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (QuantizedNodeArray *) &(swig_b0)->getLeafNodeArray();
  *(QuantizedNodeArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvh_buildInternal_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->buildInternal();
  
}


void _wrap_btOptimizedBvh_reportAabbOverlappingNodex_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  ((btQuantizedBvh const *)swig_b0)->reportAabbOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btOptimizedBvh_reportRayOverlappingNodex_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  ((btQuantizedBvh const *)swig_b0)->reportRayOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btOptimizedBvh_reportBoxCastOverlappingNodex_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btNodeOverlapCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btNodeOverlapCallback *arg2 = (btNodeOverlapCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btNodeOverlapCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  ((btQuantizedBvh const *)swig_b0)->reportBoxCastOverlappingNodex(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btOptimizedBvh_quantize_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, short *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  ((btQuantizedBvh const *)swig_b0)->quantize(arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btOptimizedBvh_quantizeWithClamp_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, short *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  ((btQuantizedBvh const *)swig_b0)->quantizeWithClamp(arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btOptimizedBvh_unQuantize_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, short *_swig_go_1) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = ((btQuantizedBvh const *)swig_b0)->unQuantize((unsigned short const *)arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btOptimizedBvh_setTraversalMode_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, intgo _swig_go_1) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btQuantizedBvh::btTraversalMode arg2 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = (btQuantizedBvh::btTraversalMode)_swig_go_1; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->setTraversalMode(arg2);
  
}


btAlignedObjectArray< btQuantizedBvhNode > *_wrap_btOptimizedBvh_getQuantizedNodeArray_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  QuantizedNodeArray *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhNode > *_swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (QuantizedNodeArray *) &(swig_b0)->getQuantizedNodeArray();
  *(QuantizedNodeArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btBvhSubtreeInfo > *_wrap_btOptimizedBvh_getSubtreeInfoArray_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  BvhSubtreeInfoArray *result = 0 ;
  btAlignedObjectArray< btBvhSubtreeInfo > *_swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (BvhSubtreeInfoArray *) &(swig_b0)->getSubtreeInfoArray();
  *(BvhSubtreeInfoArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btOptimizedBvh_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (unsigned int)((btQuantizedBvh const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btOptimizedBvh_serialize__SWIG_0_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, void *_swig_go_1, intgo _swig_go_2, bool _swig_go_3) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  unsigned int arg3 ;
  bool arg4 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  arg4 = (bool)_swig_go_3; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (bool)((btQuantizedBvh const *)swig_b0)->serialize(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btOptimizedBvh_serialize__SWIG_1_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (char *)((btQuantizedBvh const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btOptimizedBvh_getAlignmentSerializationPadding_mbt_c1af402c8cb9fdfb() {
  unsigned int result;
  intgo _swig_go_result;
  
  
  result = (unsigned int)btQuantizedBvh::getAlignmentSerializationPadding();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btOptimizedBvh_calculateSerializeBufferSizeNew_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (int)((btQuantizedBvh const *)swig_b0)->calculateSerializeBufferSizeNew();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btOptimizedBvh_deSerializeFloat_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btQuantizedBvhFloatData *_swig_go_1) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btQuantizedBvhFloatData *arg2 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhFloatData **)&_swig_go_1; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->deSerializeFloat(*arg2);
  
}


void _wrap_btOptimizedBvh_deSerializeDouble_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0, btQuantizedBvhDoubleData *_swig_go_1) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  btQuantizedBvhDoubleData *arg2 = 0 ;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhDoubleData **)&_swig_go_1; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  (swig_b0)->deSerializeDouble(*arg2);
  
}


bool _wrap_btOptimizedBvh_isQuantized_mbt_c1af402c8cb9fdfb(btOptimizedBvh *_swig_go_0) {
  btOptimizedBvh *arg1 = (btOptimizedBvh *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btOptimizedBvh **)&_swig_go_0; 
  
  btQuantizedBvh *swig_b0 = (btQuantizedBvh *)arg1;
  result = (bool)(swig_b0)->isQuantized();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_sBulletDNAstr_set_mbt_c1af402c8cb9fdfb(_gostring_ _swig_go_0) {
  char *arg1 = (char *) (char *)0 ;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  {
    if (arg1) strcpy((char *)sBulletDNAstr, (const char *)arg1);
    else sBulletDNAstr[0] = 0;
  }
  
  free(arg1); 
}


_gostring_ _wrap_sBulletDNAstr_get_mbt_c1af402c8cb9fdfb() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)(char *)sBulletDNAstr;
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_sBulletDNAlen_set_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  sBulletDNAlen = arg1;
  
}


intgo _wrap_sBulletDNAlen_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)sBulletDNAlen;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_sBulletDNAstr64_set_mbt_c1af402c8cb9fdfb(_gostring_ _swig_go_0) {
  char *arg1 = (char *) (char *)0 ;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  {
    if (arg1) strcpy((char *)sBulletDNAstr64, (const char *)arg1);
    else sBulletDNAstr64[0] = 0;
  }
  
  free(arg1); 
}


_gostring_ _wrap_sBulletDNAstr64_get_mbt_c1af402c8cb9fdfb() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)(char *)sBulletDNAstr64;
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_sBulletDNAlen64_set_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  sBulletDNAlen64 = arg1;
  
}


intgo _wrap_sBulletDNAlen64_get_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)sBulletDNAlen64;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btStrLen_mbt_c1af402c8cb9fdfb(_gostring_ _swig_go_0) {
  char *arg1 = (char *) 0 ;
  int result;
  intgo _swig_go_result;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  result = (int)btStrLen((char const *)arg1);
  _swig_go_result = result; 
  free(arg1); 
  return _swig_go_result;
}


void _wrap_btChunk_m_chunkCode_set_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_chunkCode = arg2;
  
}


intgo _wrap_btChunk_m_chunkCode_get_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_chunkCode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_length_set_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_length = arg2;
  
}


intgo _wrap_btChunk_m_length_get_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_length);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_oldPtr_set_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0, void *_swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_oldPtr = arg2;
  
}


void *_wrap_btChunk_m_oldPtr_get_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_oldPtr);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_dna_nr_set_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_dna_nr = arg2;
  
}


intgo _wrap_btChunk_m_dna_nr_get_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_dna_nr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_number_set_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_number = arg2;
  
}


intgo _wrap_btChunk_m_number_get_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_number);
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_new_btChunk_mbt_c1af402c8cb9fdfb() {
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  
  result = (btChunk *)new btChunk();
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void _wrap_delete_btChunk_mbt_c1af402c8cb9fdfb(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_SERIALIZE_NO_BVH_mbt_c1af402c8cb9fdfb() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_BVH;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_NO_TRIANGLEINFOMAP_mbt_c1af402c8cb9fdfb() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_TRIANGLEINFOMAP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_NO_DUPLICATE_ASSERT_mbt_c1af402c8cb9fdfb() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_DUPLICATE_ASSERT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_CONTACT_MANIFOLDS_mbt_c1af402c8cb9fdfb() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_CONTACT_MANIFOLDS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btSerializer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  delete arg1;
  
}


char *_wrap_btSerializer_getBufferPointer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (unsigned char *)((btSerializer const *)arg1)->getBufferPointer();
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


intgo _wrap_btSerializer_getCurrentBufferSize_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getCurrentBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btSerializer_allocate_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, long long _swig_go_1, intgo _swig_go_2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btChunk *)(arg1)->allocate(arg2,arg3);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void _wrap_btSerializer_finalizeChunk_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, btChunk *_swig_go_1, _gostring_ _swig_go_2, intgo _swig_go_3, void *_swig_go_4) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(btChunk **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  arg4 = (int)_swig_go_3; 
  arg5 = *(void **)&_swig_go_4; 
  
  (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
  
  free(arg3); 
}


void *_wrap_btSerializer_findPointer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->findPointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void *_wrap_btSerializer_getUniquePointer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->getUniquePointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSerializer_startSerialization_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  (arg1)->startSerialization();
  
}


void _wrap_btSerializer_finishSerialization_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  (arg1)->finishSerialization();
  
}


_gostring_ _wrap_btSerializer_findNameForPointer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (char *)((btSerializer const *)arg1)->findNameForPointer((void const *)arg2);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btSerializer_registerNameForPointer_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, void *_swig_go_1, _gostring_ _swig_go_2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  
  (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
  
  free(arg3); 
}


void _wrap_btSerializer_serializeName_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, _gostring_ _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  (arg1)->serializeName((char const *)arg2);
  
  free(arg2); 
}


intgo _wrap_btSerializer_getSerializationFlags_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getSerializationFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSerializer_setSerializationFlags_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, intgo _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int arg2 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setSerializationFlags(arg2);
  
}


intgo _wrap_btSerializer_getNumChunks_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getNumChunks();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btSerializer_getChunk_mbt_c1af402c8cb9fdfb(btSerializer *_swig_go_0, intgo _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int arg2 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btChunk *)((btSerializer const *)arg1)->getChunk(arg2);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


btPointerUid *_wrap_new_btPointerUid_mbt_c1af402c8cb9fdfb() {
  btPointerUid *result = 0 ;
  btPointerUid *_swig_go_result;
  
  
  result = (btPointerUid *)new btPointerUid();
  *(btPointerUid **)&_swig_go_result = (btPointerUid *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPointerUid_mbt_c1af402c8cb9fdfb(btPointerUid *_swig_go_0) {
  btPointerUid *arg1 = (btPointerUid *) 0 ;
  
  arg1 = *(btPointerUid **)&_swig_go_0; 
  
  delete arg1;
  
}


btBulletSerializedArrays *_wrap_new_btBulletSerializedArrays_mbt_c1af402c8cb9fdfb() {
  btBulletSerializedArrays *result = 0 ;
  btBulletSerializedArrays *_swig_go_result;
  
  
  result = (btBulletSerializedArrays *)new btBulletSerializedArrays();
  *(btBulletSerializedArrays **)&_swig_go_result = (btBulletSerializedArrays *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_bvhsDouble_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btQuantizedBvhDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *arg2 = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btQuantizedBvhDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhsDouble = *arg2;
  
}


btAlignedObjectArray< btQuantizedBvhDoubleData * > *_wrap_btBulletSerializedArrays_m_bvhsDouble_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *)& ((arg1)->m_bvhsDouble);
  *(btAlignedObjectArray< btQuantizedBvhDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_bvhsFloat_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btQuantizedBvhFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *arg2 = (btAlignedObjectArray< btQuantizedBvhFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btQuantizedBvhFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhsFloat = *arg2;
  
}


btAlignedObjectArray< btQuantizedBvhFloatData * > *_wrap_btBulletSerializedArrays_m_bvhsFloat_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btQuantizedBvhFloatData * > *)& ((arg1)->m_bvhsFloat);
  *(btAlignedObjectArray< btQuantizedBvhFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btQuantizedBvhFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_colShapeData_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionShapeData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *arg2 = (btAlignedObjectArray< btCollisionShapeData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionShapeData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_colShapeData = *arg2;
  
}


btAlignedObjectArray< btCollisionShapeData * > *_wrap_btBulletSerializedArrays_m_colShapeData_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *result = 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionShapeData * > *)& ((arg1)->m_colShapeData);
  *(btAlignedObjectArray< btCollisionShapeData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionShapeData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataDouble_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btDynamicsWorldDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *arg2 = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btDynamicsWorldDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dynamicWorldInfoDataDouble = *arg2;
  
}


btAlignedObjectArray< btDynamicsWorldDoubleData * > *_wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataDouble_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *result = 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *)& ((arg1)->m_dynamicWorldInfoDataDouble);
  *(btAlignedObjectArray< btDynamicsWorldDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataFloat_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btDynamicsWorldFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *arg2 = (btAlignedObjectArray< btDynamicsWorldFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btDynamicsWorldFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dynamicWorldInfoDataFloat = *arg2;
  
}


btAlignedObjectArray< btDynamicsWorldFloatData * > *_wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataFloat_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *result = 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btDynamicsWorldFloatData * > *)& ((arg1)->m_dynamicWorldInfoDataFloat);
  *(btAlignedObjectArray< btDynamicsWorldFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btDynamicsWorldFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_rigidBodyDataDouble_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btRigidBodyDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *arg2 = (btAlignedObjectArray< btRigidBodyDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btRigidBodyDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rigidBodyDataDouble = *arg2;
  
}


btAlignedObjectArray< btRigidBodyDoubleData * > *_wrap_btBulletSerializedArrays_m_rigidBodyDataDouble_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *result = 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBodyDoubleData * > *)& ((arg1)->m_rigidBodyDataDouble);
  *(btAlignedObjectArray< btRigidBodyDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btRigidBodyDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_rigidBodyDataFloat_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btRigidBodyFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *arg2 = (btAlignedObjectArray< btRigidBodyFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btRigidBodyFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rigidBodyDataFloat = *arg2;
  
}


btAlignedObjectArray< btRigidBodyFloatData * > *_wrap_btBulletSerializedArrays_m_rigidBodyDataFloat_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *result = 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBodyFloatData * > *)& ((arg1)->m_rigidBodyDataFloat);
  *(btAlignedObjectArray< btRigidBodyFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btRigidBodyFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_collisionObjectDataDouble_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionObjectDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *arg2 = (btAlignedObjectArray< btCollisionObjectDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObjectDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectDataDouble = *arg2;
  
}


btAlignedObjectArray< btCollisionObjectDoubleData * > *_wrap_btBulletSerializedArrays_m_collisionObjectDataDouble_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *result = 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObjectDoubleData * > *)& ((arg1)->m_collisionObjectDataDouble);
  *(btAlignedObjectArray< btCollisionObjectDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObjectDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_collisionObjectDataFloat_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionObjectFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *arg2 = (btAlignedObjectArray< btCollisionObjectFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObjectFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectDataFloat = *arg2;
  
}


btAlignedObjectArray< btCollisionObjectFloatData * > *_wrap_btBulletSerializedArrays_m_collisionObjectDataFloat_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *result = 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObjectFloatData * > *)& ((arg1)->m_collisionObjectDataFloat);
  *(btAlignedObjectArray< btCollisionObjectFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObjectFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintDataFloat_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *arg2 = (btAlignedObjectArray< btTypedConstraintFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintDataFloat = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintFloatData * > *_wrap_btBulletSerializedArrays_m_constraintDataFloat_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintFloatData * > *)& ((arg1)->m_constraintDataFloat);
  *(btAlignedObjectArray< btTypedConstraintFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintDataDouble_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *arg2 = (btAlignedObjectArray< btTypedConstraintDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintDataDouble = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintDoubleData * > *_wrap_btBulletSerializedArrays_m_constraintDataDouble_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintDoubleData * > *)& ((arg1)->m_constraintDataDouble);
  *(btAlignedObjectArray< btTypedConstraintDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintData_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *arg2 = (btAlignedObjectArray< btTypedConstraintData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintData = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintData * > *_wrap_btBulletSerializedArrays_m_constraintData_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintData * > *)& ((arg1)->m_constraintData);
  *(btAlignedObjectArray< btTypedConstraintData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_softBodyFloatData_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btSoftBodyFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *arg2 = (btAlignedObjectArray< btSoftBodyFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btSoftBodyFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_softBodyFloatData = *arg2;
  
}


btAlignedObjectArray< btSoftBodyFloatData * > *_wrap_btBulletSerializedArrays_m_softBodyFloatData_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *result = 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btSoftBodyFloatData * > *)& ((arg1)->m_softBodyFloatData);
  *(btAlignedObjectArray< btSoftBodyFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btSoftBodyFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_softBodyDoubleData_set_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btSoftBodyDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *arg2 = (btAlignedObjectArray< btSoftBodyDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btSoftBodyDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_softBodyDoubleData = *arg2;
  
}


btAlignedObjectArray< btSoftBodyDoubleData * > *_wrap_btBulletSerializedArrays_m_softBodyDoubleData_get_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *result = 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btSoftBodyDoubleData * > *)& ((arg1)->m_softBodyDoubleData);
  *(btAlignedObjectArray< btSoftBodyDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btSoftBodyDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBulletSerializedArrays_mbt_c1af402c8cb9fdfb(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btDefaultSerializer_m_skipPointers_set_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, btHashMap< btHashPtr,void * > *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btHashMap< btHashPtr,void * > *arg2 = (btHashMap< btHashPtr,void * > *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(btHashMap< btHashPtr,void * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_skipPointers = *arg2;
  
}


btHashMap< btHashPtr,void * > *_wrap_btDefaultSerializer_m_skipPointers_get_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btHashMap< btHashPtr,void * > *result = 0 ;
  btHashMap< btHashPtr,void * > *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (btHashMap< btHashPtr,void * > *)& ((arg1)->m_skipPointers);
  *(btHashMap< btHashPtr,void * > **)&_swig_go_result = (btHashMap< btHashPtr,void * > *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_0_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, char *_swig_go_1) {
  int arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  result = (btDefaultSerializer *)new btDefaultSerializer(arg1,arg2);
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_1_mbt_c1af402c8cb9fdfb(intgo _swig_go_0) {
  int arg1 ;
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btDefaultSerializer *)new btDefaultSerializer(arg1);
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_2_mbt_c1af402c8cb9fdfb() {
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  
  result = (btDefaultSerializer *)new btDefaultSerializer();
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDefaultSerializer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btDefaultSerializer_getMemoryDnaSizeInBytes_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btDefaultSerializer::getMemoryDnaSizeInBytes();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btDefaultSerializer_getMemoryDna_mbt_c1af402c8cb9fdfb() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)btDefaultSerializer::getMemoryDna();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_insertHeader_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->insertHeader();
  
}


void _wrap_btDefaultSerializer_writeHeader_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, char *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  ((btDefaultSerializer const *)arg1)->writeHeader(arg2);
  
}


void _wrap_btDefaultSerializer_startSerialization_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->startSerialization();
  
}


void _wrap_btDefaultSerializer_finishSerialization_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->finishSerialization();
  
}


void *_wrap_btDefaultSerializer_getUniquePointer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->getUniquePointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


char *_wrap_btDefaultSerializer_getBufferPointer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (unsigned char *)((btDefaultSerializer const *)arg1)->getBufferPointer();
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


intgo _wrap_btDefaultSerializer_getCurrentBufferSize_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getCurrentBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_finalizeChunk_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, btChunk *_swig_go_1, _gostring_ _swig_go_2, intgo _swig_go_3, void *_swig_go_4) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(btChunk **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  arg4 = (int)_swig_go_3; 
  arg5 = *(void **)&_swig_go_4; 
  
  (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
  
  free(arg3); 
}


char *_wrap_btDefaultSerializer_internalAlloc_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, long long _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  
  result = (unsigned char *)(arg1)->internalAlloc(arg2);
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


btChunk *_wrap_btDefaultSerializer_allocate_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, long long _swig_go_1, intgo _swig_go_2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btChunk *)(arg1)->allocate(arg2,arg3);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btDefaultSerializer_findNameForPointer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (char *)((btDefaultSerializer const *)arg1)->findNameForPointer((void const *)arg2);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_registerNameForPointer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, void *_swig_go_1, _gostring_ _swig_go_2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  
  (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
  
  free(arg3); 
}


void _wrap_btDefaultSerializer_serializeName_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, _gostring_ _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  (arg1)->serializeName((char const *)arg2);
  
  free(arg2); 
}


intgo _wrap_btDefaultSerializer_getSerializationFlags_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getSerializationFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_setSerializationFlags_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, intgo _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int arg2 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setSerializationFlags(arg2);
  
}


intgo _wrap_btDefaultSerializer_getNumChunks_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getNumChunks();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btDefaultSerializer_getChunk_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, intgo _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int arg2 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btChunk *)((btDefaultSerializer const *)arg1)->getChunk(arg2);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void *_wrap_btDefaultSerializer_findPointer_mbt_c1af402c8cb9fdfb(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btSerializer *swig_b0 = (btSerializer *)arg1;
  result = (void *)(swig_b0)->findPointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btTriangleInfo *_wrap_new_btTriangleInfo_mbt_c1af402c8cb9fdfb() {
  btTriangleInfo *result = 0 ;
  btTriangleInfo *_swig_go_result;
  
  
  result = (btTriangleInfo *)new btTriangleInfo();
  *(btTriangleInfo **)&_swig_go_result = (btTriangleInfo *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfo_m_flags_set_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_flags = arg2;
  
}


intgo _wrap_btTriangleInfo_m_flags_get_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_flags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfo_m_edgeV0V1Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0, float _swig_go_1) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV0V1Angle = arg2;
  
}


float _wrap_btTriangleInfo_m_edgeV0V1Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_edgeV0V1Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfo_m_edgeV1V2Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0, float _swig_go_1) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV1V2Angle = arg2;
  
}


float _wrap_btTriangleInfo_m_edgeV1V2Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_edgeV1V2Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfo_m_edgeV2V0Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0, float _swig_go_1) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV2V0Angle = arg2;
  
}


float _wrap_btTriangleInfo_m_edgeV2V0Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_edgeV2V0Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleInfo_mbt_c1af402c8cb9fdfb(btTriangleInfo *_swig_go_0) {
  btTriangleInfo *arg1 = (btTriangleInfo *) 0 ;
  
  arg1 = *(btTriangleInfo **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTriangleInfoMap_m_convexEpsilon_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_convexEpsilon = arg2;
  
}


float _wrap_btTriangleInfoMap_m_convexEpsilon_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_convexEpsilon);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_m_planarEpsilon_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_planarEpsilon = arg2;
  
}


float _wrap_btTriangleInfoMap_m_planarEpsilon_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_planarEpsilon);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_m_equalVertexThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_equalVertexThreshold = arg2;
  
}


float _wrap_btTriangleInfoMap_m_equalVertexThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_equalVertexThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_m_edgeDistanceThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeDistanceThreshold = arg2;
  
}


float _wrap_btTriangleInfoMap_m_edgeDistanceThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_edgeDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_m_maxEdgeAngleThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxEdgeAngleThreshold = arg2;
  
}


float _wrap_btTriangleInfoMap_m_maxEdgeAngleThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxEdgeAngleThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_m_zeroAreaThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_zeroAreaThreshold = arg2;
  
}


float _wrap_btTriangleInfoMap_m_zeroAreaThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_zeroAreaThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTriangleInfoMap *_wrap_new_btTriangleInfoMap_mbt_c1af402c8cb9fdfb() {
  btTriangleInfoMap *result = 0 ;
  btTriangleInfoMap *_swig_go_result;
  
  
  result = (btTriangleInfoMap *)new btTriangleInfoMap();
  *(btTriangleInfoMap **)&_swig_go_result = (btTriangleInfoMap *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleInfoMap_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btTriangleInfoMap_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  
  result = (int)((btTriangleInfoMap const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTriangleInfoMap_serialize_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btTriangleInfoMap const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMap_deSerialize_mbt_c1af402c8cb9fdfb(btTriangleInfoMap *_swig_go_0, btTriangleInfoMapData *_swig_go_1) {
  btTriangleInfoMap *arg1 = (btTriangleInfoMap *) 0 ;
  btTriangleInfoMapData *arg2 = 0 ;
  
  arg1 = *(btTriangleInfoMap **)&_swig_go_0; 
  arg2 = *(btTriangleInfoMapData **)&_swig_go_1; 
  
  (arg1)->deSerialize(*arg2);
  
}


void _wrap_btTriangleInfoData_m_flags_set_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_flags = arg2;
  
}


intgo _wrap_btTriangleInfoData_m_flags_get_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_flags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoData_m_edgeV0V1Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV0V1Angle = arg2;
  
}


float _wrap_btTriangleInfoData_m_edgeV0V1Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_edgeV0V1Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoData_m_edgeV1V2Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV1V2Angle = arg2;
  
}


float _wrap_btTriangleInfoData_m_edgeV1V2Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_edgeV1V2Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoData_m_edgeV2V0Angle_set_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeV2V0Angle = arg2;
  
}


float _wrap_btTriangleInfoData_m_edgeV2V0Angle_get_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_edgeV2V0Angle);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTriangleInfoData *_wrap_new_btTriangleInfoData_mbt_c1af402c8cb9fdfb() {
  btTriangleInfoData *result = 0 ;
  btTriangleInfoData *_swig_go_result;
  
  
  result = (btTriangleInfoData *)new btTriangleInfoData();
  *(btTriangleInfoData **)&_swig_go_result = (btTriangleInfoData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleInfoData_mbt_c1af402c8cb9fdfb(btTriangleInfoData *_swig_go_0) {
  btTriangleInfoData *arg1 = (btTriangleInfoData *) 0 ;
  
  arg1 = *(btTriangleInfoData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTriangleInfoMapData_m_hashTablePtr_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo *_swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *arg2 = (int *) 0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_hashTablePtr = arg2;
  
}


intgo *_wrap_btTriangleInfoMapData_m_hashTablePtr_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int *) ((arg1)->m_hashTablePtr);
  *(int **)&_swig_go_result = (int *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_nextPtr_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo *_swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *arg2 = (int *) 0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_nextPtr = arg2;
  
}


intgo *_wrap_btTriangleInfoMapData_m_nextPtr_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int *) ((arg1)->m_nextPtr);
  *(int **)&_swig_go_result = (int *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_valueArrayPtr_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, btTriangleInfoData *_swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  btTriangleInfoData *arg2 = (btTriangleInfoData *) 0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = *(btTriangleInfoData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_valueArrayPtr = arg2;
  
}


btTriangleInfoData *_wrap_btTriangleInfoMapData_m_valueArrayPtr_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  btTriangleInfoData *result = 0 ;
  btTriangleInfoData *_swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (btTriangleInfoData *) ((arg1)->m_valueArrayPtr);
  *(btTriangleInfoData **)&_swig_go_result = (btTriangleInfoData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_keyArrayPtr_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo *_swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *arg2 = (int *) 0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_keyArrayPtr = arg2;
  
}


intgo *_wrap_btTriangleInfoMapData_m_keyArrayPtr_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int *) ((arg1)->m_keyArrayPtr);
  *(int **)&_swig_go_result = (int *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_convexEpsilon_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_convexEpsilon = arg2;
  
}


float _wrap_btTriangleInfoMapData_m_convexEpsilon_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_convexEpsilon);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_planarEpsilon_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_planarEpsilon = arg2;
  
}


float _wrap_btTriangleInfoMapData_m_planarEpsilon_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_planarEpsilon);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_equalVertexThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_equalVertexThreshold = arg2;
  
}


float _wrap_btTriangleInfoMapData_m_equalVertexThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_equalVertexThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_edgeDistanceThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_edgeDistanceThreshold = arg2;
  
}


float _wrap_btTriangleInfoMapData_m_edgeDistanceThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_edgeDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_zeroAreaThreshold_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, float _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_zeroAreaThreshold = arg2;
  
}


float _wrap_btTriangleInfoMapData_m_zeroAreaThreshold_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_zeroAreaThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_nextSize_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_nextSize = arg2;
  
}


intgo _wrap_btTriangleInfoMapData_m_nextSize_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_nextSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_hashTableSize_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hashTableSize = arg2;
  
}


intgo _wrap_btTriangleInfoMapData_m_hashTableSize_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hashTableSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_numValues_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numValues = arg2;
  
}


intgo _wrap_btTriangleInfoMapData_m_numValues_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numValues);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_numKeys_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, intgo _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numKeys = arg2;
  
}


intgo _wrap_btTriangleInfoMapData_m_numKeys_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numKeys);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleInfoMapData_m_padding_set_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0, _gostring_ _swig_go_1) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTriangleInfoMapData_m_padding_get_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btTriangleInfoMapData *_wrap_new_btTriangleInfoMapData_mbt_c1af402c8cb9fdfb() {
  btTriangleInfoMapData *result = 0 ;
  btTriangleInfoMapData *_swig_go_result;
  
  
  result = (btTriangleInfoMapData *)new btTriangleInfoMapData();
  *(btTriangleInfoMapData **)&_swig_go_result = (btTriangleInfoMapData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleInfoMapData_mbt_c1af402c8cb9fdfb(btTriangleInfoMapData *_swig_go_0) {
  btTriangleInfoMapData *arg1 = (btTriangleInfoMapData *) 0 ;
  
  arg1 = *(btTriangleInfoMapData **)&_swig_go_0; 
  
  delete arg1;
  
}


btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_0_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, bool _swig_go_1, bool _swig_go_2) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  bool arg3 ;
  btBvhTriangleMeshShape *result = 0 ;
  btBvhTriangleMeshShape *_swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,arg3);
  *(btBvhTriangleMeshShape **)&_swig_go_result = (btBvhTriangleMeshShape *)result; 
  return _swig_go_result;
}


btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_1_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, bool _swig_go_1) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btBvhTriangleMeshShape *result = 0 ;
  btBvhTriangleMeshShape *_swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2);
  *(btBvhTriangleMeshShape **)&_swig_go_result = (btBvhTriangleMeshShape *)result; 
  return _swig_go_result;
}


btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_2_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, bool _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, bool _swig_go_4) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool arg5 ;
  btBvhTriangleMeshShape *result = 0 ;
  btBvhTriangleMeshShape *_swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (bool)_swig_go_4; 
  
  result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
  *(btBvhTriangleMeshShape **)&_swig_go_result = (btBvhTriangleMeshShape *)result; 
  return _swig_go_result;
}


btBvhTriangleMeshShape *_wrap_new_btBvhTriangleMeshShape__SWIG_3_mbt_c1af402c8cb9fdfb(btStridingMeshInterface *_swig_go_0, bool _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
  bool arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btBvhTriangleMeshShape *result = 0 ;
  btBvhTriangleMeshShape *_swig_go_result;
  
  arg1 = *(btStridingMeshInterface **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btBvhTriangleMeshShape *)new btBvhTriangleMeshShape(arg1,arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btBvhTriangleMeshShape **)&_swig_go_result = (btBvhTriangleMeshShape *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBvhTriangleMeshShape_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBvhTriangleMeshShape_getOwnsBvh_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (bool)((btBvhTriangleMeshShape const *)arg1)->getOwnsBvh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_performRaycast_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->performRaycast(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btBvhTriangleMeshShape_performConvexcast_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  (arg1)->performConvexcast(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
  
}


void _wrap_btBvhTriangleMeshShape_processAllTriangles_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBvhTriangleMeshShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btBvhTriangleMeshShape_refitTree_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->refitTree((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btBvhTriangleMeshShape_partialRefitTree_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->partialRefitTree((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


_gostring_ _wrap_btBvhTriangleMeshShape_getName_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (char *)((btBvhTriangleMeshShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btOptimizedBvh *_wrap_btBvhTriangleMeshShape_getOptimizedBvh_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *result = 0 ;
  btOptimizedBvh *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (btOptimizedBvh *)(arg1)->getOptimizedBvh();
  *(btOptimizedBvh **)&_swig_go_result = (btOptimizedBvh *)result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setOptimizedBvh__SWIG_0_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btOptimizedBvh *_swig_go_1, btVector3 *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *arg2 = (btOptimizedBvh *) 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btOptimizedBvh **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setOptimizedBvh(arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btBvhTriangleMeshShape_setOptimizedBvh__SWIG_1_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btOptimizedBvh *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btOptimizedBvh *arg2 = (btOptimizedBvh *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btOptimizedBvh **)&_swig_go_1; 
  
  (arg1)->setOptimizedBvh(arg2);
  
}


void _wrap_btBvhTriangleMeshShape_buildOptimizedBvh_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  (arg1)->buildOptimizedBvh();
  
}


bool _wrap_btBvhTriangleMeshShape_usesQuantizedAabbCompression_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (bool)((btBvhTriangleMeshShape const *)arg1)->usesQuantizedAabbCompression();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setTriangleInfoMap_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTriangleInfoMap *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *arg2 = (btTriangleInfoMap *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTriangleInfoMap **)&_swig_go_1; 
  
  (arg1)->setTriangleInfoMap(arg2);
  
}


btTriangleInfoMap *_wrap_btBvhTriangleMeshShape_getTriangleInfoMap__SWIG_0_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  btTriangleInfoMap *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (btTriangleInfoMap *)((btBvhTriangleMeshShape const *)arg1)->getTriangleInfoMap();
  *(btTriangleInfoMap **)&_swig_go_result = (btTriangleInfoMap *)result; 
  return _swig_go_result;
}


btTriangleInfoMap *_wrap_btBvhTriangleMeshShape_getTriangleInfoMap__SWIG_1_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  btTriangleInfoMap *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (btTriangleInfoMap *)(arg1)->getTriangleInfoMap();
  *(btTriangleInfoMap **)&_swig_go_result = (btTriangleInfoMap *)result; 
  return _swig_go_result;
}


intgo _wrap_btBvhTriangleMeshShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  result = (int)((btBvhTriangleMeshShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBvhTriangleMeshShape_serialize_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btBvhTriangleMeshShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_serializeSingleBvh_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btBvhTriangleMeshShape const *)arg1)->serializeSingleBvh(arg2);
  
}


void _wrap_btBvhTriangleMeshShape_serializeSingleTriangleInfoMap_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btBvhTriangleMeshShape const *)arg1)->serializeSingleTriangleInfoMap(arg2);
  
}


btVector3 *_wrap_btBvhTriangleMeshShape_localGetSupportingVertex_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = ((btTriangleMeshShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBvhTriangleMeshShape_localGetSupportingVertexWithoutMargin_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = ((btTriangleMeshShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_recalcLocalAabb_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  (swig_b0)->recalcLocalAabb();
  
}


void _wrap_btBvhTriangleMeshShape_getAabb_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  ((btTriangleMeshShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBvhTriangleMeshShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  ((btTriangleMeshShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btBvhTriangleMeshShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = (btVector3 *) &((btTriangleMeshShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btStridingMeshInterface *_wrap_btBvhTriangleMeshShape_getMeshInterface__SWIG_0_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  btStridingMeshInterface *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = (btStridingMeshInterface *)(swig_b0)->getMeshInterface();
  *(btStridingMeshInterface **)&_swig_go_result = (btStridingMeshInterface *)result; 
  return _swig_go_result;
}


btStridingMeshInterface *_wrap_btBvhTriangleMeshShape_getMeshInterface__SWIG_1_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btStridingMeshInterface *result = 0 ;
  btStridingMeshInterface *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = (btStridingMeshInterface *)((btTriangleMeshShape const *)swig_b0)->getMeshInterface();
  *(btStridingMeshInterface **)&_swig_go_result = (btStridingMeshInterface *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBvhTriangleMeshShape_getLocalAabbMin_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = (btVector3 *) &((btTriangleMeshShape const *)swig_b0)->getLocalAabbMin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBvhTriangleMeshShape_getLocalAabbMax_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  result = (btVector3 *) &((btTriangleMeshShape const *)swig_b0)->getLocalAabbMax();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBvhTriangleMeshShape_getMargin_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  result = (btScalar)((btConcaveShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setMargin_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, float _swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  (swig_b1)->setMargin(arg2);
  
}


void _wrap_btBvhTriangleMeshShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btBvhTriangleMeshShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBvhTriangleMeshShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, float _swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btBvhTriangleMeshShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isConvex2d_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isConvex_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isNonMoving_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isConcave_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isCompound_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isSoftBody_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBvhTriangleMeshShape_isInfinite_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBvhTriangleMeshShape_getShapeType_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBvhTriangleMeshShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setUserPointer_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, void *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btBvhTriangleMeshShape_getUserPointer_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setUserIndex_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, intgo _swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btBvhTriangleMeshShape_getUserIndex_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, intgo _swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btBvhTriangleMeshShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBvhTriangleMeshShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btBvhTriangleMeshShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBvhTriangleMeshShape *arg1 = (btBvhTriangleMeshShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBvhTriangleMeshShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btTriangleMeshShape *swig_b0 = (btTriangleMeshShape *)arg1;
  btConcaveShape *swig_b1 = (btConcaveShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_btTriangleMeshShapeData_m_collisionShapeData_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShapeData = *arg2;
  
}


btCollisionShapeData *_wrap_btTriangleMeshShapeData_m_collisionShapeData_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *)& ((arg1)->m_collisionShapeData);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_meshInterface_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, btStridingMeshInterfaceData *_swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btStridingMeshInterfaceData *arg2 = (btStridingMeshInterfaceData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = *(btStridingMeshInterfaceData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_meshInterface = *arg2;
  
}


btStridingMeshInterfaceData *_wrap_btTriangleMeshShapeData_m_meshInterface_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btStridingMeshInterfaceData *result = 0 ;
  btStridingMeshInterfaceData *_swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (btStridingMeshInterfaceData *)& ((arg1)->m_meshInterface);
  *(btStridingMeshInterfaceData **)&_swig_go_result = (btStridingMeshInterfaceData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_quantizedFloatBvh_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, btQuantizedBvhFloatData *_swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btQuantizedBvhFloatData *arg2 = (btQuantizedBvhFloatData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_quantizedFloatBvh = arg2;
  
}


btQuantizedBvhFloatData *_wrap_btTriangleMeshShapeData_m_quantizedFloatBvh_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btQuantizedBvhFloatData *result = 0 ;
  btQuantizedBvhFloatData *_swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (btQuantizedBvhFloatData *) ((arg1)->m_quantizedFloatBvh);
  *(btQuantizedBvhFloatData **)&_swig_go_result = (btQuantizedBvhFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_quantizedDoubleBvh_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, btQuantizedBvhDoubleData *_swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btQuantizedBvhDoubleData *arg2 = (btQuantizedBvhDoubleData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = *(btQuantizedBvhDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_quantizedDoubleBvh = arg2;
  
}


btQuantizedBvhDoubleData *_wrap_btTriangleMeshShapeData_m_quantizedDoubleBvh_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btQuantizedBvhDoubleData *result = 0 ;
  btQuantizedBvhDoubleData *_swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (btQuantizedBvhDoubleData *) ((arg1)->m_quantizedDoubleBvh);
  *(btQuantizedBvhDoubleData **)&_swig_go_result = (btQuantizedBvhDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_triangleInfoMap_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, btTriangleInfoMapData *_swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btTriangleInfoMapData *arg2 = (btTriangleInfoMapData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = *(btTriangleInfoMapData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_triangleInfoMap = arg2;
  
}


btTriangleInfoMapData *_wrap_btTriangleMeshShapeData_m_triangleInfoMap_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  btTriangleInfoMapData *result = 0 ;
  btTriangleInfoMapData *_swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (btTriangleInfoMapData *) ((arg1)->m_triangleInfoMap);
  *(btTriangleInfoMapData **)&_swig_go_result = (btTriangleInfoMapData *)result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_collisionMargin_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, float _swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionMargin = arg2;
  
}


float _wrap_btTriangleMeshShapeData_m_collisionMargin_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_collisionMargin);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTriangleMeshShapeData_m_pad3_set_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad3, (const char *)arg2, 4-1);
      arg1->m_pad3[4-1] = 0;
    } else {
      arg1->m_pad3[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTriangleMeshShapeData_m_pad3_get_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btTriangleMeshShapeData *_wrap_new_btTriangleMeshShapeData_mbt_c1af402c8cb9fdfb() {
  btTriangleMeshShapeData *result = 0 ;
  btTriangleMeshShapeData *_swig_go_result;
  
  
  result = (btTriangleMeshShapeData *)new btTriangleMeshShapeData();
  *(btTriangleMeshShapeData **)&_swig_go_result = (btTriangleMeshShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTriangleMeshShapeData_mbt_c1af402c8cb9fdfb(btTriangleMeshShapeData *_swig_go_0) {
  btTriangleMeshShapeData *arg1 = (btTriangleMeshShapeData *) 0 ;
  
  arg1 = *(btTriangleMeshShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


btContinuousConvexCollision *_wrap_new_btContinuousConvexCollision__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btConvexShape *_swig_go_1, btVoronoiSimplexSolver *_swig_go_2, btConvexPenetrationDepthSolver *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btVoronoiSimplexSolver *arg3 = (btVoronoiSimplexSolver *) 0 ;
  btConvexPenetrationDepthSolver *arg4 = (btConvexPenetrationDepthSolver *) 0 ;
  btContinuousConvexCollision *result = 0 ;
  btContinuousConvexCollision *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btVoronoiSimplexSolver **)&_swig_go_2; 
  arg4 = *(btConvexPenetrationDepthSolver **)&_swig_go_3; 
  
  result = (btContinuousConvexCollision *)new btContinuousConvexCollision((btConvexShape const *)arg1,(btConvexShape const *)arg2,arg3,arg4);
  *(btContinuousConvexCollision **)&_swig_go_result = (btContinuousConvexCollision *)result; 
  return _swig_go_result;
}


btContinuousConvexCollision *_wrap_new_btContinuousConvexCollision__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btStaticPlaneShape *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btStaticPlaneShape *arg2 = (btStaticPlaneShape *) 0 ;
  btContinuousConvexCollision *result = 0 ;
  btContinuousConvexCollision *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btStaticPlaneShape **)&_swig_go_1; 
  
  result = (btContinuousConvexCollision *)new btContinuousConvexCollision((btConvexShape const *)arg1,(btStaticPlaneShape const *)arg2);
  *(btContinuousConvexCollision **)&_swig_go_result = (btContinuousConvexCollision *)result; 
  return _swig_go_result;
}


bool _wrap_btContinuousConvexCollision_calcTimeOfImpact_mbt_c1af402c8cb9fdfb(btContinuousConvexCollision *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4, btConvexCast::CastResult *_swig_go_5) {
  btContinuousConvexCollision *arg1 = (btContinuousConvexCollision *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  btConvexCast::CastResult *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btContinuousConvexCollision **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btConvexCast::CastResult **)&_swig_go_5; 
  
  result = (bool)(arg1)->calcTimeOfImpact((btTransform const &)*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btTransform const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btContinuousConvexCollision_mbt_c1af402c8cb9fdfb(btContinuousConvexCollision *_swig_go_0) {
  btContinuousConvexCollision *arg1 = (btContinuousConvexCollision *) 0 ;
  
  arg1 = *(btContinuousConvexCollision **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btGjkPairDetector_m_lastUsedMethod_set_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, intgo _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_lastUsedMethod = arg2;
  
}


intgo _wrap_btGjkPairDetector_m_lastUsedMethod_get_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_lastUsedMethod);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGjkPairDetector_m_curIter_set_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, intgo _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_curIter = arg2;
  
}


intgo _wrap_btGjkPairDetector_m_curIter_get_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_curIter);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGjkPairDetector_m_degenerateSimplex_set_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, intgo _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_degenerateSimplex = arg2;
  
}


intgo _wrap_btGjkPairDetector_m_degenerateSimplex_get_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_degenerateSimplex);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGjkPairDetector_m_catchDegeneracies_set_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, intgo _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_catchDegeneracies = arg2;
  
}


intgo _wrap_btGjkPairDetector_m_catchDegeneracies_get_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_catchDegeneracies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGjkPairDetector_m_fixContactNormalDirection_set_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, intgo _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_fixContactNormalDirection = arg2;
  
}


intgo _wrap_btGjkPairDetector_m_fixContactNormalDirection_get_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_fixContactNormalDirection);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGjkPairDetector *_wrap_new_btGjkPairDetector__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btConvexShape *_swig_go_1, btVoronoiSimplexSolver *_swig_go_2, btConvexPenetrationDepthSolver *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btVoronoiSimplexSolver *arg3 = (btVoronoiSimplexSolver *) 0 ;
  btConvexPenetrationDepthSolver *arg4 = (btConvexPenetrationDepthSolver *) 0 ;
  btGjkPairDetector *result = 0 ;
  btGjkPairDetector *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btVoronoiSimplexSolver **)&_swig_go_2; 
  arg4 = *(btConvexPenetrationDepthSolver **)&_swig_go_3; 
  
  result = (btGjkPairDetector *)new btGjkPairDetector((btConvexShape const *)arg1,(btConvexShape const *)arg2,arg3,arg4);
  *(btGjkPairDetector **)&_swig_go_result = (btGjkPairDetector *)result; 
  return _swig_go_result;
}


btGjkPairDetector *_wrap_new_btGjkPairDetector__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btConvexShape *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5, btVoronoiSimplexSolver *_swig_go_6, btConvexPenetrationDepthSolver *_swig_go_7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btVoronoiSimplexSolver *arg7 = (btVoronoiSimplexSolver *) 0 ;
  btConvexPenetrationDepthSolver *arg8 = (btConvexPenetrationDepthSolver *) 0 ;
  btGjkPairDetector *result = 0 ;
  btGjkPairDetector *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = *(btVoronoiSimplexSolver **)&_swig_go_6; 
  arg8 = *(btConvexPenetrationDepthSolver **)&_swig_go_7; 
  
  result = (btGjkPairDetector *)new btGjkPairDetector((btConvexShape const *)arg1,(btConvexShape const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  *(btGjkPairDetector **)&_swig_go_result = (btGjkPairDetector *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGjkPairDetector_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btGjkPairDetector_getClosestPoints__SWIG_0_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btDiscreteCollisionDetectorInterface::ClosestPointInput *_swig_go_1, btDiscreteCollisionDetectorInterface::Result *_swig_go_2, btIDebugDraw *_swig_go_3, bool _swig_go_4) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btDiscreteCollisionDetectorInterface::ClosestPointInput *arg2 = 0 ;
  btDiscreteCollisionDetectorInterface::Result *arg3 = 0 ;
  btIDebugDraw *arg4 = (btIDebugDraw *) 0 ;
  bool arg5 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btDiscreteCollisionDetectorInterface::ClosestPointInput **)&_swig_go_1; 
  arg3 = *(btDiscreteCollisionDetectorInterface::Result **)&_swig_go_2; 
  arg4 = *(btIDebugDraw **)&_swig_go_3; 
  arg5 = (bool)_swig_go_4; 
  
  (arg1)->getClosestPoints((btDiscreteCollisionDetectorInterface::ClosestPointInput const &)*arg2,*arg3,arg4,arg5);
  
}


void _wrap_btGjkPairDetector_getClosestPoints__SWIG_1_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btDiscreteCollisionDetectorInterface::ClosestPointInput *_swig_go_1, btDiscreteCollisionDetectorInterface::Result *_swig_go_2, btIDebugDraw *_swig_go_3) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btDiscreteCollisionDetectorInterface::ClosestPointInput *arg2 = 0 ;
  btDiscreteCollisionDetectorInterface::Result *arg3 = 0 ;
  btIDebugDraw *arg4 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btDiscreteCollisionDetectorInterface::ClosestPointInput **)&_swig_go_1; 
  arg3 = *(btDiscreteCollisionDetectorInterface::Result **)&_swig_go_2; 
  arg4 = *(btIDebugDraw **)&_swig_go_3; 
  
  (arg1)->getClosestPoints((btDiscreteCollisionDetectorInterface::ClosestPointInput const &)*arg2,*arg3,arg4);
  
}


void _wrap_btGjkPairDetector_getClosestPointsNonVirtual_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btDiscreteCollisionDetectorInterface::ClosestPointInput *_swig_go_1, btDiscreteCollisionDetectorInterface::Result *_swig_go_2, btIDebugDraw *_swig_go_3) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btDiscreteCollisionDetectorInterface::ClosestPointInput *arg2 = 0 ;
  btDiscreteCollisionDetectorInterface::Result *arg3 = 0 ;
  btIDebugDraw *arg4 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btDiscreteCollisionDetectorInterface::ClosestPointInput **)&_swig_go_1; 
  arg3 = *(btDiscreteCollisionDetectorInterface::Result **)&_swig_go_2; 
  arg4 = *(btIDebugDraw **)&_swig_go_3; 
  
  (arg1)->getClosestPointsNonVirtual((btDiscreteCollisionDetectorInterface::ClosestPointInput const &)*arg2,*arg3,arg4);
  
}


void _wrap_btGjkPairDetector_setMinkowskiA_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btConvexShape *_swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  
  (arg1)->setMinkowskiA((btConvexShape const *)arg2);
  
}


void _wrap_btGjkPairDetector_setMinkowskiB_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btConvexShape *_swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  
  (arg1)->setMinkowskiB((btConvexShape const *)arg2);
  
}


void _wrap_btGjkPairDetector_setCachedSeparatingAxis_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btVector3 *_swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setCachedSeparatingAxis((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btGjkPairDetector_getCachedSeparatingAxis_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (btVector3 *) &((btGjkPairDetector const *)arg1)->getCachedSeparatingAxis();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGjkPairDetector_getCachedSeparatingDistance_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  
  result = (btScalar)((btGjkPairDetector const *)arg1)->getCachedSeparatingDistance();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGjkPairDetector_setPenetrationDepthSolver_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, btConvexPenetrationDepthSolver *_swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  btConvexPenetrationDepthSolver *arg2 = (btConvexPenetrationDepthSolver *) 0 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = *(btConvexPenetrationDepthSolver **)&_swig_go_1; 
  
  (arg1)->setPenetrationDepthSolver(arg2);
  
}


void _wrap_btGjkPairDetector_setIgnoreMargin_mbt_c1af402c8cb9fdfb(btGjkPairDetector *_swig_go_0, bool _swig_go_1) {
  btGjkPairDetector *arg1 = (btGjkPairDetector *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGjkPairDetector **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setIgnoreMargin(arg2);
  
}


btSubsimplexConvexCast *_wrap_new_btSubsimplexConvexCast_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btConvexShape *_swig_go_1, btVoronoiSimplexSolver *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btVoronoiSimplexSolver *arg3 = (btVoronoiSimplexSolver *) 0 ;
  btSubsimplexConvexCast *result = 0 ;
  btSubsimplexConvexCast *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btVoronoiSimplexSolver **)&_swig_go_2; 
  
  result = (btSubsimplexConvexCast *)new btSubsimplexConvexCast((btConvexShape const *)arg1,(btConvexShape const *)arg2,arg3);
  *(btSubsimplexConvexCast **)&_swig_go_result = (btSubsimplexConvexCast *)result; 
  return _swig_go_result;
}


bool _wrap_btSubsimplexConvexCast_calcTimeOfImpact_mbt_c1af402c8cb9fdfb(btSubsimplexConvexCast *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btTransform *_swig_go_4, btConvexCast::CastResult *_swig_go_5) {
  btSubsimplexConvexCast *arg1 = (btSubsimplexConvexCast *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btTransform *arg5 = 0 ;
  btConvexCast::CastResult *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSubsimplexConvexCast **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btConvexCast::CastResult **)&_swig_go_5; 
  
  result = (bool)(arg1)->calcTimeOfImpact((btTransform const &)*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btTransform const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSubsimplexConvexCast_mbt_c1af402c8cb9fdfb(btSubsimplexConvexCast *_swig_go_0) {
  btSubsimplexConvexCast *arg1 = (btSubsimplexConvexCast *) 0 ;
  
  arg1 = *(btSubsimplexConvexCast **)&_swig_go_0; 
  
  delete arg1;
  
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_0_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, float *_swig_go_2, float _swig_go_3, float _swig_go_4, intgo _swig_go_5, bool _swig_go_6) {
  int arg1 ;
  int arg2 ;
  float *arg3 = (float *) 0 ;
  btScalar arg4 ;
  btScalar arg5 ;
  int arg6 ;
  bool arg7 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(float **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  arg7 = (bool)_swig_go_6; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(float const *)arg3,arg4,arg5,arg6,arg7);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_1_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, double *_swig_go_2, float _swig_go_3, float _swig_go_4, intgo _swig_go_5, bool _swig_go_6) {
  int arg1 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  btScalar arg4 ;
  btScalar arg5 ;
  int arg6 ;
  bool arg7 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(double **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  arg7 = (bool)_swig_go_6; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(double const *)arg3,arg4,arg5,arg6,arg7);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_2_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, short *_swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, intgo _swig_go_6, bool _swig_go_7) {
  int arg1 ;
  int arg2 ;
  short *arg3 = (short *) 0 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  int arg7 ;
  bool arg8 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(short **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (int)_swig_go_6; 
  arg8 = (bool)_swig_go_7; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(short const *)arg3,arg4,arg5,arg6,arg7,arg8);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_3_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, char *_swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, intgo _swig_go_6, bool _swig_go_7) {
  int arg1 ;
  int arg2 ;
  unsigned char *arg3 = (unsigned char *) 0 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  int arg7 ;
  bool arg8 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(unsigned char **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (int)_swig_go_6; 
  arg8 = (bool)_swig_go_7; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(unsigned char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_4_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, void *_swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, intgo _swig_go_6, intgo _swig_go_7, bool _swig_go_8) {
  int arg1 ;
  int arg2 ;
  void *arg3 = (void *) 0 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  int arg7 ;
  PHY_ScalarType arg8 ;
  bool arg9 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (int)_swig_go_6; 
  arg8 = (PHY_ScalarType)_swig_go_7; 
  arg9 = (bool)_swig_go_8; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(void const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


btHeightfieldTerrainShape *_wrap_new_btHeightfieldTerrainShape__SWIG_5_mbt_c1af402c8cb9fdfb(intgo _swig_go_0, intgo _swig_go_1, void *_swig_go_2, float _swig_go_3, intgo _swig_go_4, bool _swig_go_5, bool _swig_go_6) {
  int arg1 ;
  int arg2 ;
  void *arg3 = (void *) 0 ;
  btScalar arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  btHeightfieldTerrainShape *result = 0 ;
  btHeightfieldTerrainShape *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = (bool)_swig_go_5; 
  arg7 = (bool)_swig_go_6; 
  
  result = (btHeightfieldTerrainShape *)new btHeightfieldTerrainShape(arg1,arg2,(void const *)arg3,arg4,arg5,arg6,arg7);
  *(btHeightfieldTerrainShape **)&_swig_go_result = (btHeightfieldTerrainShape *)result; 
  return _swig_go_result;
}


void _wrap_delete_btHeightfieldTerrainShape_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btHeightfieldTerrainShape_setUseDiamondSubdivision__SWIG_0_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, bool _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseDiamondSubdivision(arg2);
  
}


void _wrap_btHeightfieldTerrainShape_setUseDiamondSubdivision__SWIG_1_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  (arg1)->setUseDiamondSubdivision();
  
}


void _wrap_btHeightfieldTerrainShape_setUseZigzagSubdivision__SWIG_0_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, bool _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseZigzagSubdivision(arg2);
  
}


void _wrap_btHeightfieldTerrainShape_setUseZigzagSubdivision__SWIG_1_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  (arg1)->setUseZigzagSubdivision();
  
}


void _wrap_btHeightfieldTerrainShape_setFlipTriangleWinding_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, bool _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setFlipTriangleWinding(arg2);
  
}


void _wrap_btHeightfieldTerrainShape_getAabb_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btHeightfieldTerrainShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btHeightfieldTerrainShape_processAllTriangles_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btHeightfieldTerrainShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btHeightfieldTerrainShape_calculateLocalInertia_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btHeightfieldTerrainShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btHeightfieldTerrainShape_setLocalScaling_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btVector3 *_swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btHeightfieldTerrainShape_getLocalScaling_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btHeightfieldTerrainShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_getVertex_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, btVector3 *_swig_go_3) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int arg2 ;
  int arg3 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btHeightfieldTerrainShape const *)arg1)->getVertex(arg2,arg3,*arg4);
  
}


void _wrap_btHeightfieldTerrainShape_performRaycast_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btTriangleCallback *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btTriangleCallback **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btHeightfieldTerrainShape const *)arg1)->performRaycast(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


void _wrap_btHeightfieldTerrainShape_buildAccelerator__SWIG_0_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, intgo _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->buildAccelerator(arg2);
  
}


void _wrap_btHeightfieldTerrainShape_buildAccelerator__SWIG_1_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  (arg1)->buildAccelerator();
  
}


void _wrap_btHeightfieldTerrainShape_clearAccelerator_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  (arg1)->clearAccelerator();
  
}


intgo _wrap_btHeightfieldTerrainShape_getUpAxis_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (int)((btHeightfieldTerrainShape const *)arg1)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btHeightfieldTerrainShape_getName_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (char *)((btHeightfieldTerrainShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setUserValue3_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, float _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setUserValue3(arg2);
  
}


float _wrap_btHeightfieldTerrainShape_getUserValue3_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (btScalar)((btHeightfieldTerrainShape const *)arg1)->getUserValue3();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTriangleInfoMap *_wrap_btHeightfieldTerrainShape_getTriangleInfoMap__SWIG_0_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  btTriangleInfoMap *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (btTriangleInfoMap *)((btHeightfieldTerrainShape const *)arg1)->getTriangleInfoMap();
  *(btTriangleInfoMap **)&_swig_go_result = (btTriangleInfoMap *)result; 
  return _swig_go_result;
}


btTriangleInfoMap *_wrap_btHeightfieldTerrainShape_getTriangleInfoMap__SWIG_1_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTriangleInfoMap *result = 0 ;
  btTriangleInfoMap *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (btTriangleInfoMap *)(arg1)->getTriangleInfoMap();
  *(btTriangleInfoMap **)&_swig_go_result = (btTriangleInfoMap *)result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setTriangleInfoMap_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btTriangleInfoMap *_swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTriangleInfoMap *arg2 = (btTriangleInfoMap *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btTriangleInfoMap **)&_swig_go_1; 
  
  (arg1)->setTriangleInfoMap(arg2);
  
}


char *_wrap_btHeightfieldTerrainShape_getHeightfieldRawData_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  result = (unsigned char *)((btHeightfieldTerrainShape const *)arg1)->getHeightfieldRawData();
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


float _wrap_btHeightfieldTerrainShape_getMargin_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  result = (btScalar)((btConcaveShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setMargin_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, float _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btHeightfieldTerrainShape_getBoundingSphere_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btHeightfieldTerrainShape_getAngularMotionDisc_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btHeightfieldTerrainShape_getContactBreakingThreshold_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, float _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_calculateTemporalAabb_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btHeightfieldTerrainShape_isPolyhedral_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isConvex2d_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isConvex_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isNonMoving_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isConcave_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isCompound_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isSoftBody_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btHeightfieldTerrainShape_isInfinite_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHeightfieldTerrainShape_getShapeType_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btHeightfieldTerrainShape_getAnisotropicRollingFrictionDirection_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = ((btCollisionShape const *)swig_b1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setUserPointer_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, void *_swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserPointer(arg2);
  
}


void *_wrap_btHeightfieldTerrainShape_getUserPointer_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (void *)((btCollisionShape const *)swig_b1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setUserIndex_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, intgo _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex(arg2);
  
}


intgo _wrap_btHeightfieldTerrainShape_getUserIndex_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_setUserIndex2_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, intgo _swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex2(arg2);
  
}


intgo _wrap_btHeightfieldTerrainShape_getUserIndex2_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHeightfieldTerrainShape_calculateSerializeBufferSize_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btHeightfieldTerrainShape_serialize_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (char *)((btCollisionShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btHeightfieldTerrainShape_serializeSingleShape_mbt_c1af402c8cb9fdfb(btHeightfieldTerrainShape *_swig_go_0, btSerializer *_swig_go_1) {
  btHeightfieldTerrainShape *arg1 = (btHeightfieldTerrainShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btHeightfieldTerrainShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConcaveShape *swig_b0 = (btConcaveShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->serializeSingleShape(arg2);
  
}


btGjkEpaPenetrationDepthSolver *_wrap_new_btGjkEpaPenetrationDepthSolver_mbt_c1af402c8cb9fdfb() {
  btGjkEpaPenetrationDepthSolver *result = 0 ;
  btGjkEpaPenetrationDepthSolver *_swig_go_result;
  
  
  result = (btGjkEpaPenetrationDepthSolver *)new btGjkEpaPenetrationDepthSolver();
  *(btGjkEpaPenetrationDepthSolver **)&_swig_go_result = (btGjkEpaPenetrationDepthSolver *)result; 
  return _swig_go_result;
}


bool _wrap_btGjkEpaPenetrationDepthSolver_calcPenDepth_mbt_c1af402c8cb9fdfb(btGjkEpaPenetrationDepthSolver *_swig_go_0, btVoronoiSimplexSolver *_swig_go_1, btConvexShape *_swig_go_2, btConvexShape *_swig_go_3, btTransform *_swig_go_4, btTransform *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, btVector3 *_swig_go_8, btIDebugDraw *_swig_go_9) {
  btGjkEpaPenetrationDepthSolver *arg1 = (btGjkEpaPenetrationDepthSolver *) 0 ;
  btVoronoiSimplexSolver *arg2 = 0 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btConvexShape *arg4 = (btConvexShape *) 0 ;
  btTransform *arg5 = 0 ;
  btTransform *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btVector3 *arg9 = 0 ;
  btIDebugDraw *arg10 = (btIDebugDraw *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGjkEpaPenetrationDepthSolver **)&_swig_go_0; 
  arg2 = *(btVoronoiSimplexSolver **)&_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btConvexShape **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btTransform **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = *(btVector3 **)&_swig_go_8; 
  arg10 = *(btIDebugDraw **)&_swig_go_9; 
  
  result = (bool)(arg1)->calcPenDepth(*arg2,(btConvexShape const *)arg3,(btConvexShape const *)arg4,(btTransform const &)*arg5,(btTransform const &)*arg6,*arg7,*arg8,*arg9,arg10);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btGjkEpaPenetrationDepthSolver_mbt_c1af402c8cb9fdfb(btGjkEpaPenetrationDepthSolver *_swig_go_0) {
  btGjkEpaPenetrationDepthSolver *arg1 = (btGjkEpaPenetrationDepthSolver *) 0 ;
  
  arg1 = *(btGjkEpaPenetrationDepthSolver **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btGjkEpaSolver2_StackSizeRequirement_mbt_c1af402c8cb9fdfb() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGjkEpaSolver2::StackSizeRequirement();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGjkEpaSolver2_Distance_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btConvexShape *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btGjkEpaSolver2::sResults *_swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btGjkEpaSolver2::sResults *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btGjkEpaSolver2::sResults **)&_swig_go_5; 
  
  result = (bool)btGjkEpaSolver2::Distance((btConvexShape const *)arg1,(btTransform const &)*arg2,(btConvexShape const *)arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGjkEpaSolver2_Penetration__SWIG_0_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btConvexShape *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btGjkEpaSolver2::sResults *_swig_go_5, bool _swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btGjkEpaSolver2::sResults *arg6 = 0 ;
  bool arg7 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btGjkEpaSolver2::sResults **)&_swig_go_5; 
  arg7 = (bool)_swig_go_6; 
  
  result = (bool)btGjkEpaSolver2::Penetration((btConvexShape const *)arg1,(btTransform const &)*arg2,(btConvexShape const *)arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,*arg6,arg7);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGjkEpaSolver2_Penetration__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btConvexShape *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btGjkEpaSolver2::sResults *_swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btGjkEpaSolver2::sResults *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btGjkEpaSolver2::sResults **)&_swig_go_5; 
  
  result = (bool)btGjkEpaSolver2::Penetration((btConvexShape const *)arg1,(btTransform const &)*arg2,(btConvexShape const *)arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGjkEpaSolver2_SignedDistance__SWIG_0_mbt_c1af402c8cb9fdfb(btVector3 *_swig_go_0, float _swig_go_1, btConvexShape *_swig_go_2, btTransform *_swig_go_3, btGjkEpaSolver2::sResults *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btTransform *arg4 = 0 ;
  btGjkEpaSolver2::sResults *arg5 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btGjkEpaSolver2::sResults **)&_swig_go_4; 
  
  result = (btScalar)btGjkEpaSolver2::SignedDistance((btVector3 const &)*arg1,arg2,(btConvexShape const *)arg3,(btTransform const &)*arg4,*arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGjkEpaSolver2_SignedDistance__SWIG_1_mbt_c1af402c8cb9fdfb(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btConvexShape *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btGjkEpaSolver2::sResults *_swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btConvexShape *arg3 = (btConvexShape *) 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btGjkEpaSolver2::sResults *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btConvexShape **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btGjkEpaSolver2::sResults **)&_swig_go_5; 
  
  result = (bool)btGjkEpaSolver2::SignedDistance((btConvexShape const *)arg1,(btTransform const &)*arg2,(btConvexShape const *)arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGjkEpaSolver2 *_wrap_new_btGjkEpaSolver2_mbt_c1af402c8cb9fdfb() {
  btGjkEpaSolver2 *result = 0 ;
  btGjkEpaSolver2 *_swig_go_result;
  
  
  result = (btGjkEpaSolver2 *)new btGjkEpaSolver2();
  *(btGjkEpaSolver2 **)&_swig_go_result = (btGjkEpaSolver2 *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGjkEpaSolver2_mbt_c1af402c8cb9fdfb(btGjkEpaSolver2 *_swig_go_0) {
  btGjkEpaSolver2 *arg1 = (btGjkEpaSolver2 *) 0 ;
  
  arg1 = *(btGjkEpaSolver2 **)&_swig_go_0; 
  
  delete arg1;
  
}


#ifdef __cplusplus
}
#endif

