/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

// source: C:\MMD\mlib_go\pkg\mbt\bullet.i


extern
#ifdef __cplusplus
  "C"
#endif
  void cgo_panic__mbt_e1d552452a96202d(const char*);
static void _swig_gopanic(const char *p) {
  cgo_panic__mbt_e1d552452a96202d(p);
}



#define SWIG_VERSION 0x040200
#define SWIGGO
#define SWIGMODULE mbt
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 


/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif



#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>



typedef ptrdiff_t intgo;
typedef size_t uintgo;


# if !defined(__clang__) && (defined(__i386__) || defined(__x86_64__))
#   define SWIGSTRUCTPACKED __attribute__((__packed__, __gcc_struct__))
# else
#   define SWIGSTRUCTPACKED __attribute__((__packed__))
# endif



typedef struct { char *p; intgo n; } _gostring_;
typedef struct { void* array; intgo len; intgo cap; } _goslice_;



static _gostring_ Swig_AllocateString(const char *p, size_t l) {
  _gostring_ ret;
  ret.p = (char*)malloc(l);
  memcpy(ret.p, p, l);
  ret.n = l;
  return ret;
}


#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


static void Swig_free(void* p) {
  free(p);
}

static void* Swig_malloc(int c) {
  return malloc(c);
}


    #include <cmath>
    #include <string>


#define FLT_EPSILON      1.192092896e-07F        // smallest such that 1.0+FLT_EPSILON != 1.0
#define FLT_MAX          3.402823466e+38F        // max value



/* 7.12.4 Trigonometric functions: Double in C89 */
  extern float __cdecl sinf(float _X);
  extern long double __cdecl sinl(long double);

  extern float __cdecl cosf(float _X);
  extern long double __cdecl cosl(long double);

  extern float __cdecl tanf(float _X);
  extern long double __cdecl tanl(long double);
  extern float __cdecl asinf(float _X);
  extern long double __cdecl asinl(long double);

  extern float __cdecl acosf (float);
  extern long double __cdecl acosl (long double);

  extern float __cdecl atanf (float);
  extern long double __cdecl atanl (long double);

  extern float __cdecl atan2f (float, float);
  extern long double __cdecl atan2l (long double, long double);

/* 7.12.6.1 Double in C89 */
  extern float __cdecl expf(float _X);

/* 7.12.6.7 Double in C89 */
  extern float __cdecl logf (float);

/* 7.12.7.4 The pow functions. Double in C89 */
  extern float __cdecl powf(float _X,float _Y);

/* 7.12.7.5 The sqrt functions. Double in C89. */
  extern float __cdecl sqrtf (float);

/* 7.12.7.2 The fabs functions: Double in C89 */
  extern  float __cdecl fabsf (float x);

/* 7.12.10.1 Double in C89 */
  extern float __cdecl fmodf (float, float);




/*
Copyright (c) 2003-2009 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SCALAR_H
#define BT_SCALAR_H

#ifdef BT_MANAGED_CODE
//Aligned data types not supported in managed code
#pragma unmanaged
#endif


/* SVN $Revision$ on $Date$ from http://bullet.googlecode.com*/
#define BT_BULLET_VERSION 326

inline int btGetVersion()
{
	return BT_BULLET_VERSION;
}

inline int btIsDoublePrecision()
{
  #ifdef BT_USE_DOUBLE_PRECISION
  return true;
  #else
  return false;
  #endif
}


// The following macro "BT_NOT_EMPTY_FILE" can be put into a file
// in order suppress the MS Visual C++ Linker warning 4221
//
// warning LNK4221: no public symbols found; archive member will be inaccessible
//
// This warning occurs on PC and XBOX when a file compiles out completely
// has no externally visible symbols which may be dependant on configuration
// #defines and options.
//
// see more https://stackoverflow.com/questions/1822887/what-is-the-best-way-to-eliminate-ms-visual-c-linker-warning-warning-lnk422

#if defined(_MSC_VER)
#define BT_NOT_EMPTY_FILE_CAT_II(p, res) res
#define BT_NOT_EMPTY_FILE_CAT_I(a, b) BT_NOT_EMPTY_FILE_CAT_II(~, a##b)
#define BT_NOT_EMPTY_FILE_CAT(a, b) BT_NOT_EMPTY_FILE_CAT_I(a, b)
#define BT_NOT_EMPTY_FILE                                      \
	namespace                                                  \
	{                                                          \
	char BT_NOT_EMPTY_FILE_CAT(NoEmptyFileDummy, __COUNTER__); \
	}
#else
#define BT_NOT_EMPTY_FILE
#endif

// clang and most formatting tools don't support indentation of preprocessor guards, so turn it off
// clang-format off
#if defined(DEBUG) || defined (_DEBUG)
	#define BT_DEBUG
#endif

#ifdef _WIN32
	#if  defined(__GNUC__)	// it should handle both MINGW and CYGWIN
        	#define SIMD_FORCE_INLINE        __inline__ __attribute__((always_inline))
        	#define ATTRIBUTE_ALIGNED16(a)   a __attribute__((aligned(16)))
        	#define ATTRIBUTE_ALIGNED64(a)   a __attribute__((aligned(64)))
        	#define ATTRIBUTE_ALIGNED128(a)  a __attribute__((aligned(128)))
    	#elif ( defined(_MSC_VER) && _MSC_VER < 1300 )
		#define SIMD_FORCE_INLINE inline
		#define ATTRIBUTE_ALIGNED16(a) a
		#define ATTRIBUTE_ALIGNED64(a) a
		#define ATTRIBUTE_ALIGNED128(a) a
	#elif defined(_M_ARM)
		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec() a
		#define ATTRIBUTE_ALIGNED64(a) __declspec() a
		#define ATTRIBUTE_ALIGNED128(a) __declspec () a
	#else//__MINGW32__
		//#define BT_HAS_ALIGNED_ALLOCATOR
		#pragma warning(disable : 4324) // disable padding warning
//			#pragma warning(disable:4530) // Disable the exception disable but used in MSCV Stl warning.
		#pragma warning(disable:4996) //Turn off warnings about deprecated C routines
//			#pragma warning(disable:4786) // Disable the "debug name too long" warning

		#define SIMD_FORCE_INLINE __forceinline
		#define ATTRIBUTE_ALIGNED16(a) __declspec(align(16)) a
		#define ATTRIBUTE_ALIGNED64(a) __declspec(align(64)) a
		#define ATTRIBUTE_ALIGNED128(a) __declspec (align(128)) a
		#ifdef _XBOX
			#define BT_USE_VMX128

 			#define BT_HAVE_NATIVE_FSEL
 			#define btFsel(a,b,c) __fsel((a),(b),(c))
		#else

#if defined (_M_ARM) || defined (_M_ARM64)
            //Do not turn SSE on for ARM (may want to turn on BT_USE_NEON however)
#elif (defined (_WIN32) && (_MSC_VER) && _MSC_VER >= 1400) && (!defined (BT_USE_DOUBLE_PRECISION))

#ifdef __clang__
#define __BT_DISABLE_SSE__
#endif
#ifndef __BT_DISABLE_SSE__
			#if _MSC_VER>1400
				#define BT_USE_SIMD_VECTOR3
			#endif
			#define BT_USE_SSE
#endif//__BT_DISABLE_SSE__
			#ifdef BT_USE_SSE

#if (_MSC_FULL_VER >= 170050727)//Visual Studio 2012 can compile SSE4/FMA3 (but SSE4/FMA3 is not enabled by default)
			#define BT_ALLOW_SSE4
#endif //(_MSC_FULL_VER >= 160040219)

			//BT_USE_SSE_IN_API is disabled under Windows by default, because 
			//it makes it harder to integrate Bullet into your application under Windows 
			//(structured embedding Bullet structs/classes need to be 16-byte aligned)
			//with relatively little performance gain
			//If you are not embedded Bullet data in your classes, or make sure that you align those classes on 16-byte boundaries
			//you can manually enable this line or set it in the build system for a bit of performance gain (a few percent, dependent on usage)
			//#define BT_USE_SSE_IN_API
			#endif //BT_USE_SSE
#endif

		#endif//_XBOX

	#endif //__MINGW32__

	#ifdef BT_DEBUG
		#ifdef _MSC_VER
			#define btAssert(x) { if(!(x)){printf("Assert " __FILE__ ":%u (%s)\n", __LINE__, #x);__debugbreak();	}}
		#else//_MSC_VER
			#define btAssert assert
		#endif//_MSC_VER
	#else
		#define btAssert(x)
	#endif
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

#else//_WIN32
	
	#if defined	(__CELLOS_LV2__)
		#define SIMD_FORCE_INLINE inline __attribute__((always_inline))
		#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
		#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
		#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
		#ifndef assert
		#endif
		#ifdef BT_DEBUG
			#ifdef __SPU__
				#define printf spu_printf
				#define btAssert(x) {if(!(x)){printf("Assert " __FILE__ ":%u ("#x")\n", __LINE__);spu_hcmpeq(0,0);}}
			#else
				#define btAssert assert
			#endif
	
		#else//BT_DEBUG
				#define btAssert(x)
		#endif//BT_DEBUG
		//btFullAssert is optional, slows down a lot
		#define btFullAssert(x)

		#define btLikely(_c)  _c
		#define btUnlikely(_c) _c

	#else//defined	(__CELLOS_LV2__)

		#ifdef USE_LIBSPE2

			#define SIMD_FORCE_INLINE __inline
			#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
			#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
			#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
			#ifndef assert
			#endif
	#ifdef BT_DEBUG
			#define btAssert assert
	#else
			#define btAssert(x)
	#endif
			//btFullAssert is optional, slows down a lot
			#define btFullAssert(x)


			#define btLikely(_c)   __builtin_expect((_c), 1)
			#define btUnlikely(_c) __builtin_expect((_c), 0)
		

		#else//USE_LIBSPE2
	//non-windows systems

			#if (defined (__APPLE__) && (!defined (BT_USE_DOUBLE_PRECISION)))
				#if defined (__i386__) || defined (__x86_64__)
					#define BT_USE_SIMD_VECTOR3
					#define BT_USE_SSE
					//BT_USE_SSE_IN_API is enabled on Mac OSX by default, because memory is automatically aligned on 16-byte boundaries
					//if apps run into issues, we will disable the next line
					#define BT_USE_SSE_IN_API
					#ifdef BT_USE_SSE
						// include appropriate SSE level
						#if defined (__SSE4_1__)
						#elif defined (__SSSE3__)
						#elif defined (__SSE3__)
						#else
						#endif
					#endif //BT_USE_SSE
				#elif defined( __ARM_NEON__ )
					#ifdef __clang__
						#define BT_USE_NEON 1
						#define BT_USE_SIMD_VECTOR3
		
						#if defined BT_USE_NEON && defined (__clang__)
						#endif//BT_USE_NEON
				   #endif //__clang__
				#endif//__arm__

				#define SIMD_FORCE_INLINE inline __attribute__ ((always_inline))
			///@todo: check out alignment methods for other platforms/compilers
				#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
				 #if defined (__i386__) || defined (__x86_64__)
				 #define btAssert(x)\
				{\
				if(!(x))\
				{\
					printf("Assert %s in line %d, file %s\n",#x, __LINE__, __FILE__);\
					asm volatile ("int3");\
				}\
				}
				#else//defined (__i386__) || defined (__x86_64__)
					#define btAssert assert
				#endif//defined (__i386__) || defined (__x86_64__)
				#else//defined(DEBUG) || defined (_DEBUG)
					#define btAssert(x)
				#endif//defined(DEBUG) || defined (_DEBUG)

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c

			#else//__APPLE__

				#define SIMD_FORCE_INLINE inline
				///@todo: check out alignment methods for other platforms/compilers
				///#define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				///#define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				///#define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128)))
				#define ATTRIBUTE_ALIGNED16(a) a
				#define ATTRIBUTE_ALIGNED64(a) a
				#define ATTRIBUTE_ALIGNED128(a) a
				#ifndef assert
				#endif

				#if defined(DEBUG) || defined (_DEBUG)
					#define btAssert assert
				#else
					#define btAssert(x)
				#endif

				//btFullAssert is optional, slows down a lot
				#define btFullAssert(x)
				#define btLikely(_c)  _c
				#define btUnlikely(_c) _c
			#endif //__APPLE__ 
		#endif // LIBSPE2
	#endif	//__CELLOS_LV2__
#endif//_WIN32


///The btScalar type abstracts floating point numbers, to easily switch between double and single floating point precision.
#if defined(BT_USE_DOUBLE_PRECISION)
	typedef double btScalar;
	//this number could be bigger in double precision
	#define BT_LARGE_FLOAT 1e30
#else
	typedef float btScalar;
	//keep BT_LARGE_FLOAT*BT_LARGE_FLOAT < FLT_MAX
	#define BT_LARGE_FLOAT 1e18f
#endif

#ifdef BT_USE_SSE
	typedef __m128 btSimdFloat4;
#endif  //BT_USE_SSE

#if defined(BT_USE_SSE)
	//#if defined BT_USE_SSE_IN_API && defined (BT_USE_SSE)
	#ifdef _WIN32

		#ifndef BT_NAN
			static int btNanMask = 0x7F800001;
			#define BT_NAN (*(float *)&btNanMask)
		#endif

		#ifndef BT_INFINITY
			static int btInfinityMask = 0x7F800000;
			#define BT_INFINITY (*(float *)&btInfinityMask)
			inline int btGetInfinityMask()  //suppress stupid compiler warning
			{
				return btInfinityMask;
			}
		#endif



	//use this, in case there are clashes (such as xnamath.h)
	#ifndef BT_NO_SIMD_OPERATOR_OVERLOADS
	inline __m128 operator+(const __m128 A, const __m128 B)
	{
		return _mm_add_ps(A, B);
	}

	inline __m128 operator-(const __m128 A, const __m128 B)
	{
		return _mm_sub_ps(A, B);
	}

	inline __m128 operator*(const __m128 A, const __m128 B)
	{
		return _mm_mul_ps(A, B);
	}
	#endif  //BT_NO_SIMD_OPERATOR_OVERLOADS

	#define btCastfTo128i(a) (_mm_castps_si128(a))
	#define btCastfTo128d(a) (_mm_castps_pd(a))
	#define btCastiTo128f(a) (_mm_castsi128_ps(a))
	#define btCastdTo128f(a) (_mm_castpd_ps(a))
	#define btCastdTo128i(a) (_mm_castpd_si128(a))
	#define btAssign128(r0, r1, r2, r3) _mm_setr_ps(r0, r1, r2, r3)

	#else  //_WIN32

		#define btCastfTo128i(a) ((__m128i)(a))
		#define btCastfTo128d(a) ((__m128d)(a))
		#define btCastiTo128f(a) ((__m128)(a))
		#define btCastdTo128f(a) ((__m128)(a))
		#define btCastdTo128i(a) ((__m128i)(a))
		#define btAssign128(r0, r1, r2, r3) \
			(__m128) { r0, r1, r2, r3 }
		#define BT_INFINITY INFINITY
		#define BT_NAN NAN
	#endif  //_WIN32
#else//BT_USE_SSE

	#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
	#else  //BT_USE_NEON

	#ifndef BT_INFINITY
	struct btInfMaskConverter
	{
		union {
			float mask;
			int intmask;
		};
		btInfMaskConverter(int _mask = 0x7F800000)
			: intmask(_mask)
		{
		}
	};
	static btInfMaskConverter btInfinityMask = 0x7F800000;
	#define BT_INFINITY (btInfinityMask.mask)
	inline int btGetInfinityMask()  //suppress stupid compiler warning
	{
		return btInfinityMask.intmask;
	}
	#endif
	#endif  //BT_USE_NEON

#endif  //BT_USE_SSE

#ifdef BT_USE_NEON

	typedef float32x4_t btSimdFloat4;
	#define BT_INFINITY INFINITY
	#define BT_NAN NAN
	#define btAssign128(r0, r1, r2, r3) \
		(float32x4_t) { r0, r1, r2, r3 }
#endif//BT_USE_NEON

#define BT_DECLARE_ALIGNED_ALLOCATOR()                                                                     \
	SIMD_FORCE_INLINE void *operator new(size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); }   \
	SIMD_FORCE_INLINE void operator delete(void *ptr) { btAlignedFree(ptr); }                              \
	SIMD_FORCE_INLINE void *operator new(size_t, void *ptr) { return ptr; }                                \
	SIMD_FORCE_INLINE void operator delete(void *, void *) {}                                              \
	SIMD_FORCE_INLINE void *operator new[](size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); } \
	SIMD_FORCE_INLINE void operator delete[](void *ptr) { btAlignedFree(ptr); }                            \
	SIMD_FORCE_INLINE void *operator new[](size_t, void *ptr) { return ptr; }                              \
	SIMD_FORCE_INLINE void operator delete[](void *, void *) {}

#if defined(BT_USE_DOUBLE_PRECISION) || defined(BT_FORCE_DOUBLE_FUNCTIONS)

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar x)
	{
		return sqrt(x);
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabs(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cos(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sin(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tan(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return acos(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1)) x = btScalar(-1);
		if (x > btScalar(1)) x = btScalar(1);
		return asin(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atan(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return exp(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return log(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return pow(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmod(x, y); }

#else//BT_USE_DOUBLE_PRECISION

	SIMD_FORCE_INLINE btScalar btSqrt(btScalar y)
	{
	#ifdef USE_APPROXIMATION
	#ifdef __LP64__
		float xhalf = 0.5f * y;
		int i = *(int *)&y;
		i = 0x5f375a86 - (i >> 1);
		y = *(float *)&i;
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = y * (1.5f - xhalf * y * y);
		y = 1 / y;
		return y;
	#else
		double x, z, tempf;
		unsigned long *tfptr = ((unsigned long *)&tempf) + 1;
		tempf = y;
		*tfptr = (0xbfcdd90a - *tfptr) >> 1; /* estimate of 1/sqrt(y) */
		x = tempf;
		z = y * btScalar(0.5);
		x = (btScalar(1.5) * x) - (x * x) * (x * z); /* iteration formula     */
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		x = (btScalar(1.5) * x) - (x * x) * (x * z);
		return x * y;
	#endif
	#else
		return sqrtf(y);
	#endif
	}
	SIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabsf(x); }
	SIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cosf(x); }
	SIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sinf(x); }
	SIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tanf(x); }
	SIMD_FORCE_INLINE btScalar btAcos(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return acosf(x);
	}
	SIMD_FORCE_INLINE btScalar btAsin(btScalar x)
	{
		if (x < btScalar(-1))
			x = btScalar(-1);
		if (x > btScalar(1))
			x = btScalar(1);
		return asinf(x);
	}
	SIMD_FORCE_INLINE btScalar btAtan(btScalar x) { return atanf(x); }
	SIMD_FORCE_INLINE btScalar btAtan2(btScalar x, btScalar y) { return atan2f(x, y); }
	SIMD_FORCE_INLINE btScalar btExp(btScalar x) { return expf(x); }
	SIMD_FORCE_INLINE btScalar btLog(btScalar x) { return logf(x); }
	SIMD_FORCE_INLINE btScalar btPow(btScalar x, btScalar y) { return powf(x, y); }
	SIMD_FORCE_INLINE btScalar btFmod(btScalar x, btScalar y) { return fmodf(x, y); }

#endif//BT_USE_DOUBLE_PRECISION

#define SIMD_PI btScalar(3.1415926535897932384626433832795029)
#define SIMD_2_PI (btScalar(2.0) * SIMD_PI)
#define SIMD_HALF_PI (SIMD_PI * btScalar(0.5))
#define SIMD_RADS_PER_DEG (SIMD_2_PI / btScalar(360.0))
#define SIMD_DEGS_PER_RAD (btScalar(360.0) / SIMD_2_PI)
#define SIMDSQRT12 btScalar(0.7071067811865475244008443621048490)
#define btRecipSqrt(x) ((btScalar)(btScalar(1.0) / btSqrt(btScalar(x)))) /* reciprocal square root */
#define btRecip(x) (btScalar(1.0) / btScalar(x))

#ifdef BT_USE_DOUBLE_PRECISION
	#define SIMD_EPSILON DBL_EPSILON
	#define SIMD_INFINITY DBL_MAX
	#define BT_ONE 1.0
	#define BT_ZERO 0.0
	#define BT_TWO 2.0
	#define BT_HALF 0.5
#else
	#define SIMD_EPSILON FLT_EPSILON
	#define SIMD_INFINITY FLT_MAX
	#define BT_ONE 1.0f
	#define BT_ZERO 0.0f
	#define BT_TWO 2.0f
	#define BT_HALF 0.5f
#endif

// clang-format on

SIMD_FORCE_INLINE btScalar btAtan2Fast(btScalar y, btScalar x)
{
	btScalar coeff_1 = SIMD_PI / 4.0f;
	btScalar coeff_2 = 3.0f * coeff_1;
	btScalar abs_y = btFabs(y);
	btScalar angle;
	if (x >= 0.0f)
	{
		btScalar r = (x - abs_y) / (x + abs_y);
		angle = coeff_1 - coeff_1 * r;
	}
	else
	{
		btScalar r = (x + abs_y) / (abs_y - x);
		angle = coeff_2 - coeff_1 * r;
	}
	return (y < 0.0f) ? -angle : angle;
}

SIMD_FORCE_INLINE bool btFuzzyZero(btScalar x) { return btFabs(x) < SIMD_EPSILON; }

SIMD_FORCE_INLINE bool btEqual(btScalar a, btScalar eps)
{
	return (((a) <= eps) && !((a) < -eps));
}
SIMD_FORCE_INLINE bool btGreaterEqual(btScalar a, btScalar eps)
{
	return (!((a) <= eps));
}

SIMD_FORCE_INLINE int btIsNegative(btScalar x)
{
	return x < btScalar(0.0) ? 1 : 0;
}

SIMD_FORCE_INLINE btScalar btRadians(btScalar x) { return x * SIMD_RADS_PER_DEG; }
SIMD_FORCE_INLINE btScalar btDegrees(btScalar x) { return x * SIMD_DEGS_PER_RAD; }

#define BT_DECLARE_HANDLE(name) \
	typedef struct name##__     \
	{                           \
		int unused;             \
	} * name

#ifndef btFsel
SIMD_FORCE_INLINE btScalar btFsel(btScalar a, btScalar b, btScalar c)
{
	return a >= 0 ? b : c;
}
#endif
#define btFsels(a, b, c) (btScalar) btFsel(a, b, c)

SIMD_FORCE_INLINE bool btMachineIsLittleEndian()
{
	long int i = 1;
	const char *p = (const char *)&i;
	if (p[0] == 1)  // Lowest address contains the least significant byte
		return true;
	else
		return false;
}

///btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
///Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html
SIMD_FORCE_INLINE unsigned btSelect(unsigned condition, unsigned valueIfConditionNonZero, unsigned valueIfConditionZero)
{
	// Set testNz to 0xFFFFFFFF if condition is nonzero, 0x00000000 if condition is zero
	// Rely on positive value or'ed with its negative having sign bit on
	// and zero value or'ed with its negative (which is still zero) having sign bit off
	// Use arithmetic shift right, shifting the sign bit through all 32 bits
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return ((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE int btSelect(unsigned condition, int valueIfConditionNonZero, int valueIfConditionZero)
{
	unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
	unsigned testEqz = ~testNz;
	return static_cast<int>((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
SIMD_FORCE_INLINE float btSelect(unsigned condition, float valueIfConditionNonZero, float valueIfConditionZero)
{
#ifdef BT_HAVE_NATIVE_FSEL
	return (float)btFsel((btScalar)condition - btScalar(1.0f), valueIfConditionNonZero, valueIfConditionZero);
#else
	return (condition != 0) ? valueIfConditionNonZero : valueIfConditionZero;
#endif
}

template <typename T>
SIMD_FORCE_INLINE void btSwap(T &a, T &b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

//PCK: endian swapping functions
SIMD_FORCE_INLINE unsigned btSwapEndian(unsigned val)
{
	return (((val & 0xff000000) >> 24) | ((val & 0x00ff0000) >> 8) | ((val & 0x0000ff00) << 8) | ((val & 0x000000ff) << 24));
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(unsigned short val)
{
	return static_cast<unsigned short>(((val & 0xff00) >> 8) | ((val & 0x00ff) << 8));
}

SIMD_FORCE_INLINE unsigned btSwapEndian(int val)
{
	return btSwapEndian((unsigned)val);
}

SIMD_FORCE_INLINE unsigned short btSwapEndian(short val)
{
	return btSwapEndian((unsigned short)val);
}

///btSwapFloat uses using char pointers to swap the endianness
////btSwapFloat/btSwapDouble will NOT return a float, because the machine might 'correct' invalid floating point values
///Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754.
///When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception.
///In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you.
///so instead of returning a float/double, we return integer/long long integer
SIMD_FORCE_INLINE unsigned int btSwapEndianFloat(float d)
{
	unsigned int a = 0;
	unsigned char *dst = (unsigned char *)&a;
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];
	return a;
}

// unswap using char pointers
SIMD_FORCE_INLINE float btUnswapEndianFloat(unsigned int a)
{
	float d = 0.0f;
	unsigned char *src = (unsigned char *)&a;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[3];
	dst[1] = src[2];
	dst[2] = src[1];
	dst[3] = src[0];

	return d;
}

// swap using char pointers
SIMD_FORCE_INLINE void btSwapEndianDouble(double d, unsigned char *dst)
{
	unsigned char *src = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];
}

// unswap using char pointers
SIMD_FORCE_INLINE double btUnswapEndianDouble(const unsigned char *src)
{
	double d = 0.0;
	unsigned char *dst = (unsigned char *)&d;

	dst[0] = src[7];
	dst[1] = src[6];
	dst[2] = src[5];
	dst[3] = src[4];
	dst[4] = src[3];
	dst[5] = src[2];
	dst[6] = src[1];
	dst[7] = src[0];

	return d;
}

template <typename T>
SIMD_FORCE_INLINE void btSetZero(T *a, int n)
{
	T *acurr = a;
	size_t ncurr = n;
	while (ncurr > 0)
	{
		*(acurr++) = 0;
		--ncurr;
	}
}

SIMD_FORCE_INLINE btScalar btLargeDot(const btScalar *a, const btScalar *b, int n)
{
	btScalar p0, q0, m0, p1, q1, m1, sum;
	sum = 0;
	n -= 2;
	while (n >= 0)
	{
		p0 = a[0];
		q0 = b[0];
		m0 = p0 * q0;
		p1 = a[1];
		q1 = b[1];
		m1 = p1 * q1;
		sum += m0;
		sum += m1;
		a += 2;
		b += 2;
		n -= 2;
	}
	n += 2;
	while (n > 0)
	{
		sum += (*a) * (*b);
		a++;
		b++;
		n--;
	}
	return sum;
}

// returns normalized value in range [-SIMD_PI, SIMD_PI]
SIMD_FORCE_INLINE btScalar btNormalizeAngle(btScalar angleInRadians)
{
	angleInRadians = btFmod(angleInRadians, SIMD_2_PI);
	if (angleInRadians < -SIMD_PI)
	{
		return angleInRadians + SIMD_2_PI;
	}
	else if (angleInRadians > SIMD_PI)
	{
		return angleInRadians - SIMD_2_PI;
	}
	else
	{
		return angleInRadians;
	}
}

///rudimentary class to provide type info
struct btTypedObject
{
	btTypedObject(int objectType)
		: m_objectType(objectType)
	{
	}
	int m_objectType;
	inline int getObjectType() const
	{
		return m_objectType;
	}
};

///align a pointer to the provided alignment, upwards
template <typename T>
T *btAlignPointer(T *unalignedPtr, size_t alignment)
{
	struct btConvertPointerSizeT
	{
		union {
			T *ptr;
			size_t integer;
		};
	};
	btConvertPointerSizeT converter;

	const size_t bit_mask = ~(alignment - 1);
	converter.ptr = unalignedPtr;
	converter.integer += alignment - 1;
	converter.integer &= bit_mask;
	return converter.ptr;
}

#endif  //BT_SCALAR_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEN_MINMAX_H
#define BT_GEN_MINMAX_H

#include "LinearMath/btScalar.h"

template <class T>
SIMD_FORCE_INLINE const T& btMin(const T& a, const T& b)
{
	return a < b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btMax(const T& a, const T& b)
{
	return a > b ? a : b;
}

template <class T>
SIMD_FORCE_INLINE const T& btClamped(const T& a, const T& lb, const T& ub)
{
	return a < lb ? lb : (ub < a ? ub : a);
}

template <class T>
SIMD_FORCE_INLINE void btSetMin(T& a, const T& b)
{
	if (b < a)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btSetMax(T& a, const T& b)
{
	if (a < b)
	{
		a = b;
	}
}

template <class T>
SIMD_FORCE_INLINE void btClamp(T& a, const T& lb, const T& ub)
{
	if (a < lb)
	{
		a = lb;
	}
	else if (ub < a)
	{
		a = ub;
	}
}

#endif  //BT_GEN_MINMAX_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_ALIGNED_ALLOCATOR
#define BT_ALIGNED_ALLOCATOR

///we probably replace this with our own aligned memory allocator
///so we replace _aligned_malloc and _aligned_free with our own
///that is better portable and more predictable

#include "LinearMath/btScalar.h"

///BT_DEBUG_MEMORY_ALLOCATIONS preprocessor can be set in build system
///for regression tests to detect memory leaks
///#define BT_DEBUG_MEMORY_ALLOCATIONS 1
#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

int btDumpMemoryLeaks();

#define btAlignedAlloc(a, b) \
	btAlignedAllocInternal(a, b, __LINE__, __FILE__)

#define btAlignedFree(ptr) \
	btAlignedFreeInternal(ptr, __LINE__, __FILE__)

void* btAlignedAllocInternal(size_t size, int alignment, int line, const char* filename);

void btAlignedFreeInternal(void* ptr, int line, const char* filename);

#else
void* btAlignedAllocInternal(size_t size, int alignment);
void btAlignedFreeInternal(void* ptr);

#define btAlignedAlloc(size, alignment) btAlignedAllocInternal(size, alignment)
#define btAlignedFree(ptr) btAlignedFreeInternal(ptr)

#endif
typedef int size_type;

typedef void*(btAlignedAllocFunc)(size_t size, int alignment);
typedef void(btAlignedFreeFunc)(void* memblock);
typedef void*(btAllocFunc)(size_t size);
typedef void(btFreeFunc)(void* memblock);

///The developer can let all Bullet memory allocations go through a custom memory allocator, using btAlignedAllocSetCustom
void btAlignedAllocSetCustom(btAllocFunc* allocFunc, btFreeFunc* freeFunc);
///If the developer has already an custom aligned allocator, then btAlignedAllocSetCustomAligned can be used. The default aligned allocator pre-allocates extra memory using the non-aligned allocator, and instruments it.
void btAlignedAllocSetCustomAligned(btAlignedAllocFunc* allocFunc, btAlignedFreeFunc* freeFunc);

///The btAlignedAllocator is a portable class for aligned memory allocations.
///Default implementations for unaligned and aligned allocations can be overridden by a custom allocator using btAlignedAllocSetCustom and btAlignedAllocSetCustomAligned.
template <typename T, unsigned Alignment>
class btAlignedAllocator
{
	typedef btAlignedAllocator<T, Alignment> self_type;

public:
	//just going down a list:
	btAlignedAllocator() {}
	/*
	btAlignedAllocator( const self_type & ) {}
	*/

	template <typename Other>
	btAlignedAllocator(const btAlignedAllocator<Other, Alignment>&)
	{
	}

	typedef const T* const_pointer;
	typedef const T& const_reference;
	typedef T* pointer;
	typedef T& reference;
	typedef T value_type;

	pointer address(reference ref) const { return &ref; }
	const_pointer address(const_reference ref) const { return &ref; }
	pointer allocate(size_type n, const_pointer* hint = 0)
	{
		(void)hint;
		return reinterpret_cast<pointer>(btAlignedAlloc(sizeof(value_type) * n, Alignment));
	}
	void construct(pointer ptr, const value_type& value) { new (ptr) value_type(value); }
	void deallocate(pointer ptr)
	{
		btAlignedFree(reinterpret_cast<void*>(ptr));
	}
	void destroy(pointer ptr) { ptr->~value_type(); }

	template <typename O>
	struct rebind
	{
		typedef btAlignedAllocator<O, Alignment> other;
	};
	template <typename O>
	self_type& operator=(const btAlignedAllocator<O, Alignment>&)
	{
		return *this;
	}

	friend bool operator==(const self_type&, const self_type&) { return true; }
};

#endif  //BT_ALIGNED_ALLOCATOR





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS
int gNumAlignedAllocs = 0;
int gNumAlignedFree = 0;
int gTotalBytesAlignedAllocs = 0;  //detect memory leaks
#endif                             //BT_DEBUG_MEMORY_ALLOCATIONST_DEBUG_ALLOCATIONS

static void *btAllocDefault(size_t size)
{
  char* data = (char*) malloc(size);
  memset(data,0,size);//keep msan happy
  return data;
}

static void btFreeDefault(void *ptr)
{
	free(ptr);
}

static btAllocFunc *sAllocFunc = btAllocDefault;
static btFreeFunc *sFreeFunc = btFreeDefault;

#if defined(BT_HAS_ALIGNED_ALLOCATOR)
static void *btAlignedAllocDefault(size_t size, int alignment)
{
	return _aligned_malloc(size, (size_t)alignment);
}

static void btAlignedFreeDefault(void *ptr)
{
	_aligned_free(ptr);
}
#elif defined(__CELLOS_LV2__)

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	return memalign(alignment, size);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	free(ptr);
}
#else

static inline void *btAlignedAllocDefault(size_t size, int alignment)
{
	void *ret;
	char *real;
	real = (char *)sAllocFunc(size + sizeof(void *) + (alignment - 1));
	if (real)
	{
		ret = btAlignPointer(real + sizeof(void *), alignment);
		*((void **)(ret)-1) = (void *)(real);
	}
	else
	{
		ret = (void *)(real);
	}
  //keep msan happy
  memset((char*) ret, 0, size);
	return (ret);
}

static inline void btAlignedFreeDefault(void *ptr)
{
	void *real;

	if (ptr)
	{
		real = *((void **)(ptr)-1);
		sFreeFunc(real);
	}
}
#endif

static btAlignedAllocFunc *sAlignedAllocFunc = btAlignedAllocDefault;
static btAlignedFreeFunc *sAlignedFreeFunc = btAlignedFreeDefault;

void btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc)
{
	sAlignedAllocFunc = allocFunc ? allocFunc : btAlignedAllocDefault;
	sAlignedFreeFunc = freeFunc ? freeFunc : btAlignedFreeDefault;
}

void btAlignedAllocSetCustom(btAllocFunc *allocFunc, btFreeFunc *freeFunc)
{
	sAllocFunc = allocFunc ? allocFunc : btAllocDefault;
	sFreeFunc = freeFunc ? freeFunc : btFreeDefault;
}

#ifdef BT_DEBUG_MEMORY_ALLOCATIONS

static int allocations_id[10241024];
static int allocations_bytes[10241024];
static int mynumallocs = 0;

int btDumpMemoryLeaks()
{
	int totalLeak = 0;

	for (int i = 0; i < mynumallocs; i++)
	{
		printf("Error: leaked memory of allocation #%d (%d bytes)\n", allocations_id[i], allocations_bytes[i]);
		totalLeak += allocations_bytes[i];
	}
	if (totalLeak)
	{
		printf("Error: memory leaks: %d allocations were not freed and leaked together %d bytes\n", mynumallocs, totalLeak);
	}
	return totalLeak;
}
//this generic allocator provides the total allocated number of bytes

struct btDebugPtrMagic
{
	union {
		void **vptrptr;
		void *vptr;
		int *iptr;
		char *cptr;
	};
};

void *btAlignedAllocInternal(size_t size, int alignment, int line, const char *filename)
{
	if (size == 0)
	{
		printf("Whaat? size==0");
		return 0;
	}
	static int allocId = 0;

	void *ret;
	char *real;

	// to find some particular memory leak, you could do something like this:
	//	if (allocId==172)
	//	{
	//		printf("catch me!\n");
	//	}
	//	if (size>1024*1024)
	//	{
	//		printf("big alloc!%d\n", size);
	//	}

	gTotalBytesAlignedAllocs += size;
	gNumAlignedAllocs++;

	int sz4prt = 4 * sizeof(void *);

	real = (char *)sAllocFunc(size + sz4prt + (alignment - 1));
	if (real)
	{
		ret = (void *)btAlignPointer(real + sz4prt, alignment);
		btDebugPtrMagic p;
		p.vptr = ret;
		p.cptr -= sizeof(void *);
		*p.vptrptr = (void *)real;
		p.cptr -= sizeof(void *);
		*p.iptr = size;
		p.cptr -= sizeof(void *);
		*p.iptr = allocId;

		allocations_id[mynumallocs] = allocId;
		allocations_bytes[mynumallocs] = size;
		mynumallocs++;
	}
	else
	{
		ret = (void *)(real);  //??
	}

	printf("allocation %d at address %x, from %s,line %d, size %d (total allocated = %d)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs);
	allocId++;

	int *ptr = (int *)ret;
	*ptr = 12;
	return (ret);
}

void btAlignedFreeInternal(void *ptr, int line, const char *filename)
{
	void *real;

	if (ptr)
	{
		gNumAlignedFree++;

		btDebugPtrMagic p;
		p.vptr = ptr;
		p.cptr -= sizeof(void *);
		real = *p.vptrptr;
		p.cptr -= sizeof(void *);
		int size = *p.iptr;
		p.cptr -= sizeof(void *);
		int allocId = *p.iptr;

		bool found = false;

		for (int i = 0; i < mynumallocs; i++)
		{
			if (allocations_id[i] == allocId)
			{
				allocations_id[i] = allocations_id[mynumallocs - 1];
				allocations_bytes[i] = allocations_bytes[mynumallocs - 1];
				mynumallocs--;
				found = true;
				break;
			}
		}

		gTotalBytesAlignedAllocs -= size;

		int diff = gNumAlignedAllocs - gNumAlignedFree;
		printf("free %d at address %x, from %s,line %d, size %d (total remain = %d in %d non-freed allocations)\n", allocId, real, filename, line, size, gTotalBytesAlignedAllocs, diff);

		sFreeFunc(real);
	}
	else
	{
		//printf("deleting a NULL ptr, no effect\n");
	}
}

#else  //BT_DEBUG_MEMORY_ALLOCATIONS

void *btAlignedAllocInternal(size_t size, int alignment)
{
	void *ptr;
	ptr = sAlignedAllocFunc(size, alignment);
	//	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
	return ptr;
}

void btAlignedFreeInternal(void *ptr)
{
	if (!ptr)
	{
		return;
	}

	//	printf("btAlignedFreeInternal %x\n",ptr);
	sAlignedFreeFunc(ptr);
}

#endif  //BT_DEBUG_MEMORY_ALLOCATIONS





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_VECTOR3_H
#define BT_VECTOR3_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btAlignedAllocator.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btVector3Data btVector3DoubleData
#define btVector3DataName "btVector3DoubleData"
#else
#define btVector3Data btVector3FloatData
#define btVector3DataName "btVector3FloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#if defined BT_USE_SSE

//typedef  uint32_t __m128i __attribute__ ((vector_size(16)));

#ifdef _MSC_VER
#pragma warning(disable : 4556)  // value of intrinsic immediate argument '4294967239' is out of range '0 - 255'
#endif

#define BT_SHUFFLE(x, y, z, w) (((w) << 6 | (z) << 4 | (y) << 2 | (x)) & 0xff)
//#define bt_pshufd_ps( _a, _mask ) (__m128) _mm_shuffle_epi32((__m128i)(_a), (_mask) )
#define bt_pshufd_ps(_a, _mask) _mm_shuffle_ps((_a), (_a), (_mask))
#define bt_splat3_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, 3))
#define bt_splat_ps(_a, _i) bt_pshufd_ps((_a), BT_SHUFFLE(_i, _i, _i, _i))

#define btv3AbsiMask (_mm_set_epi32(0x00000000, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvAbsMask (_mm_set_epi32(0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))
#define btvFFF0Mask (_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))
#define btv3AbsfMask btCastiTo128f(btv3AbsiMask)
#define btvFFF0fMask btCastiTo128f(btvFFF0Mask)
#define btvxyzMaskf btvFFF0fMask
#define btvAbsfMask btCastiTo128f(btvAbsMask)

//there is an issue with XCode 3.2 (LCx errors)
#define btvMzeroMask (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f))
#define v1110 (_mm_set_ps(0.0f, 1.0f, 1.0f, 1.0f))
#define vHalf (_mm_set_ps(0.5f, 0.5f, 0.5f, 0.5f))
#define v1_5 (_mm_set_ps(1.5f, 1.5f, 1.5f, 1.5f))

//const __m128 ATTRIBUTE_ALIGNED16(btvMzeroMask) = {-0.0f, -0.0f, -0.0f, -0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(v1110) = {1.0f, 1.0f, 1.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vHalf) = {0.5f, 0.5f, 0.5f, 0.5f};
//const __m128 ATTRIBUTE_ALIGNED16(v1_5)  = {1.5f, 1.5f, 1.5f, 1.5f};

#endif

#ifdef BT_USE_NEON

const float32x4_t ATTRIBUTE_ALIGNED16(btvMzeroMask) = (float32x4_t){-0.0f, -0.0f, -0.0f, -0.0f};
const int32x4_t ATTRIBUTE_ALIGNED16(btvFFF0Mask) = (int32x4_t){static_cast<int32_t>(0xFFFFFFFF),
															   static_cast<int32_t>(0xFFFFFFFF), static_cast<int32_t>(0xFFFFFFFF), 0x0};
const int32x4_t ATTRIBUTE_ALIGNED16(btvAbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF};
const int32x4_t ATTRIBUTE_ALIGNED16(btv3AbsMask) = (int32x4_t){0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x0};

#endif

/**@brief btVector3 can be used to represent 3D points and vectors.
 * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
 * Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
 */
ATTRIBUTE_ALIGNED16(class)
btVector3
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

#if defined(__SPU__) && defined(__CELLOS_LV2__)
	btScalar m_floats[4];

public:
	SIMD_FORCE_INLINE const vec_float4& get128() const
	{
		return *((const vec_float4*)&m_floats[0]);
	}

public:
#else                                            //__CELLOS_LV2__ __SPU__
#if defined(BT_USE_SSE) || defined(BT_USE_NEON)  // _WIN32 || ARM
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif
#endif  //__CELLOS_LV2__ __SPU__

public:
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btVector3()
	{
	}

	/**@brief Constructor from scalars 
   * @param x X value
   * @param y Y value 
   * @param z Z value 
   */
	SIMD_FORCE_INLINE btVector3(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btVector3(btSimdFloat4 v)
	{
		mVec128 = v;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btVector3(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btVector3&
	operator=(const btVector3& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	/**@brief Add a vector to this one 
 * @param The vector to add to this one */
	SIMD_FORCE_INLINE btVector3& operator+=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, v.mVec128);
#else
		m_floats[0] += v.m_floats[0];
		m_floats[1] += v.m_floats[1];
		m_floats[2] += v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Subtract a vector from this one
   * @param The vector to subtract */
	SIMD_FORCE_INLINE btVector3& operator-=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, v.mVec128);
#else
		m_floats[0] -= v.m_floats[0];
		m_floats[1] -= v.m_floats[1];
		m_floats[2] -= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Scale the vector
   * @param s Scale factor */
	SIMD_FORCE_INLINE btVector3& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
#endif
		return *this;
	}

	/**@brief Inversely scale the vector 
   * @param s Scale factor to divide by */
	SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)
	{
		btFullAssert(s != btScalar(0.0));

#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
		__m128 vs = _mm_load_ss(&s);
		vs = _mm_div_ss(v1110, vs);
		vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

		mVec128 = _mm_mul_ps(mVec128, vs);
		
		return *this;
#else
		return *this *= btScalar(1.0) / s;
#endif
	}

	/**@brief Return the dot product
   * @param v The other vector in the dot product */
	SIMD_FORCE_INLINE btScalar dot(const btVector3& v) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd = _mm_mul_ps(mVec128, v.mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);
		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, v.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_low_f32(vd));
		x = vadd_f32(x, vget_high_f32(vd));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * v.m_floats[0] +
			   m_floats[1] * v.m_floats[1] +
			   m_floats[2] * v.m_floats[2];
#endif
	}

	/**@brief Return the length of the vector squared */
	SIMD_FORCE_INLINE btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the vector */
	SIMD_FORCE_INLINE btScalar length() const
	{
		return btSqrt(length2());
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar norm() const
	{
		return length();
	}

	/**@brief Return the norm (length) of the vector */
	SIMD_FORCE_INLINE btScalar safeNorm() const
	{
		btScalar d = length2();
		//workaround for some clang/gcc issue of sqrtf(tiny number) = -INF
		if (d > SIMD_EPSILON)
			return btSqrt(d);
		return btScalar(0);
	}

	/**@brief Return the distance squared between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance2(const btVector3& v) const;

	/**@brief Return the distance between the ends of this and another vector
   * This is symantically treating the vector like a point */
	SIMD_FORCE_INLINE btScalar distance(const btVector3& v) const;

	SIMD_FORCE_INLINE btVector3& safeNormalize()
	{
		btScalar l2 = length2();
		//triNormal.normalize();
		if (l2 >= SIMD_EPSILON * SIMD_EPSILON)
		{
			(*this) /= btSqrt(l2);
		}
		else
		{
			setValue(1, 0, 0);
		}
		return *this;
	}

	/**@brief Normalize this vector 
   * x^2 + y^2 + z^2 = 1 */
	SIMD_FORCE_INLINE btVector3& normalize()
	{
		btAssert(!fuzzyZero());

#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// dot product first
		__m128 vd = _mm_mul_ps(mVec128, mVec128);
		__m128 z = _mm_movehl_ps(vd, vd);
		__m128 y = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, y);
		vd = _mm_add_ss(vd, z);

#if 0
        vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(v1110, vd);
		vd = bt_splat_ps(vd, 0x80);
		mVec128 = _mm_mul_ps(mVec128, vd);
#else

		// NR step 1/sqrt(x) - vd is x, y is output
		y = _mm_rsqrt_ss(vd);  // estimate

		//  one step NR
		z = v1_5;
		vd = _mm_mul_ss(vd, vHalf);  // vd * 0.5
		//x2 = vd;
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0
		vd = _mm_mul_ss(vd, y);  // vd * 0.5 * y0 * y0
		z = _mm_sub_ss(z, vd);   // 1.5 - vd * 0.5 * y0 * y0

		y = _mm_mul_ss(y, z);  // y0 * (1.5 - vd * 0.5 * y0 * y0)

		y = bt_splat_ps(y, 0x80);
		mVec128 = _mm_mul_ps(mVec128, y);

#endif

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a normalized version of this vector */
	SIMD_FORCE_INLINE btVector3 normalized() const;

	/**@brief Return a rotated version of this vector
   * @param wAxis The axis to rotate about 
   * @param angle The angle to rotate by */
	SIMD_FORCE_INLINE btVector3 rotate(const btVector3& wAxis, const btScalar angle) const;

	/**@brief Return the angle between this and another vector
   * @param v The other vector */
	SIMD_FORCE_INLINE btScalar angle(const btVector3& v) const
	{
		btScalar s = btSqrt(length2() * v.length2());
		btFullAssert(s != btScalar(0.0));
		return btAcos(dot(v) / s);
	}

	/**@brief Return a vector with the absolute values of each element */
	SIMD_FORCE_INLINE btVector3 absolute() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector3(_mm_and_ps(mVec128, btv3AbsfMask));
#elif defined(BT_USE_NEON)
		return btVector3(vabsq_f32(mVec128));
#else
		return btVector3(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]));
#endif
	}

	/**@brief Return the cross product between this and another vector 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3 cross(const btVector3& v) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 T, V;

		T = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 3));    //	(Y Z X 0)
		V = bt_pshufd_ps(v.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, mVec128);
		T = _mm_mul_ps(T, v.mVec128);
		V = _mm_sub_ps(V, T);

		V = bt_pshufd_ps(V, BT_SHUFFLE(1, 2, 0, 3));
		return btVector3(V);
#elif defined(BT_USE_NEON)
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(mVec128);
		float32x2_t Vlow = vget_low_f32(v.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v.mVec128), 1), Vlow);

		V = vmulq_f32(V, mVec128);
		T = vmulq_f32(T, v.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);
		V = (float32x4_t)vandq_s32((int32x4_t)V, btvFFF0Mask);

		return btVector3(V);
#else
		return btVector3(
			m_floats[1] * v.m_floats[2] - m_floats[2] * v.m_floats[1],
			m_floats[2] * v.m_floats[0] - m_floats[0] * v.m_floats[2],
			m_floats[0] * v.m_floats[1] - m_floats[1] * v.m_floats[0]);
#endif
	}

	SIMD_FORCE_INLINE btScalar triple(const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		// cross:
		__m128 T = _mm_shuffle_ps(v1.mVec128, v1.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)
		__m128 V = _mm_shuffle_ps(v2.mVec128, v2.mVec128, BT_SHUFFLE(1, 2, 0, 3));  //	(Y Z X 0)

		V = _mm_mul_ps(V, v1.mVec128);
		T = _mm_mul_ps(T, v2.mVec128);
		V = _mm_sub_ps(V, T);

		V = _mm_shuffle_ps(V, V, BT_SHUFFLE(1, 2, 0, 3));

		// dot:
		V = _mm_mul_ps(V, mVec128);
		__m128 z = _mm_movehl_ps(V, V);
		__m128 y = _mm_shuffle_ps(V, V, 0x55);
		V = _mm_add_ss(V, y);
		V = _mm_add_ss(V, z);
		return _mm_cvtss_f32(V);

#elif defined(BT_USE_NEON)
		// cross:
		float32x4_t T, V;
		// form (Y, Z, X, _) of mVec128 and v.mVec128
		float32x2_t Tlow = vget_low_f32(v1.mVec128);
		float32x2_t Vlow = vget_low_f32(v2.mVec128);
		T = vcombine_f32(vext_f32(Tlow, vget_high_f32(v1.mVec128), 1), Tlow);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(v2.mVec128), 1), Vlow);

		V = vmulq_f32(V, v1.mVec128);
		T = vmulq_f32(T, v2.mVec128);
		V = vsubq_f32(V, T);
		Vlow = vget_low_f32(V);
		// form (Y, Z, X, _);
		V = vcombine_f32(vext_f32(Vlow, vget_high_f32(V), 1), Vlow);

		// dot:
		V = vmulq_f32(mVec128, V);
		float32x2_t x = vpadd_f32(vget_low_f32(V), vget_low_f32(V));
		x = vadd_f32(x, vget_high_f32(V));
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * (v1.m_floats[1] * v2.m_floats[2] - v1.m_floats[2] * v2.m_floats[1]) +
			   m_floats[1] * (v1.m_floats[2] * v2.m_floats[0] - v1.m_floats[0] * v2.m_floats[2]) +
			   m_floats[2] * (v1.m_floats[0] * v2.m_floats[1] - v1.m_floats[1] * v2.m_floats[0]);
#endif
	}

	/**@brief Return the axis with the smallest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int minAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[0] < m_floats[2] ? 0 : 2) : (m_floats[1] < m_floats[2] ? 1 : 2);
	}

	/**@brief Return the axis with the largest value 
   * Note return values are 0,1,2 for x, y, or z */
	SIMD_FORCE_INLINE int maxAxis() const
	{
		return m_floats[0] < m_floats[1] ? (m_floats[1] < m_floats[2] ? 2 : 1) : (m_floats[0] < m_floats[2] ? 2 : 0);
	}

	SIMD_FORCE_INLINE int furthestAxis() const
	{
		return absolute().minAxis();
	}

	SIMD_FORCE_INLINE int closestAxis() const
	{
		return absolute().maxAxis();
	}

	SIMD_FORCE_INLINE void setInterpolate3(const btVector3& v0, const btVector3& v1, btScalar rt)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vrt = _mm_load_ss(&rt);  //	(rt 0 0 0)
		btScalar s = btScalar(1.0) - rt;
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
		__m128 r0 = _mm_mul_ps(v0.mVec128, vs);
		vrt = bt_pshufd_ps(vrt, 0x80);  //	(rt rt rt 0.0)
		__m128 r1 = _mm_mul_ps(v1.mVec128, vrt);
		__m128 tmp3 = _mm_add_ps(r0, r1);
		mVec128 = tmp3;
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v1.mVec128, v0.mVec128);
		vl = vmulq_n_f32(vl, rt);
		mVec128 = vaddq_f32(vl, v0.mVec128);
#else
		btScalar s = btScalar(1.0) - rt;
		m_floats[0] = s * v0.m_floats[0] + rt * v1.m_floats[0];
		m_floats[1] = s * v0.m_floats[1] + rt * v1.m_floats[1];
		m_floats[2] = s * v0.m_floats[2] + rt * v1.m_floats[2];
		//don't do the unused w component
		//		m_co[3] = s * v0[3] + rt * v1[3];
#endif
	}

	/**@brief Return the linear interpolation between this and another vector 
   * @param v The other vector 
   * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
	SIMD_FORCE_INLINE btVector3 lerp(const btVector3& v, const btScalar& t) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vt = _mm_load_ss(&t);  //	(t 0 0 0)
		vt = bt_pshufd_ps(vt, 0x80);  //	(rt rt rt 0.0)
		__m128 vl = _mm_sub_ps(v.mVec128, mVec128);
		vl = _mm_mul_ps(vl, vt);
		vl = _mm_add_ps(vl, mVec128);

		return btVector3(vl);
#elif defined(BT_USE_NEON)
		float32x4_t vl = vsubq_f32(v.mVec128, mVec128);
		vl = vmulq_n_f32(vl, t);
		vl = vaddq_f32(vl, mVec128);

		return btVector3(vl);
#else
		return btVector3(m_floats[0] + (v.m_floats[0] - m_floats[0]) * t,
						 m_floats[1] + (v.m_floats[1] - m_floats[1]) * t,
						 m_floats[2] + (v.m_floats[2] - m_floats[2]) * t);
#endif
	}

	/**@brief Elementwise multiply this vector by the other 
   * @param v The other vector */
	SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_mul_ps(mVec128, v.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_f32(mVec128, v.mVec128);
#else
		m_floats[0] *= v.m_floats[0];
		m_floats[1] *= v.m_floats[1];
		m_floats[2] *= v.m_floats[2];
#endif
		return *this;
	}

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btVector3& other) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btVector3& other) const
	{
		return !(*this == other);
	}

	/**@brief Set each element to the max of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.w());
#endif
	}

	/**@brief Set each element to the min of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btVector3& other)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.w());
#endif
	}

	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = btScalar(0.f);
	}

	void getSkewSymmetricMatrix(btVector3 * v0, btVector3 * v1, btVector3 * v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 V = _mm_and_ps(mVec128, btvFFF0fMask);
		__m128 V0 = _mm_xor_ps(btvMzeroMask, V);
		__m128 V2 = _mm_movelh_ps(V0, V);

		__m128 V1 = _mm_shuffle_ps(V, V0, 0xCE);

		V0 = _mm_shuffle_ps(V0, V, 0xDB);
		V2 = _mm_shuffle_ps(V2, V, 0xF9);

		v0->mVec128 = V0;
		v1->mVec128 = V1;
		v2->mVec128 = V2;
#else
		v0->setValue(0., -z(), y());
		v1->setValue(z(), 0., -x());
		v2->setValue(-y(), x(), 0.);
#endif
	}

	void setZero()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = (__m128)_mm_xor_ps(mVec128, mVec128);
#elif defined(BT_USE_NEON)
		int32x4_t vi = vdupq_n_s32(0);
		mVec128 = vreinterpretq_f32_s32(vi);
#else
		setValue(btScalar(0.), btScalar(0.), btScalar(0.));
#endif
	}

	SIMD_FORCE_INLINE bool isZero() const
	{
		return m_floats[0] == btScalar(0) && m_floats[1] == btScalar(0) && m_floats[2] == btScalar(0);
	}

	SIMD_FORCE_INLINE bool fuzzyZero() const
	{
		return length2() < SIMD_EPSILON * SIMD_EPSILON;
	}

	SIMD_FORCE_INLINE void serialize(struct btVector3Data & dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3DoubleData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btVector3FloatData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btVector3FloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btVector3DoubleData & dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btVector3DoubleData& dataIn);

	/**@brief returns index of maximum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The maximum dot product */
	SIMD_FORCE_INLINE long maxDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/**@brief returns index of minimum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The minimum dot product */
	SIMD_FORCE_INLINE long minDot(const btVector3* array, long array_count, btScalar& dotOut) const;

	/* create a vector as  btVector3( this->dot( btVector3 v0 ), this->dot( btVector3 v1), this->dot( btVector3 v2 ))  */
	SIMD_FORCE_INLINE btVector3 dot3(const btVector3& v0, const btVector3& v1, const btVector3& v2) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

		__m128 a0 = _mm_mul_ps(v0.mVec128, this->mVec128);
		__m128 a1 = _mm_mul_ps(v1.mVec128, this->mVec128);
		__m128 a2 = _mm_mul_ps(v2.mVec128, this->mVec128);
		__m128 b0 = _mm_unpacklo_ps(a0, a1);
		__m128 b1 = _mm_unpackhi_ps(a0, a1);
		__m128 b2 = _mm_unpacklo_ps(a2, _mm_setzero_ps());
		__m128 r = _mm_movelh_ps(b0, b2);
		r = _mm_add_ps(r, _mm_movehl_ps(b2, b0));
		a2 = _mm_and_ps(a2, btvxyzMaskf);
		r = _mm_add_ps(r, btCastdTo128f(_mm_move_sd(btCastfTo128d(a2), btCastfTo128d(b1))));
		return btVector3(r);

#elif defined(BT_USE_NEON)
		static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
		float32x4_t a0 = vmulq_f32(v0.mVec128, this->mVec128);
		float32x4_t a1 = vmulq_f32(v1.mVec128, this->mVec128);
		float32x4_t a2 = vmulq_f32(v2.mVec128, this->mVec128);
		float32x2x2_t zLo = vtrn_f32(vget_high_f32(a0), vget_high_f32(a1));
		a2 = (float32x4_t)vandq_u32((uint32x4_t)a2, xyzMask);
		float32x2_t b0 = vadd_f32(vpadd_f32(vget_low_f32(a0), vget_low_f32(a1)), zLo.val[0]);
		float32x2_t b1 = vpadd_f32(vpadd_f32(vget_low_f32(a2), vget_high_f32(a2)), vdup_n_f32(0.0f));
		return btVector3(vcombine_f32(b0, b1));
#else
		return btVector3(dot(v0), dot(v1), dot(v2));
#endif
	}
};

/**@brief Return the sum of two vectors (Point symantics)*/
SIMD_FORCE_INLINE btVector3
operator+(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_add_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vaddq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] + v2.m_floats[0],
		v1.m_floats[1] + v2.m_floats[1],
		v1.m_floats[2] + v2.m_floats[2]);
#endif
}

/**@brief Return the elementwise product of two vectors */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v1, const btVector3& v2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_mul_ps(v1.mVec128, v2.mVec128));
#elif defined(BT_USE_NEON)
	return btVector3(vmulq_f32(v1.mVec128, v2.mVec128));
#else
	return btVector3(
		v1.m_floats[0] * v2.m_floats[0],
		v1.m_floats[1] * v2.m_floats[1],
		v1.m_floats[2] * v2.m_floats[2]);
#endif
}

/**@brief Return the difference between two vectors */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	//	without _mm_and_ps this code causes slowdown in Concave moving
	__m128 r = _mm_sub_ps(v1.mVec128, v2.mVec128);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	float32x4_t r = vsubq_f32(v1.mVec128, v2.mVec128);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(
		v1.m_floats[0] - v2.m_floats[0],
		v1.m_floats[1] - v2.m_floats[1],
		v1.m_floats[2] - v2.m_floats[2]);
#endif
}

/**@brief Return the negative of the vector */
SIMD_FORCE_INLINE btVector3
operator-(const btVector3& v)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 r = _mm_xor_ps(v.mVec128, btvMzeroMask);
	return btVector3(_mm_and_ps(r, btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((btSimdFloat4)veorq_s32((int32x4_t)v.mVec128, (int32x4_t)btvMzeroMask));
#else
	return btVector3(-v.m_floats[0], -v.m_floats[1], -v.m_floats[2]);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btScalar& s)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
	vs = bt_pshufd_ps(vs, 0x80);  //	(S S S 0.0)
	return btVector3(_mm_mul_ps(v.mVec128, vs));
#elif defined(BT_USE_NEON)
	float32x4_t r = vmulq_n_f32(v.mVec128, s);
	return btVector3((float32x4_t)vandq_s32((int32x4_t)r, btvFFF0Mask));
#else
	return btVector3(v.m_floats[0] * s, v.m_floats[1] * s, v.m_floats[2] * s);
#endif
}

/**@brief Return the vector scaled by s */
SIMD_FORCE_INLINE btVector3
operator*(const btScalar& s, const btVector3& v)
{
	return v * s;
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v, const btScalar& s)
{
	btFullAssert(s != btScalar(0.0));
#if 0  //defined(BT_USE_SSE_IN_API)
// this code is not faster !
	__m128 vs = _mm_load_ss(&s);
    vs = _mm_div_ss(v1110, vs);
	vs = bt_pshufd_ps(vs, 0x00);	//	(S S S S)

	return btVector3(_mm_mul_ps(v.mVec128, vs));
#else
	return v * (btScalar(1.0) / s);
#endif
}

/**@brief Return the vector inversely scaled by s */
SIMD_FORCE_INLINE btVector3
operator/(const btVector3& v1, const btVector3& v2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vec = _mm_div_ps(v1.mVec128, v2.mVec128);
	vec = _mm_and_ps(vec, btvFFF0fMask);
	return btVector3(vec);
#elif defined(BT_USE_NEON)
	float32x4_t x, y, v, m;

	x = v1.mVec128;
	y = v2.mVec128;

	v = vrecpeq_f32(y);     // v ~ 1/y
	m = vrecpsq_f32(y, v);  // m = (2-v*y)
	v = vmulq_f32(v, m);    // vv = v*m ~~ 1/y
	m = vrecpsq_f32(y, v);  // mm = (2-vv*y)
	v = vmulq_f32(v, x);    // x*vv
	v = vmulq_f32(v, m);    // (x*vv)*(2-vv*y) = x*(vv(2-vv*y)) ~~~ x/y

	return btVector3(v);
#else
	return btVector3(
		v1.m_floats[0] / v2.m_floats[0],
		v1.m_floats[1] / v2.m_floats[1],
		v1.m_floats[2] / v2.m_floats[2]);
#endif
}

/**@brief Return the dot product between two vectors */
SIMD_FORCE_INLINE btScalar
btDot(const btVector3& v1, const btVector3& v2)
{
	return v1.dot(v2);
}

/**@brief Return the distance squared between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance2(const btVector3& v1, const btVector3& v2)
{
	return v1.distance2(v2);
}

/**@brief Return the distance between two vectors */
SIMD_FORCE_INLINE btScalar
btDistance(const btVector3& v1, const btVector3& v2)
{
	return v1.distance(v2);
}

/**@brief Return the angle between two vectors */
SIMD_FORCE_INLINE btScalar
btAngle(const btVector3& v1, const btVector3& v2)
{
	return v1.angle(v2);
}

/**@brief Return the cross product of two vectors */
SIMD_FORCE_INLINE btVector3
btCross(const btVector3& v1, const btVector3& v2)
{
	return v1.cross(v2);
}

SIMD_FORCE_INLINE btScalar
btTriple(const btVector3& v1, const btVector3& v2, const btVector3& v3)
{
	return v1.triple(v2, v3);
}

/**@brief Return the linear interpolation between two vectors
 * @param v1 One vector 
 * @param v2 The other vector 
 * @param t The ration of this to v (t = 0 => return v1, t=1 => return v2) */
SIMD_FORCE_INLINE btVector3
lerp(const btVector3& v1, const btVector3& v2, const btScalar& t)
{
	return v1.lerp(v2, t);
}

SIMD_FORCE_INLINE btScalar btVector3::distance2(const btVector3& v) const
{
	return (v - *this).length2();
}

SIMD_FORCE_INLINE btScalar btVector3::distance(const btVector3& v) const
{
	return (v - *this).length();
}

SIMD_FORCE_INLINE btVector3 btVector3::normalized() const
{
	btVector3 nrm = *this;

	return nrm.normalize();
}

SIMD_FORCE_INLINE btVector3 btVector3::rotate(const btVector3& wAxis, const btScalar _angle) const
{
	// wAxis must be a unit lenght vector

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)

	__m128 O = _mm_mul_ps(wAxis.mVec128, mVec128);
	btScalar ssin = btSin(_angle);
	__m128 C = wAxis.cross(mVec128).mVec128;
	O = _mm_and_ps(O, btvFFF0fMask);
	btScalar scos = btCos(_angle);

	__m128 vsin = _mm_load_ss(&ssin);  //	(S 0 0 0)
	__m128 vcos = _mm_load_ss(&scos);  //	(S 0 0 0)

	__m128 Y = bt_pshufd_ps(O, 0xC9);  //	(Y Z X 0)
	__m128 Z = bt_pshufd_ps(O, 0xD2);  //	(Z X Y 0)
	O = _mm_add_ps(O, Y);
	vsin = bt_pshufd_ps(vsin, 0x80);  //	(S S S 0)
	O = _mm_add_ps(O, Z);
	vcos = bt_pshufd_ps(vcos, 0x80);  //	(S S S 0)

	vsin = vsin * C;
	O = O * wAxis.mVec128;
	__m128 X = mVec128 - O;

	O = O + vsin;
	vcos = vcos * X;
	O = O + vcos;

	return btVector3(O);
#else
	btVector3 o = wAxis * wAxis.dot(*this);
	btVector3 _x = *this - o;
	btVector3 _y;

	_y = wAxis.cross(*this);

	return (o + _x * btCos(_angle) + _y * btSin(_angle));
#endif
}

SIMD_FORCE_INLINE long btVector3::maxDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined _WIN32 || defined(BT_USE_SSE)
	const long scalar_cutoff = 10;
	long _maxdot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_maxdot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#endif
	if (array_count < scalar_cutoff)
#endif
	{
		btScalar maxDot1 = -SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;
		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot > maxDot1)
			{
				maxDot1 = dot;
				ptIndex = i;
			}
		}

		dotOut = maxDot1;
		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _maxdot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif
}

SIMD_FORCE_INLINE long btVector3::minDot(const btVector3* array, long array_count, btScalar& dotOut) const
{
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
#if defined BT_USE_SSE
	const long scalar_cutoff = 10;
	long _mindot_large(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#elif defined BT_USE_NEON
	const long scalar_cutoff = 4;
	extern long (*_mindot_large)(const float* array, const float* vec, unsigned long array_count, float* dotOut);
#else
#error unhandled arch!
#endif

	if (array_count < scalar_cutoff)
#endif
	{
		btScalar minDot = SIMD_INFINITY;
		int i = 0;
		int ptIndex = -1;

		for (i = 0; i < array_count; i++)
		{
			btScalar dot = array[i].dot(*this);

			if (dot < minDot)
			{
				minDot = dot;
				ptIndex = i;
			}
		}

		dotOut = minDot;

		return ptIndex;
	}
#if (defined BT_USE_SSE && defined BT_USE_SIMD_VECTOR3 && defined BT_USE_SSE_IN_API) || defined(BT_USE_NEON)
	return _mindot_large((float*)array, (float*)&m_floats[0], array_count, &dotOut);
#endif  //BT_USE_SIMD_VECTOR3
}

class btVector4 : public btVector3
{
public:
	SIMD_FORCE_INLINE btVector4() {}

	SIMD_FORCE_INLINE btVector4(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btVector3(_x, _y, _z)
	{
		m_floats[3] = _w;
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btVector4(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	SIMD_FORCE_INLINE btVector4(const btVector3& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	SIMD_FORCE_INLINE btVector4&
	operator=(const btVector4& v)
	{
		mVec128 = v.mVec128;
		return *this;
	}
#endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	SIMD_FORCE_INLINE btVector4 absolute4() const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btVector4(_mm_and_ps(mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
		return btVector4(vabsq_f32(mVec128));
#else
		return btVector4(
			btFabs(m_floats[0]),
			btFabs(m_floats[1]),
			btFabs(m_floats[2]),
			btFabs(m_floats[3]));
#endif
	}

	btScalar getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE int maxAxis4() const
	{
		int maxIndex = -1;
		btScalar maxVal = btScalar(-BT_LARGE_FLOAT);
		if (m_floats[0] > maxVal)
		{
			maxIndex = 0;
			maxVal = m_floats[0];
		}
		if (m_floats[1] > maxVal)
		{
			maxIndex = 1;
			maxVal = m_floats[1];
		}
		if (m_floats[2] > maxVal)
		{
			maxIndex = 2;
			maxVal = m_floats[2];
		}
		if (m_floats[3] > maxVal)
		{
			maxIndex = 3;
		}

		return maxIndex;
	}

	SIMD_FORCE_INLINE int minAxis4() const
	{
		int minIndex = -1;
		btScalar minVal = btScalar(BT_LARGE_FLOAT);
		if (m_floats[0] < minVal)
		{
			minIndex = 0;
			minVal = m_floats[0];
		}
		if (m_floats[1] < minVal)
		{
			minIndex = 1;
			minVal = m_floats[1];
		}
		if (m_floats[2] < minVal)
		{
			minIndex = 2;
			minVal = m_floats[2];
		}
		if (m_floats[3] < minVal)
		{
			minIndex = 3;
		}

		return minIndex;
	}

	SIMD_FORCE_INLINE int closestAxis4() const
	{
		return absolute4().maxAxis4();
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] =m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
};

///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapScalarEndian(const btScalar& sourceVal, btScalar& destVal)
{
#ifdef BT_USE_DOUBLE_PRECISION
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[7];
	dest[1] = src[6];
	dest[2] = src[5];
	dest[3] = src[4];
	dest[4] = src[3];
	dest[5] = src[2];
	dest[6] = src[1];
	dest[7] = src[0];
#else
	unsigned char* dest = (unsigned char*)&destVal;
	const unsigned char* src = (const unsigned char*)&sourceVal;
	dest[0] = src[3];
	dest[1] = src[2];
	dest[2] = src[1];
	dest[3] = src[0];
#endif  //BT_USE_DOUBLE_PRECISION
}
///btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btSwapVector3Endian(const btVector3& sourceVec, btVector3& destVec)
{
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(sourceVec[i], destVec[i]);
	}
}

///btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization
SIMD_FORCE_INLINE void btUnSwapVector3Endian(btVector3& vector)
{
	btVector3 swappedVec;
	for (int i = 0; i < 4; i++)
	{
		btSwapScalarEndian(vector[i], swappedVec[i]);
	}
	vector = swappedVec;
}

template <class T>
SIMD_FORCE_INLINE void btPlaneSpace1(const T& n, T& p, T& q)
{
	if (btFabs(n[2]) > SIMDSQRT12)
	{
		// choose p in y-z plane
		btScalar a = n[1] * n[1] + n[2] * n[2];
		btScalar k = btRecipSqrt(a);
		p[0] = 0;
		p[1] = -n[2] * k;
		p[2] = n[1] * k;
		// set q = n x p
		q[0] = a * k;
		q[1] = -n[0] * p[2];
		q[2] = n[0] * p[1];
	}
	else
	{
		// choose p in x-y plane
		btScalar a = n[0] * n[0] + n[1] * n[1];
		btScalar k = btRecipSqrt(a);
		p[0] = -n[1] * k;
		p[1] = n[0] * k;
		p[2] = 0;
		// set q = n x p
		q[0] = -n[2] * p[1];
		q[1] = n[2] * p[0];
		q[2] = a * k;
	}
}

struct btVector3FloatData
{
	float m_floats[4];
};

struct btVector3DoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btVector3::serializeFloat(struct btVector3FloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeFloat(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serializeDouble(struct btVector3DoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::deSerializeDouble(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btVector3::serialize(struct btVector3Data& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3FloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btVector3::deSerialize(const struct btVector3DoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_VECTOR3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD_QUADWORD_H
#define BT_SIMD_QUADWORD_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btMinMax.h"

#if defined(__CELLOS_LV2) && defined(__SPU__)
#endif

/**@brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.
 */
#ifndef USE_LIBSPE2
ATTRIBUTE_ALIGNED16(class)
btQuadWord
#else
class btQuadWord
#endif
{
protected:
#if defined(__SPU__) && defined(__CELLOS_LV2__)
	union {
		vec_float4 mVec128;
		btScalar m_floats[4];
	};

public:
	vec_float4 get128() const
	{
		return mVec128;
	}

protected:
#else  //__CELLOS_LV2__ __SPU__

#if defined(BT_USE_SSE) || defined(BT_USE_NEON)
	union {
		btSimdFloat4 mVec128;
		btScalar m_floats[4];
	};

public:
	SIMD_FORCE_INLINE btSimdFloat4 get128() const
	{
		return mVec128;
	}
	SIMD_FORCE_INLINE void set128(btSimdFloat4 v128)
	{
		mVec128 = v128;
	}
#else
	btScalar m_floats[4];
#endif  // BT_USE_SSE

#endif  //__CELLOS_LV2__ __SPU__

public:
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

	// Set Vector
	SIMD_FORCE_INLINE btQuadWord(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuadWord(const btQuadWord& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuadWord&
	operator=(const btQuadWord& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& getX() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& getY() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& getZ() const { return m_floats[2]; }
	/**@brief Set the x value */
	SIMD_FORCE_INLINE void setX(btScalar _x) { m_floats[0] = _x; };
	/**@brief Set the y value */
	SIMD_FORCE_INLINE void setY(btScalar _y) { m_floats[1] = _y; };
	/**@brief Set the z value */
	SIMD_FORCE_INLINE void setZ(btScalar _z) { m_floats[2] = _z; };
	/**@brief Set the w value */
	SIMD_FORCE_INLINE void setW(btScalar _w) { m_floats[3] = _w; };
	/**@brief Return the x value */
	SIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }
	/**@brief Return the y value */
	SIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }
	/**@brief Return the z value */
	SIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }
	/**@brief Return the w value */
	SIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	///operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons.
	SIMD_FORCE_INLINE operator btScalar*() { return &m_floats[0]; }
	SIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }

	SIMD_FORCE_INLINE bool operator==(const btQuadWord& other) const
	{
#ifdef BT_USE_SSE
		return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));
#else
		return ((m_floats[3] == other.m_floats[3]) &&
				(m_floats[2] == other.m_floats[2]) &&
				(m_floats[1] == other.m_floats[1]) &&
				(m_floats[0] == other.m_floats[0]));
#endif
	}

	SIMD_FORCE_INLINE bool operator!=(const btQuadWord& other) const
	{
		return !(*this == other);
	}

	/**@brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = 0.f;
	}

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] = m_floats[2];
		}
*/
	/**@brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x;
		m_floats[1] = _y;
		m_floats[2] = _z;
		m_floats[3] = _w;
	}
	/**@brief No initialization constructor */
	SIMD_FORCE_INLINE btQuadWord()
	//	:m_floats[0](btScalar(0.)),m_floats[1](btScalar(0.)),m_floats[2](btScalar(0.)),m_floats[3](btScalar(0.))
	{
	}

	/**@brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = 0.0f;
	}

	/**@brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	SIMD_FORCE_INLINE btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
	{
		m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = _w;
	}

	/**@brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMax(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_max_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vmaxq_f32(mVec128, other.mVec128);
#else
		btSetMax(m_floats[0], other.m_floats[0]);
		btSetMax(m_floats[1], other.m_floats[1]);
		btSetMax(m_floats[2], other.m_floats[2]);
		btSetMax(m_floats[3], other.m_floats[3]);
#endif
	}
	/**@brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	SIMD_FORCE_INLINE void setMin(const btQuadWord& other)
	{
#ifdef BT_USE_SSE
		mVec128 = _mm_min_ps(mVec128, other.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vminq_f32(mVec128, other.mVec128);
#else
		btSetMin(m_floats[0], other.m_floats[0]);
		btSetMin(m_floats[1], other.m_floats[1]);
		btSetMin(m_floats[2], other.m_floats[2]);
		btSetMin(m_floats[3], other.m_floats[3]);
#endif
	}
};

#endif  //BT_SIMD_QUADWORD_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMD__QUATERNION_H_
#define BT_SIMD__QUATERNION_H_

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuadWord.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btQuaternionData btQuaternionDoubleData
#define btQuaternionDataName "btQuaternionDoubleData"
#else
#define btQuaternionData btQuaternionFloatData
#define btQuaternionDataName "btQuaternionFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#ifdef BT_USE_SSE

//const __m128 ATTRIBUTE_ALIGNED16(vOnes) = {1.0f, 1.0f, 1.0f, 1.0f};
#define vOnes (_mm_set_ps(1.0f, 1.0f, 1.0f, 1.0f))

#endif

#if defined(BT_USE_SSE)

#define vQInv (_mm_set_ps(+0.0f, -0.0f, -0.0f, -0.0f))
#define vPPPM (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f))

#elif defined(BT_USE_NEON)

const btSimdFloat4 ATTRIBUTE_ALIGNED16(vQInv) = {-0.0f, -0.0f, -0.0f, +0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(vPPPM) = {+0.0f, +0.0f, +0.0f, -0.0f};

#endif

/**@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
class btQuaternion : public btQuadWord
{
public:
	/**@brief No initialization constructor */
	btQuaternion() {}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	// Set Vector
	SIMD_FORCE_INLINE btQuaternion(const btSimdFloat4 vec)
	{
		mVec128 = vec;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btQuaternion(const btQuaternion& rhs)
	{
		mVec128 = rhs.mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btQuaternion&
	operator=(const btQuaternion& v)
	{
		mVec128 = v.mVec128;

		return *this;
	}

#endif

	//		template <typename btScalar>
	//		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
	/**@brief Constructor from scalars */
	btQuaternion(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
		: btQuadWord(_x, _y, _z, _w)
	{
	}
	/**@brief Axis angle Constructor
   * @param axis The axis which the rotation is around
   * @param angle The magnitude of the rotation around the angle (Radians) */
	btQuaternion(const btVector3& _axis, const btScalar& _angle)
	{
		setRotation(_axis, _angle);
	}
	/**@brief Constructor from Euler angles
   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
	btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
#ifndef BT_EULER_DEFAULT_ZYX
		setEuler(yaw, pitch, roll);
#else
		setEulerZYX(yaw, pitch, roll);
#endif
	}
	/**@brief Set the rotation using axis angle notation 
   * @param axis The axis around which to rotate
   * @param angle The magnitude of the rotation in Radians */
	void setRotation(const btVector3& axis, const btScalar& _angle)
	{
		btScalar d = axis.length();
		btAssert(d != btScalar(0.0));
		btScalar s = btSin(_angle * btScalar(0.5)) / d;
		setValue(axis.x() * s, axis.y() * s, axis.z() * s,
				 btCos(_angle * btScalar(0.5)));
	}
	/**@brief Set the quaternion using Euler angles
   * @param yaw Angle around Y
   * @param pitch Angle around X
   * @param roll Angle around Z */
	void setEuler(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		btScalar halfYaw = btScalar(yaw) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitch) * btScalar(0.5);
		btScalar halfRoll = btScalar(roll) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,
				 sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
	}
	/**@brief Set the quaternion using euler angles 
   * @param yaw Angle around Z
   * @param pitch Angle around Y
   * @param roll Angle around X */
	void setEulerZYX(const btScalar& yawZ, const btScalar& pitchY, const btScalar& rollX)
	{
		btScalar halfYaw = btScalar(yawZ) * btScalar(0.5);
		btScalar halfPitch = btScalar(pitchY) * btScalar(0.5);
		btScalar halfRoll = btScalar(rollX) * btScalar(0.5);
		btScalar cosYaw = btCos(halfYaw);
		btScalar sinYaw = btSin(halfYaw);
		btScalar cosPitch = btCos(halfPitch);
		btScalar sinPitch = btSin(halfPitch);
		btScalar cosRoll = btCos(halfRoll);
		btScalar sinRoll = btSin(halfRoll);
		setValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,   //x
				 cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,   //y
				 cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,   //z
				 cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);  //formerly yzx
	}

	/**@brief Get the euler angles from this quaternion
	   * @param yaw Angle around Z
	   * @param pitch Angle around Y
	   * @param roll Angle around X */
	void getEulerZYX(btScalar& yawZ, btScalar& pitchY, btScalar& rollX) const
	{
		btScalar squ;
		btScalar sqx;
		btScalar sqy;
		btScalar sqz;
		btScalar sarg;
		sqx = m_floats[0] * m_floats[0];
		sqy = m_floats[1] * m_floats[1];
		sqz = m_floats[2] * m_floats[2];
		squ = m_floats[3] * m_floats[3];
		sarg = btScalar(-2.) * (m_floats[0] * m_floats[2] - m_floats[3] * m_floats[1]);

		// If the pitch angle is PI/2 or -PI/2, we can only compute
		// the sum roll + yaw.  However, any combination that gives
		// the right sum will produce the correct orientation, so we
		// set rollX = 0 and compute yawZ.
		if (sarg <= -btScalar(0.99999))
		{
			pitchY = btScalar(-0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(m_floats[0], -m_floats[1]);
		}
		else if (sarg >= btScalar(0.99999))
		{
			pitchY = btScalar(0.5) * SIMD_PI;
			rollX = 0;
			yawZ = btScalar(2) * btAtan2(-m_floats[0], m_floats[1]);
		}
		else
		{
			pitchY = btAsin(sarg);
			rollX = btAtan2(2 * (m_floats[1] * m_floats[2] + m_floats[3] * m_floats[0]), squ - sqx - sqy + sqz);
			yawZ = btAtan2(2 * (m_floats[0] * m_floats[1] + m_floats[3] * m_floats[2]), squ + sqx - sqy - sqz);
		}
	}

	/**@brief Add two quaternions
   * @param q The quaternion to add to this one */
	SIMD_FORCE_INLINE btQuaternion& operator+=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_add_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vaddq_f32(mVec128, q.mVec128);
#else
		m_floats[0] += q.x();
		m_floats[1] += q.y();
		m_floats[2] += q.z();
		m_floats[3] += q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Subtract out a quaternion
   * @param q The quaternion to subtract from this one */
	btQuaternion& operator-=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		mVec128 = _mm_sub_ps(mVec128, q.mVec128);
#elif defined(BT_USE_NEON)
		mVec128 = vsubq_f32(mVec128, q.mVec128);
#else
		m_floats[0] -= q.x();
		m_floats[1] -= q.y();
		m_floats[2] -= q.z();
		m_floats[3] -= q.m_floats[3];
#endif
		return *this;
	}

	/**@brief Scale this quaternion
   * @param s The scalar to scale by */
	btQuaternion& operator*=(const btScalar& s)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0);     //	(S S S S)
		mVec128 = _mm_mul_ps(mVec128, vs);
#elif defined(BT_USE_NEON)
		mVec128 = vmulq_n_f32(mVec128, s);
#else
		m_floats[0] *= s;
		m_floats[1] *= s;
		m_floats[2] *= s;
		m_floats[3] *= s;
#endif
		return *this;
	}

	/**@brief Multiply this quaternion by q on the right
   * @param q The other quaternion 
   * Equivilant to this = this * q */
	btQuaternion& operator*=(const btQuaternion& q)
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vQ2 = q.get128();

		__m128 A1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(0, 1, 2, 0));
		__m128 B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));

		A1 = A1 * B1;

		__m128 A2 = bt_pshufd_ps(mVec128, BT_SHUFFLE(1, 2, 0, 1));
		__m128 B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

		A2 = A2 * B2;

		B1 = bt_pshufd_ps(mVec128, BT_SHUFFLE(2, 0, 1, 2));
		B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

		B1 = B1 * B2;  //	A3 *= B3

		mVec128 = bt_splat_ps(mVec128, 3);  //	A0
		mVec128 = mVec128 * vQ2;            //	A0 * B0

		A1 = A1 + A2;                //	AB12
		mVec128 = mVec128 - B1;      //	AB03 = AB0 - AB3
		A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
		mVec128 = mVec128 + A1;      //	AB03 + AB12

#elif defined(BT_USE_NEON)

		float32x4_t vQ1 = mVec128;
		float32x4_t vQ2 = q.get128();
		float32x4_t A0, A1, B1, A2, B2, A3, B3;
		float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

		{
			float32x2x2_t tmp;
			tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
			vQ1zx = tmp.val[0];

			tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
			vQ2zx = tmp.val[0];
		}
		vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

		vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

		vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
		vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

		A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
		B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

		A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
		B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

		A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
		B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

		A1 = vmulq_f32(A1, B1);
		A2 = vmulq_f32(A2, B2);
		A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
		A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

		A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
		A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

		//	change the sign of the last element
		A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
		A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

		mVec128 = A0;
#else
		setValue(
			m_floats[3] * q.x() + m_floats[0] * q.m_floats[3] + m_floats[1] * q.z() - m_floats[2] * q.y(),
			m_floats[3] * q.y() + m_floats[1] * q.m_floats[3] + m_floats[2] * q.x() - m_floats[0] * q.z(),
			m_floats[3] * q.z() + m_floats[2] * q.m_floats[3] + m_floats[0] * q.y() - m_floats[1] * q.x(),
			m_floats[3] * q.m_floats[3] - m_floats[0] * q.x() - m_floats[1] * q.y() - m_floats[2] * q.z());
#endif
		return *this;
	}
	/**@brief Return the dot product between this quaternion and another
   * @param q The other quaternion */
	btScalar dot(const btQuaternion& q) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, q.mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		return _mm_cvtss_f32(vd);
#elif defined(BT_USE_NEON)
		float32x4_t vd = vmulq_f32(mVec128, q.mVec128);
		float32x2_t x = vpadd_f32(vget_low_f32(vd), vget_high_f32(vd));
		x = vpadd_f32(x, x);
		return vget_lane_f32(x, 0);
#else
		return m_floats[0] * q.x() +
			   m_floats[1] * q.y() +
			   m_floats[2] * q.z() +
			   m_floats[3] * q.m_floats[3];
#endif
	}

	/**@brief Return the length squared of the quaternion */
	btScalar length2() const
	{
		return dot(*this);
	}

	/**@brief Return the length of the quaternion */
	btScalar length() const
	{
		return btSqrt(length2());
	}
	btQuaternion& safeNormalize()
	{
		btScalar l2 = length2();
		if (l2 > SIMD_EPSILON)
		{
			normalize();
		}
		return *this;
	}
	/**@brief Normalize the quaternion 
   * Such that x^2 + y^2 + z^2 +w^2 = 1 */
	btQuaternion& normalize()
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vd;

		vd = _mm_mul_ps(mVec128, mVec128);

		__m128 t = _mm_movehl_ps(vd, vd);
		vd = _mm_add_ps(vd, t);
		t = _mm_shuffle_ps(vd, vd, 0x55);
		vd = _mm_add_ss(vd, t);

		vd = _mm_sqrt_ss(vd);
		vd = _mm_div_ss(vOnes, vd);
		vd = bt_pshufd_ps(vd, 0);  // splat
		mVec128 = _mm_mul_ps(mVec128, vd);

		return *this;
#else
		return *this /= length();
#endif
	}

	/**@brief Return a scaled version of this quaternion
   * @param s The scale factor */
	SIMD_FORCE_INLINE btQuaternion
	operator*(const btScalar& s) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs = _mm_load_ss(&s);  //	(S 0 0 0)
		vs = bt_pshufd_ps(vs, 0x00);  //	(S S S S)

		return btQuaternion(_mm_mul_ps(mVec128, vs));
#elif defined(BT_USE_NEON)
		return btQuaternion(vmulq_n_f32(mVec128, s));
#else
		return btQuaternion(x() * s, y() * s, z() * s, m_floats[3] * s);
#endif
	}

	/**@brief Return an inversely scaled versionof this quaternion
   * @param s The inverse scale factor */
	btQuaternion operator/(const btScalar& s) const
	{
		btAssert(s != btScalar(0.0));
		return *this * (btScalar(1.0) / s);
	}

	/**@brief Inversely scale this quaternion
   * @param s The scale factor */
	btQuaternion& operator/=(const btScalar& s)
	{
		btAssert(s != btScalar(0.0));
		return *this *= btScalar(1.0) / s;
	}

	/**@brief Return a normalized version of this quaternion */
	btQuaternion normalized() const
	{
		return *this / length();
	}
	/**@brief Return the ***half*** angle between this quaternion and the other
   * @param q The other quaternion */
	btScalar angle(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		return btAcos(dot(q) / s);
	}

	/**@brief Return the angle between this quaternion and the other along the shortest path
	* @param q The other quaternion */
	btScalar angleShortestPath(const btQuaternion& q) const
	{
		btScalar s = btSqrt(length2() * q.length2());
		btAssert(s != btScalar(0.0));
		if (dot(q) < 0)  // Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			return btAcos(dot(-q) / s) * btScalar(2.0);
		else
			return btAcos(dot(q) / s) * btScalar(2.0);
	}

	/**@brief Return the angle [0, 2Pi] of rotation represented by this quaternion */
	btScalar getAngle() const
	{
		btScalar s = btScalar(2.) * btAcos(m_floats[3]);
		return s;
	}

	/**@brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path */
	btScalar getAngleShortestPath() const
	{
		btScalar s;
		if (m_floats[3] >= 0)
			s = btScalar(2.) * btAcos(m_floats[3]);
		else
			s = btScalar(2.) * btAcos(-m_floats[3]);
		return s;
	}

	/**@brief Return the axis of the rotation represented by this quaternion */
	btVector3 getAxis() const
	{
		btScalar s_squared = 1.f - m_floats[3] * m_floats[3];

		if (s_squared < btScalar(10.) * SIMD_EPSILON)  //Check for divide by zero
			return btVector3(1.0, 0.0, 0.0);           // Arbitrary
		btScalar s = 1.f / btSqrt(s_squared);
		return btVector3(m_floats[0] * s, m_floats[1] * s, m_floats[2] * s);
	}

	/**@brief Return the inverse of this quaternion */
	btQuaternion inverse() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, vQInv));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)vQInv));
#else
		return btQuaternion(-m_floats[0], -m_floats[1], -m_floats[2], m_floats[3]);
#endif
	}

	/**@brief Return the sum of this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator+(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_add_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vaddq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() + q2.x(), q1.y() + q2.y(), q1.z() + q2.z(), q1.m_floats[3] + q2.m_floats[3]);
#endif
	}

	/**@brief Return the difference between this quaternion and the other 
   * @param q2 The other quaternion */
	SIMD_FORCE_INLINE btQuaternion
	operator-(const btQuaternion& q2) const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_sub_ps(mVec128, q2.mVec128));
#elif defined(BT_USE_NEON)
		return btQuaternion(vsubq_f32(mVec128, q2.mVec128));
#else
		const btQuaternion& q1 = *this;
		return btQuaternion(q1.x() - q2.x(), q1.y() - q2.y(), q1.z() - q2.z(), q1.m_floats[3] - q2.m_floats[3]);
#endif
	}

	/**@brief Return the negative of this quaternion 
   * This simply negates each element */
	SIMD_FORCE_INLINE btQuaternion operator-() const
	{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		return btQuaternion(_mm_xor_ps(mVec128, btvMzeroMask));
#elif defined(BT_USE_NEON)
		return btQuaternion((btSimdFloat4)veorq_s32((int32x4_t)mVec128, (int32x4_t)btvMzeroMask));
#else
		const btQuaternion& q2 = *this;
		return btQuaternion(-q2.x(), -q2.y(), -q2.z(), -q2.m_floats[3]);
#endif
	}
	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion farthest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) > sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@todo document this and it's use */
	SIMD_FORCE_INLINE btQuaternion nearest(const btQuaternion& qd) const
	{
		btQuaternion diff, sum;
		diff = *this - qd;
		sum = *this + qd;
		if (diff.dot(diff) < sum.dot(sum))
			return qd;
		return (-qd);
	}

	/**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
   * @param q The other quaternion to interpolate with 
   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
   * Slerp interpolates assuming constant velocity.  */
	btQuaternion slerp(const btQuaternion& q, const btScalar& t) const
	{
		const btScalar magnitude = btSqrt(length2() * q.length2());
		btAssert(magnitude > btScalar(0));

		const btScalar product = dot(q) / magnitude;
		const btScalar absproduct = btFabs(product);

		if (absproduct < btScalar(1.0 - SIMD_EPSILON))
		{
			// Take care of long angle case see http://en.wikipedia.org/wiki/Slerp
			const btScalar theta = btAcos(absproduct);
			const btScalar d = btSin(theta);
			btAssert(d > btScalar(0));

			const btScalar sign = (product < 0) ? btScalar(-1) : btScalar(1);
			const btScalar s0 = btSin((btScalar(1.0) - t) * theta) / d;
			const btScalar s1 = btSin(sign * t * theta) / d;

			return btQuaternion(
				(m_floats[0] * s0 + q.x() * s1),
				(m_floats[1] * s0 + q.y() * s1),
				(m_floats[2] * s0 + q.z() * s1),
				(m_floats[3] * s0 + q.w() * s1));
		}
		else
		{
			return *this;
		}
	}

	static const btQuaternion& getIdentity()
	{
		static const btQuaternion identityQuat(btScalar(0.), btScalar(0.), btScalar(0.), btScalar(1.));
		return identityQuat;
	}

	SIMD_FORCE_INLINE const btScalar& getW() const { return m_floats[3]; }

	SIMD_FORCE_INLINE void serialize(struct btQuaternionData& dataOut) const;

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void deSerialize(const struct btQuaternionDoubleData& dataIn);

	SIMD_FORCE_INLINE void serializeFloat(struct btQuaternionFloatData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeFloat(const struct btQuaternionFloatData& dataIn);

	SIMD_FORCE_INLINE void serializeDouble(struct btQuaternionDoubleData& dataOut) const;

	SIMD_FORCE_INLINE void deSerializeDouble(const struct btQuaternionDoubleData& dataIn);
};

/**@brief Return the product of two quaternions */
SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q1, const btQuaternion& q2)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q1.get128();
	__m128 vQ2 = q2.get128();
	__m128 A0, A1, B1, A2, B2;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x     //      vtrn
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X     // vdup vext

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));  // Y Z  X Y     // vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));  // z x  Y Y     // vtrn vdup

	A2 = A2 * B2;

	B1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));  // z x Y Z      // vtrn vext
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));  // Y Z x z      // vext vtrn

	B1 = B1 * B2;  //	A3 *= B3

	A0 = bt_splat_ps(vQ1, 3);  //	A0
	A0 = A0 * vQ2;             //	A0 * B0

	A1 = A1 + A2;  //	AB12
	A0 = A0 - B1;  //	AB03 = AB0 - AB3

	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A0 = A0 + A1;                //	AB03 + AB12

	return btQuaternion(A0);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q1.get128();
	float32x4_t vQ2 = q2.get128();
	float32x4_t A0, A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;
		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);                           //	A3 *= B3
	A0 = vmulq_lane_f32(vQ2, vget_high_f32(vQ1), 1);  //	A0 * B0

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2
	A0 = vsubq_f32(A0, A3);  //	AB03 = AB0 - AB3

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);
	A0 = vaddq_f32(A0, A1);  //	AB03 + AB12

	return btQuaternion(A0);

#else
	return btQuaternion(
		q1.w() * q2.x() + q1.x() * q2.w() + q1.y() * q2.z() - q1.z() * q2.y(),
		q1.w() * q2.y() + q1.y() * q2.w() + q1.z() * q2.x() - q1.x() * q2.z(),
		q1.w() * q2.z() + q1.z() * q2.w() + q1.x() * q2.y() - q1.y() * q2.x(),
		q1.w() * q2.w() - q1.x() * q2.x() - q1.y() * q2.y() - q1.z() * q2.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q, const btVector3& w)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = q.get128();
	__m128 vQ2 = w.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(3, 3, 3, 0));
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(0, 1, 2, 0));

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = q.get128();
	float32x4_t vQ2 = w.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1wx, vQ2zx, vQ1yz, vQ2yz, vQ1zx, vQ2xz;

	vQ1wx = vext_f32(vget_high_f32(vQ1), vget_low_f32(vQ1), 1);
	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];
	}

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ1), 1), vQ1wx);  // W W  W X
	B1 = vcombine_f32(vget_low_f32(vQ2), vQ2zx);                     // X Y  z x

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		q.w() * w.x() + q.y() * w.z() - q.z() * w.y(),
		q.w() * w.y() + q.z() * w.x() - q.x() * w.z(),
		q.w() * w.z() + q.x() * w.y() - q.y() * w.x(),
		-q.x() * w.x() - q.y() * w.y() - q.z() * w.z());
#endif
}

SIMD_FORCE_INLINE btQuaternion
operator*(const btVector3& w, const btQuaternion& q)
{
#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 vQ1 = w.get128();
	__m128 vQ2 = q.get128();
	__m128 A1, B1, A2, B2, A3, B3;

	A1 = bt_pshufd_ps(vQ1, BT_SHUFFLE(0, 1, 2, 0));  // X Y  z x
	B1 = bt_pshufd_ps(vQ2, BT_SHUFFLE(3, 3, 3, 0));  // W W  W X

	A1 = A1 * B1;

	A2 = bt_pshufd_ps(vQ1, BT_SHUFFLE(1, 2, 0, 1));
	B2 = bt_pshufd_ps(vQ2, BT_SHUFFLE(2, 0, 1, 1));

	A2 = A2 * B2;

	A3 = bt_pshufd_ps(vQ1, BT_SHUFFLE(2, 0, 1, 2));
	B3 = bt_pshufd_ps(vQ2, BT_SHUFFLE(1, 2, 0, 2));

	A3 = A3 * B3;  //	A3 *= B3

	A1 = A1 + A2;                //	AB12
	A1 = _mm_xor_ps(A1, vPPPM);  //	change sign of the last element
	A1 = A1 - A3;                //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#elif defined(BT_USE_NEON)

	float32x4_t vQ1 = w.get128();
	float32x4_t vQ2 = q.get128();
	float32x4_t A1, B1, A2, B2, A3, B3;
	float32x2_t vQ1zx, vQ2wx, vQ1yz, vQ2zx, vQ2yz, vQ2xz;

	{
		float32x2x2_t tmp;

		tmp = vtrn_f32(vget_high_f32(vQ1), vget_low_f32(vQ1));  // {z x}, {w y}
		vQ1zx = tmp.val[0];

		tmp = vtrn_f32(vget_high_f32(vQ2), vget_low_f32(vQ2));  // {z x}, {w y}
		vQ2zx = tmp.val[0];
	}
	vQ2wx = vext_f32(vget_high_f32(vQ2), vget_low_f32(vQ2), 1);

	vQ1yz = vext_f32(vget_low_f32(vQ1), vget_high_f32(vQ1), 1);

	vQ2yz = vext_f32(vget_low_f32(vQ2), vget_high_f32(vQ2), 1);
	vQ2xz = vext_f32(vQ2zx, vQ2zx, 1);

	A1 = vcombine_f32(vget_low_f32(vQ1), vQ1zx);                     // X Y  z x
	B1 = vcombine_f32(vdup_lane_f32(vget_high_f32(vQ2), 1), vQ2wx);  // W W  W X

	A2 = vcombine_f32(vQ1yz, vget_low_f32(vQ1));
	B2 = vcombine_f32(vQ2zx, vdup_lane_f32(vget_low_f32(vQ2), 1));

	A3 = vcombine_f32(vQ1zx, vQ1yz);  // Z X Y Z
	B3 = vcombine_f32(vQ2yz, vQ2xz);  // Y Z x z

	A1 = vmulq_f32(A1, B1);
	A2 = vmulq_f32(A2, B2);
	A3 = vmulq_f32(A3, B3);  //	A3 *= B3

	A1 = vaddq_f32(A1, A2);  //	AB12 = AB1 + AB2

	//	change the sign of the last element
	A1 = (btSimdFloat4)veorq_s32((int32x4_t)A1, (int32x4_t)vPPPM);

	A1 = vsubq_f32(A1, A3);  //	AB123 = AB12 - AB3

	return btQuaternion(A1);

#else
	return btQuaternion(
		+w.x() * q.w() + w.y() * q.z() - w.z() * q.y(),
		+w.y() * q.w() + w.z() * q.x() - w.x() * q.z(),
		+w.z() * q.w() + w.x() * q.y() - w.y() * q.x(),
		-w.x() * q.x() - w.y() * q.y() - w.z() * q.z());
#endif
}

/**@brief Calculate the dot product between two quaternions */
SIMD_FORCE_INLINE btScalar
dot(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.dot(q2);
}

/**@brief Return the length of a quaternion */
SIMD_FORCE_INLINE btScalar
length(const btQuaternion& q)
{
	return q.length();
}

/**@brief Return the angle between two quaternions*/
SIMD_FORCE_INLINE btScalar
btAngle(const btQuaternion& q1, const btQuaternion& q2)
{
	return q1.angle(q2);
}

/**@brief Return the inverse of a quaternion*/
SIMD_FORCE_INLINE btQuaternion
inverse(const btQuaternion& q)
{
	return q.inverse();
}

/**@brief Return the result of spherical linear interpolation betwen two quaternions 
 * @param q1 The first quaternion
 * @param q2 The second quaternion 
 * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
 * Slerp assumes constant velocity between positions. */
SIMD_FORCE_INLINE btQuaternion
slerp(const btQuaternion& q1, const btQuaternion& q2, const btScalar& t)
{
	return q1.slerp(q2, t);
}

SIMD_FORCE_INLINE btVector3
quatRotate(const btQuaternion& rotation, const btVector3& v)
{
	btQuaternion q = rotation * v;
	q *= rotation.inverse();
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	return btVector3(_mm_and_ps(q.get128(), btvFFF0fMask));
#elif defined(BT_USE_NEON)
	return btVector3((float32x4_t)vandq_s32((int32x4_t)q.get128(), btvFFF0Mask));
#else
	return btVector3(q.getX(), q.getY(), q.getZ());
#endif
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuat(const btVector3& v0, const btVector3& v1)  // Game Programming Gems 2.10. make sure v0,v1 are normalized
{
	btVector3 c = v0.cross(v1);
	btScalar d = v0.dot(v1);

	if (d < -1.0 + SIMD_EPSILON)
	{
		btVector3 n, unused;
		btPlaneSpace1(v0, n, unused);
		return btQuaternion(n.x(), n.y(), n.z(), 0.0f);  // just pick any vector that is orthogonal to v0
	}

	btScalar s = btSqrt((1.0f + d) * 2.0f);
	btScalar rs = 1.0f / s;

	return btQuaternion(c.getX() * rs, c.getY() * rs, c.getZ() * rs, s * 0.5f);
}

SIMD_FORCE_INLINE btQuaternion
shortestArcQuatNormalize2(btVector3& v0, btVector3& v1)
{
	v0.normalize();
	v1.normalize();
	return shortestArcQuat(v0, v1);
}

struct btQuaternionFloatData
{
	float m_floats[4];
};

struct btQuaternionDoubleData
{
	double m_floats[4];
};

SIMD_FORCE_INLINE void btQuaternion::serializeFloat(struct btQuaternionFloatData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = float(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeFloat(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serializeDouble(struct btQuaternionDoubleData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = double(m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::deSerializeDouble(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = btScalar(dataIn.m_floats[i]);
}

SIMD_FORCE_INLINE void btQuaternion::serialize(struct btQuaternionData& dataOut) const
{
	///could also do a memcpy, check if it is worth it
	for (int i = 0; i < 4; i++)
		dataOut.m_floats[i] = m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionFloatData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

SIMD_FORCE_INLINE void btQuaternion::deSerialize(const struct btQuaternionDoubleData& dataIn)
{
	for (int i = 0; i < 4; i++)
		m_floats[i] = (btScalar)dataIn.m_floats[i];
}

#endif  //BT_SIMD__QUATERNION_H_





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MATRIX3x3_H
#define BT_MATRIX3x3_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btQuaternion.h"

#ifdef BT_USE_SSE
//const __m128 ATTRIBUTE_ALIGNED16(v2220) = {2.0f, 2.0f, 2.0f, 0.0f};
//const __m128 ATTRIBUTE_ALIGNED16(vMPPP) = {-0.0f, +0.0f, +0.0f, +0.0f};
#define vMPPP (_mm_set_ps(+0.0f, +0.0f, +0.0f, -0.0f))
#endif

#if defined(BT_USE_SSE)
#define v0000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 0.0f))
#define v1000 (_mm_set_ps(0.0f, 0.0f, 0.0f, 1.0f))
#define v0100 (_mm_set_ps(0.0f, 0.0f, 1.0f, 0.0f))
#define v0010 (_mm_set_ps(0.0f, 1.0f, 0.0f, 0.0f))
#elif defined(BT_USE_NEON)
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0000) = {0.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v1000) = {1.0f, 0.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0100) = {0.0f, 1.0f, 0.0f, 0.0f};
const btSimdFloat4 ATTRIBUTE_ALIGNED16(v0010) = {0.0f, 0.0f, 1.0f, 0.0f};
#endif

#ifdef BT_USE_DOUBLE_PRECISION
#define btMatrix3x3Data btMatrix3x3DoubleData
#else
#define btMatrix3x3Data btMatrix3x3FloatData
#endif  //BT_USE_DOUBLE_PRECISION

/**@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
ATTRIBUTE_ALIGNED16(class)
btMatrix3x3
{
	///Data storage for the matrix, each vector is a row of the matrix
	btVector3 m_el[3];

public:
	/** @brief No initializaion constructor */
	btMatrix3x3() {}

	//		explicit btMatrix3x3(const btScalar *m) { setFromOpenGLSubMatrix(m); }

	/**@brief Constructor from Quaternion */
	explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }
	/*
	template <typename btScalar>
	Matrix3x3(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{ 
	setEulerYPR(yaw, pitch, roll);
	}
	*/
	/** @brief Constructor with row major formatting */
	btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				const btScalar& yx, const btScalar& yy, const btScalar& yz,
				const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		setValue(xx, xy, xz,
				 yx, yy, yz,
				 zx, zy, zz);
	}

#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	SIMD_FORCE_INLINE btMatrix3x3(const btSimdFloat4 v0, const btSimdFloat4 v1, const btSimdFloat4 v2)
	{
		m_el[0].mVec128 = v0;
		m_el[1].mVec128 = v1;
		m_el[2].mVec128 = v2;
	}

	SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
	{
		m_el[0] = v0;
		m_el[1] = v1;
		m_el[2] = v2;
	}

	// Copy constructor
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& rhs)
	{
		m_el[0].mVec128 = rhs.m_el[0].mVec128;
		m_el[1].mVec128 = rhs.m_el[1].mVec128;
		m_el[2].mVec128 = rhs.m_el[2].mVec128;
	}

	// Assignment Operator
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& m)
	{
		m_el[0].mVec128 = m.m_el[0].mVec128;
		m_el[1].mVec128 = m.m_el[1].mVec128;
		m_el[2].mVec128 = m.m_el[2].mVec128;

		return *this;
	}

#else

	/** @brief Copy constructor */
	SIMD_FORCE_INLINE btMatrix3x3(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
	}

	/** @brief Assignment Operator */
	SIMD_FORCE_INLINE btMatrix3x3& operator=(const btMatrix3x3& other)
	{
		m_el[0] = other.m_el[0];
		m_el[1] = other.m_el[1];
		m_el[2] = other.m_el[2];
		return *this;
	}
    
    SIMD_FORCE_INLINE btMatrix3x3(const btVector3& v0, const btVector3& v1, const btVector3& v2)
    {
        m_el[0] = v0;
        m_el[1] = v1;
        m_el[2] = v2;
    }

#endif

	/** @brief Get a column of the matrix as a vector 
	*  @param i Column number 0 indexed */
	SIMD_FORCE_INLINE btVector3 getColumn(int i) const
	{
		return btVector3(m_el[0][i], m_el[1][i], m_el[2][i]);
	}

	/** @brief Get a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& getRow(int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a mutable reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE btVector3& operator[](int i)
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Get a const reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	SIMD_FORCE_INLINE const btVector3& operator[](int i) const
	{
		btFullAssert(0 <= i && i < 3);
		return m_el[i];
	}

	/** @brief Multiply by the target matrix on the right
	*  @param m Rotation matrix to be applied 
	* Equivilant to this = this * m */
	btMatrix3x3& operator*=(const btMatrix3x3& m);

	/** @brief Adds by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this + m */
	btMatrix3x3& operator+=(const btMatrix3x3& m);

	/** @brief Substractss by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this - m */
	btMatrix3x3& operator-=(const btMatrix3x3& m);

	/** @brief Set from the rotational part of a 4x4 OpenGL matrix
	*  @param m A pointer to the beginning of the array of scalars*/
	void setFromOpenGLSubMatrix(const btScalar* m)
	{
		m_el[0].setValue(m[0], m[4], m[8]);
		m_el[1].setValue(m[1], m[5], m[9]);
		m_el[2].setValue(m[2], m[6], m[10]);
	}
	/** @brief Set the values of the matrix explicitly (row major)
	*  @param xx Top left
	*  @param xy Top Middle
	*  @param xz Top Right
	*  @param yx Middle Left
	*  @param yy Middle Middle
	*  @param yz Middle Right
	*  @param zx Bottom Left
	*  @param zy Bottom Middle
	*  @param zz Bottom Right*/
	void setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz,
				  const btScalar& yx, const btScalar& yy, const btScalar& yz,
				  const btScalar& zx, const btScalar& zy, const btScalar& zz)
	{
		m_el[0].setValue(xx, xy, xz);
		m_el[1].setValue(yx, yy, yz);
		m_el[2].setValue(zx, zy, zz);
	}

	/** @brief Set the matrix from a quaternion
	*  @param q The Quaternion to match */
	void setRotation(const btQuaternion& q)
	{
		btScalar d = q.length2();
		btFullAssert(d != btScalar(0.0));
		btScalar s = btScalar(2.0) / d;

#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 vs, Q = q.get128();
		__m128i Qi = btCastfTo128i(Q);
		__m128 Y, Z;
		__m128 V1, V2, V3;
		__m128 V11, V21, V31;
		__m128 NQ = _mm_xor_ps(Q, btvMzeroMask);
		__m128i NQi = btCastfTo128i(NQ);

		V1 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 2, 3)));  // Y X Z W
		V2 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(0, 0, 1, 3));                 // -X -X  Y  W
		V3 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(2, 1, 0, 3)));  // Z Y X W
		V1 = _mm_xor_ps(V1, vMPPP);                                         //	change the sign of the first element

		V11 = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 1, 0, 3)));  // Y Y X W
		V21 = _mm_unpackhi_ps(Q, Q);                                         //  Z  Z  W  W
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(0, 2, 0, 3));                 //  X  Z -X -W

		V2 = V2 * V1;   //
		V1 = V1 * V11;  //
		V3 = V3 * V31;  //

		V11 = _mm_shuffle_ps(NQ, Q, BT_SHUFFLE(2, 3, 1, 3));                //	-Z -W  Y  W
		V11 = V11 * V21;                                                    //
		V21 = _mm_xor_ps(V21, vMPPP);                                       //	change the sign of the first element
		V31 = _mm_shuffle_ps(Q, NQ, BT_SHUFFLE(3, 3, 1, 3));                //	 W  W -Y -W
		V31 = _mm_xor_ps(V31, vMPPP);                                       //	change the sign of the first element
		Y = btCastiTo128f(_mm_shuffle_epi32(NQi, BT_SHUFFLE(3, 2, 0, 3)));  // -W -Z -X -W
		Z = btCastiTo128f(_mm_shuffle_epi32(Qi, BT_SHUFFLE(1, 0, 1, 3)));   //  Y  X  Y  W

		vs = _mm_load_ss(&s);
		V21 = V21 * Y;
		V31 = V31 * Z;

		V1 = V1 + V11;
		V2 = V2 + V21;
		V3 = V3 + V31;

		vs = bt_splat3_ps(vs, 0);
		//	s ready
		V1 = V1 * vs;
		V2 = V2 * vs;
		V3 = V3 * vs;

		V1 = V1 + v1000;
		V2 = V2 + v0100;
		V3 = V3 + v0010;

		m_el[0] = V1;
		m_el[1] = V2;
		m_el[2] = V3;
#else
		btScalar xs = q.x() * s, ys = q.y() * s, zs = q.z() * s;
		btScalar wx = q.w() * xs, wy = q.w() * ys, wz = q.w() * zs;
		btScalar xx = q.x() * xs, xy = q.x() * ys, xz = q.x() * zs;
		btScalar yy = q.y() * ys, yz = q.y() * zs, zz = q.z() * zs;
		setValue(
			btScalar(1.0) - (yy + zz), xy - wz, xz + wy,
			xy + wz, btScalar(1.0) - (xx + zz), yz - wx,
			xz - wy, yz + wx, btScalar(1.0) - (xx + yy));
#endif
	}

	/** @brief Set the matrix from euler angles using YPR around YXZ respectively
	*  @param yaw Yaw about Y axis
	*  @param pitch Pitch about X axis
	*  @param roll Roll about Z axis 
	*/
	void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{
		setEulerZYX(roll, pitch, yaw);
	}

	/** @brief Set the matrix from euler angles YPR around ZYX axes
	* @param eulerX Roll about X axis
	* @param eulerY Pitch around Y axis
	* @param eulerZ Yaw about Z axis
	* 
	* These angles are used to produce a rotation matrix. The euler
	* angles are applied in ZYX order. I.e a vector is first rotated 
	* about X then Y and then Z
	**/
	void setEulerZYX(btScalar eulerX, btScalar eulerY, btScalar eulerZ)
	{
		///@todo proposed to reverse this since it's labeled zyx but takes arguments xyz and it will match all other parts of the code
		btScalar ci(btCos(eulerX));
		btScalar cj(btCos(eulerY));
		btScalar ch(btCos(eulerZ));
		btScalar si(btSin(eulerX));
		btScalar sj(btSin(eulerY));
		btScalar sh(btSin(eulerZ));
		btScalar cc = ci * ch;
		btScalar cs = ci * sh;
		btScalar sc = si * ch;
		btScalar ss = si * sh;

		setValue(cj * ch, sj * sc - cs, sj * cc + ss,
				 cj * sh, sj * ss + cc, sj * cs - sc,
				 -sj, cj * si, cj * ci);
	}

	/**@brief Set the matrix to the identity */
	void setIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		m_el[0] = v1000;
		m_el[1] = v0100;
		m_el[2] = v0010;
#else
		setValue(btScalar(1.0), btScalar(0.0), btScalar(0.0),
				 btScalar(0.0), btScalar(1.0), btScalar(0.0),
				 btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
	}
    
    /**@brief Set the matrix to the identity */
    void setZero()
    {
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
        m_el[0] = v0000;
        m_el[1] = v0000;
        m_el[2] = v0000;
#else
        setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0),
                 btScalar(0.0), btScalar(0.0), btScalar(0.0));
#endif
    }

	static const btMatrix3x3& getIdentity()
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		static const btMatrix3x3
			identityMatrix(v1000, v0100, v0010);
#else
		static const btMatrix3x3
			identityMatrix(
				btScalar(1.0), btScalar(0.0), btScalar(0.0),
				btScalar(0.0), btScalar(1.0), btScalar(0.0),
				btScalar(0.0), btScalar(0.0), btScalar(1.0));
#endif
		return identityMatrix;
	}

	/**@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
	* @param m The array to be filled */
	void getOpenGLSubMatrix(btScalar * m) const
	{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
		__m128 v0 = m_el[0].mVec128;
		__m128 v1 = m_el[1].mVec128;
		__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
		__m128* vm = (__m128*)m;
		__m128 vT;

		v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

		vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
		v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

		v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
		v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
		v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#elif defined(BT_USE_NEON)
		// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
		static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
		float32x4_t* vm = (float32x4_t*)m;
		float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
		float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
		float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
		float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
		float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
		float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0

		vm[0] = v0;
		vm[1] = v1;
		vm[2] = v2;
#else
		m[0] = btScalar(m_el[0].x());
		m[1] = btScalar(m_el[1].x());
		m[2] = btScalar(m_el[2].x());
		m[3] = btScalar(0.0);
		m[4] = btScalar(m_el[0].y());
		m[5] = btScalar(m_el[1].y());
		m[6] = btScalar(m_el[2].y());
		m[7] = btScalar(0.0);
		m[8] = btScalar(m_el[0].z());
		m[9] = btScalar(m_el[1].z());
		m[10] = btScalar(m_el[2].z());
		m[11] = btScalar(0.0);
#endif
	}

	/**@brief Get the matrix represented as a quaternion 
	* @param q The quaternion which will be set */
	void getRotation(btQuaternion & q) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
		btScalar s, x;

		union {
			btSimdFloat4 vec;
			btScalar f[4];
		} temp;

		if (trace > btScalar(0.0))
		{
			x = trace + btScalar(1.0);

			temp.f[0] = m_el[2].y() - m_el[1].z();
			temp.f[1] = m_el[0].z() - m_el[2].x();
			temp.f[2] = m_el[1].x() - m_el[0].y();
			temp.f[3] = x;
			//temp.f[3]= s * btScalar(0.5);
		}
		else
		{
			int i, j, k;
			if (m_el[0].x() < m_el[1].y())
			{
				if (m_el[1].y() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 1;
					j = 2;
					k = 0;
				}
			}
			else
			{
				if (m_el[0].x() < m_el[2].z())
				{
					i = 2;
					j = 0;
					k = 1;
				}
				else
				{
					i = 0;
					j = 1;
					k = 2;
				}
			}

			x = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);

			temp.f[3] = (m_el[k][j] - m_el[j][k]);
			temp.f[j] = (m_el[j][i] + m_el[i][j]);
			temp.f[k] = (m_el[k][i] + m_el[i][k]);
			temp.f[i] = x;
			//temp.f[i] = s * btScalar(0.5);
		}

		s = btSqrt(x);
		q.set128(temp.vec);
		s = btScalar(0.5) / s;

		q *= s;
#else
		btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();

		btScalar temp[4];

		if (trace > btScalar(0.0))
		{
			btScalar s = btSqrt(trace + btScalar(1.0));
			temp[3] = (s * btScalar(0.5));
			s = btScalar(0.5) / s;

			temp[0] = ((m_el[2].y() - m_el[1].z()) * s);
			temp[1] = ((m_el[0].z() - m_el[2].x()) * s);
			temp[2] = ((m_el[1].x() - m_el[0].y()) * s);
		}
		else
		{
			int i = m_el[0].x() < m_el[1].y() ? (m_el[1].y() < m_el[2].z() ? 2 : 1) : (m_el[0].x() < m_el[2].z() ? 2 : 0);
			int j = (i + 1) % 3;
			int k = (i + 2) % 3;

			btScalar s = btSqrt(m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0));
			temp[i] = s * btScalar(0.5);
			s = btScalar(0.5) / s;

			temp[3] = (m_el[k][j] - m_el[j][k]) * s;
			temp[j] = (m_el[j][i] + m_el[i][j]) * s;
			temp[k] = (m_el[k][i] + m_el[i][k]) * s;
		}
		q.setValue(temp[0], temp[1], temp[2], temp[3]);
#endif
	}

	/**@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
	* @param yaw Yaw around Y axis
	* @param pitch Pitch around X axis
	* @param roll around Z axis */
	void getEulerYPR(btScalar & yaw, btScalar & pitch, btScalar & roll) const
	{
		// first use the normal calculus
		yaw = btScalar(btAtan2(m_el[1].x(), m_el[0].x()));
		pitch = btScalar(btAsin(-m_el[2].x()));
		roll = btScalar(btAtan2(m_el[2].y(), m_el[2].z()));

		// on pitch = +/-HalfPI
		if (btFabs(pitch) == SIMD_HALF_PI)
		{
			if (yaw > 0)
				yaw -= SIMD_PI;
			else
				yaw += SIMD_PI;

			if (roll > 0)
				roll -= SIMD_PI;
			else
				roll += SIMD_PI;
		}
	};

	/**@brief Get the matrix represented as euler angles around ZYX
	* @param yaw Yaw around Z axis
	* @param pitch Pitch around Y axis
	* @param roll around X axis 
	* @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
	void getEulerZYX(btScalar & yaw, btScalar & pitch, btScalar & roll, unsigned int solution_number = 1) const
	{
		struct Euler
		{
			btScalar yaw;
			btScalar pitch;
			btScalar roll;
		};

		Euler euler_out;
		Euler euler_out2;  //second solution
		//get the pointer to the raw data

		// Check that pitch is not at a singularity
		if (btFabs(m_el[2].x()) >= 1)
		{
			euler_out.yaw = 0;
			euler_out2.yaw = 0;

			// From difference of angles formula
			btScalar delta = btAtan2(m_el[0].x(), m_el[0].z());
			if (m_el[2].x() > 0)  //gimbal locked up
			{
				euler_out.pitch = SIMD_PI / btScalar(2.0);
				euler_out2.pitch = SIMD_PI / btScalar(2.0);
				euler_out.roll = euler_out.pitch + delta;
				euler_out2.roll = euler_out.pitch + delta;
			}
			else  // gimbal locked down
			{
				euler_out.pitch = -SIMD_PI / btScalar(2.0);
				euler_out2.pitch = -SIMD_PI / btScalar(2.0);
				euler_out.roll = -euler_out.pitch + delta;
				euler_out2.roll = -euler_out.pitch + delta;
			}
		}
		else
		{
			euler_out.pitch = -btAsin(m_el[2].x());
			euler_out2.pitch = SIMD_PI - euler_out.pitch;

			euler_out.roll = btAtan2(m_el[2].y() / btCos(euler_out.pitch),
									 m_el[2].z() / btCos(euler_out.pitch));
			euler_out2.roll = btAtan2(m_el[2].y() / btCos(euler_out2.pitch),
									  m_el[2].z() / btCos(euler_out2.pitch));

			euler_out.yaw = btAtan2(m_el[1].x() / btCos(euler_out.pitch),
									m_el[0].x() / btCos(euler_out.pitch));
			euler_out2.yaw = btAtan2(m_el[1].x() / btCos(euler_out2.pitch),
									 m_el[0].x() / btCos(euler_out2.pitch));
		}

		if (solution_number == 1)
		{
			yaw = euler_out.yaw;
			pitch = euler_out.pitch;
			roll = euler_out.roll;
		}
		else
		{
			yaw = euler_out2.yaw;
			pitch = euler_out2.pitch;
			roll = euler_out2.roll;
		}
	}

	/**@brief Create a scaled copy of the matrix 
	* @param s Scaling vector The elements of the vector will scale each column */

	btMatrix3x3 scaled(const btVector3& s) const
	{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
		return btMatrix3x3(m_el[0] * s, m_el[1] * s, m_el[2] * s);
#else
		return btMatrix3x3(
			m_el[0].x() * s.x(), m_el[0].y() * s.y(), m_el[0].z() * s.z(),
			m_el[1].x() * s.x(), m_el[1].y() * s.y(), m_el[1].z() * s.z(),
			m_el[2].x() * s.x(), m_el[2].y() * s.y(), m_el[2].z() * s.z());
#endif
	}

	/**@brief Return the determinant of the matrix */
	btScalar determinant() const;
	/**@brief Return the adjoint of the matrix */
	btMatrix3x3 adjoint() const;
	/**@brief Return the matrix with all values non negative */
	btMatrix3x3 absolute() const;
	/**@brief Return the transpose of the matrix */
	btMatrix3x3 transpose() const;
	/**@brief Return the inverse of the matrix */
	btMatrix3x3 inverse() const;

	/// Solve A * x = b, where b is a column vector. This is more efficient
	/// than computing the inverse in one-shot cases.
	///Solve33 is from Box2d, thanks to Erin Catto,
	btVector3 solve33(const btVector3& b) const
	{
		btVector3 col1 = getColumn(0);
		btVector3 col2 = getColumn(1);
		btVector3 col3 = getColumn(2);

		btScalar det = btDot(col1, btCross(col2, col3));
		if (btFabs(det) > SIMD_EPSILON)
		{
			det = 1.0f / det;
		}
		btVector3 x;
		x[0] = det * btDot(b, btCross(col2, col3));
		x[1] = det * btDot(col1, btCross(b, col3));
		x[2] = det * btDot(col1, btCross(col2, b));
		return x;
	}

	btMatrix3x3 transposeTimes(const btMatrix3x3& m) const;
	btMatrix3x3 timesTranspose(const btMatrix3x3& m) const;

	SIMD_FORCE_INLINE btScalar tdotx(const btVector3& v) const
	{
		return m_el[0].x() * v.x() + m_el[1].x() * v.y() + m_el[2].x() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdoty(const btVector3& v) const
	{
		return m_el[0].y() * v.x() + m_el[1].y() * v.y() + m_el[2].y() * v.z();
	}
	SIMD_FORCE_INLINE btScalar tdotz(const btVector3& v) const
	{
		return m_el[0].z() * v.x() + m_el[1].z() * v.y() + m_el[2].z() * v.z();
	}

	///extractRotation is from "A robust method to extract the rotational part of deformations"
	///See http://dl.acm.org/citation.cfm?doid=2994258.2994269
	///decomposes a matrix A in a orthogonal matrix R and a
	///symmetric matrix S:
	///A = R*S.
	///note that R can include both rotation and scaling.
	SIMD_FORCE_INLINE void extractRotation(btQuaternion & q, btScalar tolerance = 1.0e-9, int maxIter = 100)
	{
		int iter = 0;
		btScalar w;
		const btMatrix3x3& A = *this;
		for (iter = 0; iter < maxIter; iter++)
		{
			btMatrix3x3 R(q);
			btVector3 omega = (R.getColumn(0).cross(A.getColumn(0)) + R.getColumn(1).cross(A.getColumn(1)) + R.getColumn(2).cross(A.getColumn(2))) * (btScalar(1.0) / btFabs(R.getColumn(0).dot(A.getColumn(0)) + R.getColumn(1).dot(A.getColumn(1)) + R.getColumn(2).dot(A.getColumn(2))) +
																																					  tolerance);
			w = omega.norm();
			if (w < tolerance)
				break;
			q = btQuaternion(btVector3((btScalar(1.0) / w) * omega), w) *
				q;
			q.normalize();
		}
	}

	/**@brief diagonalizes this matrix by the Jacobi method.
	* @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
	* coordinate system, i.e., old_this = rot * new_this * rot^T.
	* @param threshold See iteration
	* @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied
	* by the sum of the absolute values of the diagonal, or when maxSteps have been executed.
	*
	* Note that this matrix is assumed to be symmetric.
	*/
	void diagonalize(btMatrix3x3 & rot, btScalar threshold, int maxSteps)
	{
		rot.setIdentity();
		for (int step = maxSteps; step > 0; step--)
		{
			// find off-diagonal element [p][q] with largest magnitude
			int p = 0;
			int q = 1;
			int r = 2;
			btScalar max = btFabs(m_el[0][1]);
			btScalar v = btFabs(m_el[0][2]);
			if (v > max)
			{
				q = 2;
				r = 1;
				max = v;
			}
			v = btFabs(m_el[1][2]);
			if (v > max)
			{
				p = 1;
				q = 2;
				r = 0;
				max = v;
			}

			btScalar t = threshold * (btFabs(m_el[0][0]) + btFabs(m_el[1][1]) + btFabs(m_el[2][2]));
			if (max <= t)
			{
				if (max <= SIMD_EPSILON * t)
				{
					return;
				}
				step = 1;
			}

			// compute Jacobi rotation J which leads to a zero for element [p][q]
			btScalar mpq = m_el[p][q];
			btScalar theta = (m_el[q][q] - m_el[p][p]) / (2 * mpq);
			btScalar theta2 = theta * theta;
			btScalar cos;
			btScalar sin;
			if (theta2 * theta2 < btScalar(10 / SIMD_EPSILON))
			{
				t = (theta >= 0) ? 1 / (theta + btSqrt(1 + theta2))
								 : 1 / (theta - btSqrt(1 + theta2));
				cos = 1 / btSqrt(1 + t * t);
				sin = cos * t;
			}
			else
			{
				// approximation for large theta-value, i.e., a nearly diagonal matrix
				t = 1 / (theta * (2 + btScalar(0.5) / theta2));
				cos = 1 - btScalar(0.5) * t * t;
				sin = cos * t;
			}

			// apply rotation to matrix (this = J^T * this * J)
			m_el[p][q] = m_el[q][p] = 0;
			m_el[p][p] -= t * mpq;
			m_el[q][q] += t * mpq;
			btScalar mrp = m_el[r][p];
			btScalar mrq = m_el[r][q];
			m_el[r][p] = m_el[p][r] = cos * mrp - sin * mrq;
			m_el[r][q] = m_el[q][r] = cos * mrq + sin * mrp;

			// apply rotation to rot (rot = rot * J)
			for (int i = 0; i < 3; i++)
			{
				btVector3& row = rot[i];
				mrp = row[p];
				mrq = row[q];
				row[p] = cos * mrp - sin * mrq;
				row[q] = cos * mrq + sin * mrp;
			}
		}
	}

	/**@brief Calculate the matrix cofactor 
	* @param r1 The first row to use for calculating the cofactor
	* @param c1 The first column to use for calculating the cofactor
	* @param r1 The second row to use for calculating the cofactor
	* @param c1 The second column to use for calculating the cofactor
	* See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
	*/
	btScalar cofac(int r1, int c1, int r2, int c2) const
	{
		return m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];
	}

	void serialize(struct btMatrix3x3Data & dataOut) const;

	void serializeFloat(struct btMatrix3x3FloatData & dataOut) const;

	void deSerialize(const struct btMatrix3x3Data& dataIn);

	void deSerializeFloat(const struct btMatrix3x3FloatData& dataIn);

	void deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn);
};

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator*=(const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)
	__m128 rv00, rv01, rv02;
	__m128 rv10, rv11, rv12;
	__m128 rv20, rv21, rv22;
	__m128 mv0, mv1, mv2;

	rv02 = m_el[0].mVec128;
	rv12 = m_el[1].mVec128;
	rv22 = m_el[2].mVec128;

	mv0 = _mm_and_ps(m[0].mVec128, btvFFF0fMask);
	mv1 = _mm_and_ps(m[1].mVec128, btvFFF0fMask);
	mv2 = _mm_and_ps(m[2].mVec128, btvFFF0fMask);

	// rv0
	rv00 = bt_splat_ps(rv02, 0);
	rv01 = bt_splat_ps(rv02, 1);
	rv02 = bt_splat_ps(rv02, 2);

	rv00 = _mm_mul_ps(rv00, mv0);
	rv01 = _mm_mul_ps(rv01, mv1);
	rv02 = _mm_mul_ps(rv02, mv2);

	// rv1
	rv10 = bt_splat_ps(rv12, 0);
	rv11 = bt_splat_ps(rv12, 1);
	rv12 = bt_splat_ps(rv12, 2);

	rv10 = _mm_mul_ps(rv10, mv0);
	rv11 = _mm_mul_ps(rv11, mv1);
	rv12 = _mm_mul_ps(rv12, mv2);

	// rv2
	rv20 = bt_splat_ps(rv22, 0);
	rv21 = bt_splat_ps(rv22, 1);
	rv22 = bt_splat_ps(rv22, 2);

	rv20 = _mm_mul_ps(rv20, mv0);
	rv21 = _mm_mul_ps(rv21, mv1);
	rv22 = _mm_mul_ps(rv22, mv2);

	rv00 = _mm_add_ps(rv00, rv01);
	rv10 = _mm_add_ps(rv10, rv11);
	rv20 = _mm_add_ps(rv20, rv21);

	m_el[0].mVec128 = _mm_add_ps(rv00, rv02);
	m_el[1].mVec128 = _mm_add_ps(rv10, rv12);
	m_el[2].mVec128 = _mm_add_ps(rv20, rv22);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m_el[0].mVec128;
	v1 = m_el[1].mVec128;
	v2 = m_el[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	m_el[0].mVec128 = rv0;
	m_el[1].mVec128 = rv1;
	m_el[2].mVec128 = rv2;
#else
	setValue(
		m.tdotx(m_el[0]), m.tdoty(m_el[0]), m.tdotz(m_el[0]),
		m.tdotx(m_el[1]), m.tdoty(m_el[1]), m.tdotz(m_el[1]),
		m.tdotx(m_el[2]), m.tdoty(m_el[2]), m.tdotz(m_el[2]));
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator+=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 + m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 + m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 + m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] + m.m_el[0][0],
		m_el[0][1] + m.m_el[0][1],
		m_el[0][2] + m.m_el[0][2],
		m_el[1][0] + m.m_el[1][0],
		m_el[1][1] + m.m_el[1][1],
		m_el[1][2] + m.m_el[1][2],
		m_el[2][0] + m.m_el[2][0],
		m_el[2][1] + m.m_el[2][1],
		m_el[2][2] + m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m, const btScalar& k)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 vk = bt_splat_ps(_mm_load_ss((float*)&k), 0x80);
	return btMatrix3x3(
		_mm_mul_ps(m[0].mVec128, vk),
		_mm_mul_ps(m[1].mVec128, vk),
		_mm_mul_ps(m[2].mVec128, vk));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		vmulq_n_f32(m[0].mVec128, k),
		vmulq_n_f32(m[1].mVec128, k),
		vmulq_n_f32(m[2].mVec128, k));
#else
	return btMatrix3x3(
		m[0].x() * k, m[0].y() * k, m[0].z() * k,
		m[1].x() * k, m[1].y() * k, m[1].z() * k,
		m[2].x() * k, m[2].y() * k, m[2].z() * k);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator+(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 + m2[0].mVec128,
		m1[1].mVec128 + m2[1].mVec128,
		m1[2].mVec128 + m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] + m2[0][0],
		m1[0][1] + m2[0][1],
		m1[0][2] + m2[0][2],

		m1[1][0] + m2[1][0],
		m1[1][1] + m2[1][1],
		m1[1][2] + m2[1][2],

		m1[2][0] + m2[2][0],
		m1[2][1] + m2[2][1],
		m1[2][2] + m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator-(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return btMatrix3x3(
		m1[0].mVec128 - m2[0].mVec128,
		m1[1].mVec128 - m2[1].mVec128,
		m1[2].mVec128 - m2[2].mVec128);
#else
	return btMatrix3x3(
		m1[0][0] - m2[0][0],
		m1[0][1] - m2[0][1],
		m1[0][2] - m2[0][2],

		m1[1][0] - m2[1][0],
		m1[1][1] - m2[1][1],
		m1[1][2] - m2[1][2],

		m1[2][0] - m2[2][0],
		m1[2][1] - m2[2][1],
		m1[2][2] - m2[2][2]);
#endif
}

SIMD_FORCE_INLINE btMatrix3x3&
btMatrix3x3::operator-=(const btMatrix3x3& m)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	m_el[0].mVec128 = m_el[0].mVec128 - m.m_el[0].mVec128;
	m_el[1].mVec128 = m_el[1].mVec128 - m.m_el[1].mVec128;
	m_el[2].mVec128 = m_el[2].mVec128 - m.m_el[2].mVec128;
#else
	setValue(
		m_el[0][0] - m.m_el[0][0],
		m_el[0][1] - m.m_el[0][1],
		m_el[0][2] - m.m_el[0][2],
		m_el[1][0] - m.m_el[1][0],
		m_el[1][1] - m.m_el[1][1],
		m_el[1][2] - m.m_el[1][2],
		m_el[2][0] - m.m_el[2][0],
		m_el[2][1] - m.m_el[2][1],
		m_el[2][2] - m.m_el[2][2]);
#endif
	return *this;
}

SIMD_FORCE_INLINE btScalar
btMatrix3x3::determinant() const
{
	return btTriple((*this)[0], (*this)[1], (*this)[2]);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::absolute() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	return btMatrix3x3(
		_mm_and_ps(m_el[0].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[1].mVec128, btvAbsfMask),
		_mm_and_ps(m_el[2].mVec128, btvAbsfMask));
#elif defined(BT_USE_NEON)
	return btMatrix3x3(
		(float32x4_t)vandq_s32((int32x4_t)m_el[0].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[1].mVec128, btv3AbsMask),
		(float32x4_t)vandq_s32((int32x4_t)m_el[2].mVec128, btv3AbsMask));
#else
	return btMatrix3x3(
		btFabs(m_el[0].x()), btFabs(m_el[0].y()), btFabs(m_el[0].z()),
		btFabs(m_el[1].x()), btFabs(m_el[1].y()), btFabs(m_el[1].z()),
		btFabs(m_el[2].x()), btFabs(m_el[2].y()), btFabs(m_el[2].z()));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transpose() const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 v0 = m_el[0].mVec128;
	__m128 v1 = m_el[1].mVec128;
	__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2
	__m128 vT;

	v2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0

	vT = _mm_unpackhi_ps(v0, v1);  //	z0 z1 * *
	v0 = _mm_unpacklo_ps(v0, v1);  //	x0 x1 y0 y1

	v1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0
	v0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0
	v2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0

	return btMatrix3x3(v0, v1, v2);
#elif defined(BT_USE_NEON)
	// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.
	static const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};
	float32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}
	float32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}
	float32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);
	float32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);
	float32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);
	float32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0
	return btMatrix3x3(v0, v1, v2);
#else
	return btMatrix3x3(m_el[0].x(), m_el[1].x(), m_el[2].x(),
					   m_el[0].y(), m_el[1].y(), m_el[2].y(),
					   m_el[0].z(), m_el[1].z(), m_el[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::adjoint() const
{
	return btMatrix3x3(cofac(1, 1, 2, 2), cofac(0, 2, 2, 1), cofac(0, 1, 1, 2),
					   cofac(1, 2, 2, 0), cofac(0, 0, 2, 2), cofac(0, 2, 1, 0),
					   cofac(1, 0, 2, 1), cofac(0, 1, 2, 0), cofac(0, 0, 1, 1));
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::inverse() const
{
	btVector3 co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));
	btScalar det = (*this)[0].dot(co);
	//btFullAssert(det != btScalar(0.0));
	btAssert(det != btScalar(0.0));
	btScalar s = btScalar(1.0) / det;
	return btMatrix3x3(co.x() * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
					   co.y() * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
					   co.z() * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::transposeTimes(const btMatrix3x3& m) const
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	// zeros w
	//    static const __m128i xyzMask = (const __m128i){ -1ULL, 0xffffffffULL };
	__m128 row = m_el[0].mVec128;
	__m128 m0 = _mm_and_ps(m.getRow(0).mVec128, btvFFF0fMask);
	__m128 m1 = _mm_and_ps(m.getRow(1).mVec128, btvFFF0fMask);
	__m128 m2 = _mm_and_ps(m.getRow(2).mVec128, btvFFF0fMask);
	__m128 r0 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0));
	__m128 r1 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0x55));
	__m128 r2 = _mm_mul_ps(m0, _mm_shuffle_ps(row, row, 0xaa));
	row = m_el[1].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m1, _mm_shuffle_ps(row, row, 0xaa)));
	row = m_el[2].mVec128;
	r0 = _mm_add_ps(r0, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(m2, _mm_shuffle_ps(row, row, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	// zeros w
	static const uint32x4_t xyzMask = (const uint32x4_t){static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), static_cast<uint32_t>(-1), 0};
	float32x4_t m0 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(0).mVec128, xyzMask);
	float32x4_t m1 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(1).mVec128, xyzMask);
	float32x4_t m2 = (float32x4_t)vandq_u32((uint32x4_t)m.getRow(2).mVec128, xyzMask);
	float32x4_t row = m_el[0].mVec128;
	float32x4_t r0 = vmulq_lane_f32(m0, vget_low_f32(row), 0);
	float32x4_t r1 = vmulq_lane_f32(m0, vget_low_f32(row), 1);
	float32x4_t r2 = vmulq_lane_f32(m0, vget_high_f32(row), 0);
	row = m_el[1].mVec128;
	r0 = vmlaq_lane_f32(r0, m1, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m1, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m1, vget_high_f32(row), 0);
	row = m_el[2].mVec128;
	r0 = vmlaq_lane_f32(r0, m2, vget_low_f32(row), 0);
	r1 = vmlaq_lane_f32(r1, m2, vget_low_f32(row), 1);
	r2 = vmlaq_lane_f32(r2, m2, vget_high_f32(row), 0);
	return btMatrix3x3(r0, r1, r2);
#else
	return btMatrix3x3(
		m_el[0].x() * m[0].x() + m_el[1].x() * m[1].x() + m_el[2].x() * m[2].x(),
		m_el[0].x() * m[0].y() + m_el[1].x() * m[1].y() + m_el[2].x() * m[2].y(),
		m_el[0].x() * m[0].z() + m_el[1].x() * m[1].z() + m_el[2].x() * m[2].z(),
		m_el[0].y() * m[0].x() + m_el[1].y() * m[1].x() + m_el[2].y() * m[2].x(),
		m_el[0].y() * m[0].y() + m_el[1].y() * m[1].y() + m_el[2].y() * m[2].y(),
		m_el[0].y() * m[0].z() + m_el[1].y() * m[1].z() + m_el[2].y() * m[2].z(),
		m_el[0].z() * m[0].x() + m_el[1].z() * m[1].x() + m_el[2].z() * m[2].x(),
		m_el[0].z() * m[0].y() + m_el[1].z() * m[1].y() + m_el[2].z() * m[2].y(),
		m_el[0].z() * m[0].z() + m_el[1].z() * m[1].z() + m_el[2].z() * m[2].z());
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::timesTranspose(const btMatrix3x3& m) const
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))
	__m128 a0 = m_el[0].mVec128;
	__m128 a1 = m_el[1].mVec128;
	__m128 a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	__m128 mx = mT[0].mVec128;
	__m128 my = mT[1].mVec128;
	__m128 mz = mT[2].mVec128;

	__m128 r0 = _mm_mul_ps(mx, _mm_shuffle_ps(a0, a0, 0x00));
	__m128 r1 = _mm_mul_ps(mx, _mm_shuffle_ps(a1, a1, 0x00));
	__m128 r2 = _mm_mul_ps(mx, _mm_shuffle_ps(a2, a2, 0x00));
	r0 = _mm_add_ps(r0, _mm_mul_ps(my, _mm_shuffle_ps(a0, a0, 0x55)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(my, _mm_shuffle_ps(a1, a1, 0x55)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(my, _mm_shuffle_ps(a2, a2, 0x55)));
	r0 = _mm_add_ps(r0, _mm_mul_ps(mz, _mm_shuffle_ps(a0, a0, 0xaa)));
	r1 = _mm_add_ps(r1, _mm_mul_ps(mz, _mm_shuffle_ps(a1, a1, 0xaa)));
	r2 = _mm_add_ps(r2, _mm_mul_ps(mz, _mm_shuffle_ps(a2, a2, 0xaa)));
	return btMatrix3x3(r0, r1, r2);

#elif defined BT_USE_NEON
	float32x4_t a0 = m_el[0].mVec128;
	float32x4_t a1 = m_el[1].mVec128;
	float32x4_t a2 = m_el[2].mVec128;

	btMatrix3x3 mT = m.transpose();  // we rely on transpose() zeroing w channel so that we don't have to do it here
	float32x4_t mx = mT[0].mVec128;
	float32x4_t my = mT[1].mVec128;
	float32x4_t mz = mT[2].mVec128;

	float32x4_t r0 = vmulq_lane_f32(mx, vget_low_f32(a0), 0);
	float32x4_t r1 = vmulq_lane_f32(mx, vget_low_f32(a1), 0);
	float32x4_t r2 = vmulq_lane_f32(mx, vget_low_f32(a2), 0);
	r0 = vmlaq_lane_f32(r0, my, vget_low_f32(a0), 1);
	r1 = vmlaq_lane_f32(r1, my, vget_low_f32(a1), 1);
	r2 = vmlaq_lane_f32(r2, my, vget_low_f32(a2), 1);
	r0 = vmlaq_lane_f32(r0, mz, vget_high_f32(a0), 0);
	r1 = vmlaq_lane_f32(r1, mz, vget_high_f32(a1), 0);
	r2 = vmlaq_lane_f32(r2, mz, vget_high_f32(a2), 0);
	return btMatrix3x3(r0, r1, r2);

#else
	return btMatrix3x3(
		m_el[0].dot(m[0]), m_el[0].dot(m[1]), m_el[0].dot(m[2]),
		m_el[1].dot(m[0]), m_el[1].dot(m[1]), m_el[1].dot(m[2]),
		m_el[2].dot(m[0]), m_el[2].dot(m[1]), m_el[2].dot(m[2]));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btMatrix3x3& m, const btVector3& v)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
	return v.dot3(m[0], m[1], m[2]);
#else
	return btVector3(m[0].dot(v), m[1].dot(v), m[2].dot(v));
#endif
}

SIMD_FORCE_INLINE btVector3
operator*(const btVector3& v, const btMatrix3x3& m)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	const __m128 vv = v.mVec128;

	__m128 c0 = bt_splat_ps(vv, 0);
	__m128 c1 = bt_splat_ps(vv, 1);
	__m128 c2 = bt_splat_ps(vv, 2);

	c0 = _mm_mul_ps(c0, _mm_and_ps(m[0].mVec128, btvFFF0fMask));
	c1 = _mm_mul_ps(c1, _mm_and_ps(m[1].mVec128, btvFFF0fMask));
	c0 = _mm_add_ps(c0, c1);
	c2 = _mm_mul_ps(c2, _mm_and_ps(m[2].mVec128, btvFFF0fMask));

	return btVector3(_mm_add_ps(c0, c2));
#elif defined(BT_USE_NEON)
	const float32x4_t vv = v.mVec128;
	const float32x2_t vlo = vget_low_f32(vv);
	const float32x2_t vhi = vget_high_f32(vv);

	float32x4_t c0, c1, c2;

	c0 = (float32x4_t)vandq_s32((int32x4_t)m[0].mVec128, btvFFF0Mask);
	c1 = (float32x4_t)vandq_s32((int32x4_t)m[1].mVec128, btvFFF0Mask);
	c2 = (float32x4_t)vandq_s32((int32x4_t)m[2].mVec128, btvFFF0Mask);

	c0 = vmulq_lane_f32(c0, vlo, 0);
	c1 = vmulq_lane_f32(c1, vlo, 1);
	c2 = vmulq_lane_f32(c2, vhi, 0);
	c0 = vaddq_f32(c0, c1);
	c0 = vaddq_f32(c0, c2);

	return btVector3(c0);
#else
	return btVector3(m.tdotx(v), m.tdoty(v), m.tdotz(v));
#endif
}

SIMD_FORCE_INLINE btMatrix3x3
operator*(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 m10 = m1[0].mVec128;
	__m128 m11 = m1[1].mVec128;
	__m128 m12 = m1[2].mVec128;

	__m128 m2v = _mm_and_ps(m2[0].mVec128, btvFFF0fMask);

	__m128 c0 = bt_splat_ps(m10, 0);
	__m128 c1 = bt_splat_ps(m11, 0);
	__m128 c2 = bt_splat_ps(m12, 0);

	c0 = _mm_mul_ps(c0, m2v);
	c1 = _mm_mul_ps(c1, m2v);
	c2 = _mm_mul_ps(c2, m2v);

	m2v = _mm_and_ps(m2[1].mVec128, btvFFF0fMask);

	__m128 c0_1 = bt_splat_ps(m10, 1);
	__m128 c1_1 = bt_splat_ps(m11, 1);
	__m128 c2_1 = bt_splat_ps(m12, 1);

	c0_1 = _mm_mul_ps(c0_1, m2v);
	c1_1 = _mm_mul_ps(c1_1, m2v);
	c2_1 = _mm_mul_ps(c2_1, m2v);

	m2v = _mm_and_ps(m2[2].mVec128, btvFFF0fMask);

	c0 = _mm_add_ps(c0, c0_1);
	c1 = _mm_add_ps(c1, c1_1);
	c2 = _mm_add_ps(c2, c2_1);

	m10 = bt_splat_ps(m10, 2);
	m11 = bt_splat_ps(m11, 2);
	m12 = bt_splat_ps(m12, 2);

	m10 = _mm_mul_ps(m10, m2v);
	m11 = _mm_mul_ps(m11, m2v);
	m12 = _mm_mul_ps(m12, m2v);

	c0 = _mm_add_ps(c0, m10);
	c1 = _mm_add_ps(c1, m11);
	c2 = _mm_add_ps(c2, m12);

	return btMatrix3x3(c0, c1, c2);

#elif defined(BT_USE_NEON)

	float32x4_t rv0, rv1, rv2;
	float32x4_t v0, v1, v2;
	float32x4_t mv0, mv1, mv2;

	v0 = m1[0].mVec128;
	v1 = m1[1].mVec128;
	v2 = m1[2].mVec128;

	mv0 = (float32x4_t)vandq_s32((int32x4_t)m2[0].mVec128, btvFFF0Mask);
	mv1 = (float32x4_t)vandq_s32((int32x4_t)m2[1].mVec128, btvFFF0Mask);
	mv2 = (float32x4_t)vandq_s32((int32x4_t)m2[2].mVec128, btvFFF0Mask);

	rv0 = vmulq_lane_f32(mv0, vget_low_f32(v0), 0);
	rv1 = vmulq_lane_f32(mv0, vget_low_f32(v1), 0);
	rv2 = vmulq_lane_f32(mv0, vget_low_f32(v2), 0);

	rv0 = vmlaq_lane_f32(rv0, mv1, vget_low_f32(v0), 1);
	rv1 = vmlaq_lane_f32(rv1, mv1, vget_low_f32(v1), 1);
	rv2 = vmlaq_lane_f32(rv2, mv1, vget_low_f32(v2), 1);

	rv0 = vmlaq_lane_f32(rv0, mv2, vget_high_f32(v0), 0);
	rv1 = vmlaq_lane_f32(rv1, mv2, vget_high_f32(v1), 0);
	rv2 = vmlaq_lane_f32(rv2, mv2, vget_high_f32(v2), 0);

	return btMatrix3x3(rv0, rv1, rv2);

#else
	return btMatrix3x3(
		m2.tdotx(m1[0]), m2.tdoty(m1[0]), m2.tdotz(m1[0]),
		m2.tdotx(m1[1]), m2.tdoty(m1[1]), m2.tdotz(m1[1]),
		m2.tdotx(m1[2]), m2.tdoty(m1[2]), m2.tdotz(m1[2]));
#endif
}

/*
SIMD_FORCE_INLINE btMatrix3x3 btMultTransposeLeft(const btMatrix3x3& m1, const btMatrix3x3& m2) {
return btMatrix3x3(
m1[0][0] * m2[0][0] + m1[1][0] * m2[1][0] + m1[2][0] * m2[2][0],
m1[0][0] * m2[0][1] + m1[1][0] * m2[1][1] + m1[2][0] * m2[2][1],
m1[0][0] * m2[0][2] + m1[1][0] * m2[1][2] + m1[2][0] * m2[2][2],
m1[0][1] * m2[0][0] + m1[1][1] * m2[1][0] + m1[2][1] * m2[2][0],
m1[0][1] * m2[0][1] + m1[1][1] * m2[1][1] + m1[2][1] * m2[2][1],
m1[0][1] * m2[0][2] + m1[1][1] * m2[1][2] + m1[2][1] * m2[2][2],
m1[0][2] * m2[0][0] + m1[1][2] * m2[1][0] + m1[2][2] * m2[2][0],
m1[0][2] * m2[0][1] + m1[1][2] * m2[1][1] + m1[2][2] * m2[2][1],
m1[0][2] * m2[0][2] + m1[1][2] * m2[1][2] + m1[2][2] * m2[2][2]);
}
*/

/**@brief Equality operator between two matrices
* It will test all elements are equal.  */
SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
{
#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))

	__m128 c0, c1, c2;

	c0 = _mm_cmpeq_ps(m1[0].mVec128, m2[0].mVec128);
	c1 = _mm_cmpeq_ps(m1[1].mVec128, m2[1].mVec128);
	c2 = _mm_cmpeq_ps(m1[2].mVec128, m2[2].mVec128);

	c0 = _mm_and_ps(c0, c1);
	c0 = _mm_and_ps(c0, c2);

	int m = _mm_movemask_ps((__m128)c0);
	return (0x7 == (m & 0x7));

#else
	return (m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&
			m1[0][1] == m2[0][1] && m1[1][1] == m2[1][1] && m1[2][1] == m2[2][1] &&
			m1[0][2] == m2[0][2] && m1[1][2] == m2[1][2] && m1[2][2] == m2[2][2]);
#endif
}

///for serialization
struct btMatrix3x3FloatData
{
	btVector3FloatData m_el[3];
};

///for serialization
struct btMatrix3x3DoubleData
{
	btVector3DoubleData m_el[3];
};

SIMD_FORCE_INLINE void btMatrix3x3::serialize(struct btMatrix3x3Data& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serialize(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::serializeFloat(struct btMatrix3x3FloatData& dataOut) const
{
	for (int i = 0; i < 3; i++)
		m_el[i].serializeFloat(dataOut.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerialize(const struct btMatrix3x3Data& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerialize(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeFloat(const struct btMatrix3x3FloatData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeFloat(dataIn.m_el[i]);
}

SIMD_FORCE_INLINE void btMatrix3x3::deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn)
{
	for (int i = 0; i < 3; i++)
		m_el[i].deSerializeDouble(dataIn.m_el[i]);
}

#endif  //BT_MATRIX3x3_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRANSFORM_H
#define BT_TRANSFORM_H

#include "LinearMath/btMatrix3x3.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTransformData btTransformDoubleData
#else
#define btTransformData btTransformFloatData
#endif

/**@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
 *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
ATTRIBUTE_ALIGNED16(class)
btTransform
{
	///Storage for the rotation
	btMatrix3x3 m_basis;
	///Storage for the translation
	btVector3 m_origin;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();
	/**@brief No initialization constructor */
	btTransform() {}
	/**@brief Constructor from btQuaternion (optional btVector3 )
   * @param q Rotation from quaternion 
   * @param c Translation from Vector (default 0,0,0) */
	explicit SIMD_FORCE_INLINE btTransform(const btQuaternion& q,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(q),
		  m_origin(c)
	{
	}

	/**@brief Constructor from btMatrix3x3 (optional btVector3)
   * @param b Rotation from Matrix 
   * @param c Translation from Vector default (0,0,0)*/
	explicit SIMD_FORCE_INLINE btTransform(const btMatrix3x3& b,
										   const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
		: m_basis(b),
		  m_origin(c)
	{
	}
	/**@brief Copy constructor */
	SIMD_FORCE_INLINE btTransform(const btTransform& other)
		: m_basis(other.m_basis),
		  m_origin(other.m_origin)
	{
	}
	/**@brief Assignment Operator */
	SIMD_FORCE_INLINE btTransform& operator=(const btTransform& other)
	{
		m_basis = other.m_basis;
		m_origin = other.m_origin;
		return *this;
	}

	/**@brief Set the current transform as the value of the product of two transforms
   * @param t1 Transform 1
   * @param t2 Transform 2
   * This = Transform1 * Transform2 */
	SIMD_FORCE_INLINE void mult(const btTransform& t1, const btTransform& t2)
	{
		m_basis = t1.m_basis * t2.m_basis;
		m_origin = t1(t2.m_origin);
	}

	/*		void multInverseLeft(const btTransform& t1, const btTransform& t2) {
			btVector3 v = t2.m_origin - t1.m_origin;
			m_basis = btMultTransposeLeft(t1.m_basis, t2.m_basis);
			m_origin = v * t1.m_basis;
		}
		*/

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator()(const btVector3& x) const
	{
		return x.dot3(m_basis[0], m_basis[1], m_basis[2]) + m_origin;
	}

	/**@brief Return the transform of the vector */
	SIMD_FORCE_INLINE btVector3 operator*(const btVector3& x) const
	{
		return (*this)(x);
	}

	/**@brief Return the transform of the btQuaternion */
	SIMD_FORCE_INLINE btQuaternion operator*(const btQuaternion& q) const
	{
		return getRotation() * q;
	}

	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE btMatrix3x3& getBasis() { return m_basis; }
	/**@brief Return the basis matrix for the rotation */
	SIMD_FORCE_INLINE const btMatrix3x3& getBasis() const { return m_basis; }

	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE btVector3& getOrigin() { return m_origin; }
	/**@brief Return the origin vector translation */
	SIMD_FORCE_INLINE const btVector3& getOrigin() const { return m_origin; }

	/**@brief Return a quaternion representing the rotation */
	btQuaternion getRotation() const
	{
		btQuaternion q;
		m_basis.getRotation(q);
		return q;
	}

	/**@brief Set from an array 
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void setFromOpenGLMatrix(const btScalar* m)
	{
		m_basis.setFromOpenGLSubMatrix(m);
		m_origin.setValue(m[12], m[13], m[14]);
	}

	/**@brief Fill an array representation
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	void getOpenGLMatrix(btScalar * m) const
	{
		m_basis.getOpenGLSubMatrix(m);
		m[12] = m_origin.x();
		m[13] = m_origin.y();
		m[14] = m_origin.z();
		m[15] = btScalar(1.0);
	}

	/**@brief Set the translational element
   * @param origin The vector to set the translation to */
	SIMD_FORCE_INLINE void setOrigin(const btVector3& origin)
	{
		m_origin = origin;
	}

	SIMD_FORCE_INLINE btVector3 invXform(const btVector3& inVec) const;

	/**@brief Set the rotational element by btMatrix3x3 */
	SIMD_FORCE_INLINE void setBasis(const btMatrix3x3& basis)
	{
		m_basis = basis;
	}

	/**@brief Set the rotational element by btQuaternion */
	SIMD_FORCE_INLINE void setRotation(const btQuaternion& q)
	{
		m_basis.setRotation(q);
	}

	/**@brief Set this transformation to the identity */
	void setIdentity()
	{
		m_basis.setIdentity();
		m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	/**@brief Multiply this Transform by another(this = this * another) 
   * @param t The other transform */
	btTransform& operator*=(const btTransform& t)
	{
		m_origin += m_basis * t.m_origin;
		m_basis *= t.m_basis;
		return *this;
	}

	/**@brief Return the inverse of this transform */
	btTransform inverse() const
	{
		btMatrix3x3 inv = m_basis.transpose();
		return btTransform(inv, inv * -m_origin);
	}

	/**@brief Return the inverse of this transform times the other transform
   * @param t The other transform 
   * return this.inverse() * the other */
	btTransform inverseTimes(const btTransform& t) const;

	/**@brief Return the product of this transform and the other */
	btTransform operator*(const btTransform& t) const;

	/**@brief Return an identity transform */
	static const btTransform& getIdentity()
	{
		static const btTransform identityTransform(btMatrix3x3::getIdentity());
		return identityTransform;
	}

	void serialize(struct btTransformData & dataOut) const;

	void serializeFloat(struct btTransformFloatData & dataOut) const;

	void deSerialize(const struct btTransformData& dataIn);

	void deSerializeDouble(const struct btTransformDoubleData& dataIn);

	void deSerializeFloat(const struct btTransformFloatData& dataIn);
};

SIMD_FORCE_INLINE btVector3
btTransform::invXform(const btVector3& inVec) const
{
	btVector3 v = inVec - m_origin;
	return (m_basis.transpose() * v);
}

SIMD_FORCE_INLINE btTransform
btTransform::inverseTimes(const btTransform& t) const
{
	btVector3 v = t.getOrigin() - m_origin;
	return btTransform(m_basis.transposeTimes(t.m_basis),
					   v * m_basis);
}

SIMD_FORCE_INLINE btTransform
	btTransform::operator*(const btTransform& t) const
{
	return btTransform(m_basis * t.m_basis,
					   (*this)(t.m_origin));
}

/**@brief Test if two transforms have all elements equal */
SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)
{
	return (t1.getBasis() == t2.getBasis() &&
			t1.getOrigin() == t2.getOrigin());
}

///for serialization
struct btTransformFloatData
{
	btMatrix3x3FloatData m_basis;
	btVector3FloatData m_origin;
};

struct btTransformDoubleData
{
	btMatrix3x3DoubleData m_basis;
	btVector3DoubleData m_origin;
};

SIMD_FORCE_INLINE void btTransform::serialize(btTransformData& dataOut) const
{
	m_basis.serialize(dataOut.m_basis);
	m_origin.serialize(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::serializeFloat(btTransformFloatData& dataOut) const
{
	m_basis.serializeFloat(dataOut.m_basis);
	m_origin.serializeFloat(dataOut.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerialize(const btTransformData& dataIn)
{
	m_basis.deSerialize(dataIn.m_basis);
	m_origin.deSerialize(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeFloat(const btTransformFloatData& dataIn)
{
	m_basis.deSerializeFloat(dataIn.m_basis);
	m_origin.deSerializeFloat(dataIn.m_origin);
}

SIMD_FORCE_INLINE void btTransform::deSerializeDouble(const btTransformDoubleData& dataIn)
{
	m_basis.deSerializeDouble(dataIn.m_basis);
	m_origin.deSerializeDouble(dataIn.m_origin);
}

#endif  //BT_TRANSFORM_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MOTIONSTATE_H
#define BT_MOTIONSTATE_H

#include "LinearMath/btTransform.h"

///The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
///For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
class btMotionState
{
public:
	virtual ~btMotionState()
	{
	}

	virtual void getWorldTransform(btTransform& worldTrans) const = 0;

	//Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& worldTrans) = 0;
};

#endif  //BT_MOTIONSTATE_H





#ifndef BT_DEFAULT_MOTION_STATE_H
#define BT_DEFAULT_MOTION_STATE_H

#include "LinearMath/btMotionState.h"

///The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
ATTRIBUTE_ALIGNED16(struct)
btDefaultMotionState : public btMotionState
{
	btTransform m_graphicsWorldTrans;
	btTransform m_centerOfMassOffset;
	btTransform m_startWorldTrans;
	void* m_userPointer;

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btDefaultMotionState(const btTransform& startTrans = btTransform::getIdentity(), const btTransform& centerOfMassOffset = btTransform::getIdentity())
		: m_graphicsWorldTrans(startTrans),
		  m_centerOfMassOffset(centerOfMassOffset),
		  m_startWorldTrans(startTrans),
		  m_userPointer(0)

	{
	}

	///synchronizes world transform from user to physics
	virtual void getWorldTransform(btTransform & centerOfMassWorldTrans) const
	{
		centerOfMassWorldTrans = m_graphicsWorldTrans * m_centerOfMassOffset.inverse();
	}

	///synchronizes world transform from physics to user
	///Bullet only calls the update of worldtransform for active objects
	virtual void setWorldTransform(const btTransform& centerOfMassWorldTrans)
	{
		m_graphicsWorldTrans = centerOfMassWorldTrans * m_centerOfMassOffset;
	}
};

#endif  //BT_DEFAULT_MOTION_STATE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_UNION_FIND_H
#define BT_UNION_FIND_H

#include "LinearMath/btAlignedObjectArray.h"

#define USE_PATH_COMPRESSION 1

///see for discussion of static island optimizations by Vroonsh here: http://code.google.com/p/bullet/issues/detail?id=406
#define STATIC_SIMULATION_ISLAND_OPTIMIZATION 1

struct btElement
{
	int m_id;
	int m_sz;
};

///UnionFind calculates connected subsets
// Implements weighted Quick Union with path compression
// optimization: could use short ints instead of ints (halving memory, would limit the number of rigid bodies to 64k, sounds reasonable)
class btUnionFind
{
private:
	btAlignedObjectArray<btElement> m_elements;

public:
	btUnionFind();
	~btUnionFind();

	//this is a special operation, destroying the content of btUnionFind.
	//it sorts the elements, based on island id, in order to make it easy to iterate over islands
	void sortIslands();

	void reset(int N);

	SIMD_FORCE_INLINE int getNumElements() const
	{
		return int(m_elements.size());
	}
	SIMD_FORCE_INLINE bool isRoot(int x) const
	{
		return (x == m_elements[x].m_id);
	}

	btElement& getElement(int index)
	{
		return m_elements[index];
	}
	const btElement& getElement(int index) const
	{
		return m_elements[index];
	}

	void allocate(int N);
	void Free();

	int find(int p, int q)
	{
		return (find(p) == find(q));
	}

	void unite(int p, int q)
	{
		int i = find(p), j = find(q);
		if (i == j)
			return;

#ifndef USE_PATH_COMPRESSION
		//weighted quick union, this keeps the 'trees' balanced, and keeps performance of unite O( log(n) )
		if (m_elements[i].m_sz < m_elements[j].m_sz)
		{
			m_elements[i].m_id = j;
			m_elements[j].m_sz += m_elements[i].m_sz;
		}
		else
		{
			m_elements[j].m_id = i;
			m_elements[i].m_sz += m_elements[j].m_sz;
		}
#else
		m_elements[i].m_id = j;
		m_elements[j].m_sz += m_elements[i].m_sz;
#endif  //USE_PATH_COMPRESSION
	}

	int find(int x)
	{
		//btAssert(x < m_N);
		//btAssert(x >= 0);

		while (x != m_elements[x].m_id)
		{
			//not really a reason not to use path compression, and it flattens the trees/improves find performance dramatically

#ifdef USE_PATH_COMPRESSION
			const btElement* elementPtr = &m_elements[m_elements[x].m_id];
			m_elements[x].m_id = elementPtr->m_id;
			x = elementPtr->m_id;
#else  //
			x = m_elements[x].m_id;
#endif
			//btAssert(x < m_N);
			//btAssert(x >= 0);
		}
		return x;
	}
};

#endif  //BT_UNION_FIND_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btUnionFind.h"

btUnionFind::~btUnionFind()
{
	Free();
}

btUnionFind::btUnionFind()
{
}

void btUnionFind::allocate(int N)
{
	m_elements.resize(N);
}
void btUnionFind::Free()
{
	m_elements.clear();
}

void btUnionFind::reset(int N)
{
	allocate(N);

	for (int i = 0; i < N; i++)
	{
		m_elements[i].m_id = i;
		m_elements[i].m_sz = 1;
	}
}

class btUnionFindElementSortPredicate
{
public:
	bool operator()(const btElement& lhs, const btElement& rhs) const
	{
		return lhs.m_id < rhs.m_id;
	}
};

///this is a special operation, destroying the content of btUnionFind.
///it sorts the elements, based on island id, in order to make it easy to iterate over islands
void btUnionFind::sortIslands()
{
	//first store the original body index, and islandId
	int numElements = m_elements.size();

	for (int i = 0; i < numElements; i++)
	{
		m_elements[i].m_id = find(i);
#ifndef STATIC_SIMULATION_ISLAND_OPTIMIZATION
		m_elements[i].m_sz = i;
#endif  //STATIC_SIMULATION_ISLAND_OPTIMIZATION
	}

	// Sort the vector using predicate and std::sort
	//std::sort(m_elements.begin(), m_elements.end(), btUnionFindElementSortPredicate);
	m_elements.quickSort(btUnionFindElementSortPredicate());
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBJECT_ARRAY__
#define BT_OBJECT_ARRAY__

#include "LinearMath/btScalar.h"
#include "LinearMath/btAlignedAllocator.h"

///If the platform doesn't support placement new, you can disable BT_USE_PLACEMENT_NEW
///then the btAlignedObjectArray doesn't support objects with virtual methods, and non-trivial constructors/destructors
///You can enable BT_USE_MEMCPY, then swapping elements in the array will use memcpy instead of operator=
///see discussion here: https://bulletphysics.orgphpBB2/viewtopic.php?t=1231 and
///http://www.continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=1240

#define BT_USE_PLACEMENT_NEW 1
//#define BT_USE_MEMCPY 1 //disable, because it is cumbersome to find out for each platform where memcpy is defined. It can be in <memory.h> or <string.h> or otherwise...
#define BT_ALLOW_ARRAY_COPY_OPERATOR  // enabling this can accidently perform deep copies of data if you are not careful

#ifdef BT_USE_MEMCPY
#endif  //BT_USE_MEMCPY

#ifdef BT_USE_PLACEMENT_NEW
#endif          //BT_USE_PLACEMENT_NEW

///The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
///It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
template <typename T>
//template <class T>
class btAlignedObjectArray
{
	btAlignedAllocator<T, 16> m_allocator;

	int m_size;
	int m_capacity;
	T* m_data;
	//PCK: added this line
	bool m_ownsMemory;

#ifdef BT_ALLOW_ARRAY_COPY_OPERATOR
public:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other)
	{
		copyFromArray(other);
		return *this;
	}
#else   //BT_ALLOW_ARRAY_COPY_OPERATOR
private:
	SIMD_FORCE_INLINE btAlignedObjectArray<T>& operator=(const btAlignedObjectArray<T>& other);
#endif  //BT_ALLOW_ARRAY_COPY_OPERATOR

protected:
	SIMD_FORCE_INLINE int allocSize(int size)
	{
		return (size ? size * 2 : 1);
	}
	SIMD_FORCE_INLINE void copy(int start, int end, T* dest) const
	{
		int i;
		for (i = start; i < end; ++i)
#ifdef BT_USE_PLACEMENT_NEW
			new (&dest[i]) T(m_data[i]);
#else
			dest[i] = m_data[i];
#endif  //BT_USE_PLACEMENT_NEW
	}

	SIMD_FORCE_INLINE void init()
	{
		//PCK: added this line
		m_ownsMemory = true;
		m_data = 0;
		m_size = 0;
		m_capacity = 0;
	}
	SIMD_FORCE_INLINE void destroy(int first, int last)
	{
		int i;
		for (i = first; i < last; i++)
		{
			m_data[i].~T();
		}
	}

	SIMD_FORCE_INLINE void* allocate(int size)
	{
		if (size)
			return m_allocator.allocate(size);
		return 0;
	}

	SIMD_FORCE_INLINE void deallocate()
	{
		if (m_data)
		{
			//PCK: enclosed the deallocation in this block
			if (m_ownsMemory)
			{
				m_allocator.deallocate(m_data);
			}
			m_data = 0;
		}
	}

public:
	btAlignedObjectArray()
	{
		init();
	}

	~btAlignedObjectArray()
	{
		clear();
	}

	///Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead.
	btAlignedObjectArray(const btAlignedObjectArray& otherArray)
	{
		init();

		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}

	/// return the number of elements in the array
	SIMD_FORCE_INLINE int size() const
	{
		return m_size;
	}

	SIMD_FORCE_INLINE const T& at(int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& at(int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE const T& operator[](int n) const
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	SIMD_FORCE_INLINE T& operator[](int n)
	{
		btAssert(n >= 0);
		btAssert(n < size());
		return m_data[n];
	}

	///clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void clear()
	{
		destroy(0, size());

		deallocate();

		init();
	}

	SIMD_FORCE_INLINE void pop_back()
	{
		btAssert(m_size > 0);
		m_size--;
		m_data[m_size].~T();
	}

	///resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	///when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations.
	SIMD_FORCE_INLINE void resizeNoInitialize(int newsize)
	{
		if (newsize > size())
		{
			reserve(newsize);
		}
		m_size = newsize;
	}

	SIMD_FORCE_INLINE void resize(int newsize, const T& fillData = T())
	{
		const int curSize = size();

		if (newsize < curSize)
		{
			for (int i = newsize; i < curSize; i++)
			{
				m_data[i].~T();
			}
		}
		else
		{
			if (newsize > curSize)
			{
				reserve(newsize);
			}
#ifdef BT_USE_PLACEMENT_NEW
			for (int i = curSize; i < newsize; i++)
			{
				new (&m_data[i]) T(fillData);
			}
#endif  //BT_USE_PLACEMENT_NEW
		}

		m_size = newsize;
	}
	SIMD_FORCE_INLINE T& expandNonInitializing()
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;

		return m_data[sz];
	}

	SIMD_FORCE_INLINE T& expand(const T& fillValue = T())
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}
		m_size++;
#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[sz]) T(fillValue);  //use the in-place new (not really allocating heap memory)
#endif

		return m_data[sz];
	}

	SIMD_FORCE_INLINE void push_back(const T& _Val)
	{
		const int sz = size();
		if (sz == capacity())
		{
			reserve(allocSize(size()));
		}

#ifdef BT_USE_PLACEMENT_NEW
		new (&m_data[m_size]) T(_Val);
#else
		m_data[size()] = _Val;
#endif  //BT_USE_PLACEMENT_NEW

		m_size++;
	}

	/// return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve()
	SIMD_FORCE_INLINE int capacity() const
	{
		return m_capacity;
	}

	SIMD_FORCE_INLINE void reserve(int _Count)
	{  // determine new minimum length of allocated storage
		if (capacity() < _Count)
		{  // not enough room, reallocate
			T* s = (T*)allocate(_Count);

			copy(0, size(), s);

			destroy(0, size());

			deallocate();

			//PCK: added this line
			m_ownsMemory = true;

			m_data = s;

			m_capacity = _Count;
		}
	}

	class less
	{
	public:
		bool operator()(const T& a, const T& b) const
		{
			return (a < b);
		}
	};

	template <typename L>
	void quickSortInternal(const L& CompareFunc, int lo, int hi)
	{
		//  lo is the lower index, hi is the upper index
		//  of the region of array a that is to be sorted
		int i = lo, j = hi;
		T x = m_data[(lo + hi) / 2];

		//  partition
		do
		{
			while (CompareFunc(m_data[i], x))
				i++;
			while (CompareFunc(x, m_data[j]))
				j--;
			if (i <= j)
			{
				swap(i, j);
				i++;
				j--;
			}
		} while (i <= j);

		//  recursion
		if (lo < j)
			quickSortInternal(CompareFunc, lo, j);
		if (i < hi)
			quickSortInternal(CompareFunc, i, hi);
	}

	template <typename L>
	void quickSort(const L& CompareFunc)
	{
		//don't sort 0 or 1 elements
		if (size() > 1)
		{
			quickSortInternal(CompareFunc, 0, size() - 1);
		}
	}

	///heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/
	template <typename L>
	void downHeap(T* pArr, int k, int n, const L& CompareFunc)
	{
		/*  PRE: a[k+1..N] is a heap */
		/* POST:  a[k..N]  is a heap */

		T temp = pArr[k - 1];
		/* k has child(s) */
		while (k <= n / 2)
		{
			int child = 2 * k;

			if ((child < n) && CompareFunc(pArr[child - 1], pArr[child]))
			{
				child++;
			}
			/* pick larger child */
			if (CompareFunc(temp, pArr[child - 1]))
			{
				/* move child up */
				pArr[k - 1] = pArr[child - 1];
				k = child;
			}
			else
			{
				break;
			}
		}
		pArr[k - 1] = temp;
	} /*downHeap*/

	void swap(int index0, int index1)
	{
#ifdef BT_USE_MEMCPY
		char temp[sizeof(T)];
		memcpy(temp, &m_data[index0], sizeof(T));
		memcpy(&m_data[index0], &m_data[index1], sizeof(T));
		memcpy(&m_data[index1], temp, sizeof(T));
#else
		T temp = m_data[index0];
		m_data[index0] = m_data[index1];
		m_data[index1] = temp;
#endif  //BT_USE_PLACEMENT_NEW
	}

	template <typename L>
	void heapSort(const L& CompareFunc)
	{
		/* sort a[0..N-1],  N.B. 0 to N-1 */
		int k;
		int n = m_size;
		for (k = n / 2; k > 0; k--)
		{
			downHeap(m_data, k, n, CompareFunc);
		}

		/* a[1..N] is now a heap */
		while (n >= 1)
		{
			swap(0, n - 1); /* largest of a[0..n-1] */

			n = n - 1;
			/* restore a[1..i-1] heap */
			downHeap(m_data, 1, n, CompareFunc);
		}
	}

	///non-recursive binary search, assumes sorted array
	int findBinarySearch(const T& key) const
	{
		int first = 0;
		int last = size() - 1;

		//assume sorted array
		while (first <= last)
		{
			int mid = (first + last) / 2;  // compute mid point.
			if (key > m_data[mid])
				first = mid + 1;  // repeat search in top half.
			else if (key < m_data[mid])
				last = mid - 1;  // repeat search in bottom half.
			else
				return mid;  // found it. return position /////
		}
		return size();  // failed to find key
	}

	int findLinearSearch(const T& key) const
	{
		int index = size();
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	int findLinearSearch2(const T& key) const
	{
		int index = -1;
		int i;

		for (i = 0; i < size(); i++)
		{
			if (m_data[i] == key)
			{
				index = i;
				break;
			}
		}
		return index;
	}

	void removeAtIndex(int index)
	{
		if (index < size())
		{
			swap(index, size() - 1);
			pop_back();
		}
	}
	void remove(const T& key)
	{
		int findIndex = findLinearSearch(key);
		removeAtIndex(findIndex);
	}

	//PCK: whole function
	void initializeFromBuffer(void* buffer, int size, int capacity)
	{
		clear();
		m_ownsMemory = false;
		m_data = (T*)buffer;
		m_size = size;
		m_capacity = capacity;
	}

	void copyFromArray(const btAlignedObjectArray& otherArray)
	{
		int otherSize = otherArray.size();
		resize(otherSize);
		otherArray.copy(0, otherSize, m_data);
	}
};

#endif  //BT_OBJECT_ARRAY__





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_HASH_MAP_H
#define BT_HASH_MAP_H

#include "LinearMath/btAlignedObjectArray.h"

///very basic hashable string implementation, compatible with btHashMap
struct btHashString
{
	std::string m_string1;
	unsigned int m_hash;

	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		return m_hash;
	}

	btHashString()
	{
		m_string1 = "";
		m_hash = 0;
	}
	btHashString(const char* name)
		: m_string1(name)
	{
		/* magic numbers from http://www.isthe.com/chongo/tech/comp/fnv/ */
		static const unsigned int InitialFNV = 2166136261u;
		static const unsigned int FNVMultiple = 16777619u;

		/* Fowler / Noll / Vo (FNV) Hash */
		unsigned int hash = InitialFNV;

		for (int i = 0; m_string1.c_str()[i]; i++)
		{
			hash = hash ^ (m_string1.c_str()[i]); /* xor  the low 8 bits */
			hash = hash * FNVMultiple;            /* multiply by the magic number */
		}
		m_hash = hash;
	}

	bool equals(const btHashString& other) const
	{
		return (m_string1 == other.m_string1);
	}
};

const int BT_HASH_NULL = 0xffffffff;

class btHashInt
{
	int m_uid;

public:
	btHashInt()
	{
	}

	btHashInt(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	void setUid1(int uid)
	{
		m_uid = uid;
	}

	bool equals(const btHashInt& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);

		return key;
	}
};

class btHashPtr
{
	union {
		const void* m_pointer;
		unsigned int m_hashValues[2];
	};

public:
	btHashPtr()
	{
	}

	btHashPtr(const void* ptr)
		: m_pointer(ptr)
	{
	}

	const void* getPointer() const
	{
		return m_pointer;
	}

	bool equals(const btHashPtr& other) const
	{
		return getPointer() == other.getPointer();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));

		unsigned int key = VOID_IS_8 ? m_hashValues[0] + m_hashValues[1] : m_hashValues[0];
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKeyPtr
{
	int m_uid;

public:
	btHashKeyPtr(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKeyPtr<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}

	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

template <class Value>
class btHashKey
{
	int m_uid;

public:
	btHashKey(int uid) : m_uid(uid)
	{
	}

	int getUid1() const
	{
		return m_uid;
	}

	bool equals(const btHashKey<Value>& other) const
	{
		return getUid1() == other.getUid1();
	}
	//to our success
	SIMD_FORCE_INLINE unsigned int getHash() const
	{
		unsigned int key = m_uid;
		// Thomas Wang's hash
		key += ~(key << 15);
		key ^= (key >> 10);
		key += (key << 3);
		key ^= (key >> 6);
		key += ~(key << 11);
		key ^= (key >> 16);
		return key;
	}
};

///The btHashMap template class implements a generic and lightweight hashmap.
///A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
template <class Key, class Value>
class btHashMap
{
protected:
	btAlignedObjectArray<int> m_hashTable;
	btAlignedObjectArray<int> m_next;

	btAlignedObjectArray<Value> m_valueArray;
	btAlignedObjectArray<Key> m_keyArray;

	void growTables(const Key& /*key*/)
	{
		int newCapacity = m_valueArray.capacity();

		if (m_hashTable.size() < newCapacity)
		{
			//grow hashtable and next table
			int curHashtableSize = m_hashTable.size();

			m_hashTable.resize(newCapacity);
			m_next.resize(newCapacity);

			int i;

			for (i = 0; i < newCapacity; ++i)
			{
				m_hashTable[i] = BT_HASH_NULL;
			}
			for (i = 0; i < newCapacity; ++i)
			{
				m_next[i] = BT_HASH_NULL;
			}

			for (i = 0; i < curHashtableSize; i++)
			{
				//const Value& value = m_valueArray[i];
				//const Key& key = m_keyArray[i];

				int hashValue = m_keyArray[i].getHash() & (m_valueArray.capacity() - 1);  // New hash value with new mask
				m_next[i] = m_hashTable[hashValue];
				m_hashTable[hashValue] = i;
			}
		}
	}

public:
	void insert(const Key& key, const Value& value)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		//replace value if the key is already there
		int index = findIndex(key);
		if (index != BT_HASH_NULL)
		{
			m_valueArray[index] = value;
			return;
		}

		int count = m_valueArray.size();
		int oldCapacity = m_valueArray.capacity();
		m_valueArray.push_back(value);
		m_keyArray.push_back(key);

		int newCapacity = m_valueArray.capacity();
		if (oldCapacity < newCapacity)
		{
			growTables(key);
			//hash with new capacity
			hash = key.getHash() & (m_valueArray.capacity() - 1);
		}
		m_next[count] = m_hashTable[hash];
		m_hashTable[hash] = count;
	}

	void remove(const Key& key)
	{
		int hash = key.getHash() & (m_valueArray.capacity() - 1);

		int pairIndex = findIndex(key);

		if (pairIndex == BT_HASH_NULL)
		{
			return;
		}

		// Remove the pair from the hash table.
		int index = m_hashTable[hash];
		btAssert(index != BT_HASH_NULL);

		int previous = BT_HASH_NULL;
		while (index != pairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == pairIndex);
			m_next[previous] = m_next[pairIndex];
		}
		else
		{
			m_hashTable[hash] = m_next[pairIndex];
		}

		// We now move the last pair into spot of the
		// pair being removed. We need to fix the hash
		// table indices to support the move.

		int lastPairIndex = m_valueArray.size() - 1;

		// If the removed pair is the last pair, we are done.
		if (lastPairIndex == pairIndex)
		{
			m_valueArray.pop_back();
			m_keyArray.pop_back();
			return;
		}

		// Remove the last pair from the hash table.
		int lastHash = m_keyArray[lastPairIndex].getHash() & (m_valueArray.capacity() - 1);

		index = m_hashTable[lastHash];
		btAssert(index != BT_HASH_NULL);

		previous = BT_HASH_NULL;
		while (index != lastPairIndex)
		{
			previous = index;
			index = m_next[index];
		}

		if (previous != BT_HASH_NULL)
		{
			btAssert(m_next[previous] == lastPairIndex);
			m_next[previous] = m_next[lastPairIndex];
		}
		else
		{
			m_hashTable[lastHash] = m_next[lastPairIndex];
		}

		// Copy the last pair into the remove pair's spot.
		m_valueArray[pairIndex] = m_valueArray[lastPairIndex];
		m_keyArray[pairIndex] = m_keyArray[lastPairIndex];

		// Insert the last pair into the hash table
		m_next[pairIndex] = m_hashTable[lastHash];
		m_hashTable[lastHash] = pairIndex;

		m_valueArray.pop_back();
		m_keyArray.pop_back();
	}

	int size() const
	{
		return m_valueArray.size();
	}

	const Value* getAtIndex(int index) const
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Value* getAtIndex(int index)
	{
		btAssert(index < m_valueArray.size());
		btAssert(index >= 0);
		if (index >= 0 && index < m_valueArray.size())
		{
			return &m_valueArray[index];
		}
		return 0;
	}

	Key getKeyAtIndex(int index)
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	const Key getKeyAtIndex(int index) const
	{
		btAssert(index < m_keyArray.size());
		btAssert(index >= 0);
		return m_keyArray[index];
	}

	Value* operator[](const Key& key)
	{
		return find(key);
	}

	const Value* operator[](const Key& key) const
	{
		return find(key);
	}

	const Value* find(const Key& key) const
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	Value* find(const Key& key)
	{
		int index = findIndex(key);
		if (index == BT_HASH_NULL)
		{
			return NULL;
		}
		return &m_valueArray[index];
	}

	int findIndex(const Key& key) const
	{
		unsigned int hash = key.getHash() & (m_valueArray.capacity() - 1);

		if (hash >= (unsigned int)m_hashTable.size())
		{
			return BT_HASH_NULL;
		}

		int index = m_hashTable[hash];
		while ((index != BT_HASH_NULL) && key.equals(m_keyArray[index]) == false)
		{
			index = m_next[index];
		}
		return index;
	}

	void clear()
	{
		m_hashTable.clear();
		m_next.clear();
		m_valueArray.clear();
		m_keyArray.clear();
	}
};

#endif  //BT_HASH_MAP_H




#include <string.h>



/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SERIALIZER_H
#define BT_SERIALIZER_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btHashMap.h"

#if !defined(__CELLOS_LV2__) && !defined(__MWERKS__)
#endif

extern char sBulletDNAstr[];
extern int sBulletDNAlen;
extern char sBulletDNAstr64[];
extern int sBulletDNAlen64;

SIMD_FORCE_INLINE int btStrLen(const char* str)
{
	if (!str)
		return (0);
	int len = 0;

	while (*str != 0)
	{
		str++;
		len++;
	}

	return len;
}

class btChunk
{
public:
	int m_chunkCode;
	int m_length;
	void* m_oldPtr;
	int m_dna_nr;
	int m_number;
};

enum btSerializationFlags
{
	BT_SERIALIZE_NO_BVH = 1,
	BT_SERIALIZE_NO_TRIANGLEINFOMAP = 2,
	BT_SERIALIZE_NO_DUPLICATE_ASSERT = 4,
	BT_SERIALIZE_CONTACT_MANIFOLDS = 8,
};

class btSerializer
{
public:
	virtual ~btSerializer() {}

	virtual const unsigned char* getBufferPointer() const = 0;

	virtual int getCurrentBufferSize() const = 0;

	virtual btChunk* allocate(size_t size, int numElements) = 0;

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr) = 0;

	virtual void* findPointer(void* oldPtr) = 0;

	virtual void* getUniquePointer(void* oldPtr) = 0;

	virtual void startSerialization() = 0;

	virtual void finishSerialization() = 0;

	virtual const char* findNameForPointer(const void* ptr) const = 0;

	virtual void registerNameForPointer(const void* ptr, const char* name) = 0;

	virtual void serializeName(const char* ptr) = 0;

	virtual int getSerializationFlags() const = 0;

	virtual void setSerializationFlags(int flags) = 0;

	virtual int getNumChunks() const = 0;

	virtual const btChunk* getChunk(int chunkIndex) const = 0;
};

#define BT_HEADER_LENGTH 12
#if defined(__sgi) || defined(__sparc) || defined(__sparc__) || defined(__PPC__) || defined(__ppc__) || defined(__BIG_ENDIAN__)
#define BT_MAKE_ID(a, b, c, d) ((int)(a) << 24 | (int)(b) << 16 | (c) << 8 | (d))
#else
#define BT_MAKE_ID(a, b, c, d) ((int)(d) << 24 | (int)(c) << 16 | (b) << 8 | (a))
#endif

#define BT_MULTIBODY_CODE BT_MAKE_ID('M', 'B', 'D', 'Y')
#define BT_MB_LINKCOLLIDER_CODE BT_MAKE_ID('M', 'B', 'L', 'C')
#define BT_SOFTBODY_CODE BT_MAKE_ID('S', 'B', 'D', 'Y')
#define BT_COLLISIONOBJECT_CODE BT_MAKE_ID('C', 'O', 'B', 'J')
#define BT_RIGIDBODY_CODE BT_MAKE_ID('R', 'B', 'D', 'Y')
#define BT_CONSTRAINT_CODE BT_MAKE_ID('C', 'O', 'N', 'S')
#define BT_BOXSHAPE_CODE BT_MAKE_ID('B', 'O', 'X', 'S')
#define BT_QUANTIZED_BVH_CODE BT_MAKE_ID('Q', 'B', 'V', 'H')
#define BT_TRIANLGE_INFO_MAP BT_MAKE_ID('T', 'M', 'A', 'P')
#define BT_SHAPE_CODE BT_MAKE_ID('S', 'H', 'A', 'P')
#define BT_ARRAY_CODE BT_MAKE_ID('A', 'R', 'A', 'Y')
#define BT_SBMATERIAL_CODE BT_MAKE_ID('S', 'B', 'M', 'T')
#define BT_SBNODE_CODE BT_MAKE_ID('S', 'B', 'N', 'D')
#define BT_DYNAMICSWORLD_CODE BT_MAKE_ID('D', 'W', 'L', 'D')
#define BT_CONTACTMANIFOLD_CODE BT_MAKE_ID('C', 'O', 'N', 'T')
#define BT_DNA_CODE BT_MAKE_ID('D', 'N', 'A', '1')

struct btPointerUid
{
	union {
		void* m_ptr;
		int m_uniqueIds[2];
	};
};

struct btBulletSerializedArrays
{
	btBulletSerializedArrays()
	{
	}
	btAlignedObjectArray<struct btQuantizedBvhDoubleData*> m_bvhsDouble;
	btAlignedObjectArray<struct btQuantizedBvhFloatData*> m_bvhsFloat;
	btAlignedObjectArray<struct btCollisionShapeData*> m_colShapeData;
	btAlignedObjectArray<struct btDynamicsWorldDoubleData*> m_dynamicWorldInfoDataDouble;
	btAlignedObjectArray<struct btDynamicsWorldFloatData*> m_dynamicWorldInfoDataFloat;
	btAlignedObjectArray<struct btRigidBodyDoubleData*> m_rigidBodyDataDouble;
	btAlignedObjectArray<struct btRigidBodyFloatData*> m_rigidBodyDataFloat;
	btAlignedObjectArray<struct btCollisionObjectDoubleData*> m_collisionObjectDataDouble;
	btAlignedObjectArray<struct btCollisionObjectFloatData*> m_collisionObjectDataFloat;
	btAlignedObjectArray<struct btTypedConstraintFloatData*> m_constraintDataFloat;
	btAlignedObjectArray<struct btTypedConstraintDoubleData*> m_constraintDataDouble;
	btAlignedObjectArray<struct btTypedConstraintData*> m_constraintData;  //for backwards compatibility
	btAlignedObjectArray<struct btSoftBodyFloatData*> m_softBodyFloatData;
	btAlignedObjectArray<struct btSoftBodyDoubleData*> m_softBodyDoubleData;
};

///The btDefaultSerializer is the main Bullet serialization class.
///The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
class btDefaultSerializer : public btSerializer
{
protected:
	btAlignedObjectArray<char*> mTypes;
	btAlignedObjectArray<short*> mStructs;
	btAlignedObjectArray<short> mTlens;
	btHashMap<btHashInt, int> mStructReverse;
	btHashMap<btHashString, int> mTypeLookup;

	btHashMap<btHashPtr, void*> m_chunkP;

	btHashMap<btHashPtr, const char*> m_nameMap;

	btHashMap<btHashPtr, btPointerUid> m_uniquePointers;
	int m_uniqueIdGenerator;

	int m_totalSize;
	unsigned char* m_buffer;
	bool m_ownsBuffer;
	int m_currentSize;
	void* m_dna;
	int m_dnaLength;

	int m_serializationFlags;

	btAlignedObjectArray<btChunk*> m_chunkPtrs;

protected:
	virtual void* findPointer(void* oldPtr)
	{
		void** ptr = m_chunkP.find(oldPtr);
		if (ptr && *ptr)
			return *ptr;
		return 0;
	}

	virtual void writeDNA()
	{
		btChunk* dnaChunk = allocate(m_dnaLength, 1);
		memcpy(dnaChunk->m_oldPtr, m_dna, m_dnaLength);
		finalizeChunk(dnaChunk, "DNA1", BT_DNA_CODE, m_dna);
	}

	int getReverseType(const char* type) const
	{
		btHashString key(type);
		const int* valuePtr = mTypeLookup.find(key);
		if (valuePtr)
			return *valuePtr;

		return -1;
	}

	void initDNA(const char* bdnaOrg, int dnalen)
	{
		///was already initialized
		if (m_dna)
			return;

		int littleEndian = 1;
		littleEndian = ((char*)&littleEndian)[0];

		m_dna = btAlignedAlloc(dnalen, 16);
		memcpy(m_dna, bdnaOrg, dnalen);
		m_dnaLength = dnalen;

		int* intPtr = 0;
		short* shtPtr = 0;
		char* cp = 0;
		int dataLen = 0;
		intPtr = (int*)m_dna;

		/*
				SDNA (4 bytes) (magic number)
				NAME (4 bytes)
				<nr> (4 bytes) amount of names (int)
				<string>
				<string>
			*/

		if (strncmp((const char*)m_dna, "SDNA", 4) == 0)
		{
			// skip ++ NAME
			intPtr++;
			intPtr++;
		}

		// Parse names
		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);

		dataLen = *intPtr;

		intPtr++;

		cp = (char*)intPtr;
		int i;
		for (i = 0; i < dataLen; i++)
		{
			while (*cp) cp++;
			cp++;
		}
		cp = btAlignPointer(cp, 4);

		/*
				TYPE (4 bytes)
				<nr> amount of types (int)
				<string>
				<string>
			*/

		intPtr = (int*)cp;
		btAssert(strncmp(cp, "TYPE", 4) == 0);
		intPtr++;

		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);

		dataLen = *intPtr;
		intPtr++;

		cp = (char*)intPtr;
		for (i = 0; i < dataLen; i++)
		{
			mTypes.push_back(cp);
			while (*cp) cp++;
			cp++;
		}

		cp = btAlignPointer(cp, 4);

		/*
				TLEN (4 bytes)
				<len> (short) the lengths of types
				<len>
			*/

		// Parse type lens
		intPtr = (int*)cp;
		btAssert(strncmp(cp, "TLEN", 4) == 0);
		intPtr++;

		dataLen = (int)mTypes.size();

		shtPtr = (short*)intPtr;
		for (i = 0; i < dataLen; i++, shtPtr++)
		{
			if (!littleEndian)
				shtPtr[0] = btSwapEndian(shtPtr[0]);
			mTlens.push_back(shtPtr[0]);
		}

		if (dataLen & 1) shtPtr++;

		/*
				STRC (4 bytes)
				<nr> amount of structs (int)
				<typenr>
				<nr_of_elems>
				<typenr>
				<namenr>
				<typenr>
				<namenr>
			*/

		intPtr = (int*)shtPtr;
		cp = (char*)intPtr;
		btAssert(strncmp(cp, "STRC", 4) == 0);
		intPtr++;

		if (!littleEndian)
			*intPtr = btSwapEndian(*intPtr);
		dataLen = *intPtr;
		intPtr++;

		shtPtr = (short*)intPtr;
		for (i = 0; i < dataLen; i++)
		{
			mStructs.push_back(shtPtr);

			if (!littleEndian)
			{
				shtPtr[0] = btSwapEndian(shtPtr[0]);
				shtPtr[1] = btSwapEndian(shtPtr[1]);

				int len = shtPtr[1];
				shtPtr += 2;

				for (int a = 0; a < len; a++, shtPtr += 2)
				{
					shtPtr[0] = btSwapEndian(shtPtr[0]);
					shtPtr[1] = btSwapEndian(shtPtr[1]);
				}
			}
			else
			{
				shtPtr += (2 * shtPtr[1]) + 2;
			}
		}

		// build reverse lookups
		for (i = 0; i < (int)mStructs.size(); i++)
		{
			short* strc = mStructs.at(i);
			mStructReverse.insert(strc[0], i);
			mTypeLookup.insert(btHashString(mTypes[strc[0]]), i);
		}
	}

public:
	btHashMap<btHashPtr, void*> m_skipPointers;

	btDefaultSerializer(int totalSize = 0, unsigned char* buffer = 0)
		: m_uniqueIdGenerator(0),
		  m_totalSize(totalSize),
		  m_currentSize(0),
		  m_dna(0),
		  m_dnaLength(0),
		  m_serializationFlags(0)
	{
		if (buffer == 0)
		{
			m_buffer = m_totalSize ? (unsigned char*)btAlignedAlloc(totalSize, 16) : 0;
			m_ownsBuffer = true;
		}
		else
		{
			m_buffer = buffer;
			m_ownsBuffer = false;
		}

		const bool VOID_IS_8 = ((sizeof(void*) == 8));

#ifdef BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
		if (VOID_IS_8)
		{
#if _WIN64
			initDNA((const char*)sBulletDNAstr64, sBulletDNAlen64);
#else
			btAssert(0);
#endif
		}
		else
		{
#ifndef _WIN64
			initDNA((const char*)sBulletDNAstr, sBulletDNAlen);
#else
			btAssert(0);
#endif
		}

#else   //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
		if (VOID_IS_8)
		{
			initDNA((const char*)sBulletDNAstr64, sBulletDNAlen64);
		}
		else
		{
			initDNA((const char*)sBulletDNAstr, sBulletDNAlen);
		}
#endif  //BT_INTERNAL_UPDATE_SERIALIZATION_STRUCTURES
	}

	virtual ~btDefaultSerializer()
	{
		if (m_buffer && m_ownsBuffer)
			btAlignedFree(m_buffer);
		if (m_dna)
			btAlignedFree(m_dna);
	}

	static int getMemoryDnaSizeInBytes()
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));

		if (VOID_IS_8)
		{
			return sBulletDNAlen64;
		}
		return sBulletDNAlen;
	}
	static const char* getMemoryDna()
	{
		const bool VOID_IS_8 = ((sizeof(void*) == 8));
		if (VOID_IS_8)
		{
			return (const char*)sBulletDNAstr64;
		}
		return (const char*)sBulletDNAstr;
	}

	void insertHeader()
	{
		writeHeader(m_buffer);
		m_currentSize += BT_HEADER_LENGTH;
	}

	void writeHeader(unsigned char* buffer) const
	{
#ifdef BT_USE_DOUBLE_PRECISION
		memcpy(buffer, "BULLETd", 7);
#else
		memcpy(buffer, "BULLETf", 7);
#endif  //BT_USE_DOUBLE_PRECISION

		int littleEndian = 1;
		littleEndian = ((char*)&littleEndian)[0];

		if (sizeof(void*) == 8)
		{
			buffer[7] = '-';
		}
		else
		{
			buffer[7] = '_';
		}

		if (littleEndian)
		{
			buffer[8] = 'v';
		}
		else
		{
			buffer[8] = 'V';
		}

		buffer[9] = '3';
		buffer[10] = '2';
		buffer[11] = '6';
	}

	virtual void startSerialization()
	{
		m_uniqueIdGenerator = 1;
		if (m_totalSize)
		{
			unsigned char* buffer = internalAlloc(BT_HEADER_LENGTH);
			writeHeader(buffer);
		}
	}

	virtual void finishSerialization()
	{
		writeDNA();

		//if we didn't pre-allocate a buffer, we need to create a contiguous buffer now
		if (!m_totalSize)
		{
			if (m_buffer)
				btAlignedFree(m_buffer);

			m_currentSize += BT_HEADER_LENGTH;
			m_buffer = (unsigned char*)btAlignedAlloc(m_currentSize, 16);

			unsigned char* currentPtr = m_buffer;
			writeHeader(m_buffer);
			currentPtr += BT_HEADER_LENGTH;
			for (int i = 0; i < m_chunkPtrs.size(); i++)
			{
				int curLength = (int)sizeof(btChunk) + m_chunkPtrs[i]->m_length;
				memcpy(currentPtr, m_chunkPtrs[i], curLength);
				btAlignedFree(m_chunkPtrs[i]);
				currentPtr += curLength;
			}
		}

		mTypes.clear();
		mStructs.clear();
		mTlens.clear();
		mStructReverse.clear();
		mTypeLookup.clear();
		m_skipPointers.clear();
		m_chunkP.clear();
		m_nameMap.clear();
		m_uniquePointers.clear();
		m_chunkPtrs.clear();
	}

	virtual void* getUniquePointer(void* oldPtr)
	{
		btAssert(m_uniqueIdGenerator >= 0);
		if (!oldPtr)
			return 0;

		btPointerUid* uptr = (btPointerUid*)m_uniquePointers.find(oldPtr);
		if (uptr)
		{
			return uptr->m_ptr;
		}

		void** ptr2 = m_skipPointers[oldPtr];
		if (ptr2)
		{
			return 0;
		}

		m_uniqueIdGenerator++;

		btPointerUid uid;
		uid.m_uniqueIds[0] = m_uniqueIdGenerator;
		uid.m_uniqueIds[1] = m_uniqueIdGenerator;
		m_uniquePointers.insert(oldPtr, uid);
		return uid.m_ptr;
	}

	virtual const unsigned char* getBufferPointer() const
	{
		return m_buffer;
	}

	virtual int getCurrentBufferSize() const
	{
		return m_currentSize;
	}

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr)
	{
		if (!(m_serializationFlags & BT_SERIALIZE_NO_DUPLICATE_ASSERT))
		{
			btAssert(!findPointer(oldPtr));
		}

		chunk->m_dna_nr = getReverseType(structType);

		chunk->m_chunkCode = chunkCode;

		void* uniquePtr = getUniquePointer(oldPtr);

		m_chunkP.insert(oldPtr, uniquePtr);  //chunk->m_oldPtr);
		chunk->m_oldPtr = uniquePtr;         //oldPtr;
	}

	virtual unsigned char* internalAlloc(size_t size)
	{
		unsigned char* ptr = 0;

		if (m_totalSize)
		{
			ptr = m_buffer + m_currentSize;
			m_currentSize += int(size);
			btAssert(m_currentSize < m_totalSize);
		}
		else
		{
			ptr = (unsigned char*)btAlignedAlloc(size, 16);
			m_currentSize += int(size);
		}
		return ptr;
	}

	virtual btChunk* allocate(size_t size, int numElements)
	{
		unsigned char* ptr = internalAlloc(int(size) * numElements + sizeof(btChunk));

		unsigned char* data = ptr + sizeof(btChunk);

		btChunk* chunk = (btChunk*)ptr;
		chunk->m_chunkCode = 0;
		chunk->m_oldPtr = data;
		chunk->m_length = int(size) * numElements;
		chunk->m_number = numElements;

		m_chunkPtrs.push_back(chunk);

		return chunk;
	}

	virtual const char* findNameForPointer(const void* ptr) const
	{
		const char* const* namePtr = m_nameMap.find(ptr);
		if (namePtr && *namePtr)
			return *namePtr;
		return 0;
	}

	virtual void registerNameForPointer(const void* ptr, const char* name)
	{
		m_nameMap.insert(ptr, name);
	}

	virtual void serializeName(const char* name)
	{
		if (name)
		{
			//don't serialize name twice
			if (findPointer((void*)name))
				return;

			int len = btStrLen(name);
			if (len)
			{
				int newLen = len + 1;
				int padding = ((newLen + 3) & ~3) - newLen;
				newLen += padding;

				//serialize name string now
				btChunk* chunk = allocate(sizeof(char), newLen);
				char* destinationName = (char*)chunk->m_oldPtr;
				for (int i = 0; i < len; i++)
				{
					destinationName[i] = name[i];
				}
				destinationName[len] = 0;
				finalizeChunk(chunk, "char", BT_ARRAY_CODE, (void*)name);
			}
		}
	}

	virtual int getSerializationFlags() const
	{
		return m_serializationFlags;
	}

	virtual void setSerializationFlags(int flags)
	{
		m_serializationFlags = flags;
	}
	int getNumChunks() const
	{
		return m_chunkPtrs.size();
	}

	const btChunk* getChunk(int chunkIndex) const
	{
		return m_chunkPtrs[chunkIndex];
	}
};

///In general it is best to use btDefaultSerializer,
///in particular when writing the data to disk or sending it over the network.
///The btInMemorySerializer is experimental and only suitable in a few cases.
///The btInMemorySerializer takes a shortcut and can be useful to create a deep-copy
///of objects. There will be a demo on how to use the btInMemorySerializer.
#ifdef ENABLE_INMEMORY_SERIALIZER

struct btInMemorySerializer : public btDefaultSerializer
{
	btHashMap<btHashPtr, btChunk*> m_uid2ChunkPtr;
	btHashMap<btHashPtr, void*> m_orgPtr2UniqueDataPtr;
	btHashMap<btHashString, const void*> m_names2Ptr;

	btBulletSerializedArrays m_arrays;

	btInMemorySerializer(int totalSize = 0, unsigned char* buffer = 0)
		: btDefaultSerializer(totalSize, buffer)
	{
	}

	virtual void startSerialization()
	{
		m_uid2ChunkPtr.clear();
		//todo: m_arrays.clear();
		btDefaultSerializer::startSerialization();
	}

	btChunk* findChunkFromUniquePointer(void* uniquePointer)
	{
		btChunk** chkPtr = m_uid2ChunkPtr[uniquePointer];
		if (chkPtr)
		{
			return *chkPtr;
		}
		return 0;
	}

	virtual void registerNameForPointer(const void* ptr, const char* name)
	{
		btDefaultSerializer::registerNameForPointer(ptr, name);
		m_names2Ptr.insert(name, ptr);
	}

	virtual void finishSerialization()
	{
	}

	virtual void* getUniquePointer(void* oldPtr)
	{
		if (oldPtr == 0)
			return 0;

		// void* uniquePtr = getUniquePointer(oldPtr);
		btChunk* chunk = findChunkFromUniquePointer(oldPtr);
		if (chunk)
		{
			return chunk->m_oldPtr;
		}
		else
		{
			const char* n = (const char*)oldPtr;
			const void** ptr = m_names2Ptr[n];
			if (ptr)
			{
				return oldPtr;
			}
			else
			{
				void** ptr2 = m_skipPointers[oldPtr];
				if (ptr2)
				{
					return 0;
				}
				else
				{
					//If this assert hit, serialization happened in the wrong order
					// 'getUniquePointer'
					btAssert(0);
				}
			}
			return 0;
		}
		return oldPtr;
	}

	virtual void finalizeChunk(btChunk* chunk, const char* structType, int chunkCode, void* oldPtr)
	{
		if (!(m_serializationFlags & BT_SERIALIZE_NO_DUPLICATE_ASSERT))
		{
			btAssert(!findPointer(oldPtr));
		}

		chunk->m_dna_nr = getReverseType(structType);
		chunk->m_chunkCode = chunkCode;
		//void* uniquePtr = getUniquePointer(oldPtr);
		m_chunkP.insert(oldPtr, oldPtr);  //chunk->m_oldPtr);
		// chunk->m_oldPtr = uniquePtr;//oldPtr;

		void* uid = findPointer(oldPtr);
		m_uid2ChunkPtr.insert(uid, chunk);

		switch (chunk->m_chunkCode)
		{
			case BT_SOFTBODY_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_softBodyDoubleData.push_back((btSoftBodyDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_softBodyFloatData.push_back((btSoftBodyFloatData*)chunk->m_oldPtr);
#endif
				break;
			}
			case BT_COLLISIONOBJECT_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_collisionObjectDataDouble.push_back((btCollisionObjectDoubleData*)chunk->m_oldPtr);
#else   //BT_USE_DOUBLE_PRECISION
				m_arrays.m_collisionObjectDataFloat.push_back((btCollisionObjectFloatData*)chunk->m_oldPtr);
#endif  //BT_USE_DOUBLE_PRECISION
				break;
			}
			case BT_RIGIDBODY_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_rigidBodyDataDouble.push_back((btRigidBodyDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_rigidBodyDataFloat.push_back((btRigidBodyFloatData*)chunk->m_oldPtr);
#endif  //BT_USE_DOUBLE_PRECISION
				break;
			};
			case BT_CONSTRAINT_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_constraintDataDouble.push_back((btTypedConstraintDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_constraintDataFloat.push_back((btTypedConstraintFloatData*)chunk->m_oldPtr);
#endif
				break;
			}
			case BT_QUANTIZED_BVH_CODE:
			{
#ifdef BT_USE_DOUBLE_PRECISION
				m_arrays.m_bvhsDouble.push_back((btQuantizedBvhDoubleData*)chunk->m_oldPtr);
#else
				m_arrays.m_bvhsFloat.push_back((btQuantizedBvhFloatData*)chunk->m_oldPtr);
#endif
				break;
			}

			case BT_SHAPE_CODE:
			{
				btCollisionShapeData* shapeData = (btCollisionShapeData*)chunk->m_oldPtr;
				m_arrays.m_colShapeData.push_back(shapeData);
				break;
			}
			case BT_TRIANLGE_INFO_MAP:
			case BT_ARRAY_CODE:
			case BT_SBMATERIAL_CODE:
			case BT_SBNODE_CODE:
			case BT_DYNAMICSWORLD_CODE:
			case BT_DNA_CODE:
			{
				break;
			}
			default:
			{
			}
		};
	}

	int getNumChunks() const
	{
		return m_uid2ChunkPtr.size();
	}

	const btChunk* getChunk(int chunkIndex) const
	{
		return *m_uid2ChunkPtr.getAtIndex(chunkIndex);
	}
};
#endif  //ENABLE_INMEMORY_SERIALIZER

#endif  //BT_SERIALIZER_H





char sBulletDNAstr[]= {
char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-74),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(111),
char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(76),char(111),char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(66),char(91),char(52),char(93),char(0),
char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),
char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(78),char(111),char(114),char(109),
char(97),char(108),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),
char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(68),char(105),char(114),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),
char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(68),char(105),char(114),char(50),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(68),char(105),char(115),char(116),
char(97),char(110),char(99),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(114),char(101),char(118),char(82),char(72),char(83),char(91),char(52),char(93),
char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),
char(100),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(111),char(108),char(108),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(83),char(112),char(105),char(110),char(110),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),
char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),
char(97),char(114),char(116),char(73),char(100),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(80),char(97),char(114),char(116),char(73),char(100),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),
char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),
char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(111),char(105),char(110),
char(116),char(70),char(108),char(97),char(103),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),
char(114),char(97),char(108),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),char(114),char(97),
char(108),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),char(110),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),
char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),
char(110),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(67),char(70),char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(69),char(82),char(80),char(91),char(52),char(93),char(0),char(109),
char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(67),char(70),
char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(105),char(102),
char(101),char(84),char(105),char(109),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(97),char(99),char(104),char(101),char(100),
char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),
char(65),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(66),char(0),char(109),char(95),char(105),
char(110),char(100),char(101),char(120),char(49),char(97),char(0),char(109),char(95),char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),
char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(66),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),
char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(42),char(109),char(95),char(98),
char(111),char(100),char(121),char(48),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(49),char(0),char(109),char(95),char(103),char(105),char(109),char(112),
char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),
char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),
char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),
char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),
char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),
char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),
char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),
char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),
char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),
char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),
char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),
char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),
char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),
char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),
char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),
char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),
char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),
char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),
char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),
char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),
char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(105),char(108),
char(116),char(101),char(114),char(71),char(114),char(111),char(117),char(112),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(105),char(108),char(116),char(101),char(114),char(77),char(97),char(115),char(107),char(0),char(109),char(95),char(117),char(110),char(105),char(113),char(117),char(101),char(73),
char(100),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),char(114),char(111),char(114),char(82),
char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),char(95),char(101),char(114),char(112),
char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),char(67),char(102),char(109),char(0),
char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),char(110),char(101),char(116),char(114),
char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(115),char(112),char(108),
char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),char(115),char(116),char(97),char(114),
char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(114),char(116),char(105),char(99),char(117),char(108),
char(97),char(116),char(101),char(100),char(87),char(97),char(114),char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),
char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),
char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),
char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),
char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),
char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),
char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),
char(114),char(116),char(105),char(97),char(84),char(101),char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),
char(114),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),
char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),
char(97),char(108),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),
char(116),char(97),char(108),char(84),char(111),char(114),char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),
char(97),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),
char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),
char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),
char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),
char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),
char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),
char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),
char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),
char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(82),char(111),char(119),char(115),char(0),char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),
char(114),char(98),char(66),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),char(100),char(98),char(97),char(99),char(107),char(0),
char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(100),
char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),char(105),char(115),char(97),char(98),char(108),char(101),
char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),char(101),char(101),char(110),char(76),char(105),char(110),
char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),char(101),char(114),char(114),char(105),char(100),char(101),
char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(0),char(112),
char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),
char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),
char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),
char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),
char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),
char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),
char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),
char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),
char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),
char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),
char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),
char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),
char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),
char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),
char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),
char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),
char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),
char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),
char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),
char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(97),char(120),char(77),
char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),
char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),
char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),
char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),
char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),
char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),
char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),
char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),char(114),
char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),char(100),char(101),char(114),char(0),char(109),char(95),
char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(66),char(0),char(109),char(95),
char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),
char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),
char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),
char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),
char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),
char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),
char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),
char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),
char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),
char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),
char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),
char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),
char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),
char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),
char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),
char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),
char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),
char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),
char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),
char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),
char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),
char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),
char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),
char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),
char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),
char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),
char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),
char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),
char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),
char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),
char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),
char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),
char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),
char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),
char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),
char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),
char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),
char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),
char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),
char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),
char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),
char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),
char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),
char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),
char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),
char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),
char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),
char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),
char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),
char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),
char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),
char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(109),
char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),char(84),char(111),char(84),char(104),char(105),char(115),
char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),char(84),char(104),char(105),char(115),char(80),char(105),
char(118),char(111),char(116),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),char(80),char(105),char(118),char(111),
char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(106),
char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),
char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),
char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),
char(70),char(114),char(97),char(109),char(101),char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),
char(111),char(109),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),char(99),char(86),char(101),char(108),char(111),
char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),
char(99),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),char(111),char(109),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),
char(0),char(109),char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),
char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(84),char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
char(106),char(111),char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(77),char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),
char(95),char(108),char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),
char(100),char(105),char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(80),
char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(79),
char(114),char(105),char(101),char(110),char(116),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(76),char(105),char(110),
char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),
char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),
char(109),char(95),char(98),char(97),char(115),char(101),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),
char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(79),char(98),char(106),char(68),char(97),char(116),char(97),char(0),
char(42),char(109),char(95),char(109),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(107),char(0),
char(84),char(89),char(80),char(69),char(99),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),
char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),
char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),
char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),
char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),
char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),
char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),
char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),
char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),
char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),
char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),
char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),
char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),
char(112),char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),
char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),
char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),
char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),
char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),
char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),
char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),
char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),
char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),
char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),
char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(67),char(111),char(108),char(108),
char(105),char(100),char(101),char(114),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),
char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),
char(12),char(0),char(36),char(0),char(8),char(0),char(16),char(0),char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(84),char(0),char(-124),char(0),char(12),char(0),char(52),char(0),char(52),char(0),
char(20),char(0),char(64),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(32),char(0),char(28),char(0),char(60),char(0),char(56),char(0),
char(76),char(0),char(76),char(0),char(24),char(0),char(60),char(0),char(60),char(0),char(60),char(0),char(16),char(0),char(16),char(6),char(-24),char(1),char(72),char(3),
char(16),char(1),char(64),char(0),char(68),char(0),char(-96),char(0),char(88),char(0),char(-64),char(0),char(104),char(0),char(-8),char(1),char(-72),char(3),char(8),char(0),
char(52),char(0),char(52),char(0),char(0),char(0),char(68),char(0),char(84),char(0),char(-124),char(0),char(116),char(0),char(92),char(1),char(-36),char(0),char(-116),char(1),
char(124),char(1),char(-44),char(0),char(-4),char(0),char(-52),char(1),char(92),char(1),char(116),char(2),char(-124),char(2),char(-76),char(4),char(-52),char(0),char(108),char(1),
char(92),char(0),char(-116),char(0),char(16),char(0),char(100),char(0),char(20),char(0),char(36),char(0),char(100),char(0),char(92),char(0),char(104),char(0),char(-64),char(0),
char(92),char(1),char(104),char(0),char(-68),char(1),char(112),char(3),char(-56),char(1),char(-68),char(0),char(100),char(0),char(28),char(1),char(-12),char(1),char(0),char(0),
char(83),char(84),char(82),char(67),char(88),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),
char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),
char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(16),char(0),char(1),char(0),
char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),char(18),char(0),char(10),char(0),
char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(25),char(0),char(12),char(0),
char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(21),char(0),char(32),char(0),
char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(21),char(0),char(32),char(0),
char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(28),char(0),char(5),char(0),
char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(31),char(0),char(4),char(0),
char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(32),char(0),char(1),char(0),
char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(34),char(0),char(2),char(0),
char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),char(34),char(0),char(57),char(0),
char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(37),char(0),char(4),char(0),
char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(38),char(0),char(7),char(0),
char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),char(39),char(0),char(68),char(0),
char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(3),char(0),
char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),char(29),char(0),char(47),char(0),
char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),char(7),char(0),char(80),char(0),
char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),char(4),char(0),char(84),char(0),
char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),
char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),
char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(39),char(0),char(14),char(0),char(96),char(0),char(14),char(0),char(97),char(0),
char(14),char(0),char(98),char(0),char(14),char(0),char(99),char(0),char(14),char(0),char(100),char(0),char(14),char(0),char(101),char(0),char(14),char(0),char(102),char(0),
char(8),char(0),char(103),char(0),char(8),char(0),char(104),char(0),char(8),char(0),char(105),char(0),char(8),char(0),char(106),char(0),char(8),char(0),char(107),char(0),
char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),
char(8),char(0),char(118),char(0),char(8),char(0),char(119),char(0),char(8),char(0),char(120),char(0),char(8),char(0),char(121),char(0),char(8),char(0),char(122),char(0),
char(8),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(48),char(0),char(-124),char(0),char(48),char(0),char(-123),char(0),char(49),char(0),char(39),char(0),char(13),char(0),char(96),char(0),char(13),char(0),char(97),char(0),
char(13),char(0),char(98),char(0),char(13),char(0),char(99),char(0),char(13),char(0),char(100),char(0),char(13),char(0),char(101),char(0),char(13),char(0),char(102),char(0),
char(7),char(0),char(103),char(0),char(7),char(0),char(104),char(0),char(7),char(0),char(105),char(0),char(7),char(0),char(106),char(0),char(7),char(0),char(107),char(0),
char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),
char(7),char(0),char(118),char(0),char(7),char(0),char(119),char(0),char(7),char(0),char(120),char(0),char(7),char(0),char(121),char(0),char(7),char(0),char(122),char(0),
char(7),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(50),char(0),char(-124),char(0),char(50),char(0),char(-123),char(0),char(51),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),
char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(-122),char(0),char(52),char(0),char(5),char(0),char(29),char(0),char(47),char(0),
char(13),char(0),char(-121),char(0),char(14),char(0),char(-120),char(0),char(4),char(0),char(-119),char(0),char(0),char(0),char(-118),char(0),char(48),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(20),char(0),char(-114),char(0),
char(20),char(0),char(-113),char(0),char(14),char(0),char(-112),char(0),char(14),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),char(8),char(0),char(-125),char(0),
char(8),char(0),char(-109),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-107),char(0),char(8),char(0),char(-106),char(0),char(8),char(0),char(-105),char(0),
char(8),char(0),char(-104),char(0),char(8),char(0),char(-103),char(0),char(8),char(0),char(-102),char(0),char(8),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(50),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(-114),char(0),
char(19),char(0),char(-113),char(0),char(13),char(0),char(-112),char(0),char(13),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(7),char(0),char(-125),char(0),
char(7),char(0),char(-109),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-107),char(0),char(7),char(0),char(-106),char(0),char(7),char(0),char(-105),char(0),
char(7),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),char(7),char(0),char(-102),char(0),char(7),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(53),char(0),char(23),char(0),
char(8),char(0),char(-90),char(0),char(8),char(0),char(-89),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-88),char(0),char(8),char(0),char(-104),char(0),
char(8),char(0),char(-87),char(0),char(8),char(0),char(-86),char(0),char(8),char(0),char(-85),char(0),char(8),char(0),char(-84),char(0),char(8),char(0),char(-83),char(0),
char(8),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(-78),char(0),
char(8),char(0),char(-77),char(0),char(8),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),
char(4),char(0),char(-72),char(0),char(4),char(0),char(-71),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(22),char(0),char(7),char(0),char(-90),char(0),
char(7),char(0),char(-89),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-104),char(0),char(7),char(0),char(-87),char(0),
char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(7),char(0),char(-82),char(0),
char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-79),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
char(7),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(4),char(0),char(-72),char(0),
char(4),char(0),char(-71),char(0),char(55),char(0),char(2),char(0),char(53),char(0),char(-70),char(0),char(14),char(0),char(-69),char(0),char(56),char(0),char(2),char(0),
char(54),char(0),char(-70),char(0),char(13),char(0),char(-69),char(0),char(57),char(0),char(21),char(0),char(50),char(0),char(-68),char(0),char(17),char(0),char(-67),char(0),
char(13),char(0),char(-66),char(0),char(13),char(0),char(-65),char(0),char(13),char(0),char(-64),char(0),char(13),char(0),char(-63),char(0),char(13),char(0),char(-69),char(0),
char(13),char(0),char(-62),char(0),char(13),char(0),char(-61),char(0),char(13),char(0),char(-60),char(0),char(13),char(0),char(-59),char(0),char(7),char(0),char(-58),char(0),
char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
char(7),char(0),char(-52),char(0),char(7),char(0),char(-51),char(0),char(7),char(0),char(-50),char(0),char(4),char(0),char(-49),char(0),char(58),char(0),char(22),char(0),
char(48),char(0),char(-68),char(0),char(18),char(0),char(-67),char(0),char(14),char(0),char(-66),char(0),char(14),char(0),char(-65),char(0),char(14),char(0),char(-64),char(0),
char(14),char(0),char(-63),char(0),char(14),char(0),char(-69),char(0),char(14),char(0),char(-62),char(0),char(14),char(0),char(-61),char(0),char(14),char(0),char(-60),char(0),
char(14),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),char(8),char(0),char(-55),char(0),
char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),char(8),char(0),char(-52),char(0),char(8),char(0),char(-51),char(0),char(8),char(0),char(-50),char(0),
char(4),char(0),char(-49),char(0),char(0),char(0),char(37),char(0),char(59),char(0),char(2),char(0),char(4),char(0),char(-48),char(0),char(4),char(0),char(-47),char(0),
char(60),char(0),char(13),char(0),char(57),char(0),char(-46),char(0),char(57),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),
char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),
char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(61),char(0),char(13),char(0),
char(62),char(0),char(-46),char(0),char(62),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),
char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(63),char(0),char(14),char(0),char(58),char(0),char(-46),char(0),
char(58),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),
char(4),char(0),char(-42),char(0),char(8),char(0),char(-41),char(0),char(8),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),
char(8),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(0),char(0),char(-35),char(0),char(64),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),
char(13),char(0),char(-33),char(0),char(13),char(0),char(-32),char(0),char(65),char(0),char(3),char(0),char(63),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),
char(14),char(0),char(-32),char(0),char(66),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),char(14),char(0),char(-32),char(0),
char(67),char(0),char(13),char(0),char(61),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),
char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),
char(7),char(0),char(-23),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(68),char(0),char(13),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),
char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),
char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(69),char(0),char(14),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),
char(8),char(0),char(-26),char(0),char(8),char(0),char(-25),char(0),char(8),char(0),char(-24),char(0),char(8),char(0),char(-23),char(0),char(8),char(0),char(-22),char(0),
char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(0),char(0),char(-19),char(0),char(70),char(0),char(10),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(8),char(0),char(-18),char(0),char(8),char(0),char(-17),char(0),char(8),char(0),char(-16),char(0),
char(8),char(0),char(-22),char(0),char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(8),char(0),char(-89),char(0),char(71),char(0),char(11),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(7),char(0),char(-18),char(0),char(7),char(0),char(-17),char(0),
char(7),char(0),char(-16),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-89),char(0),
char(0),char(0),char(21),char(0),char(72),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),
char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(73),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),
char(14),char(0),char(-15),char(0),char(14),char(0),char(-14),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(74),char(0),char(5),char(0),char(72),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),
char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(75),char(0),char(5),char(0),char(73),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),
char(8),char(0),char(-7),char(0),char(8),char(0),char(-6),char(0),char(8),char(0),char(-5),char(0),char(76),char(0),char(41),char(0),char(61),char(0),char(-34),char(0),
char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-4),char(0),
char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),char(13),char(0),char(0),char(1),char(13),char(0),char(1),char(1),
char(13),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(13),char(0),char(5),char(1),char(13),char(0),char(6),char(1),
char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),
char(0),char(0),char(-19),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(13),char(0),char(12),char(1),char(13),char(0),char(13),char(1),
char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),char(13),char(0),char(17),char(1),char(13),char(0),char(18),char(1),
char(13),char(0),char(19),char(1),char(13),char(0),char(20),char(1),char(13),char(0),char(21),char(1),char(13),char(0),char(22),char(1),char(0),char(0),char(23),char(1),
char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),
char(77),char(0),char(41),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(14),char(0),char(-15),char(0),
char(14),char(0),char(-14),char(0),char(14),char(0),char(-4),char(0),char(14),char(0),char(-3),char(0),char(14),char(0),char(-2),char(0),char(14),char(0),char(-1),char(0),
char(14),char(0),char(0),char(1),char(14),char(0),char(1),char(1),char(14),char(0),char(2),char(1),char(14),char(0),char(3),char(1),char(14),char(0),char(4),char(1),
char(14),char(0),char(5),char(1),char(14),char(0),char(6),char(1),char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),
char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),char(0),char(0),char(-19),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),
char(14),char(0),char(12),char(1),char(14),char(0),char(13),char(1),char(14),char(0),char(14),char(1),char(14),char(0),char(15),char(1),char(14),char(0),char(16),char(1),
char(14),char(0),char(17),char(1),char(14),char(0),char(18),char(1),char(14),char(0),char(19),char(1),char(14),char(0),char(20),char(1),char(14),char(0),char(21),char(1),
char(14),char(0),char(22),char(1),char(0),char(0),char(23),char(1),char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),
char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),char(78),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),
char(19),char(0),char(-30),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),char(7),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(79),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),
char(20),char(0),char(-30),char(0),char(8),char(0),char(-15),char(0),char(8),char(0),char(-14),char(0),char(8),char(0),char(-13),char(0),char(8),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(80),char(0),char(5),char(0),char(60),char(0),char(-34),char(0),char(13),char(0),char(29),char(1),
char(13),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(0),char(0),char(37),char(0),char(81),char(0),char(4),char(0),char(63),char(0),char(-34),char(0),
char(14),char(0),char(29),char(1),char(14),char(0),char(30),char(1),char(8),char(0),char(31),char(1),char(82),char(0),char(4),char(0),char(7),char(0),char(32),char(1),
char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),char(4),char(0),char(79),char(0),char(83),char(0),char(10),char(0),char(82),char(0),char(35),char(1),
char(13),char(0),char(36),char(1),char(13),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(13),char(0),char(39),char(1),char(13),char(0),char(40),char(1),
char(7),char(0),char(-58),char(0),char(7),char(0),char(41),char(1),char(4),char(0),char(42),char(1),char(4),char(0),char(53),char(0),char(84),char(0),char(4),char(0),
char(82),char(0),char(35),char(1),char(4),char(0),char(43),char(1),char(7),char(0),char(44),char(1),char(4),char(0),char(45),char(1),char(85),char(0),char(4),char(0),
char(13),char(0),char(40),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(46),char(1),char(7),char(0),char(47),char(1),char(86),char(0),char(7),char(0),
char(13),char(0),char(48),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(49),char(1),char(7),char(0),char(50),char(1),char(7),char(0),char(51),char(1),
char(7),char(0),char(52),char(1),char(4),char(0),char(53),char(0),char(87),char(0),char(6),char(0),char(17),char(0),char(53),char(1),char(13),char(0),char(51),char(1),
char(13),char(0),char(54),char(1),char(62),char(0),char(55),char(1),char(4),char(0),char(56),char(1),char(7),char(0),char(52),char(1),char(88),char(0),char(26),char(0),
char(4),char(0),char(57),char(1),char(7),char(0),char(58),char(1),char(7),char(0),char(-89),char(0),char(7),char(0),char(59),char(1),char(7),char(0),char(60),char(1),
char(7),char(0),char(61),char(1),char(7),char(0),char(62),char(1),char(7),char(0),char(63),char(1),char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),
char(7),char(0),char(66),char(1),char(7),char(0),char(67),char(1),char(7),char(0),char(68),char(1),char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),
char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),char(7),char(0),char(74),char(1),char(7),char(0),char(75),char(1),
char(7),char(0),char(76),char(1),char(4),char(0),char(77),char(1),char(4),char(0),char(78),char(1),char(4),char(0),char(79),char(1),char(4),char(0),char(80),char(1),
char(4),char(0),char(-99),char(0),char(89),char(0),char(12),char(0),char(17),char(0),char(81),char(1),char(17),char(0),char(82),char(1),char(17),char(0),char(83),char(1),
char(13),char(0),char(84),char(1),char(13),char(0),char(85),char(1),char(7),char(0),char(86),char(1),char(4),char(0),char(87),char(1),char(4),char(0),char(88),char(1),
char(4),char(0),char(89),char(1),char(4),char(0),char(90),char(1),char(7),char(0),char(50),char(1),char(4),char(0),char(53),char(0),char(90),char(0),char(27),char(0),
char(19),char(0),char(91),char(1),char(17),char(0),char(92),char(1),char(17),char(0),char(93),char(1),char(13),char(0),char(84),char(1),char(13),char(0),char(94),char(1),
char(13),char(0),char(95),char(1),char(13),char(0),char(96),char(1),char(13),char(0),char(97),char(1),char(13),char(0),char(98),char(1),char(4),char(0),char(99),char(1),
char(7),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(103),char(1),char(7),char(0),char(104),char(1),
char(7),char(0),char(105),char(1),char(4),char(0),char(106),char(1),char(4),char(0),char(107),char(1),char(7),char(0),char(108),char(1),char(7),char(0),char(109),char(1),
char(7),char(0),char(110),char(1),char(7),char(0),char(111),char(1),char(7),char(0),char(112),char(1),char(7),char(0),char(113),char(1),char(4),char(0),char(114),char(1),
char(4),char(0),char(115),char(1),char(4),char(0),char(116),char(1),char(91),char(0),char(12),char(0),char(9),char(0),char(117),char(1),char(9),char(0),char(118),char(1),
char(13),char(0),char(119),char(1),char(7),char(0),char(120),char(1),char(7),char(0),char(-85),char(0),char(7),char(0),char(121),char(1),char(4),char(0),char(122),char(1),
char(13),char(0),char(123),char(1),char(4),char(0),char(124),char(1),char(4),char(0),char(125),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(53),char(0),
char(92),char(0),char(19),char(0),char(50),char(0),char(-68),char(0),char(89),char(0),char(127),char(1),char(82),char(0),char(-128),char(1),char(83),char(0),char(-127),char(1),
char(84),char(0),char(-126),char(1),char(85),char(0),char(-125),char(1),char(86),char(0),char(-124),char(1),char(87),char(0),char(-123),char(1),char(90),char(0),char(-122),char(1),
char(91),char(0),char(-121),char(1),char(4),char(0),char(-120),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(-119),char(1),char(4),char(0),char(-118),char(1),
char(4),char(0),char(-117),char(1),char(4),char(0),char(-116),char(1),char(4),char(0),char(-115),char(1),char(4),char(0),char(-114),char(1),char(88),char(0),char(-113),char(1),
char(93),char(0),char(28),char(0),char(16),char(0),char(-112),char(1),char(14),char(0),char(-111),char(1),char(14),char(0),char(-110),char(1),char(14),char(0),char(-109),char(1),
char(14),char(0),char(-108),char(1),char(14),char(0),char(-107),char(1),char(14),char(0),char(-106),char(1),char(14),char(0),char(-105),char(1),char(14),char(0),char(-104),char(1),
char(14),char(0),char(-103),char(1),char(8),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(-100),char(1),
char(4),char(0),char(-99),char(1),char(8),char(0),char(-98),char(1),char(8),char(0),char(-97),char(1),char(8),char(0),char(-96),char(1),char(8),char(0),char(-95),char(1),
char(8),char(0),char(-94),char(1),char(8),char(0),char(-93),char(1),char(8),char(0),char(-92),char(1),char(8),char(0),char(-91),char(1),char(8),char(0),char(-90),char(1),
char(0),char(0),char(-89),char(1),char(0),char(0),char(-88),char(1),char(48),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(94),char(0),char(28),char(0),
char(15),char(0),char(-112),char(1),char(13),char(0),char(-111),char(1),char(13),char(0),char(-110),char(1),char(13),char(0),char(-109),char(1),char(13),char(0),char(-108),char(1),
char(13),char(0),char(-107),char(1),char(13),char(0),char(-106),char(1),char(13),char(0),char(-105),char(1),char(13),char(0),char(-104),char(1),char(13),char(0),char(-103),char(1),
char(4),char(0),char(-100),char(1),char(7),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(7),char(0),char(-98),char(1),
char(7),char(0),char(-97),char(1),char(7),char(0),char(-96),char(1),char(4),char(0),char(-99),char(1),char(7),char(0),char(-95),char(1),char(7),char(0),char(-94),char(1),
char(7),char(0),char(-93),char(1),char(7),char(0),char(-92),char(1),char(7),char(0),char(-91),char(1),char(7),char(0),char(-90),char(1),char(0),char(0),char(-89),char(1),
char(0),char(0),char(-88),char(1),char(50),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(95),char(0),char(11),char(0),char(14),char(0),char(-85),char(1),
char(16),char(0),char(-84),char(1),char(14),char(0),char(-83),char(1),char(14),char(0),char(-82),char(1),char(14),char(0),char(-81),char(1),char(8),char(0),char(-80),char(1),
char(4),char(0),char(-119),char(1),char(0),char(0),char(37),char(0),char(0),char(0),char(-79),char(1),char(93),char(0),char(-126),char(1),char(48),char(0),char(-78),char(1),
char(96),char(0),char(10),char(0),char(13),char(0),char(-85),char(1),char(15),char(0),char(-84),char(1),char(13),char(0),char(-83),char(1),char(13),char(0),char(-82),char(1),
char(13),char(0),char(-81),char(1),char(7),char(0),char(-80),char(1),char(4),char(0),char(-119),char(1),char(0),char(0),char(-79),char(1),char(94),char(0),char(-126),char(1),
char(50),char(0),char(-78),char(1),char(97),char(0),char(4),char(0),char(50),char(0),char(-77),char(1),char(96),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),char(98),char(0),char(4),char(0),char(48),char(0),char(-77),char(1),char(95),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),};
int sBulletDNAlen= sizeof(sBulletDNAstr);





char sBulletDNAstr64[]= {
char(83),char(68),char(78),char(65),char(78),char(65),char(77),char(69),char(-74),char(1),char(0),char(0),char(109),char(95),char(115),char(105),char(122),char(101),char(0),char(109),
char(95),char(99),char(97),char(112),char(97),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(100),char(97),char(116),char(97),char(0),char(109),char(95),
char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(115),char(0),char(109),char(95),char(99),char(111),
char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(115),char(0),char(42),char(102),char(105),char(114),char(115),char(116),char(0),char(42),char(108),char(97),char(115),
char(116),char(0),char(109),char(95),char(102),char(108),char(111),char(97),char(116),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(108),char(91),char(51),
char(93),char(0),char(109),char(95),char(98),char(97),char(115),char(105),char(115),char(0),char(109),char(95),char(111),char(114),char(105),char(103),char(105),char(110),char(0),char(109),
char(95),char(114),char(111),char(111),char(116),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),
char(116),char(114),char(101),char(101),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),
char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(91),char(51),char(93),char(0),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(65),char(97),char(98),char(98),char(77),char(97),char(120),char(91),char(51),char(93),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),
char(105),char(110),char(79),char(114),char(103),char(0),char(109),char(95),char(97),char(97),char(98),char(98),char(77),char(97),char(120),char(79),char(114),char(103),char(0),char(109),
char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(115),char(117),char(98),char(80),char(97),
char(114),char(116),char(0),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),
char(95),char(112),char(97),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(101),char(115),char(99),char(97),char(112),char(101),char(73),char(110),char(100),char(101),
char(120),char(79),char(114),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(98),
char(118),char(104),char(65),char(97),char(98),char(98),char(77),char(105),char(110),char(0),char(109),char(95),char(98),char(118),char(104),char(65),char(97),char(98),char(98),char(77),
char(97),char(120),char(0),char(109),char(95),char(98),char(118),char(104),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),
char(0),char(109),char(95),char(99),char(117),char(114),char(78),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),char(117),char(115),
char(101),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(110),char(117),char(109),char(67),
char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(76),char(101),char(97),char(102),char(78),char(111),char(100),char(101),char(115),char(0),char(109),
char(95),char(110),char(117),char(109),char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),
char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(99),char(111),char(110),char(116),char(105),char(103),char(117),char(111),
char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),
char(122),char(101),char(100),char(67),char(111),char(110),char(116),char(105),char(103),char(117),char(111),char(117),char(115),char(78),char(111),char(100),char(101),char(115),char(80),char(116),
char(114),char(0),char(42),char(109),char(95),char(115),char(117),char(98),char(84),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(80),char(116),char(114),char(0),
char(109),char(95),char(116),char(114),char(97),char(118),char(101),char(114),char(115),char(97),char(108),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(110),char(117),
char(109),char(83),char(117),char(98),char(116),char(114),char(101),char(101),char(72),char(101),char(97),char(100),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(110),
char(97),char(109),char(101),char(0),char(109),char(95),char(115),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(112),char(97),
char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(83),char(99),char(97),
char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(108),char(97),char(110),char(101),char(78),char(111),char(114),char(109),char(97),char(108),char(0),char(109),
char(95),char(112),char(108),char(97),char(110),char(101),char(67),char(111),char(110),char(115),char(116),char(97),char(110),char(116),char(0),char(109),char(95),char(105),char(109),char(112),
char(108),char(105),char(99),char(105),char(116),char(83),char(104),char(97),char(112),char(101),char(68),char(105),char(109),char(101),char(110),char(115),char(105),char(111),char(110),char(115),
char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(109),
char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(0),char(109),char(95),char(112),char(111),char(115),char(0),char(109),char(95),char(114),char(97),char(100),
char(105),char(117),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),char(110),char(97),char(108),
char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(42),char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(80),char(111),
char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),char(108),char(111),char(99),
char(97),char(108),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(65),char(114),char(114),char(97),char(121),char(83),char(105),char(122),char(101),char(0),
char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(0),char(109),char(95),char(112),char(97),char(100),char(91),char(50),char(93),char(0),char(109),char(95),char(118),
char(97),char(108),char(117),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(112),char(97),char(100),char(0),char(42),char(109),char(95),char(118),char(101),
char(114),char(116),char(105),char(99),char(101),char(115),char(51),char(102),char(0),char(42),char(109),char(95),char(118),char(101),char(114),char(116),char(105),char(99),char(101),char(115),
char(51),char(100),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(51),char(50),char(0),char(42),char(109),char(95),char(51),
char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(42),char(109),char(95),char(51),char(105),char(110),char(100),char(105),char(99),char(101),
char(115),char(56),char(0),char(42),char(109),char(95),char(105),char(110),char(100),char(105),char(99),char(101),char(115),char(49),char(54),char(0),char(109),char(95),char(110),char(117),
char(109),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(101),char(114),char(116),
char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(115),char(80),char(116),char(114),
char(0),char(109),char(95),char(115),char(99),char(97),char(108),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(101),char(115),char(104),
char(80),char(97),char(114),char(116),char(115),char(0),char(109),char(95),char(109),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),
char(101),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(70),char(108),char(111),char(97),char(116),char(66),
char(118),char(104),char(0),char(42),char(109),char(95),char(113),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(68),char(111),char(117),char(98),char(108),
char(101),char(66),char(118),char(104),char(0),char(42),char(109),char(95),char(116),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),
char(77),char(97),char(112),char(0),char(109),char(95),char(112),char(97),char(100),char(51),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(114),char(105),char(109),
char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(116),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(0),char(109),
char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),char(97),char(112),char(101),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),
char(105),char(108),char(100),char(77),char(97),char(114),char(103),char(105),char(110),char(0),char(42),char(109),char(95),char(99),char(104),char(105),char(108),char(100),char(83),char(104),
char(97),char(112),char(101),char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(104),char(105),char(108),char(100),char(83),char(104),char(97),
char(112),char(101),char(115),char(0),char(109),char(95),char(117),char(112),char(65),char(120),char(105),char(115),char(0),char(109),char(95),char(117),char(112),char(73),char(110),char(100),
char(101),char(120),char(0),char(109),char(95),char(102),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(48),char(86),
char(49),char(65),char(110),char(103),char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(49),char(86),char(50),char(65),char(110),char(103),
char(108),char(101),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(86),char(50),char(86),char(48),char(65),char(110),char(103),char(108),char(101),char(0),char(42),
char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(110),char(101),
char(120),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),char(118),char(97),char(108),char(117),char(101),char(65),char(114),char(114),char(97),char(121),char(80),
char(116),char(114),char(0),char(42),char(109),char(95),char(107),char(101),char(121),char(65),char(114),char(114),char(97),char(121),char(80),char(116),char(114),char(0),char(109),char(95),
char(99),char(111),char(110),char(118),char(101),char(120),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(112),char(108),char(97),char(110),
char(97),char(114),char(69),char(112),char(115),char(105),char(108),char(111),char(110),char(0),char(109),char(95),char(101),char(113),char(117),char(97),char(108),char(86),char(101),char(114),
char(116),char(101),char(120),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(101),char(100),char(103),char(101),char(68),
char(105),char(115),char(116),char(97),char(110),char(99),char(101),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(122),
char(101),char(114),char(111),char(65),char(114),char(101),char(97),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(110),
char(101),char(120),char(116),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(104),char(97),char(115),char(104),char(84),char(97),char(98),char(108),char(101),char(83),
char(105),char(122),char(101),char(0),char(109),char(95),char(110),char(117),char(109),char(86),char(97),char(108),char(117),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(75),char(101),char(121),char(115),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(111),
char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(76),char(111),char(99),char(97),char(108),char(80),char(111),char(105),char(110),char(116),char(66),char(91),char(52),char(93),char(0),
char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),
char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(65),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(78),char(111),char(114),char(109),
char(97),char(108),char(87),char(111),char(114),char(108),char(100),char(79),char(110),char(66),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),
char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(68),char(105),char(114),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),
char(101),char(76),char(97),char(116),char(101),char(114),char(97),char(108),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(68),char(105),char(114),char(50),
char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(68),char(105),char(115),char(116),
char(97),char(110),char(99),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),char(114),char(101),char(118),char(82),char(72),char(83),char(91),char(52),char(93),
char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),
char(100),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(111),char(108),char(108),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(83),char(112),char(105),char(110),char(110),char(105),char(110),char(103),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),
char(105),char(111),char(110),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(80),
char(97),char(114),char(116),char(73),char(100),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(80),char(97),char(114),char(116),char(73),char(100),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),
char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(73),char(110),char(100),char(101),char(120),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),
char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(111),char(105),char(110),
char(116),char(70),char(108),char(97),char(103),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),
char(104),char(101),char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),
char(114),char(97),char(108),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),
char(65),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(76),char(97),char(116),char(101),char(114),char(97),
char(108),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),char(110),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),
char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(77),char(111),char(116),char(105),char(111),
char(110),char(50),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(67),char(70),char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),
char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(49),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),
char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(69),char(82),char(80),char(91),char(52),char(93),char(0),char(109),
char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(67),char(111),char(109),char(98),char(105),char(110),char(101),char(100),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),char(95),
char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(67),char(70),
char(77),char(91),char(52),char(93),char(0),char(109),char(95),char(112),char(111),char(105),char(110),char(116),char(67),char(97),char(99),char(104),char(101),char(76),char(105),char(102),
char(101),char(84),char(105),char(109),char(101),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(97),char(99),char(104),char(101),char(100),
char(80),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),
char(65),char(0),char(109),char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(66),char(0),char(109),char(95),char(105),
char(110),char(100),char(101),char(120),char(49),char(97),char(0),char(109),char(95),char(111),char(98),char(106),char(101),char(99),char(116),char(84),char(121),char(112),char(101),char(0),
char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(66),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),char(99),char(116),char(80),char(114),char(111),char(99),
char(101),char(115),char(115),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(42),char(109),char(95),char(98),
char(111),char(100),char(121),char(48),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(49),char(0),char(109),char(95),char(103),char(105),char(109),char(112),
char(97),char(99),char(116),char(83),char(117),char(98),char(84),char(121),char(112),char(101),char(0),char(42),char(109),char(95),char(117),char(110),char(115),char(99),char(97),char(108),
char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(70),char(108),char(111),char(97),char(116),char(80),char(116),char(114),char(0),char(42),char(109),char(95),
char(117),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),char(110),char(116),char(115),char(68),char(111),char(117),char(98),char(108),char(101),
char(80),char(116),char(114),char(0),char(109),char(95),char(110),char(117),char(109),char(85),char(110),char(115),char(99),char(97),char(108),char(101),char(100),char(80),char(111),char(105),
char(110),char(116),char(115),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(51),char(91),char(52),char(93),char(0),char(42),char(109),
char(95),char(98),char(114),char(111),char(97),char(100),char(112),char(104),char(97),char(115),char(101),char(72),char(97),char(110),char(100),char(108),char(101),char(0),char(42),char(109),
char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(42),char(109),char(95),char(114),
char(111),char(111),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(0),char(109),char(95),
char(119),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(87),char(111),char(114),char(108),char(100),char(84),char(114),char(97),char(110),char(115),
char(102),char(111),char(114),char(109),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),
char(76),char(105),char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(105),char(110),char(116),
char(101),char(114),char(112),char(111),char(108),char(97),char(116),char(105),char(111),char(110),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),char(70),
char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(100),char(101),char(97),char(99),char(116),char(105),char(118),char(97),char(116),char(105),
char(111),char(110),char(84),char(105),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),
char(114),char(111),char(108),char(108),char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(99),char(116),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(99),char(111),char(110),char(116),char(97),
char(99),char(116),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(116),
char(117),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(104),char(105),char(116),char(70),char(114),char(97),char(99),char(116),char(105),char(111),char(110),char(0),
char(109),char(95),char(99),char(99),char(100),char(83),char(119),char(101),char(112),char(116),char(83),char(112),char(104),char(101),char(114),char(101),char(82),char(97),char(100),char(105),
char(117),char(115),char(0),char(109),char(95),char(99),char(99),char(100),char(77),char(111),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),
char(111),char(108),char(100),char(0),char(109),char(95),char(104),char(97),char(115),char(65),char(110),char(105),char(115),char(111),char(116),char(114),char(111),char(112),char(105),char(99),
char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(108),char(97),char(103),char(115),char(0),char(109),char(95),char(105),char(115),char(108),char(97),char(110),char(100),char(84),char(97),char(103),char(49),char(0),char(109),
char(95),char(99),char(111),char(109),char(112),char(97),char(110),char(105),char(111),char(110),char(73),char(100),char(0),char(109),char(95),char(97),char(99),char(116),char(105),char(118),
char(97),char(116),char(105),char(111),char(110),char(83),char(116),char(97),char(116),char(101),char(49),char(0),char(109),char(95),char(105),char(110),char(116),char(101),char(114),char(110),
char(97),char(108),char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(99),char(104),char(101),char(99),char(107),char(67),char(111),char(108),char(108),char(105),char(100),
char(101),char(87),char(105),char(116),char(104),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(70),char(105),char(108),
char(116),char(101),char(114),char(71),char(114),char(111),char(117),char(112),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),
char(70),char(105),char(108),char(116),char(101),char(114),char(77),char(97),char(115),char(107),char(0),char(109),char(95),char(117),char(110),char(105),char(113),char(117),char(101),char(73),
char(100),char(0),char(109),char(95),char(116),char(97),char(117),char(0),char(109),char(95),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(116),char(105),char(109),char(101),char(83),char(116),char(101),char(112),char(0),char(109),char(95),char(109),char(97),char(120),char(69),char(114),char(114),char(111),char(114),char(82),
char(101),char(100),char(117),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(115),char(111),char(114),char(0),char(109),char(95),char(101),char(114),char(112),
char(0),char(109),char(95),char(101),char(114),char(112),char(50),char(0),char(109),char(95),char(103),char(108),char(111),char(98),char(97),char(108),char(67),char(102),char(109),char(0),
char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(80),char(101),char(110),char(101),char(116),char(114),
char(97),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(115),char(112),char(108),
char(105),char(116),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(117),char(114),char(110),char(69),char(114),char(112),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(83),char(108),char(111),char(112),char(0),char(109),char(95),char(119),char(97),char(114),char(109),char(115),char(116),char(97),char(114),
char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(97),char(114),char(116),char(105),char(99),char(117),char(108),
char(97),char(116),char(101),char(100),char(87),char(97),char(114),char(109),char(115),char(116),char(97),char(114),char(116),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(109),char(97),char(120),char(71),char(121),char(114),char(111),char(115),char(99),char(111),char(112),char(105),char(99),char(70),char(111),
char(114),char(99),char(101),char(0),char(109),char(95),char(115),char(105),char(110),char(103),char(108),char(101),char(65),char(120),char(105),char(115),char(82),char(111),char(108),char(108),
char(105),char(110),char(103),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),
char(0),char(109),char(95),char(110),char(117),char(109),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(115),
char(111),char(108),char(118),char(101),char(114),char(77),char(111),char(100),char(101),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(105),char(110),char(103),char(67),
char(111),char(110),char(116),char(97),char(99),char(116),char(82),char(101),char(115),char(116),char(105),char(116),char(117),char(116),char(105),char(111),char(110),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(109),char(105),char(110),char(105),char(109),char(117),char(109),char(83),char(111),char(108),char(118),
char(101),char(114),char(66),char(97),char(116),char(99),char(104),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(0),
char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),
char(114),char(116),char(105),char(97),char(84),char(101),char(110),char(115),char(111),char(114),char(87),char(111),char(114),char(108),char(100),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),
char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(70),char(97),char(99),char(116),char(111),
char(114),char(0),char(109),char(95),char(103),char(114),char(97),char(118),char(105),char(116),char(121),char(95),char(97),char(99),char(99),char(101),char(108),char(101),char(114),char(97),
char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(105),char(110),char(118),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(76),char(111),char(99),
char(97),char(108),char(0),char(109),char(95),char(116),char(111),char(116),char(97),char(108),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(116),char(111),
char(116),char(97),char(108),char(84),char(111),char(114),char(113),char(117),char(101),char(0),char(109),char(95),char(105),char(110),char(118),char(101),char(114),char(115),char(101),char(77),
char(97),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),
char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(97),
char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),
char(111),char(114),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(76),char(105),char(110),char(101),char(97),
char(114),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),
char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),
char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(83),char(113),char(114),char(0),
char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(65),char(110),char(103),char(117),char(108),char(97),char(114),char(68),
char(97),char(109),char(112),char(105),char(110),char(103),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),
char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),
char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(108),char(101),char(101),char(112),char(105),char(110),char(103),char(84),char(104),char(114),char(101),
char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(97),char(100),char(100),char(105),char(116),char(105),char(111),char(110),char(97),char(108),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(82),char(111),char(119),char(115),char(0),char(110),char(117),char(98),char(0),char(42),char(109),char(95),char(114),char(98),char(65),char(0),char(42),char(109),char(95),
char(114),char(98),char(66),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(84),char(121),char(112),char(101),char(0),char(109),char(95),char(117),char(115),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(73),char(100),char(0),char(109),char(95),char(110),char(101),char(101),char(100),char(115),char(70),char(101),char(101),char(100),char(98),char(97),char(99),char(107),char(0),
char(109),char(95),char(97),char(112),char(112),char(108),char(105),char(101),char(100),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(100),
char(98),char(103),char(68),char(114),char(97),char(119),char(83),char(105),char(122),char(101),char(0),char(109),char(95),char(100),char(105),char(115),char(97),char(98),char(108),char(101),
char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(115),char(66),char(101),char(116),char(119),char(101),char(101),char(110),char(76),char(105),char(110),
char(107),char(101),char(100),char(66),char(111),char(100),char(105),char(101),char(115),char(0),char(109),char(95),char(111),char(118),char(101),char(114),char(114),char(105),char(100),char(101),
char(78),char(117),char(109),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),
char(109),char(95),char(98),char(114),char(101),char(97),char(107),char(105),char(110),char(103),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(84),char(104),char(114),
char(101),char(115),char(104),char(111),char(108),char(100),char(0),char(109),char(95),char(105),char(115),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(0),char(112),
char(97),char(100),char(100),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(116),char(121),char(112),char(101),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),
char(65),char(0),char(109),char(95),char(112),char(105),char(118),char(111),char(116),char(73),char(110),char(66),char(0),char(109),char(95),char(114),char(98),char(65),char(70),char(114),
char(97),char(109),char(101),char(0),char(109),char(95),char(114),char(98),char(66),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(117),char(115),char(101),
char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),char(65),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(79),char(110),char(108),char(121),char(0),char(109),char(95),char(101),char(110),char(97),char(98),char(108),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(0),char(109),char(95),char(109),char(111),char(116),char(111),char(114),char(84),char(97),
char(114),char(103),char(101),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(109),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(108),char(111),char(119),char(101),char(114),char(76),char(105),
char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),
char(105),char(109),char(105),char(116),char(83),char(111),char(102),char(116),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(98),char(105),char(97),char(115),char(70),
char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(114),char(101),char(108),char(97),char(120),char(97),char(116),char(105),char(111),char(110),char(70),char(97),
char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(112),char(97),char(100),char(100),char(105),char(110),char(103),char(49),char(91),char(52),char(93),char(0),char(109),
char(95),char(115),char(119),char(105),char(110),char(103),char(83),char(112),char(97),char(110),char(49),char(0),char(109),char(95),char(115),char(119),char(105),char(110),char(103),char(83),
char(112),char(97),char(110),char(50),char(0),char(109),char(95),char(116),char(119),char(105),char(115),char(116),char(83),char(112),char(97),char(110),char(0),char(109),char(95),char(108),
char(105),char(110),char(101),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),char(117),char(115),char(101),
char(76),char(105),char(110),char(101),char(97),char(114),char(82),char(101),char(102),char(101),char(114),char(101),char(110),char(99),char(101),char(70),char(114),char(97),char(109),char(101),
char(65),char(0),char(109),char(95),char(117),char(115),char(101),char(79),char(102),char(102),char(115),char(101),char(116),char(70),char(111),char(114),char(67),char(111),char(110),char(115),
char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(54),char(100),char(111),char(102),char(68),char(97),
char(116),char(97),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(69),char(110),char(97),char(98),char(108),char(101),char(100),char(91),char(54),
char(93),char(0),char(109),char(95),char(101),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),
char(115),char(91),char(54),char(93),char(0),char(109),char(95),char(115),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),
char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),
char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),
char(101),char(97),char(114),char(83),char(116),char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),
char(111),char(116),char(111),char(114),char(69),char(82),char(80),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(111),char(116),char(111),
char(114),char(67),char(70),char(77),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),
char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(77),char(97),char(120),char(77),
char(111),char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(108),char(105),char(110),char(101),
char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(105),
char(110),char(101),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),char(105),char(110),char(116),
char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),char(111),char(116),char(111),char(114),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(101),char(114),char(118),char(111),char(77),char(111),char(116),
char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),
char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),
char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(66),char(111),char(117),char(110),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),
char(114),char(83),char(116),char(111),char(112),char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),
char(111),char(112),char(67),char(70),char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),
char(69),char(82),char(80),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(111),char(116),char(111),char(114),char(67),char(70),
char(77),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(84),char(97),char(114),char(103),char(101),char(116),char(86),char(101),char(108),
char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(77),char(97),char(120),char(77),char(111),
char(116),char(111),char(114),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),
char(114),char(118),char(111),char(84),char(97),char(114),char(103),char(101),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),
char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),
char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),
char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(113),char(117),char(105),char(108),char(105),char(98),char(114),char(105),char(117),char(109),char(80),char(111),
char(105),char(110),char(116),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(69),char(110),char(97),char(98),char(108),char(101),char(77),
char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(101),char(114),
char(118),char(111),char(77),char(111),char(116),char(111),char(114),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(69),char(110),char(97),char(98),char(108),char(101),char(83),char(112),char(114),char(105),char(110),char(103),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),
char(103),char(117),char(108),char(97),char(114),char(83),char(112),char(114),char(105),char(110),char(103),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(76),char(105),char(109),char(105),char(116),char(101),char(100),char(91),char(52),char(93),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),
char(83),char(112),char(114),char(105),char(110),char(103),char(68),char(97),char(109),char(112),char(105),char(110),char(103),char(76),char(105),char(109),char(105),char(116),char(101),char(100),
char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(111),char(116),char(97),char(116),char(101),char(79),char(114),char(100),char(101),char(114),char(0),char(109),char(95),
char(97),char(120),char(105),char(115),char(73),char(110),char(65),char(0),char(109),char(95),char(97),char(120),char(105),char(115),char(73),char(110),char(66),char(0),char(109),char(95),
char(114),char(97),char(116),char(105),char(111),char(0),char(109),char(95),char(108),char(105),char(110),char(101),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),
char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),char(103),char(117),char(108),char(97),char(114),char(83),char(116),char(105),char(102),char(102),char(110),char(101),
char(115),char(115),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(83),char(116),char(105),char(102),char(102),char(110),char(101),char(115),char(115),
char(0),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(0),char(109),char(95),char(112),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(114),char(101),char(118),char(105),char(111),char(117),char(115),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(97),char(99),char(99),char(117),
char(109),char(117),char(108),char(97),char(116),char(101),char(100),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(110),char(111),char(114),char(109),char(97),
char(108),char(0),char(109),char(95),char(97),char(114),char(101),char(97),char(0),char(109),char(95),char(97),char(116),char(116),char(97),char(99),char(104),char(0),char(109),char(95),
char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(114),char(101),char(115),
char(116),char(76),char(101),char(110),char(103),char(116),char(104),char(0),char(109),char(95),char(98),char(98),char(101),char(110),char(100),char(105),char(110),char(103),char(0),char(109),
char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(51),char(93),char(0),char(109),char(95),char(114),char(101),
char(115),char(116),char(65),char(114),char(101),char(97),char(0),char(109),char(95),char(99),char(48),char(91),char(52),char(93),char(0),char(109),char(95),char(110),char(111),char(100),
char(101),char(73),char(110),char(100),char(105),char(99),char(101),char(115),char(91),char(52),char(93),char(0),char(109),char(95),char(114),char(101),char(115),char(116),char(86),char(111),
char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(99),char(49),char(0),char(109),char(95),char(99),char(50),char(0),char(109),char(95),char(99),char(48),char(0),
char(109),char(95),char(108),char(111),char(99),char(97),char(108),char(70),char(114),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(114),char(105),char(103),char(105),
char(100),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),char(100),char(101),char(120),char(0),char(109),char(95),
char(97),char(101),char(114),char(111),char(77),char(111),char(100),char(101),char(108),char(0),char(109),char(95),char(98),char(97),char(117),char(109),char(103),char(97),char(114),char(116),
char(101),char(0),char(109),char(95),char(100),char(114),char(97),char(103),char(0),char(109),char(95),char(108),char(105),char(102),char(116),char(0),char(109),char(95),char(112),char(114),
char(101),char(115),char(115),char(117),char(114),char(101),char(0),char(109),char(95),char(118),char(111),char(108),char(117),char(109),char(101),char(0),char(109),char(95),char(100),char(121),
char(110),char(97),char(109),char(105),char(99),char(70),char(114),char(105),char(99),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(112),char(111),char(115),char(101),
char(77),char(97),char(116),char(99),char(104),char(0),char(109),char(95),char(114),char(105),char(103),char(105),char(100),char(67),char(111),char(110),char(116),char(97),char(99),char(116),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(107),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(111),
char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),
char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(97),char(110),
char(99),char(104),char(111),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(82),
char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),
char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),char(108),char(117),char(115),char(116),char(101),char(114),
char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(72),char(97),char(114),char(100),char(110),char(101),char(115),char(115),char(0),char(109),char(95),char(115),char(111),char(102),
char(116),char(82),char(105),char(103),char(105),char(100),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),
char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(115),char(111),char(102),char(116),char(75),char(105),char(110),char(101),char(116),char(105),char(99),char(67),
char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),
char(95),char(115),char(111),char(102),char(116),char(83),char(111),char(102),char(116),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(109),char(112),char(117),
char(108),char(115),char(101),char(83),char(112),char(108),char(105),char(116),char(0),char(109),char(95),char(109),char(97),char(120),char(86),char(111),char(108),char(117),char(109),char(101),
char(0),char(109),char(95),char(116),char(105),char(109),char(101),char(83),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(118),char(101),char(108),char(111),char(99),
char(105),char(116),char(121),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(112),char(111),char(115),char(105),
char(116),char(105),char(111),char(110),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(100),char(114),char(105),
char(102),char(116),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),
char(101),char(114),char(73),char(116),char(101),char(114),char(97),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),char(114),char(111),char(116),char(0),char(109),
char(95),char(115),char(99),char(97),char(108),char(101),char(0),char(109),char(95),char(97),char(113),char(113),char(0),char(109),char(95),char(99),char(111),char(109),char(0),char(42),
char(109),char(95),char(112),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(42),char(109),char(95),char(119),char(101),char(105),char(103),char(104),
char(116),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(80),char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(87),char(101),char(105),char(103),char(116),char(115),char(0),char(109),char(95),char(98),char(118),char(111),char(108),char(117),char(109),char(101),char(0),
char(109),char(95),char(98),char(102),char(114),char(97),char(109),char(101),char(0),char(109),char(95),char(102),char(114),char(97),char(109),char(101),char(120),char(102),char(111),char(114),
char(109),char(0),char(109),char(95),char(108),char(111),char(99),char(105),char(105),char(0),char(109),char(95),char(105),char(110),char(118),char(119),char(105),char(0),char(109),char(95),
char(118),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(100),char(105),char(109),char(112),char(117),
char(108),char(115),char(101),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(108),char(118),char(0),char(109),char(95),char(97),char(118),char(0),char(42),char(109),
char(95),char(102),char(114),char(97),char(109),char(101),char(114),char(101),char(102),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(73),char(110),
char(100),char(105),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(109),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(117),
char(109),char(70),char(114),char(97),char(109),char(101),char(82),char(101),char(102),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(78),char(111),char(100),char(101),
char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(77),char(97),char(115),char(115),char(101),char(115),char(0),char(109),char(95),char(105),char(100),char(109),char(97),
char(115),char(115),char(0),char(109),char(95),char(105),char(109),char(97),char(115),char(115),char(0),char(109),char(95),char(110),char(118),char(105),char(109),char(112),char(117),char(108),
char(115),char(101),char(115),char(0),char(109),char(95),char(110),char(100),char(105),char(109),char(112),char(117),char(108),char(115),char(101),char(115),char(0),char(109),char(95),char(110),
char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(108),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),
char(95),char(97),char(100),char(97),char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(109),char(97),char(116),char(99),char(104),char(105),char(110),char(103),
char(0),char(109),char(95),char(109),char(97),char(120),char(83),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(73),
char(109),char(112),char(117),char(108),char(115),char(101),char(0),char(109),char(95),char(115),char(101),char(108),char(102),char(67),char(111),char(108),char(108),char(105),char(115),char(105),
char(111),char(110),char(73),char(109),char(112),char(117),char(108),char(115),char(101),char(70),char(97),char(99),char(116),char(111),char(114),char(0),char(109),char(95),char(99),char(111),
char(110),char(116),char(97),char(105),char(110),char(115),char(65),char(110),char(99),char(104),char(111),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(108),char(105),
char(100),char(101),char(0),char(109),char(95),char(99),char(108),char(117),char(115),char(116),char(101),char(114),char(73),char(110),char(100),char(101),char(120),char(0),char(42),char(109),
char(95),char(98),char(111),char(100),char(121),char(65),char(0),char(42),char(109),char(95),char(98),char(111),char(100),char(121),char(66),char(0),char(109),char(95),char(114),char(101),
char(102),char(115),char(91),char(50),char(93),char(0),char(109),char(95),char(99),char(102),char(109),char(0),char(109),char(95),char(115),char(112),char(108),char(105),char(116),char(0),
char(109),char(95),char(100),char(101),char(108),char(101),char(116),char(101),char(0),char(109),char(95),char(114),char(101),char(108),char(80),char(111),char(115),char(105),char(116),char(105),
char(111),char(110),char(91),char(50),char(93),char(0),char(109),char(95),char(98),char(111),char(100),char(121),char(65),char(116),char(121),char(112),char(101),char(0),char(109),char(95),
char(98),char(111),char(100),char(121),char(66),char(116),char(121),char(112),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(84),char(121),char(112),
char(101),char(0),char(42),char(109),char(95),char(112),char(111),char(115),char(101),char(0),char(42),char(42),char(109),char(95),char(109),char(97),char(116),char(101),char(114),char(105),
char(97),char(108),char(115),char(0),char(42),char(109),char(95),char(110),char(111),char(100),char(101),char(115),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(115),char(0),char(42),char(109),char(95),char(102),char(97),char(99),char(101),char(115),char(0),char(42),char(109),char(95),char(116),char(101),char(116),char(114),char(97),char(104),
char(101),char(100),char(114),char(97),char(0),char(42),char(109),char(95),char(97),char(110),char(99),char(104),char(111),char(114),char(115),char(0),char(42),char(109),char(95),char(99),
char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(77),char(97),char(116),char(101),char(114),char(105),char(97),char(108),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(76),char(105),
char(110),char(107),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(70),char(97),char(99),char(101),char(115),char(0),char(109),char(95),char(110),char(117),char(109),
char(84),char(101),char(116),char(114),char(97),char(104),char(101),char(100),char(114),char(97),char(0),char(109),char(95),char(110),char(117),char(109),char(65),char(110),char(99),char(104),
char(111),char(114),char(115),char(0),char(109),char(95),char(110),char(117),char(109),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(115),char(0),char(109),char(95),
char(110),char(117),char(109),char(74),char(111),char(105),char(110),char(116),char(115),char(0),char(109),char(95),char(99),char(111),char(110),char(102),char(105),char(103),char(0),char(109),
char(95),char(122),char(101),char(114),char(111),char(82),char(111),char(116),char(80),char(97),char(114),char(101),char(110),char(116),char(84),char(111),char(84),char(104),char(105),char(115),
char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(67),char(111),char(109),char(84),char(111),char(84),char(104),char(105),char(115),char(80),char(105),
char(118),char(111),char(116),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(116),char(104),char(105),char(115),char(80),char(105),char(118),char(111),
char(116),char(84),char(111),char(84),char(104),char(105),char(115),char(67),char(111),char(109),char(79),char(102),char(102),char(115),char(101),char(116),char(0),char(109),char(95),char(106),
char(111),char(105),char(110),char(116),char(65),char(120),char(105),char(115),char(84),char(111),char(112),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),
char(110),char(116),char(65),char(120),char(105),char(115),char(66),char(111),char(116),char(116),char(111),char(109),char(91),char(54),char(93),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),
char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),
char(70),char(114),char(97),char(109),char(101),char(84),char(111),char(116),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),
char(111),char(109),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),char(99),char(86),char(101),char(108),char(111),
char(99),char(105),char(116),char(121),char(84),char(111),char(112),char(0),char(109),char(95),char(97),char(98),char(115),char(70),char(114),char(97),char(109),char(101),char(76),char(111),
char(99),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(66),char(111),char(116),char(116),char(111),char(109),char(0),char(109),char(95),char(108),char(105),
char(110),char(107),char(77),char(97),char(115),char(115),char(0),char(109),char(95),char(112),char(97),char(114),char(101),char(110),char(116),char(73),char(110),char(100),char(101),char(120),
char(0),char(109),char(95),char(100),char(111),char(102),char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(112),char(111),char(115),char(86),char(97),char(114),
char(67),char(111),char(117),char(110),char(116),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(80),char(111),char(115),char(91),char(55),char(93),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(86),char(101),char(108),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(84),char(111),char(114),char(113),char(117),char(101),char(91),char(54),char(93),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(68),char(97),
char(109),char(112),char(105),char(110),char(103),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(70),char(114),char(105),char(99),char(116),char(105),char(111),
char(110),char(0),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(76),char(111),char(119),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),
char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(85),char(112),char(112),char(101),char(114),char(76),char(105),char(109),char(105),char(116),char(0),char(109),char(95),
char(106),char(111),char(105),char(110),char(116),char(77),char(97),char(120),char(70),char(111),char(114),char(99),char(101),char(0),char(109),char(95),char(106),char(111),char(105),char(110),
char(116),char(77),char(97),char(120),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(42),char(109),char(95),char(108),char(105),char(110),char(107),
char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(106),char(111),char(105),char(110),char(116),char(78),char(97),char(109),char(101),char(0),char(42),char(109),
char(95),char(108),char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(42),char(109),char(95),char(112),char(97),char(100),
char(100),char(105),char(110),char(103),char(80),char(116),char(114),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(80),
char(111),char(115),char(105),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(87),char(111),char(114),char(108),char(100),char(79),
char(114),char(105),char(101),char(110),char(116),char(97),char(116),char(105),char(111),char(110),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(76),char(105),char(110),
char(101),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(65),char(110),
char(103),char(117),char(108),char(97),char(114),char(86),char(101),char(108),char(111),char(99),char(105),char(116),char(121),char(0),char(109),char(95),char(98),char(97),char(115),char(101),
char(73),char(110),char(101),char(114),char(116),char(105),char(97),char(0),char(109),char(95),char(98),char(97),char(115),char(101),char(77),char(97),char(115),char(115),char(0),char(42),
char(109),char(95),char(98),char(97),char(115),char(101),char(78),char(97),char(109),char(101),char(0),char(42),char(109),char(95),char(98),char(97),char(115),char(101),char(67),char(111),
char(108),char(108),char(105),char(100),char(101),char(114),char(0),char(109),char(95),char(99),char(111),char(108),char(79),char(98),char(106),char(68),char(97),char(116),char(97),char(0),
char(42),char(109),char(95),char(109),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(0),char(109),char(95),char(108),char(105),char(110),char(107),char(0),
char(84),char(89),char(80),char(69),char(99),char(0),char(0),char(0),char(99),char(104),char(97),char(114),char(0),char(117),char(99),char(104),char(97),char(114),char(0),char(115),
char(104),char(111),char(114),char(116),char(0),char(117),char(115),char(104),char(111),char(114),char(116),char(0),char(105),char(110),char(116),char(0),char(108),char(111),char(110),char(103),
char(0),char(117),char(108),char(111),char(110),char(103),char(0),char(102),char(108),char(111),char(97),char(116),char(0),char(100),char(111),char(117),char(98),char(108),char(101),char(0),
char(118),char(111),char(105),char(100),char(0),char(80),char(111),char(105),char(110),char(116),char(101),char(114),char(65),char(114),char(114),char(97),char(121),char(0),char(98),char(116),
char(80),char(104),char(121),char(115),char(105),char(99),char(115),char(83),char(121),char(115),char(116),char(101),char(109),char(0),char(76),char(105),char(115),char(116),char(66),char(97),
char(115),char(101),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(86),char(101),char(99),char(116),char(111),char(114),char(51),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(70),char(108),char(111),char(97),char(116),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(116),char(101),char(114),char(110),char(105),char(111),char(110),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(97),char(116),char(114),char(105),char(120),char(51),char(120),char(51),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),char(114),
char(109),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(97),char(110),char(115),char(102),char(111),
char(114),char(109),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(66),char(118),char(104),char(83),char(117),
char(98),char(116),char(114),char(101),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),
char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(79),char(112),char(116),char(105),char(109),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),char(116),char(105),char(122),
char(101),char(100),char(66),char(118),char(104),char(78),char(111),char(100),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(81),char(117),char(97),char(110),
char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(81),char(117),char(97),char(110),char(116),char(105),char(122),char(101),char(100),char(66),char(118),char(104),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),
char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(83),char(104),char(97),char(112),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),char(97),char(116),char(105),char(99),char(80),char(108),char(97),char(110),char(101),char(83),char(104),char(97),
char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(118),char(101),char(120),char(73),char(110),char(116),char(101),char(114),
char(110),char(97),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(115),char(105),char(116),
char(105),char(111),char(110),char(65),char(110),char(100),char(82),char(97),char(100),char(105),char(117),char(115),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),
char(83),char(112),char(104),char(101),char(114),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(104),char(111),char(114),char(116),char(73),char(110),
char(116),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(104),char(97),char(114),char(73),char(110),char(100),char(101),char(120),char(84),char(114),char(105),char(112),char(108),char(101),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(101),char(115),char(104),char(80),char(97),char(114),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(116),
char(114),char(105),char(100),char(105),char(110),char(103),char(77),char(101),char(115),char(104),char(73),char(110),char(116),char(101),char(114),char(102),char(97),char(99),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),
char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),
char(102),char(111),char(77),char(97),char(112),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(99),char(97),char(108),char(101),char(100),char(84),char(114),
char(105),char(97),char(110),char(103),char(108),char(101),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),char(67),char(104),char(105),char(108),char(100),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(109),char(112),char(111),char(117),char(110),char(100),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(121),char(108),char(105),char(110),char(100),char(101),char(114),char(83),char(104),char(97),char(112),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(67),char(97),char(112),char(115),char(117),char(108),char(101),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(84),char(114),char(105),char(97),char(110),char(103),char(108),char(101),char(73),char(110),char(102),char(111),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),
char(110),char(79),char(98),char(106),char(101),char(99),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(80),char(101),char(114),char(115),char(105),char(115),char(116),char(101),char(110),char(116),char(77),char(97),char(110),char(105),char(102),char(111),char(108),char(100),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(108),char(108),char(105),char(115),char(105),char(111),char(110),char(79),
char(98),char(106),char(101),char(99),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(73),char(109),
char(112),char(97),char(99),char(116),char(77),char(101),char(115),char(104),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(67),char(111),char(110),char(118),char(101),char(120),char(72),char(117),char(108),char(108),char(83),char(104),char(97),char(112),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(116),char(97),char(99),char(116),char(83),
char(111),char(108),char(118),char(101),char(114),char(73),char(110),char(102),char(111),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),
char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(68),char(121),char(110),char(97),char(109),char(105),char(99),char(115),char(87),char(111),char(114),char(108),char(100),
char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),
char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),
char(100),char(121),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(115),char(116),
char(114),char(97),char(105),char(110),char(116),char(73),char(110),char(102),char(111),char(49),char(0),char(98),char(116),char(84),char(121),char(112),char(101),char(100),char(67),char(111),
char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),
char(84),char(121),char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(82),char(105),char(103),char(105),char(100),char(66),char(111),char(100),char(121),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(84),char(121),
char(112),char(101),char(100),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),
char(97),char(116),char(97),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),
char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(80),
char(111),char(105),char(110),char(116),char(50),char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(80),char(111),char(105),char(110),char(116),char(50),
char(80),char(111),char(105),char(110),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),
char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(72),char(105),char(110),char(103),
char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(72),char(105),char(110),char(103),char(101),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),
char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),
char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(0),char(98),char(116),char(67),char(111),char(110),char(101),char(84),char(119),char(105),char(115),char(116),char(67),char(111),char(110),char(115),char(116),char(114),char(97),
char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),
char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),
char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),
char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),
char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),
char(114),char(105),char(110),char(103),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),
char(68),char(97),char(116),char(97),char(50),char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),
char(112),char(114),char(105),char(110),char(103),char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(110),char(101),char(114),char(105),char(99),char(54),char(68),char(111),char(102),char(83),char(112),char(114),char(105),char(110),char(103),
char(50),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),
char(97),char(50),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),
char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(108),char(105),char(100),char(101),char(114),char(67),char(111),char(110),char(115),char(116),char(114),
char(97),char(105),char(110),char(116),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(71),char(101),char(97),
char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(71),char(101),char(97),char(114),char(67),char(111),char(110),char(115),char(116),char(114),char(97),char(105),char(110),char(116),char(68),char(111),char(117),
char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(77),char(97),char(116),char(101),
char(114),char(105),char(97),char(108),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(78),char(111),char(100),
char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(97),
char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(70),char(97),char(99),char(101),char(68),char(97),char(116),char(97),char(0),
char(83),char(111),char(102),char(116),char(66),char(111),char(100),char(121),char(84),char(101),char(116),char(114),char(97),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(82),char(105),char(103),char(105),char(100),char(65),char(110),char(99),char(104),char(111),char(114),char(68),char(97),char(116),char(97),char(0),char(83),char(111),
char(102),char(116),char(66),char(111),char(100),char(121),char(67),char(111),char(110),char(102),char(105),char(103),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),
char(116),char(66),char(111),char(100),char(121),char(80),char(111),char(115),char(101),char(68),char(97),char(116),char(97),char(0),char(83),char(111),char(102),char(116),char(66),char(111),
char(100),char(121),char(67),char(108),char(117),char(115),char(116),char(101),char(114),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(74),char(111),char(105),char(110),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(83),char(111),char(102),char(116),
char(66),char(111),char(100),char(121),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),
char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),
char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(70),char(108),char(111),char(97),char(116),
char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(68),char(111),char(117),char(98),
char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(70),char(108),
char(111),char(97),char(116),char(68),char(97),char(116),char(97),char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),
char(105),char(110),char(107),char(67),char(111),char(108),char(108),char(105),char(100),char(101),char(114),char(70),char(108),char(111),char(97),char(116),char(68),char(97),char(116),char(97),
char(0),char(98),char(116),char(77),char(117),char(108),char(116),char(105),char(66),char(111),char(100),char(121),char(76),char(105),char(110),char(107),char(67),char(111),char(108),char(108),
char(105),char(100),char(101),char(114),char(68),char(111),char(117),char(98),char(108),char(101),char(68),char(97),char(116),char(97),char(0),char(0),char(84),char(76),char(69),char(78),
char(1),char(0),char(1),char(0),char(2),char(0),char(2),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(0),char(0),
char(16),char(0),char(48),char(0),char(16),char(0),char(16),char(0),char(32),char(0),char(16),char(0),char(32),char(0),char(48),char(0),char(96),char(0),char(64),char(0),
char(-128),char(0),char(20),char(0),char(48),char(0),char(80),char(0),char(16),char(0),char(96),char(0),char(-112),char(0),char(16),char(0),char(56),char(0),char(56),char(0),
char(20),char(0),char(72),char(0),char(4),char(0),char(4),char(0),char(8),char(0),char(4),char(0),char(56),char(0),char(32),char(0),char(80),char(0),char(72),char(0),
char(96),char(0),char(80),char(0),char(32),char(0),char(64),char(0),char(64),char(0),char(64),char(0),char(16),char(0),char(24),char(6),char(-8),char(1),char(80),char(3),
char(32),char(1),char(72),char(0),char(80),char(0),char(-96),char(0),char(88),char(0),char(-64),char(0),char(104),char(0),char(8),char(2),char(-56),char(3),char(8),char(0),
char(64),char(0),char(64),char(0),char(0),char(0),char(80),char(0),char(96),char(0),char(-112),char(0),char(-128),char(0),char(104),char(1),char(-24),char(0),char(-104),char(1),
char(-120),char(1),char(-32),char(0),char(8),char(1),char(-40),char(1),char(104),char(1),char(-128),char(2),char(-112),char(2),char(-64),char(4),char(-40),char(0),char(120),char(1),
char(104),char(0),char(-104),char(0),char(16),char(0),char(104),char(0),char(24),char(0),char(40),char(0),char(104),char(0),char(96),char(0),char(104),char(0),char(-56),char(0),
char(104),char(1),char(112),char(0),char(-16),char(1),char(-128),char(3),char(-40),char(1),char(-56),char(0),char(112),char(0),char(48),char(1),char(8),char(2),char(0),char(0),
char(83),char(84),char(82),char(67),char(88),char(0),char(0),char(0),char(10),char(0),char(3),char(0),char(4),char(0),char(0),char(0),char(4),char(0),char(1),char(0),
char(9),char(0),char(2),char(0),char(11),char(0),char(3),char(0),char(10),char(0),char(3),char(0),char(10),char(0),char(4),char(0),char(10),char(0),char(5),char(0),
char(12),char(0),char(2),char(0),char(9),char(0),char(6),char(0),char(9),char(0),char(7),char(0),char(13),char(0),char(1),char(0),char(7),char(0),char(8),char(0),
char(14),char(0),char(1),char(0),char(8),char(0),char(8),char(0),char(15),char(0),char(1),char(0),char(7),char(0),char(8),char(0),char(16),char(0),char(1),char(0),
char(8),char(0),char(8),char(0),char(17),char(0),char(1),char(0),char(13),char(0),char(9),char(0),char(18),char(0),char(1),char(0),char(14),char(0),char(9),char(0),
char(19),char(0),char(2),char(0),char(17),char(0),char(10),char(0),char(13),char(0),char(11),char(0),char(20),char(0),char(2),char(0),char(18),char(0),char(10),char(0),
char(14),char(0),char(11),char(0),char(21),char(0),char(4),char(0),char(4),char(0),char(12),char(0),char(4),char(0),char(13),char(0),char(2),char(0),char(14),char(0),
char(2),char(0),char(15),char(0),char(22),char(0),char(6),char(0),char(13),char(0),char(16),char(0),char(13),char(0),char(17),char(0),char(4),char(0),char(18),char(0),
char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),char(23),char(0),char(6),char(0),char(14),char(0),char(16),char(0),
char(14),char(0),char(17),char(0),char(4),char(0),char(18),char(0),char(4),char(0),char(19),char(0),char(4),char(0),char(20),char(0),char(0),char(0),char(21),char(0),
char(24),char(0),char(3),char(0),char(2),char(0),char(14),char(0),char(2),char(0),char(15),char(0),char(4),char(0),char(22),char(0),char(25),char(0),char(12),char(0),
char(13),char(0),char(23),char(0),char(13),char(0),char(24),char(0),char(13),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),
char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),char(22),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(21),char(0),char(32),char(0),
char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(26),char(0),char(12),char(0),char(14),char(0),char(23),char(0),char(14),char(0),char(24),char(0),
char(14),char(0),char(25),char(0),char(4),char(0),char(26),char(0),char(4),char(0),char(27),char(0),char(4),char(0),char(28),char(0),char(4),char(0),char(29),char(0),
char(23),char(0),char(30),char(0),char(24),char(0),char(31),char(0),char(4),char(0),char(33),char(0),char(4),char(0),char(34),char(0),char(21),char(0),char(32),char(0),
char(27),char(0),char(3),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(36),char(0),char(0),char(0),char(37),char(0),char(28),char(0),char(5),char(0),
char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(40),char(0),char(7),char(0),char(41),char(0),char(0),char(0),char(21),char(0),
char(29),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(13),char(0),char(39),char(0),char(13),char(0),char(42),char(0),char(7),char(0),char(43),char(0),
char(4),char(0),char(44),char(0),char(30),char(0),char(2),char(0),char(13),char(0),char(45),char(0),char(7),char(0),char(46),char(0),char(31),char(0),char(4),char(0),
char(29),char(0),char(47),char(0),char(30),char(0),char(48),char(0),char(4),char(0),char(49),char(0),char(0),char(0),char(37),char(0),char(32),char(0),char(1),char(0),
char(4),char(0),char(50),char(0),char(33),char(0),char(2),char(0),char(2),char(0),char(50),char(0),char(0),char(0),char(51),char(0),char(34),char(0),char(2),char(0),
char(2),char(0),char(52),char(0),char(0),char(0),char(51),char(0),char(35),char(0),char(2),char(0),char(0),char(0),char(52),char(0),char(0),char(0),char(53),char(0),
char(36),char(0),char(8),char(0),char(13),char(0),char(54),char(0),char(14),char(0),char(55),char(0),char(32),char(0),char(56),char(0),char(34),char(0),char(57),char(0),
char(35),char(0),char(58),char(0),char(33),char(0),char(59),char(0),char(4),char(0),char(60),char(0),char(4),char(0),char(61),char(0),char(37),char(0),char(4),char(0),
char(36),char(0),char(62),char(0),char(13),char(0),char(63),char(0),char(4),char(0),char(64),char(0),char(0),char(0),char(37),char(0),char(38),char(0),char(7),char(0),
char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),char(25),char(0),char(66),char(0),char(26),char(0),char(67),char(0),char(39),char(0),char(68),char(0),
char(7),char(0),char(43),char(0),char(0),char(0),char(69),char(0),char(40),char(0),char(2),char(0),char(38),char(0),char(70),char(0),char(13),char(0),char(39),char(0),
char(41),char(0),char(4),char(0),char(19),char(0),char(71),char(0),char(27),char(0),char(72),char(0),char(4),char(0),char(73),char(0),char(7),char(0),char(74),char(0),
char(42),char(0),char(4),char(0),char(27),char(0),char(38),char(0),char(41),char(0),char(75),char(0),char(4),char(0),char(76),char(0),char(7),char(0),char(43),char(0),
char(43),char(0),char(3),char(0),char(29),char(0),char(47),char(0),char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(44),char(0),char(3),char(0),
char(29),char(0),char(47),char(0),char(4),char(0),char(78),char(0),char(0),char(0),char(37),char(0),char(45),char(0),char(3),char(0),char(29),char(0),char(47),char(0),
char(4),char(0),char(77),char(0),char(0),char(0),char(37),char(0),char(46),char(0),char(4),char(0),char(4),char(0),char(79),char(0),char(7),char(0),char(80),char(0),
char(7),char(0),char(81),char(0),char(7),char(0),char(82),char(0),char(39),char(0),char(14),char(0),char(4),char(0),char(83),char(0),char(4),char(0),char(84),char(0),
char(46),char(0),char(85),char(0),char(4),char(0),char(86),char(0),char(7),char(0),char(87),char(0),char(7),char(0),char(88),char(0),char(7),char(0),char(89),char(0),
char(7),char(0),char(90),char(0),char(7),char(0),char(91),char(0),char(4),char(0),char(92),char(0),char(4),char(0),char(93),char(0),char(4),char(0),char(94),char(0),
char(4),char(0),char(95),char(0),char(0),char(0),char(37),char(0),char(47),char(0),char(39),char(0),char(14),char(0),char(96),char(0),char(14),char(0),char(97),char(0),
char(14),char(0),char(98),char(0),char(14),char(0),char(99),char(0),char(14),char(0),char(100),char(0),char(14),char(0),char(101),char(0),char(14),char(0),char(102),char(0),
char(8),char(0),char(103),char(0),char(8),char(0),char(104),char(0),char(8),char(0),char(105),char(0),char(8),char(0),char(106),char(0),char(8),char(0),char(107),char(0),
char(8),char(0),char(108),char(0),char(8),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(8),char(0),char(115),char(0),char(8),char(0),char(116),char(0),char(8),char(0),char(117),char(0),
char(8),char(0),char(118),char(0),char(8),char(0),char(119),char(0),char(8),char(0),char(120),char(0),char(8),char(0),char(121),char(0),char(8),char(0),char(122),char(0),
char(8),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(8),char(0),char(-126),char(0),char(8),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(48),char(0),char(-124),char(0),char(48),char(0),char(-123),char(0),char(49),char(0),char(39),char(0),char(13),char(0),char(96),char(0),char(13),char(0),char(97),char(0),
char(13),char(0),char(98),char(0),char(13),char(0),char(99),char(0),char(13),char(0),char(100),char(0),char(13),char(0),char(101),char(0),char(13),char(0),char(102),char(0),
char(7),char(0),char(103),char(0),char(7),char(0),char(104),char(0),char(7),char(0),char(105),char(0),char(7),char(0),char(106),char(0),char(7),char(0),char(107),char(0),
char(7),char(0),char(108),char(0),char(7),char(0),char(109),char(0),char(4),char(0),char(110),char(0),char(4),char(0),char(111),char(0),char(4),char(0),char(112),char(0),
char(4),char(0),char(113),char(0),char(4),char(0),char(114),char(0),char(7),char(0),char(115),char(0),char(7),char(0),char(116),char(0),char(7),char(0),char(117),char(0),
char(7),char(0),char(118),char(0),char(7),char(0),char(119),char(0),char(7),char(0),char(120),char(0),char(7),char(0),char(121),char(0),char(7),char(0),char(122),char(0),
char(7),char(0),char(123),char(0),char(4),char(0),char(124),char(0),char(4),char(0),char(125),char(0),char(4),char(0),char(126),char(0),char(4),char(0),char(127),char(0),
char(4),char(0),char(-128),char(0),char(4),char(0),char(-127),char(0),char(7),char(0),char(-126),char(0),char(7),char(0),char(-125),char(0),char(4),char(0),char(44),char(0),
char(50),char(0),char(-124),char(0),char(50),char(0),char(-123),char(0),char(51),char(0),char(5),char(0),char(27),char(0),char(38),char(0),char(37),char(0),char(65),char(0),
char(13),char(0),char(39),char(0),char(7),char(0),char(43),char(0),char(4),char(0),char(-122),char(0),char(52),char(0),char(5),char(0),char(29),char(0),char(47),char(0),
char(13),char(0),char(-121),char(0),char(14),char(0),char(-120),char(0),char(4),char(0),char(-119),char(0),char(0),char(0),char(-118),char(0),char(48),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(20),char(0),char(-114),char(0),
char(20),char(0),char(-113),char(0),char(14),char(0),char(-112),char(0),char(14),char(0),char(-111),char(0),char(14),char(0),char(-110),char(0),char(8),char(0),char(-125),char(0),
char(8),char(0),char(-109),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-107),char(0),char(8),char(0),char(-106),char(0),char(8),char(0),char(-105),char(0),
char(8),char(0),char(-104),char(0),char(8),char(0),char(-103),char(0),char(8),char(0),char(-102),char(0),char(8),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(50),char(0),char(29),char(0),
char(9),char(0),char(-117),char(0),char(9),char(0),char(-116),char(0),char(27),char(0),char(-115),char(0),char(0),char(0),char(35),char(0),char(19),char(0),char(-114),char(0),
char(19),char(0),char(-113),char(0),char(13),char(0),char(-112),char(0),char(13),char(0),char(-111),char(0),char(13),char(0),char(-110),char(0),char(7),char(0),char(-125),char(0),
char(7),char(0),char(-109),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-107),char(0),char(7),char(0),char(-106),char(0),char(7),char(0),char(-105),char(0),
char(7),char(0),char(-104),char(0),char(7),char(0),char(-103),char(0),char(7),char(0),char(-102),char(0),char(7),char(0),char(-101),char(0),char(4),char(0),char(-100),char(0),
char(4),char(0),char(-99),char(0),char(4),char(0),char(-98),char(0),char(4),char(0),char(-97),char(0),char(4),char(0),char(-96),char(0),char(4),char(0),char(-95),char(0),
char(4),char(0),char(-94),char(0),char(4),char(0),char(-93),char(0),char(4),char(0),char(-92),char(0),char(4),char(0),char(-91),char(0),char(53),char(0),char(23),char(0),
char(8),char(0),char(-90),char(0),char(8),char(0),char(-89),char(0),char(8),char(0),char(-108),char(0),char(8),char(0),char(-88),char(0),char(8),char(0),char(-104),char(0),
char(8),char(0),char(-87),char(0),char(8),char(0),char(-86),char(0),char(8),char(0),char(-85),char(0),char(8),char(0),char(-84),char(0),char(8),char(0),char(-83),char(0),
char(8),char(0),char(-82),char(0),char(8),char(0),char(-81),char(0),char(8),char(0),char(-80),char(0),char(8),char(0),char(-79),char(0),char(8),char(0),char(-78),char(0),
char(8),char(0),char(-77),char(0),char(8),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),
char(4),char(0),char(-72),char(0),char(4),char(0),char(-71),char(0),char(0),char(0),char(37),char(0),char(54),char(0),char(22),char(0),char(7),char(0),char(-90),char(0),
char(7),char(0),char(-89),char(0),char(7),char(0),char(-108),char(0),char(7),char(0),char(-88),char(0),char(7),char(0),char(-104),char(0),char(7),char(0),char(-87),char(0),
char(7),char(0),char(-86),char(0),char(7),char(0),char(-85),char(0),char(7),char(0),char(-84),char(0),char(7),char(0),char(-83),char(0),char(7),char(0),char(-82),char(0),
char(7),char(0),char(-81),char(0),char(7),char(0),char(-80),char(0),char(7),char(0),char(-79),char(0),char(7),char(0),char(-78),char(0),char(7),char(0),char(-77),char(0),
char(7),char(0),char(-76),char(0),char(4),char(0),char(-75),char(0),char(4),char(0),char(-74),char(0),char(4),char(0),char(-73),char(0),char(4),char(0),char(-72),char(0),
char(4),char(0),char(-71),char(0),char(55),char(0),char(2),char(0),char(53),char(0),char(-70),char(0),char(14),char(0),char(-69),char(0),char(56),char(0),char(2),char(0),
char(54),char(0),char(-70),char(0),char(13),char(0),char(-69),char(0),char(57),char(0),char(21),char(0),char(50),char(0),char(-68),char(0),char(17),char(0),char(-67),char(0),
char(13),char(0),char(-66),char(0),char(13),char(0),char(-65),char(0),char(13),char(0),char(-64),char(0),char(13),char(0),char(-63),char(0),char(13),char(0),char(-69),char(0),
char(13),char(0),char(-62),char(0),char(13),char(0),char(-61),char(0),char(13),char(0),char(-60),char(0),char(13),char(0),char(-59),char(0),char(7),char(0),char(-58),char(0),
char(7),char(0),char(-57),char(0),char(7),char(0),char(-56),char(0),char(7),char(0),char(-55),char(0),char(7),char(0),char(-54),char(0),char(7),char(0),char(-53),char(0),
char(7),char(0),char(-52),char(0),char(7),char(0),char(-51),char(0),char(7),char(0),char(-50),char(0),char(4),char(0),char(-49),char(0),char(58),char(0),char(22),char(0),
char(48),char(0),char(-68),char(0),char(18),char(0),char(-67),char(0),char(14),char(0),char(-66),char(0),char(14),char(0),char(-65),char(0),char(14),char(0),char(-64),char(0),
char(14),char(0),char(-63),char(0),char(14),char(0),char(-69),char(0),char(14),char(0),char(-62),char(0),char(14),char(0),char(-61),char(0),char(14),char(0),char(-60),char(0),
char(14),char(0),char(-59),char(0),char(8),char(0),char(-58),char(0),char(8),char(0),char(-57),char(0),char(8),char(0),char(-56),char(0),char(8),char(0),char(-55),char(0),
char(8),char(0),char(-54),char(0),char(8),char(0),char(-53),char(0),char(8),char(0),char(-52),char(0),char(8),char(0),char(-51),char(0),char(8),char(0),char(-50),char(0),
char(4),char(0),char(-49),char(0),char(0),char(0),char(37),char(0),char(59),char(0),char(2),char(0),char(4),char(0),char(-48),char(0),char(4),char(0),char(-47),char(0),
char(60),char(0),char(13),char(0),char(57),char(0),char(-46),char(0),char(57),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),
char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),
char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(61),char(0),char(13),char(0),
char(62),char(0),char(-46),char(0),char(62),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),
char(4),char(0),char(-43),char(0),char(4),char(0),char(-42),char(0),char(7),char(0),char(-41),char(0),char(7),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),
char(4),char(0),char(-38),char(0),char(7),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(63),char(0),char(14),char(0),char(58),char(0),char(-46),char(0),
char(58),char(0),char(-45),char(0),char(0),char(0),char(35),char(0),char(4),char(0),char(-127),char(0),char(4),char(0),char(-44),char(0),char(4),char(0),char(-43),char(0),
char(4),char(0),char(-42),char(0),char(8),char(0),char(-41),char(0),char(8),char(0),char(-40),char(0),char(4),char(0),char(-39),char(0),char(4),char(0),char(-38),char(0),
char(8),char(0),char(-37),char(0),char(4),char(0),char(-36),char(0),char(0),char(0),char(-35),char(0),char(64),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),
char(13),char(0),char(-33),char(0),char(13),char(0),char(-32),char(0),char(65),char(0),char(3),char(0),char(63),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),
char(14),char(0),char(-32),char(0),char(66),char(0),char(3),char(0),char(61),char(0),char(-34),char(0),char(14),char(0),char(-33),char(0),char(14),char(0),char(-32),char(0),
char(67),char(0),char(13),char(0),char(61),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),
char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),
char(7),char(0),char(-23),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(68),char(0),char(13),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),
char(4),char(0),char(-27),char(0),char(7),char(0),char(-26),char(0),char(7),char(0),char(-25),char(0),char(7),char(0),char(-24),char(0),char(7),char(0),char(-23),char(0),
char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(69),char(0),char(14),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(4),char(0),char(-29),char(0),char(4),char(0),char(-28),char(0),char(4),char(0),char(-27),char(0),
char(8),char(0),char(-26),char(0),char(8),char(0),char(-25),char(0),char(8),char(0),char(-24),char(0),char(8),char(0),char(-23),char(0),char(8),char(0),char(-22),char(0),
char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(0),char(0),char(-19),char(0),char(70),char(0),char(10),char(0),char(63),char(0),char(-34),char(0),
char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(8),char(0),char(-18),char(0),char(8),char(0),char(-17),char(0),char(8),char(0),char(-16),char(0),
char(8),char(0),char(-22),char(0),char(8),char(0),char(-21),char(0),char(8),char(0),char(-20),char(0),char(8),char(0),char(-89),char(0),char(71),char(0),char(11),char(0),
char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(7),char(0),char(-18),char(0),char(7),char(0),char(-17),char(0),
char(7),char(0),char(-16),char(0),char(7),char(0),char(-22),char(0),char(7),char(0),char(-21),char(0),char(7),char(0),char(-20),char(0),char(7),char(0),char(-89),char(0),
char(0),char(0),char(21),char(0),char(72),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),
char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(73),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),
char(14),char(0),char(-15),char(0),char(14),char(0),char(-14),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),char(4),char(0),char(-11),char(0),
char(4),char(0),char(-10),char(0),char(74),char(0),char(5),char(0),char(72),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),char(7),char(0),char(-7),char(0),
char(7),char(0),char(-6),char(0),char(7),char(0),char(-5),char(0),char(75),char(0),char(5),char(0),char(73),char(0),char(-9),char(0),char(4),char(0),char(-8),char(0),
char(8),char(0),char(-7),char(0),char(8),char(0),char(-6),char(0),char(8),char(0),char(-5),char(0),char(76),char(0),char(41),char(0),char(61),char(0),char(-34),char(0),
char(19),char(0),char(-31),char(0),char(19),char(0),char(-30),char(0),char(13),char(0),char(-15),char(0),char(13),char(0),char(-14),char(0),char(13),char(0),char(-4),char(0),
char(13),char(0),char(-3),char(0),char(13),char(0),char(-2),char(0),char(13),char(0),char(-1),char(0),char(13),char(0),char(0),char(1),char(13),char(0),char(1),char(1),
char(13),char(0),char(2),char(1),char(13),char(0),char(3),char(1),char(13),char(0),char(4),char(1),char(13),char(0),char(5),char(1),char(13),char(0),char(6),char(1),
char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),
char(0),char(0),char(-19),char(0),char(13),char(0),char(-13),char(0),char(13),char(0),char(-12),char(0),char(13),char(0),char(12),char(1),char(13),char(0),char(13),char(1),
char(13),char(0),char(14),char(1),char(13),char(0),char(15),char(1),char(13),char(0),char(16),char(1),char(13),char(0),char(17),char(1),char(13),char(0),char(18),char(1),
char(13),char(0),char(19),char(1),char(13),char(0),char(20),char(1),char(13),char(0),char(21),char(1),char(13),char(0),char(22),char(1),char(0),char(0),char(23),char(1),
char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),
char(77),char(0),char(41),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),char(20),char(0),char(-30),char(0),char(14),char(0),char(-15),char(0),
char(14),char(0),char(-14),char(0),char(14),char(0),char(-4),char(0),char(14),char(0),char(-3),char(0),char(14),char(0),char(-2),char(0),char(14),char(0),char(-1),char(0),
char(14),char(0),char(0),char(1),char(14),char(0),char(1),char(1),char(14),char(0),char(2),char(1),char(14),char(0),char(3),char(1),char(14),char(0),char(4),char(1),
char(14),char(0),char(5),char(1),char(14),char(0),char(6),char(1),char(0),char(0),char(7),char(1),char(0),char(0),char(8),char(1),char(0),char(0),char(9),char(1),
char(0),char(0),char(10),char(1),char(0),char(0),char(11),char(1),char(0),char(0),char(-19),char(0),char(14),char(0),char(-13),char(0),char(14),char(0),char(-12),char(0),
char(14),char(0),char(12),char(1),char(14),char(0),char(13),char(1),char(14),char(0),char(14),char(1),char(14),char(0),char(15),char(1),char(14),char(0),char(16),char(1),
char(14),char(0),char(17),char(1),char(14),char(0),char(18),char(1),char(14),char(0),char(19),char(1),char(14),char(0),char(20),char(1),char(14),char(0),char(21),char(1),
char(14),char(0),char(22),char(1),char(0),char(0),char(23),char(1),char(0),char(0),char(24),char(1),char(0),char(0),char(25),char(1),char(0),char(0),char(26),char(1),
char(0),char(0),char(27),char(1),char(4),char(0),char(28),char(1),char(78),char(0),char(9),char(0),char(61),char(0),char(-34),char(0),char(19),char(0),char(-31),char(0),
char(19),char(0),char(-30),char(0),char(7),char(0),char(-15),char(0),char(7),char(0),char(-14),char(0),char(7),char(0),char(-13),char(0),char(7),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(79),char(0),char(9),char(0),char(63),char(0),char(-34),char(0),char(20),char(0),char(-31),char(0),
char(20),char(0),char(-30),char(0),char(8),char(0),char(-15),char(0),char(8),char(0),char(-14),char(0),char(8),char(0),char(-13),char(0),char(8),char(0),char(-12),char(0),
char(4),char(0),char(-11),char(0),char(4),char(0),char(-10),char(0),char(80),char(0),char(5),char(0),char(60),char(0),char(-34),char(0),char(13),char(0),char(29),char(1),
char(13),char(0),char(30),char(1),char(7),char(0),char(31),char(1),char(0),char(0),char(37),char(0),char(81),char(0),char(4),char(0),char(63),char(0),char(-34),char(0),
char(14),char(0),char(29),char(1),char(14),char(0),char(30),char(1),char(8),char(0),char(31),char(1),char(82),char(0),char(4),char(0),char(7),char(0),char(32),char(1),
char(7),char(0),char(33),char(1),char(7),char(0),char(34),char(1),char(4),char(0),char(79),char(0),char(83),char(0),char(10),char(0),char(82),char(0),char(35),char(1),
char(13),char(0),char(36),char(1),char(13),char(0),char(37),char(1),char(13),char(0),char(38),char(1),char(13),char(0),char(39),char(1),char(13),char(0),char(40),char(1),
char(7),char(0),char(-58),char(0),char(7),char(0),char(41),char(1),char(4),char(0),char(42),char(1),char(4),char(0),char(53),char(0),char(84),char(0),char(4),char(0),
char(82),char(0),char(35),char(1),char(4),char(0),char(43),char(1),char(7),char(0),char(44),char(1),char(4),char(0),char(45),char(1),char(85),char(0),char(4),char(0),
char(13),char(0),char(40),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(46),char(1),char(7),char(0),char(47),char(1),char(86),char(0),char(7),char(0),
char(13),char(0),char(48),char(1),char(82),char(0),char(35),char(1),char(4),char(0),char(49),char(1),char(7),char(0),char(50),char(1),char(7),char(0),char(51),char(1),
char(7),char(0),char(52),char(1),char(4),char(0),char(53),char(0),char(87),char(0),char(6),char(0),char(17),char(0),char(53),char(1),char(13),char(0),char(51),char(1),
char(13),char(0),char(54),char(1),char(62),char(0),char(55),char(1),char(4),char(0),char(56),char(1),char(7),char(0),char(52),char(1),char(88),char(0),char(26),char(0),
char(4),char(0),char(57),char(1),char(7),char(0),char(58),char(1),char(7),char(0),char(-89),char(0),char(7),char(0),char(59),char(1),char(7),char(0),char(60),char(1),
char(7),char(0),char(61),char(1),char(7),char(0),char(62),char(1),char(7),char(0),char(63),char(1),char(7),char(0),char(64),char(1),char(7),char(0),char(65),char(1),
char(7),char(0),char(66),char(1),char(7),char(0),char(67),char(1),char(7),char(0),char(68),char(1),char(7),char(0),char(69),char(1),char(7),char(0),char(70),char(1),
char(7),char(0),char(71),char(1),char(7),char(0),char(72),char(1),char(7),char(0),char(73),char(1),char(7),char(0),char(74),char(1),char(7),char(0),char(75),char(1),
char(7),char(0),char(76),char(1),char(4),char(0),char(77),char(1),char(4),char(0),char(78),char(1),char(4),char(0),char(79),char(1),char(4),char(0),char(80),char(1),
char(4),char(0),char(-99),char(0),char(89),char(0),char(12),char(0),char(17),char(0),char(81),char(1),char(17),char(0),char(82),char(1),char(17),char(0),char(83),char(1),
char(13),char(0),char(84),char(1),char(13),char(0),char(85),char(1),char(7),char(0),char(86),char(1),char(4),char(0),char(87),char(1),char(4),char(0),char(88),char(1),
char(4),char(0),char(89),char(1),char(4),char(0),char(90),char(1),char(7),char(0),char(50),char(1),char(4),char(0),char(53),char(0),char(90),char(0),char(27),char(0),
char(19),char(0),char(91),char(1),char(17),char(0),char(92),char(1),char(17),char(0),char(93),char(1),char(13),char(0),char(84),char(1),char(13),char(0),char(94),char(1),
char(13),char(0),char(95),char(1),char(13),char(0),char(96),char(1),char(13),char(0),char(97),char(1),char(13),char(0),char(98),char(1),char(4),char(0),char(99),char(1),
char(7),char(0),char(100),char(1),char(4),char(0),char(101),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(103),char(1),char(7),char(0),char(104),char(1),
char(7),char(0),char(105),char(1),char(4),char(0),char(106),char(1),char(4),char(0),char(107),char(1),char(7),char(0),char(108),char(1),char(7),char(0),char(109),char(1),
char(7),char(0),char(110),char(1),char(7),char(0),char(111),char(1),char(7),char(0),char(112),char(1),char(7),char(0),char(113),char(1),char(4),char(0),char(114),char(1),
char(4),char(0),char(115),char(1),char(4),char(0),char(116),char(1),char(91),char(0),char(12),char(0),char(9),char(0),char(117),char(1),char(9),char(0),char(118),char(1),
char(13),char(0),char(119),char(1),char(7),char(0),char(120),char(1),char(7),char(0),char(-85),char(0),char(7),char(0),char(121),char(1),char(4),char(0),char(122),char(1),
char(13),char(0),char(123),char(1),char(4),char(0),char(124),char(1),char(4),char(0),char(125),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(53),char(0),
char(92),char(0),char(19),char(0),char(50),char(0),char(-68),char(0),char(89),char(0),char(127),char(1),char(82),char(0),char(-128),char(1),char(83),char(0),char(-127),char(1),
char(84),char(0),char(-126),char(1),char(85),char(0),char(-125),char(1),char(86),char(0),char(-124),char(1),char(87),char(0),char(-123),char(1),char(90),char(0),char(-122),char(1),
char(91),char(0),char(-121),char(1),char(4),char(0),char(-120),char(1),char(4),char(0),char(102),char(1),char(4),char(0),char(-119),char(1),char(4),char(0),char(-118),char(1),
char(4),char(0),char(-117),char(1),char(4),char(0),char(-116),char(1),char(4),char(0),char(-115),char(1),char(4),char(0),char(-114),char(1),char(88),char(0),char(-113),char(1),
char(93),char(0),char(28),char(0),char(16),char(0),char(-112),char(1),char(14),char(0),char(-111),char(1),char(14),char(0),char(-110),char(1),char(14),char(0),char(-109),char(1),
char(14),char(0),char(-108),char(1),char(14),char(0),char(-107),char(1),char(14),char(0),char(-106),char(1),char(14),char(0),char(-105),char(1),char(14),char(0),char(-104),char(1),
char(14),char(0),char(-103),char(1),char(8),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(4),char(0),char(-100),char(1),
char(4),char(0),char(-99),char(1),char(8),char(0),char(-98),char(1),char(8),char(0),char(-97),char(1),char(8),char(0),char(-96),char(1),char(8),char(0),char(-95),char(1),
char(8),char(0),char(-94),char(1),char(8),char(0),char(-93),char(1),char(8),char(0),char(-92),char(1),char(8),char(0),char(-91),char(1),char(8),char(0),char(-90),char(1),
char(0),char(0),char(-89),char(1),char(0),char(0),char(-88),char(1),char(48),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(94),char(0),char(28),char(0),
char(15),char(0),char(-112),char(1),char(13),char(0),char(-111),char(1),char(13),char(0),char(-110),char(1),char(13),char(0),char(-109),char(1),char(13),char(0),char(-108),char(1),
char(13),char(0),char(-107),char(1),char(13),char(0),char(-106),char(1),char(13),char(0),char(-105),char(1),char(13),char(0),char(-104),char(1),char(13),char(0),char(-103),char(1),
char(4),char(0),char(-100),char(1),char(7),char(0),char(-102),char(1),char(4),char(0),char(-101),char(1),char(4),char(0),char(126),char(1),char(7),char(0),char(-98),char(1),
char(7),char(0),char(-97),char(1),char(7),char(0),char(-96),char(1),char(4),char(0),char(-99),char(1),char(7),char(0),char(-95),char(1),char(7),char(0),char(-94),char(1),
char(7),char(0),char(-93),char(1),char(7),char(0),char(-92),char(1),char(7),char(0),char(-91),char(1),char(7),char(0),char(-90),char(1),char(0),char(0),char(-89),char(1),
char(0),char(0),char(-88),char(1),char(50),char(0),char(-87),char(1),char(0),char(0),char(-86),char(1),char(95),char(0),char(11),char(0),char(14),char(0),char(-85),char(1),
char(16),char(0),char(-84),char(1),char(14),char(0),char(-83),char(1),char(14),char(0),char(-82),char(1),char(14),char(0),char(-81),char(1),char(8),char(0),char(-80),char(1),
char(4),char(0),char(-119),char(1),char(0),char(0),char(37),char(0),char(0),char(0),char(-79),char(1),char(93),char(0),char(-126),char(1),char(48),char(0),char(-78),char(1),
char(96),char(0),char(10),char(0),char(13),char(0),char(-85),char(1),char(15),char(0),char(-84),char(1),char(13),char(0),char(-83),char(1),char(13),char(0),char(-82),char(1),
char(13),char(0),char(-81),char(1),char(7),char(0),char(-80),char(1),char(4),char(0),char(-119),char(1),char(0),char(0),char(-79),char(1),char(94),char(0),char(-126),char(1),
char(50),char(0),char(-78),char(1),char(97),char(0),char(4),char(0),char(50),char(0),char(-77),char(1),char(96),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),char(98),char(0),char(4),char(0),char(48),char(0),char(-77),char(1),char(95),char(0),char(-76),char(1),char(4),char(0),char(-75),char(1),
char(0),char(0),char(37),char(0),};
int sBulletDNAlen64= sizeof(sBulletDNAstr64);





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_AABB_UTIL2
#define BT_AABB_UTIL2

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

SIMD_FORCE_INLINE void AabbExpand(btVector3& aabbMin,
								  btVector3& aabbMax,
								  const btVector3& expansionMin,
								  const btVector3& expansionMax)
{
	aabbMin = aabbMin + expansionMin;
	aabbMax = aabbMax + expansionMax;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestPointAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											 const btVector3& point)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > point.getX() || aabbMax1.getX() < point.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > point.getZ() || aabbMax1.getZ() < point.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > point.getY() || aabbMax1.getY() < point.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between two aabbs
SIMD_FORCE_INLINE bool TestAabbAgainstAabb2(const btVector3& aabbMin1, const btVector3& aabbMax1,
											const btVector3& aabbMin2, const btVector3& aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1.getX() > aabbMax2.getX() || aabbMax1.getX() < aabbMin2.getX()) ? false : overlap;
	overlap = (aabbMin1.getZ() > aabbMax2.getZ() || aabbMax1.getZ() < aabbMin2.getZ()) ? false : overlap;
	overlap = (aabbMin1.getY() > aabbMax2.getY() || aabbMax1.getY() < aabbMin2.getY()) ? false : overlap;
	return overlap;
}

/// conservative test for overlap between triangle and aabb
SIMD_FORCE_INLINE bool TestTriangleAgainstAabb2(const btVector3* vertices,
												const btVector3& aabbMin, const btVector3& aabbMax)
{
	const btVector3& p1 = vertices[0];
	const btVector3& p2 = vertices[1];
	const btVector3& p3 = vertices[2];

	if (btMin(btMin(p1[0], p2[0]), p3[0]) > aabbMax[0]) return false;
	if (btMax(btMax(p1[0], p2[0]), p3[0]) < aabbMin[0]) return false;

	if (btMin(btMin(p1[2], p2[2]), p3[2]) > aabbMax[2]) return false;
	if (btMax(btMax(p1[2], p2[2]), p3[2]) < aabbMin[2]) return false;

	if (btMin(btMin(p1[1], p2[1]), p3[1]) > aabbMax[1]) return false;
	if (btMax(btMax(p1[1], p2[1]), p3[1]) < aabbMin[1]) return false;
	return true;
}

SIMD_FORCE_INLINE int btOutcode(const btVector3& p, const btVector3& halfExtent)
{
	return (p.getX() < -halfExtent.getX() ? 0x01 : 0x0) |
		   (p.getX() > halfExtent.getX() ? 0x08 : 0x0) |
		   (p.getY() < -halfExtent.getY() ? 0x02 : 0x0) |
		   (p.getY() > halfExtent.getY() ? 0x10 : 0x0) |
		   (p.getZ() < -halfExtent.getZ() ? 0x4 : 0x0) |
		   (p.getZ() > halfExtent.getZ() ? 0x20 : 0x0);
}

SIMD_FORCE_INLINE bool btRayAabb2(const btVector3& rayFrom,
								  const btVector3& rayInvDirection,
								  const unsigned int raySign[3],
								  const btVector3 bounds[2],
								  btScalar& tmin,
								  btScalar lambda_min,
								  btScalar lambda_max)
{
	btScalar tmax, tymin, tymax, tzmin, tzmax;
	tmin = (bounds[raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tmax = (bounds[1 - raySign[0]].getX() - rayFrom.getX()) * rayInvDirection.getX();
	tymin = (bounds[raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();
	tymax = (bounds[1 - raySign[1]].getY() - rayFrom.getY()) * rayInvDirection.getY();

	if ((tmin > tymax) || (tymin > tmax))
		return false;

	if (tymin > tmin)
		tmin = tymin;

	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();
	tzmax = (bounds[1 - raySign[2]].getZ() - rayFrom.getZ()) * rayInvDirection.getZ();

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;
	return ((tmin < lambda_max) && (tmax > lambda_min));
}

SIMD_FORCE_INLINE bool btRayAabb(const btVector3& rayFrom,
								 const btVector3& rayTo,
								 const btVector3& aabbMin,
								 const btVector3& aabbMax,
								 btScalar& param, btVector3& normal)
{
	btVector3 aabbHalfExtent = (aabbMax - aabbMin) * btScalar(0.5);
	btVector3 aabbCenter = (aabbMax + aabbMin) * btScalar(0.5);
	btVector3 source = rayFrom - aabbCenter;
	btVector3 target = rayTo - aabbCenter;
	int sourceOutcode = btOutcode(source, aabbHalfExtent);
	int targetOutcode = btOutcode(target, aabbHalfExtent);
	if ((sourceOutcode & targetOutcode) == 0x0)
	{
		btScalar lambda_enter = btScalar(0.0);
		btScalar lambda_exit = param;
		btVector3 r = target - source;
		int i;
		btScalar normSign = 1;
		btVector3 hitNormal(0, 0, 0);
		int bit = 1;

		for (int j = 0; j < 2; j++)
		{
			for (i = 0; i != 3; ++i)
			{
				if (sourceOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					if (lambda_enter <= lambda)
					{
						lambda_enter = lambda;
						hitNormal.setValue(0, 0, 0);
						hitNormal[i] = normSign;
					}
				}
				else if (targetOutcode & bit)
				{
					btScalar lambda = (-source[i] - aabbHalfExtent[i] * normSign) / r[i];
					btSetMin(lambda_exit, lambda);
				}
				bit <<= 1;
			}
			normSign = btScalar(-1.);
		}
		if (lambda_enter <= lambda_exit)
		{
			param = lambda_enter;
			normal = hitNormal;
			return true;
		}
	}
	return false;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& halfExtents, btScalar margin, const btTransform& t, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btVector3 halfExtentsWithMargin = halfExtents + btVector3(margin, margin, margin);
	btMatrix3x3 abs_b = t.getBasis().absolute();
	btVector3 center = t.getOrigin();
	btVector3 extent = halfExtentsWithMargin.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

SIMD_FORCE_INLINE void btTransformAabb(const btVector3& localAabbMin, const btVector3& localAabbMax, btScalar margin, const btTransform& trans, btVector3& aabbMinOut, btVector3& aabbMaxOut)
{
	btAssert(localAabbMin.getX() <= localAabbMax.getX());
	btAssert(localAabbMin.getY() <= localAabbMax.getY());
	btAssert(localAabbMin.getZ() <= localAabbMax.getZ());
	btVector3 localHalfExtents = btScalar(0.5) * (localAabbMax - localAabbMin);
	localHalfExtents += btVector3(margin, margin, margin);

	btVector3 localCenter = btScalar(0.5) * (localAabbMax + localAabbMin);
	btMatrix3x3 abs_b = trans.getBasis().absolute();
	btVector3 center = trans(localCenter);
	btVector3 extent = localHalfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
	aabbMinOut = center - extent;
	aabbMaxOut = center + extent;
}

#define USE_BANCHLESS 1
#ifdef USE_BANCHLESS
//This block replaces the block below and uses no branches, and replaces the 8 bit return with a 32 bit return for improved performance (~3x on XBox 360)
SIMD_FORCE_INLINE unsigned testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	return static_cast<unsigned int>(btSelect((unsigned)((aabbMin1[0] <= aabbMax2[0]) & (aabbMax1[0] >= aabbMin2[0]) & (aabbMin1[2] <= aabbMax2[2]) & (aabbMax1[2] >= aabbMin2[2]) & (aabbMin1[1] <= aabbMax2[1]) & (aabbMax1[1] >= aabbMin2[1])),
											  1, 0));
}
#else
SIMD_FORCE_INLINE bool testQuantizedAabbAgainstQuantizedAabb(const unsigned short int* aabbMin1, const unsigned short int* aabbMax1, const unsigned short int* aabbMin2, const unsigned short int* aabbMax2)
{
	bool overlap = true;
	overlap = (aabbMin1[0] > aabbMax2[0] || aabbMax1[0] < aabbMin2[0]) ? false : overlap;
	overlap = (aabbMin1[2] > aabbMax2[2] || aabbMax1[2] < aabbMin2[2]) ? false : overlap;
	overlap = (aabbMin1[1] > aabbMax2[1] || aabbMax1[1] < aabbMin2[1]) ? false : overlap;
	return overlap;
}
#endif  //USE_BANCHLESS

#endif  //BT_AABB_UTIL2





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_HULL_COMPUTER_H
#define BT_CONVEX_HULL_COMPUTER_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullComputer
{
private:
	btScalar compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp);

public:
	class Edge
	{
	private:
		int next;
		int reverse;
		int targetVertex;

		friend class btConvexHullComputer;

	public:
		int getSourceVertex() const
		{
			return (this + reverse)->targetVertex;
		}

		int getTargetVertex() const
		{
			return targetVertex;
		}

		const Edge* getNextEdgeOfVertex() const  // clockwise list of all edges of a vertex
		{
			return this + next;
		}

		const Edge* getNextEdgeOfFace() const  // counter-clockwise list of all edges of a face
		{
			return (this + reverse)->getNextEdgeOfVertex();
		}

		const Edge* getReverseEdge() const
		{
			return this + reverse;
		}
	};

	// Vertices of the output hull
	btAlignedObjectArray<btVector3> vertices;

	// The original vertex index in the input coords array
	btAlignedObjectArray<int> original_vertex_index;

	// Edges of the output hull
	btAlignedObjectArray<Edge> edges;

	// Faces of the convex hull. Each entry is an index into the "edges" array pointing to an edge of the face. Faces are planar n-gons
	btAlignedObjectArray<int> faces;

	/*
		Compute convex hull of "count" vertices stored in "coords". "stride" is the difference in bytes
		between the addresses of consecutive vertices. If "shrink" is positive, the convex hull is shrunken
		by that amount (each face is moved by "shrink" length units towards the center along its normal).
		If "shrinkClamp" is positive, "shrink" is clamped to not exceed "shrinkClamp * innerRadius", where "innerRadius"
		is the minimum distance of a face to the center of the convex hull.

		The returned value is the amount by which the hull has been shrunken. If it is negative, the amount was so large
		that the resulting convex hull is empty.

		The output convex hull can be found in the member variables "vertices", "edges", "faces".
		*/
	btScalar compute(const float* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, false, stride, count, shrink, shrinkClamp);
	}

	// same as above, but double precision
	btScalar compute(const double* coords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
	{
		return compute(coords, true, stride, count, shrink, shrinkClamp);
	}
};

#endif  //BT_CONVEX_HULL_COMPUTER_H





/*
Copyright (c) 2011 Ole Kniemeyer, MAXON, www.maxon.net

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/


#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btVector3.h"

#ifdef __GNUC__
#elif defined(_MSC_VER)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
typedef int int32_t;
typedef long long int int64_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
#endif

//The definition of USE_X86_64_ASM is moved into the build system. You can enable it manually by commenting out the following lines
//#if (defined(__GNUC__) && defined(__x86_64__) && !defined(__ICL))  // || (defined(__ICL) && defined(_M_X64))   bug in Intel compiler, disable inline assembly
//	#define USE_X86_64_ASM
//#endif

//#define DEBUG_CONVEX_HULL
//#define SHOW_ITERATIONS

#if defined(DEBUG_CONVEX_HULL) || defined(SHOW_ITERATIONS)
#endif

// Convex hull implementation based on Preparata and Hong
// Ole Kniemeyer, MAXON Computer GmbH
class btConvexHullInternal
{
public:
	class Point64
	{
	public:
		int64_t x;
		int64_t y;
		int64_t z;

		Point64(int64_t x, int64_t y, int64_t z) : x(x), y(y), z(z)
		{
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}
	};

	class Point32
	{
	public:
		int32_t x;
		int32_t y;
		int32_t z;
		int index;

		Point32()
		{
		}

		Point32(int32_t x, int32_t y, int32_t z) : x(x), y(y), z(z), index(-1)
		{
		}

		bool operator==(const Point32& b) const
		{
			return (x == b.x) && (y == b.y) && (z == b.z);
		}

		bool operator!=(const Point32& b) const
		{
			return (x != b.x) || (y != b.y) || (z != b.z);
		}

		bool isZero()
		{
			return (x == 0) && (y == 0) && (z == 0);
		}

		Point64 cross(const Point32& b) const
		{
			return Point64(((int64_t)y) * b.z - ((int64_t)z) * b.y, ((int64_t)z) * b.x - ((int64_t)x) * b.z, ((int64_t)x) * b.y - ((int64_t)y) * b.x);
		}

		Point64 cross(const Point64& b) const
		{
			return Point64(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x);
		}

		int64_t dot(const Point32& b) const
		{
			return ((int64_t)x) * b.x + ((int64_t)y) * b.y + ((int64_t)z) * b.z;
		}

		int64_t dot(const Point64& b) const
		{
			return x * b.x + y * b.y + z * b.z;
		}

		Point32 operator+(const Point32& b) const
		{
			return Point32(x + b.x, y + b.y, z + b.z);
		}

		Point32 operator-(const Point32& b) const
		{
			return Point32(x - b.x, y - b.y, z - b.z);
		}
	};

	class Int128
	{
	public:
		uint64_t low;
		uint64_t high;

		Int128()
		{
		}

		Int128(uint64_t low, uint64_t high) : low(low), high(high)
		{
		}

		Int128(uint64_t low) : low(low), high(0)
		{
		}

		Int128(int64_t value) : low(value), high((value >= 0) ? 0 : (uint64_t)-1LL)
		{
		}

		static Int128 mul(int64_t a, int64_t b);

		static Int128 mul(uint64_t a, uint64_t b);

		Int128 operator-() const
		{
			return Int128((uint64_t) - (int64_t)low, ~high + (low == 0));
		}

		Int128 operator+(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			uint64_t lo = low + b.low;
			return Int128(lo, high + b.high + (lo < low));
#endif
		}

		Int128 operator-(const Int128& b) const
		{
#ifdef USE_X86_64_ASM
			Int128 result;
			__asm__(
				"subq %[bl], %[rl]\n\t"
				"sbbq %[bh], %[rh]\n\t"
				: [rl] "=r"(result.low), [rh] "=r"(result.high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
			return result;
#else
			return *this + -b;
#endif
		}

		Int128& operator+=(const Int128& b)
		{
#ifdef USE_X86_64_ASM
			__asm__(
				"addq %[bl], %[rl]\n\t"
				"adcq %[bh], %[rh]\n\t"
				: [rl] "=r"(low), [rh] "=r"(high)
				: "0"(low), "1"(high), [bl] "g"(b.low), [bh] "g"(b.high)
				: "cc");
#else
			uint64_t lo = low + b.low;
			if (lo < low)
			{
				++high;
			}
			low = lo;
			high += b.high;
#endif
			return *this;
		}

		Int128& operator++()
		{
			if (++low == 0)
			{
				++high;
			}
			return *this;
		}

		Int128 operator*(int64_t b) const;

		btScalar toScalar() const
		{
			return ((int64_t)high >= 0) ? btScalar(high) * (btScalar(0x100000000LL) * btScalar(0x100000000LL)) + btScalar(low)
										: -(-*this).toScalar();
		}

		int getSign() const
		{
			return ((int64_t)high < 0) ? -1 : (high || low) ? 1 : 0;
		}

		bool operator<(const Int128& b) const
		{
			return (high < b.high) || ((high == b.high) && (low < b.low));
		}

		int ucmp(const Int128& b) const
		{
			if (high < b.high)
			{
				return -1;
			}
			if (high > b.high)
			{
				return 1;
			}
			if (low < b.low)
			{
				return -1;
			}
			if (low > b.low)
			{
				return 1;
			}
			return 0;
		}
	};

	class Rational64
	{
	private:
		uint64_t m_numerator;
		uint64_t m_denominator;
		int sign;

	public:
		Rational64(int64_t numerator, int64_t denominator)
		{
			if (numerator > 0)
			{
				sign = 1;
				m_numerator = (uint64_t)numerator;
			}
			else if (numerator < 0)
			{
				sign = -1;
				m_numerator = (uint64_t)-numerator;
			}
			else
			{
				sign = 0;
				m_numerator = 0;
			}
			if (denominator > 0)
			{
				m_denominator = (uint64_t)denominator;
			}
			else if (denominator < 0)
			{
				sign = -sign;
				m_denominator = (uint64_t)-denominator;
			}
			else
			{
				m_denominator = 0;
			}
		}

		bool isNegativeInfinity() const
		{
			return (sign < 0) && (m_denominator == 0);
		}

		bool isNaN() const
		{
			return (sign == 0) && (m_denominator == 0);
		}

		int compare(const Rational64& b) const;

		btScalar toScalar() const
		{
			return sign * ((m_denominator == 0) ? SIMD_INFINITY : (btScalar)m_numerator / m_denominator);
		}
	};

	class Rational128
	{
	private:
		Int128 numerator;
		Int128 denominator;
		int sign;
		bool isInt64;

	public:
		Rational128(int64_t value)
		{
			if (value > 0)
			{
				sign = 1;
				this->numerator = value;
			}
			else if (value < 0)
			{
				sign = -1;
				this->numerator = -value;
			}
			else
			{
				sign = 0;
				this->numerator = (uint64_t)0;
			}
			this->denominator = (uint64_t)1;
			isInt64 = true;
		}

		Rational128(const Int128& numerator, const Int128& denominator)
		{
			sign = numerator.getSign();
			if (sign >= 0)
			{
				this->numerator = numerator;
			}
			else
			{
				this->numerator = -numerator;
			}
			int dsign = denominator.getSign();
			if (dsign >= 0)
			{
				this->denominator = denominator;
			}
			else
			{
				sign = -sign;
				this->denominator = -denominator;
			}
			isInt64 = false;
		}

		int compare(const Rational128& b) const;

		int compare(int64_t b) const;

		btScalar toScalar() const
		{
			return sign * ((denominator.getSign() == 0) ? SIMD_INFINITY : numerator.toScalar() / denominator.toScalar());
		}
	};

	class PointR128
	{
	public:
		Int128 x;
		Int128 y;
		Int128 z;
		Int128 denominator;

		PointR128()
		{
		}

		PointR128(Int128 x, Int128 y, Int128 z, Int128 denominator) : x(x), y(y), z(z), denominator(denominator)
		{
		}

		btScalar xvalue() const
		{
			return x.toScalar() / denominator.toScalar();
		}

		btScalar yvalue() const
		{
			return y.toScalar() / denominator.toScalar();
		}

		btScalar zvalue() const
		{
			return z.toScalar() / denominator.toScalar();
		}
	};

	class Edge;
	class Face;

	class Vertex
	{
	public:
		Vertex* next;
		Vertex* prev;
		Edge* edges;
		Face* firstNearbyFace;
		Face* lastNearbyFace;
		PointR128 point128;
		Point32 point;
		int copy;

		Vertex() : next(NULL), prev(NULL), edges(NULL), firstNearbyFace(NULL), lastNearbyFace(NULL), copy(-1)
		{
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("V%d (%d, %d, %d)", point.index, point.x, point.y, point.z);
		}

		void printGraph();
#endif

		Point32 operator-(const Vertex& b) const
		{
			return point - b.point;
		}

		Rational128 dot(const Point64& b) const
		{
			return (point.index >= 0) ? Rational128(point.dot(b))
									  : Rational128(point128.x * b.x + point128.y * b.y + point128.z * b.z, point128.denominator);
		}

		btScalar xvalue() const
		{
			return (point.index >= 0) ? btScalar(point.x) : point128.xvalue();
		}

		btScalar yvalue() const
		{
			return (point.index >= 0) ? btScalar(point.y) : point128.yvalue();
		}

		btScalar zvalue() const
		{
			return (point.index >= 0) ? btScalar(point.z) : point128.zvalue();
		}

		void receiveNearbyFaces(Vertex* src)
		{
			if (lastNearbyFace)
			{
				lastNearbyFace->nextWithSameNearbyVertex = src->firstNearbyFace;
			}
			else
			{
				firstNearbyFace = src->firstNearbyFace;
			}
			if (src->lastNearbyFace)
			{
				lastNearbyFace = src->lastNearbyFace;
			}
			for (Face* f = src->firstNearbyFace; f; f = f->nextWithSameNearbyVertex)
			{
				btAssert(f->nearbyVertex == src);
				f->nearbyVertex = this;
			}
			src->firstNearbyFace = NULL;
			src->lastNearbyFace = NULL;
		}
	};

	class Edge
	{
	public:
		Edge* next;
		Edge* prev;
		Edge* reverse;
		Vertex* target;
		Face* face;
		int copy;

		~Edge()
		{
			next = NULL;
			prev = NULL;
			reverse = NULL;
			target = NULL;
			face = NULL;
		}

		void link(Edge* n)
		{
			btAssert(reverse->target == n->reverse->target);
			next = n;
			n->prev = this;
		}

#ifdef DEBUG_CONVEX_HULL
		void print()
		{
			printf("E%p : %d -> %d,  n=%p p=%p   (0 %d\t%d\t%d) -> (%d %d %d)", this, reverse->target->point.index, target->point.index, next, prev,
				   reverse->target->point.x, reverse->target->point.y, reverse->target->point.z, target->point.x, target->point.y, target->point.z);
		}
#endif
	};

	class Face
	{
	public:
		Face* next;
		Vertex* nearbyVertex;
		Face* nextWithSameNearbyVertex;
		Point32 origin;
		Point32 dir0;
		Point32 dir1;

		Face() : next(NULL), nearbyVertex(NULL), nextWithSameNearbyVertex(NULL)
		{
		}

		void init(Vertex* a, Vertex* b, Vertex* c)
		{
			nearbyVertex = a;
			origin = a->point;
			dir0 = *b - *a;
			dir1 = *c - *a;
			if (a->lastNearbyFace)
			{
				a->lastNearbyFace->nextWithSameNearbyVertex = this;
			}
			else
			{
				a->firstNearbyFace = this;
			}
			a->lastNearbyFace = this;
		}

		Point64 getNormal()
		{
			return dir0.cross(dir1);
		}
	};

	template <typename UWord, typename UHWord>
	class DMul
	{
	private:
		static uint32_t high(uint64_t value)
		{
			return (uint32_t)(value >> 32);
		}

		static uint32_t low(uint64_t value)
		{
			return (uint32_t)value;
		}

		static uint64_t mul(uint32_t a, uint32_t b)
		{
			return (uint64_t)a * (uint64_t)b;
		}

		static void shlHalf(uint64_t& value)
		{
			value <<= 32;
		}

		static uint64_t high(Int128 value)
		{
			return value.high;
		}

		static uint64_t low(Int128 value)
		{
			return value.low;
		}

		static Int128 mul(uint64_t a, uint64_t b)
		{
			return Int128::mul(a, b);
		}

		static void shlHalf(Int128& value)
		{
			value.high = value.low;
			value.low = 0;
		}

	public:
		static void mul(UWord a, UWord b, UWord& resLow, UWord& resHigh)
		{
			UWord p00 = mul(low(a), low(b));
			UWord p01 = mul(low(a), high(b));
			UWord p10 = mul(high(a), low(b));
			UWord p11 = mul(high(a), high(b));
			UWord p0110 = UWord(low(p01)) + UWord(low(p10));
			p11 += high(p01);
			p11 += high(p10);
			p11 += high(p0110);
			shlHalf(p0110);
			p00 += p0110;
			if (p00 < p0110)
			{
				++p11;
			}
			resLow = p00;
			resHigh = p11;
		}
	};

private:
	class IntermediateHull
	{
	public:
		Vertex* minXy;
		Vertex* maxXy;
		Vertex* minYx;
		Vertex* maxYx;

		IntermediateHull() : minXy(NULL), maxXy(NULL), minYx(NULL), maxYx(NULL)
		{
		}

		void print();
	};

	enum Orientation
	{
		NONE,
		CLOCKWISE,
		COUNTER_CLOCKWISE
	};

	template <typename T>
	class PoolArray
	{
	private:
		T* array;
		int size;

	public:
		PoolArray<T>* next;

		PoolArray(int size) : size(size), next(NULL)
		{
			array = (T*)btAlignedAlloc(sizeof(T) * size, 16);
		}

		~PoolArray()
		{
			btAlignedFree(array);
		}

		T* init()
		{
			T* o = array;
			for (int i = 0; i < size; i++, o++)
			{
				o->next = (i + 1 < size) ? o + 1 : NULL;
			}
			return array;
		}
	};

	template <typename T>
	class Pool
	{
	private:
		PoolArray<T>* arrays;
		PoolArray<T>* nextArray;
		T* freeObjects;
		int arraySize;

	public:
		Pool() : arrays(NULL), nextArray(NULL), freeObjects(NULL), arraySize(256)
		{
		}

		~Pool()
		{
			while (arrays)
			{
				PoolArray<T>* p = arrays;
				arrays = p->next;
				p->~PoolArray<T>();
				btAlignedFree(p);
			}
		}

		void reset()
		{
			nextArray = arrays;
			freeObjects = NULL;
		}

		void setArraySize(int arraySize)
		{
			this->arraySize = arraySize;
		}

		T* newObject()
		{
			T* o = freeObjects;
			if (!o)
			{
				PoolArray<T>* p = nextArray;
				if (p)
				{
					nextArray = p->next;
				}
				else
				{
					p = new (btAlignedAlloc(sizeof(PoolArray<T>), 16)) PoolArray<T>(arraySize);
					p->next = arrays;
					arrays = p;
				}
				o = p->init();
			}
			freeObjects = o->next;
			return new (o) T();
		};

		void freeObject(T* object)
		{
			object->~T();
			object->next = freeObjects;
			freeObjects = object;
		}
	};

	btVector3 scaling;
	btVector3 center;
	Pool<Vertex> vertexPool;
	Pool<Edge> edgePool;
	Pool<Face> facePool;
	btAlignedObjectArray<Vertex*> originalVertices;
	int mergeStamp;
	int minAxis;
	int medAxis;
	int maxAxis;
	int usedEdgePairs;
	int maxUsedEdgePairs;

	static Orientation getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t);
	Edge* findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot);
	void findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1);

	Edge* newEdgePair(Vertex* from, Vertex* to);

	void removeEdgePair(Edge* edge)
	{
		Edge* n = edge->next;
		Edge* r = edge->reverse;

		btAssert(edge->target && r->target);

		if (n != edge)
		{
			n->prev = edge->prev;
			edge->prev->next = n;
			r->target->edges = n;
		}
		else
		{
			r->target->edges = NULL;
		}

		n = r->next;

		if (n != r)
		{
			n->prev = r->prev;
			r->prev->next = n;
			edge->target->edges = n;
		}
		else
		{
			edge->target->edges = NULL;
		}

		edgePool.freeObject(edge);
		edgePool.freeObject(r);
		usedEdgePairs--;
	}

	void computeInternal(int start, int end, IntermediateHull& result);

	bool mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1);

	void merge(IntermediateHull& h0, IntermediateHull& h1);

	btVector3 toBtVector(const Point32& v);

	btVector3 getBtNormal(Face* face);

	bool shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack);

public:
	Vertex* vertexList;

	void compute(const void* coords, bool doubleCoords, int stride, int count);

	btVector3 getCoordinates(const Vertex* v);

	btScalar shrink(btScalar amount, btScalar clampAmount);
};

btConvexHullInternal::Int128 btConvexHullInternal::Int128::operator*(int64_t b) const
{
	bool negative = (int64_t)high < 0;
	Int128 a = negative ? -*this : *this;
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	Int128 result = mul(a.low, (uint64_t)b);
	result.high += a.high * (uint64_t)b;
	return negative ? -result : result;
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(int64_t a, int64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("imulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");
	return result;

#else
	bool negative = a < 0;
	if (negative)
	{
		a = -a;
	}
	if (b < 0)
	{
		negative = !negative;
		b = -b;
	}
	DMul<uint64_t, uint32_t>::mul((uint64_t)a, (uint64_t)b, result.low, result.high);
	return negative ? -result : result;
#endif
}

btConvexHullInternal::Int128 btConvexHullInternal::Int128::mul(uint64_t a, uint64_t b)
{
	Int128 result;

#ifdef USE_X86_64_ASM
	__asm__("mulq %[b]"
			: "=a"(result.low), "=d"(result.high)
			: "0"(a), [b] "r"(b)
			: "cc");

#else
	DMul<uint64_t, uint32_t>::mul(a, b, result.low, result.high);
#endif

	return result;
}

int btConvexHullInternal::Rational64::compare(const Rational64& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}

	//	return (numerator * b.denominator > b.numerator * denominator) ? sign : (numerator * b.denominator < b.numerator * denominator) ? -sign : 0;

#ifdef USE_X86_64_ASM

	int result;
	int64_t tmp;
	int64_t dummy;
	__asm__(
		"mulq %[bn]\n\t"
		"movq %%rax, %[tmp]\n\t"
		"movq %%rdx, %%rbx\n\t"
		"movq %[tn], %%rax\n\t"
		"mulq %[bd]\n\t"
		"subq %[tmp], %%rax\n\t"
		"sbbq %%rbx, %%rdx\n\t"  // rdx:rax contains 128-bit-difference "numerator*b.denominator - b.numerator*denominator"
		"setnsb %%bh\n\t"        // bh=1 if difference is non-negative, bh=0 otherwise
		"orq %%rdx, %%rax\n\t"
		"setnzb %%bl\n\t"      // bl=1 if difference if non-zero, bl=0 if it is zero
		"decb %%bh\n\t"        // now bx=0x0000 if difference is zero, 0xff01 if it is negative, 0x0001 if it is positive (i.e., same sign as difference)
		"shll $16, %%ebx\n\t"  // ebx has same sign as difference
		: "=&b"(result), [tmp] "=&r"(tmp), "=a"(dummy)
		: "a"(m_denominator), [bn] "g"(b.m_numerator), [tn] "g"(m_numerator), [bd] "g"(b.m_denominator)
		: "%rdx", "cc");
	return result ? result ^ sign  // if sign is +1, only bit 0 of result is inverted, which does not change the sign of result (and cannot result in zero)
								   // if sign is -1, all bits of result are inverted, which changes the sign of result (and again cannot result in zero)
				  : 0;

#else

	return sign * Int128::mul(m_numerator, b.m_denominator).ucmp(Int128::mul(m_denominator, b.m_numerator));

#endif
}

int btConvexHullInternal::Rational128::compare(const Rational128& b) const
{
	if (sign != b.sign)
	{
		return sign - b.sign;
	}
	else if (sign == 0)
	{
		return 0;
	}
	if (isInt64)
	{
		return -b.compare(sign * (int64_t)numerator.low);
	}

	Int128 nbdLow, nbdHigh, dbnLow, dbnHigh;
	DMul<Int128, uint64_t>::mul(numerator, b.denominator, nbdLow, nbdHigh);
	DMul<Int128, uint64_t>::mul(denominator, b.numerator, dbnLow, dbnHigh);

	int cmp = nbdHigh.ucmp(dbnHigh);
	if (cmp)
	{
		return cmp * sign;
	}
	return nbdLow.ucmp(dbnLow) * sign;
}

int btConvexHullInternal::Rational128::compare(int64_t b) const
{
	if (isInt64)
	{
		int64_t a = sign * (int64_t)numerator.low;
		return (a > b) ? 1 : (a < b) ? -1 : 0;
	}
	if (b > 0)
	{
		if (sign <= 0)
		{
			return -1;
		}
	}
	else if (b < 0)
	{
		if (sign >= 0)
		{
			return 1;
		}
		b = -b;
	}
	else
	{
		return sign;
	}

	return numerator.ucmp(denominator * b) * sign;
}

btConvexHullInternal::Edge* btConvexHullInternal::newEdgePair(Vertex* from, Vertex* to)
{
	btAssert(from && to);
	Edge* e = edgePool.newObject();
	Edge* r = edgePool.newObject();
	e->reverse = r;
	r->reverse = e;
	e->copy = mergeStamp;
	r->copy = mergeStamp;
	e->target = to;
	r->target = from;
	e->face = NULL;
	r->face = NULL;
	usedEdgePairs++;
	if (usedEdgePairs > maxUsedEdgePairs)
	{
		maxUsedEdgePairs = usedEdgePairs;
	}
	return e;
}

bool btConvexHullInternal::mergeProjection(IntermediateHull& h0, IntermediateHull& h1, Vertex*& c0, Vertex*& c1)
{
	Vertex* v0 = h0.maxYx;
	Vertex* v1 = h1.minYx;
	if ((v0->point.x == v1->point.x) && (v0->point.y == v1->point.y))
	{
		btAssert(v0->point.z < v1->point.z);
		Vertex* v1p = v1->prev;
		if (v1p == v1)
		{
			c0 = v0;
			if (v1->edges)
			{
				btAssert(v1->edges->next == v1->edges);
				v1 = v1->edges->target;
				btAssert(v1->edges->next == v1->edges);
			}
			c1 = v1;
			return false;
		}
		Vertex* v1n = v1->next;
		v1p->next = v1n;
		v1n->prev = v1p;
		if (v1 == h1.minXy)
		{
			if ((v1n->point.x < v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y < v1p->point.y)))
			{
				h1.minXy = v1n;
			}
			else
			{
				h1.minXy = v1p;
			}
		}
		if (v1 == h1.maxXy)
		{
			if ((v1n->point.x > v1p->point.x) || ((v1n->point.x == v1p->point.x) && (v1n->point.y > v1p->point.y)))
			{
				h1.maxXy = v1n;
			}
			else
			{
				h1.maxXy = v1p;
			}
		}
	}

	v0 = h0.maxXy;
	v1 = h1.maxXy;
	Vertex* v00 = NULL;
	Vertex* v10 = NULL;
	int32_t sign = 1;

	for (int side = 0; side <= 1; side++)
	{
		int32_t dx = (v1->point.x - v0->point.x) * sign;
		if (dx > 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w0 = side ? v0->next : v0->prev;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					if ((dy0 <= 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx <= dy * dx0))))
					{
						v0 = w0;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w1 = side ? v1->next : v1->prev;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					int32_t dxn = (w1->point.x - v0->point.x) * sign;
					if ((dxn > 0) && (dy1 < 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx < dy * dx1))))
					{
						v1 = w1;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else if (dx < 0)
		{
			while (true)
			{
				int32_t dy = v1->point.y - v0->point.y;

				Vertex* w1 = side ? v1->prev : v1->next;
				if (w1 != v1)
				{
					int32_t dx1 = (w1->point.x - v1->point.x) * sign;
					int32_t dy1 = w1->point.y - v1->point.y;
					if ((dy1 >= 0) && ((dx1 == 0) || ((dx1 < 0) && (dy1 * dx <= dy * dx1))))
					{
						v1 = w1;
						dx = (v1->point.x - v0->point.x) * sign;
						continue;
					}
				}

				Vertex* w0 = side ? v0->prev : v0->next;
				if (w0 != v0)
				{
					int32_t dx0 = (w0->point.x - v0->point.x) * sign;
					int32_t dy0 = w0->point.y - v0->point.y;
					int32_t dxn = (v1->point.x - w0->point.x) * sign;
					if ((dxn < 0) && (dy0 > 0) && ((dx0 == 0) || ((dx0 < 0) && (dy0 * dx < dy * dx0))))
					{
						v0 = w0;
						dx = dxn;
						continue;
					}
				}

				break;
			}
		}
		else
		{
			int32_t x = v0->point.x;
			int32_t y0 = v0->point.y;
			Vertex* w0 = v0;
			Vertex* t;
			while (((t = side ? w0->next : w0->prev) != v0) && (t->point.x == x) && (t->point.y <= y0))
			{
				w0 = t;
				y0 = t->point.y;
			}
			v0 = w0;

			int32_t y1 = v1->point.y;
			Vertex* w1 = v1;
			while (((t = side ? w1->prev : w1->next) != v1) && (t->point.x == x) && (t->point.y >= y1))
			{
				w1 = t;
				y1 = t->point.y;
			}
			v1 = w1;
		}

		if (side == 0)
		{
			v00 = v0;
			v10 = v1;

			v0 = h0.minXy;
			v1 = h1.minXy;
			sign = -1;
		}
	}

	v0->prev = v1;
	v1->next = v0;

	v00->next = v10;
	v10->prev = v00;

	if (h1.minXy->point.x < h0.minXy->point.x)
	{
		h0.minXy = h1.minXy;
	}
	if (h1.maxXy->point.x >= h0.maxXy->point.x)
	{
		h0.maxXy = h1.maxXy;
	}

	h0.maxYx = h1.maxYx;

	c0 = v00;
	c1 = v10;

	return true;
}

void btConvexHullInternal::computeInternal(int start, int end, IntermediateHull& result)
{
	int n = end - start;
	switch (n)
	{
		case 0:
			result.minXy = NULL;
			result.maxXy = NULL;
			result.minYx = NULL;
			result.maxYx = NULL;
			return;
		case 2:
		{
			Vertex* v = originalVertices[start];
			Vertex* w = v + 1;
			if (v->point != w->point)
			{
				int32_t dx = v->point.x - w->point.x;
				int32_t dy = v->point.y - w->point.y;

				if ((dx == 0) && (dy == 0))
				{
					if (v->point.z > w->point.z)
					{
						Vertex* t = w;
						w = v;
						v = t;
					}
					btAssert(v->point.z < w->point.z);
					v->next = v;
					v->prev = v;
					result.minXy = v;
					result.maxXy = v;
					result.minYx = v;
					result.maxYx = v;
				}
				else
				{
					v->next = w;
					v->prev = w;
					w->next = v;
					w->prev = v;

					if ((dx < 0) || ((dx == 0) && (dy < 0)))
					{
						result.minXy = v;
						result.maxXy = w;
					}
					else
					{
						result.minXy = w;
						result.maxXy = v;
					}

					if ((dy < 0) || ((dy == 0) && (dx < 0)))
					{
						result.minYx = v;
						result.maxYx = w;
					}
					else
					{
						result.minYx = w;
						result.maxYx = v;
					}
				}

				Edge* e = newEdgePair(v, w);
				e->link(e);
				v->edges = e;

				e = e->reverse;
				e->link(e);
				w->edges = e;

				return;
			}
			{
				Vertex* v = originalVertices[start];
				v->edges = NULL;
				v->next = v;
				v->prev = v;

				result.minXy = v;
				result.maxXy = v;
				result.minYx = v;
				result.maxYx = v;
			}

			return;
		}

		case 1:
		{
			Vertex* v = originalVertices[start];
			v->edges = NULL;
			v->next = v;
			v->prev = v;

			result.minXy = v;
			result.maxXy = v;
			result.minYx = v;
			result.maxYx = v;

			return;
		}
	}

	int split0 = start + n / 2;
	Point32 p = originalVertices[split0 - 1]->point;
	int split1 = split0;
	while ((split1 < end) && (originalVertices[split1]->point == p))
	{
		split1++;
	}
	computeInternal(start, split0, result);
	IntermediateHull hull1;
	computeInternal(split1, end, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n\nMerge\n");
	result.print();
	hull1.print();
#endif
	merge(result, hull1);
#ifdef DEBUG_CONVEX_HULL
	printf("\n  Result\n");
	result.print();
#endif
}

#ifdef DEBUG_CONVEX_HULL
void btConvexHullInternal::IntermediateHull::print()
{
	printf("    Hull\n");
	for (Vertex* v = minXy; v;)
	{
		printf("      ");
		v->print();
		if (v == maxXy)
		{
			printf(" maxXy");
		}
		if (v == minYx)
		{
			printf(" minYx");
		}
		if (v == maxYx)
		{
			printf(" maxYx");
		}
		if (v->next->prev != v)
		{
			printf(" Inconsistency");
		}
		printf("\n");
		v = v->next;
		if (v == minXy)
		{
			break;
		}
	}
	if (minXy)
	{
		minXy->copy = (minXy->copy == -1) ? -2 : -1;
		minXy->printGraph();
	}
}

void btConvexHullInternal::Vertex::printGraph()
{
	print();
	printf("\nEdges\n");
	Edge* e = edges;
	if (e)
	{
		do
		{
			e->print();
			printf("\n");
			e = e->next;
		} while (e != edges);
		do
		{
			Vertex* v = e->target;
			if (v->copy != copy)
			{
				v->copy = copy;
				v->printGraph();
			}
			e = e->next;
		} while (e != edges);
	}
}
#endif

btConvexHullInternal::Orientation btConvexHullInternal::getOrientation(const Edge* prev, const Edge* next, const Point32& s, const Point32& t)
{
	btAssert(prev->reverse->target == next->reverse->target);
	if (prev->next == next)
	{
		if (prev->prev == next)
		{
			Point64 n = t.cross(s);
			Point64 m = (*prev->target - *next->reverse->target).cross(*next->target - *next->reverse->target);
			btAssert(!m.isZero());
			int64_t dot = n.dot(m);
			btAssert(dot != 0);
			return (dot > 0) ? COUNTER_CLOCKWISE : CLOCKWISE;
		}
		return COUNTER_CLOCKWISE;
	}
	else if (prev->prev == next)
	{
		return CLOCKWISE;
	}
	else
	{
		return NONE;
	}
}

btConvexHullInternal::Edge* btConvexHullInternal::findMaxAngle(bool ccw, const Vertex* start, const Point32& s, const Point64& rxs, const Point64& sxrxs, Rational64& minCot)
{
	Edge* minEdge = NULL;

#ifdef DEBUG_CONVEX_HULL
	printf("find max edge for %d\n", start->point.index);
#endif
	Edge* e = start->edges;
	if (e)
	{
		do
		{
			if (e->copy > mergeStamp)
			{
				Point32 t = *e->target - *start;
				Rational64 cot(t.dot(sxrxs), t.dot(rxs));
#ifdef DEBUG_CONVEX_HULL
				printf("      Angle is %f (%d) for ", (float)btAtan(cot.toScalar()), (int)cot.isNaN());
				e->print();
#endif
				if (cot.isNaN())
				{
					btAssert(ccw ? (t.dot(s) < 0) : (t.dot(s) > 0));
				}
				else
				{
					int cmp;
					if (minEdge == NULL)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp = cot.compare(minCot)) < 0)
					{
						minCot = cot;
						minEdge = e;
					}
					else if ((cmp == 0) && (ccw == (getOrientation(minEdge, e, s, t) == COUNTER_CLOCKWISE)))
					{
						minEdge = e;
					}
				}
#ifdef DEBUG_CONVEX_HULL
				printf("\n");
#endif
			}
			e = e->next;
		} while (e != start->edges);
	}
	return minEdge;
}

void btConvexHullInternal::findEdgeForCoplanarFaces(Vertex* c0, Vertex* c1, Edge*& e0, Edge*& e1, Vertex* stop0, Vertex* stop1)
{
	Edge* start0 = e0;
	Edge* start1 = e1;
	Point32 et0 = start0 ? start0->target->point : c0->point;
	Point32 et1 = start1 ? start1->target->point : c1->point;
	Point32 s = c1->point - c0->point;
	Point64 normal = ((start0 ? start0 : start1)->target->point - c0->point).cross(s);
	int64_t dist = c0->point.dot(normal);
	btAssert(!start1 || (start1->target->point.dot(normal) == dist));
	Point64 perp = s.cross(normal);
	btAssert(!perp.isZero());

#ifdef DEBUG_CONVEX_HULL
	printf("   Advancing %d %d  (%p %p, %d %d)\n", c0->point.index, c1->point.index, start0, start1, start0 ? start0->target->point.index : -1, start1 ? start1->target->point.index : -1);
#endif

	int64_t maxDot0 = et0.dot(perp);
	if (e0)
	{
		while (e0->target != stop0)
		{
			Edge* e = e0->reverse->prev;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot0)
			{
				break;
			}
			maxDot0 = dot;
			e0 = e;
			et0 = e->target->point;
		}
	}

	int64_t maxDot1 = et1.dot(perp);
	if (e1)
	{
		while (e1->target != stop1)
		{
			Edge* e = e1->reverse->next;
			if (e->target->point.dot(normal) < dist)
			{
				break;
			}
			btAssert(e->target->point.dot(normal) == dist);
			if (e->copy == mergeStamp)
			{
				break;
			}
			int64_t dot = e->target->point.dot(perp);
			if (dot <= maxDot1)
			{
				break;
			}
			maxDot1 = dot;
			e1 = e;
			et1 = e->target->point;
		}
	}

#ifdef DEBUG_CONVEX_HULL
	printf("   Starting at %d %d\n", et0.index, et1.index);
#endif

	int64_t dx = maxDot1 - maxDot0;
	if (dx > 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->next->reverse;
				if (f0->copy > mergeStamp)
				{
					int64_t dx0 = (f0->target->point - et0).dot(perp);
					int64_t dy0 = (f0->target->point - et0).dot(s);
					if ((dx0 == 0) ? (dy0 < 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) >= 0)))
					{
						et0 = f0->target->point;
						dx = (et1 - et0).dot(perp);
						e0 = (e0 == start0) ? NULL : f0;
						continue;
					}
				}
			}

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->reverse->next;
				if (f1->copy > mergeStamp)
				{
					Point32 d1 = f1->target->point - et1;
					if (d1.dot(normal) == 0)
					{
						int64_t dx1 = d1.dot(perp);
						int64_t dy1 = d1.dot(s);
						int64_t dxn = (f1->target->point - et0).dot(perp);
						if ((dxn > 0) && ((dx1 == 0) ? (dy1 < 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) > 0))))
						{
							e1 = f1;
							et1 = e1->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e1 == start1) && (d1.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
	else if (dx < 0)
	{
		while (true)
		{
			int64_t dy = (et1 - et0).dot(s);

			if (e1 && (e1->target != stop1))
			{
				Edge* f1 = e1->prev->reverse;
				if (f1->copy > mergeStamp)
				{
					int64_t dx1 = (f1->target->point - et1).dot(perp);
					int64_t dy1 = (f1->target->point - et1).dot(s);
					if ((dx1 == 0) ? (dy1 > 0) : ((dx1 < 0) && (Rational64(dy1, dx1).compare(Rational64(dy, dx)) <= 0)))
					{
						et1 = f1->target->point;
						dx = (et1 - et0).dot(perp);
						e1 = (e1 == start1) ? NULL : f1;
						continue;
					}
				}
			}

			if (e0 && (e0->target != stop0))
			{
				Edge* f0 = e0->reverse->prev;
				if (f0->copy > mergeStamp)
				{
					Point32 d0 = f0->target->point - et0;
					if (d0.dot(normal) == 0)
					{
						int64_t dx0 = d0.dot(perp);
						int64_t dy0 = d0.dot(s);
						int64_t dxn = (et1 - f0->target->point).dot(perp);
						if ((dxn < 0) && ((dx0 == 0) ? (dy0 > 0) : ((dx0 < 0) && (Rational64(dy0, dx0).compare(Rational64(dy, dx)) < 0))))
						{
							e0 = f0;
							et0 = e0->target->point;
							dx = dxn;
							continue;
						}
					}
					else
					{
						btAssert((e0 == start0) && (d0.dot(normal) < 0));
					}
				}
			}

			break;
		}
	}
#ifdef DEBUG_CONVEX_HULL
	printf("   Advanced edges to %d %d\n", et0.index, et1.index);
#endif
}

void btConvexHullInternal::merge(IntermediateHull& h0, IntermediateHull& h1)
{
	if (!h1.maxXy)
	{
		return;
	}
	if (!h0.maxXy)
	{
		h0 = h1;
		return;
	}

	mergeStamp--;

	Vertex* c0 = NULL;
	Edge* toPrev0 = NULL;
	Edge* firstNew0 = NULL;
	Edge* pendingHead0 = NULL;
	Edge* pendingTail0 = NULL;
	Vertex* c1 = NULL;
	Edge* toPrev1 = NULL;
	Edge* firstNew1 = NULL;
	Edge* pendingHead1 = NULL;
	Edge* pendingTail1 = NULL;
	Point32 prevPoint;

	if (mergeProjection(h0, h1, c0, c1))
	{
		Point32 s = *c1 - *c0;
		Point64 normal = Point32(0, 0, -1).cross(s);
		Point64 t = s.cross(normal);
		btAssert(!t.isZero());

		Edge* e = c0->edges;
		Edge* start0 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c0).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c0).dot(t) > 0))
				{
					if (!start0 || (getOrientation(start0, e, s, Point32(0, 0, -1)) == CLOCKWISE))
					{
						start0 = e;
					}
				}
				e = e->next;
			} while (e != c0->edges);
		}

		e = c1->edges;
		Edge* start1 = NULL;
		if (e)
		{
			do
			{
				int64_t dot = (*e->target - *c1).dot(normal);
				btAssert(dot <= 0);
				if ((dot == 0) && ((*e->target - *c1).dot(t) > 0))
				{
					if (!start1 || (getOrientation(start1, e, s, Point32(0, 0, -1)) == COUNTER_CLOCKWISE))
					{
						start1 = e;
					}
				}
				e = e->next;
			} while (e != c1->edges);
		}

		if (start0 || start1)
		{
			findEdgeForCoplanarFaces(c0, c1, start0, start1, NULL, NULL);
			if (start0)
			{
				c0 = start0->target;
			}
			if (start1)
			{
				c1 = start1->target;
			}
		}

		prevPoint = c1->point;
		prevPoint.z++;
	}
	else
	{
		prevPoint = c1->point;
		prevPoint.x++;
	}

	Vertex* first0 = c0;
	Vertex* first1 = c1;
	bool firstRun = true;

	while (true)
	{
		Point32 s = *c1 - *c0;
		Point32 r = prevPoint - c0->point;
		Point64 rxs = r.cross(s);
		Point64 sxrxs = s.cross(rxs);

#ifdef DEBUG_CONVEX_HULL
		printf("\n  Checking %d %d\n", c0->point.index, c1->point.index);
#endif
		Rational64 minCot0(0, 0);
		Edge* min0 = findMaxAngle(false, c0, s, rxs, sxrxs, minCot0);
		Rational64 minCot1(0, 0);
		Edge* min1 = findMaxAngle(true, c1, s, rxs, sxrxs, minCot1);
		if (!min0 && !min1)
		{
			Edge* e = newEdgePair(c0, c1);
			e->link(e);
			c0->edges = e;

			e = e->reverse;
			e->link(e);
			c1->edges = e;
			return;
		}
		else
		{
			int cmp = !min0 ? 1 : !min1 ? -1 : minCot0.compare(minCot1);
#ifdef DEBUG_CONVEX_HULL
			printf("    -> Result %d\n", cmp);
#endif
			if (firstRun || ((cmp >= 0) ? !minCot1.isNegativeInfinity() : !minCot0.isNegativeInfinity()))
			{
				Edge* e = newEdgePair(c0, c1);
				if (pendingTail0)
				{
					pendingTail0->prev = e;
				}
				else
				{
					pendingHead0 = e;
				}
				e->next = pendingTail0;
				pendingTail0 = e;

				e = e->reverse;
				if (pendingTail1)
				{
					pendingTail1->next = e;
				}
				else
				{
					pendingHead1 = e;
				}
				e->prev = pendingTail1;
				pendingTail1 = e;
			}

			Edge* e0 = min0;
			Edge* e1 = min1;

#ifdef DEBUG_CONVEX_HULL
			printf("   Found min edges to %d %d\n", e0 ? e0->target->point.index : -1, e1 ? e1->target->point.index : -1);
#endif

			if (cmp == 0)
			{
				findEdgeForCoplanarFaces(c0, c1, e0, e1, NULL, NULL);
			}

			if ((cmp >= 0) && e1)
			{
				if (toPrev1)
				{
					for (Edge *e = toPrev1->next, *n = NULL; e != min1; e = n)
					{
						n = e->next;
						removeEdgePair(e);
					}
				}

				if (pendingTail1)
				{
					if (toPrev1)
					{
						toPrev1->link(pendingHead1);
					}
					else
					{
						min1->prev->link(pendingHead1);
						firstNew1 = pendingHead1;
					}
					pendingTail1->link(min1);
					pendingHead1 = NULL;
					pendingTail1 = NULL;
				}
				else if (!toPrev1)
				{
					firstNew1 = min1;
				}

				prevPoint = c1->point;
				c1 = e1->target;
				toPrev1 = e1->reverse;
			}

			if ((cmp <= 0) && e0)
			{
				if (toPrev0)
				{
					for (Edge *e = toPrev0->prev, *n = NULL; e != min0; e = n)
					{
						n = e->prev;
						removeEdgePair(e);
					}
				}

				if (pendingTail0)
				{
					if (toPrev0)
					{
						pendingHead0->link(toPrev0);
					}
					else
					{
						pendingHead0->link(min0->next);
						firstNew0 = pendingHead0;
					}
					min0->link(pendingTail0);
					pendingHead0 = NULL;
					pendingTail0 = NULL;
				}
				else if (!toPrev0)
				{
					firstNew0 = min0;
				}

				prevPoint = c0->point;
				c0 = e0->target;
				toPrev0 = e0->reverse;
			}
		}

		if ((c0 == first0) && (c1 == first1))
		{
			if (toPrev0 == NULL)
			{
				pendingHead0->link(pendingTail0);
				c0->edges = pendingTail0;
			}
			else
			{
				for (Edge *e = toPrev0->prev, *n = NULL; e != firstNew0; e = n)
				{
					n = e->prev;
					removeEdgePair(e);
				}
				if (pendingTail0)
				{
					pendingHead0->link(toPrev0);
					firstNew0->link(pendingTail0);
				}
			}

			if (toPrev1 == NULL)
			{
				pendingTail1->link(pendingHead1);
				c1->edges = pendingTail1;
			}
			else
			{
				for (Edge *e = toPrev1->next, *n = NULL; e != firstNew1; e = n)
				{
					n = e->next;
					removeEdgePair(e);
				}
				if (pendingTail1)
				{
					toPrev1->link(pendingHead1);
					pendingTail1->link(firstNew1);
				}
			}

			return;
		}

		firstRun = false;
	}
}

class pointCmp
{
public:
	bool operator()(const btConvexHullInternal::Point32& p, const btConvexHullInternal::Point32& q) const
	{
		return (p.y < q.y) || ((p.y == q.y) && ((p.x < q.x) || ((p.x == q.x) && (p.z < q.z))));
	}
};

void btConvexHullInternal::compute(const void* coords, bool doubleCoords, int stride, int count)
{
	btVector3 min(btScalar(1e30), btScalar(1e30), btScalar(1e30)), max(btScalar(-1e30), btScalar(-1e30), btScalar(-1e30));
	const char* ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			min.setMin(p);
			max.setMax(p);
		}
	}

	btVector3 s = max - min;
	maxAxis = s.maxAxis();
	minAxis = s.minAxis();
	if (minAxis == maxAxis)
	{
		minAxis = (maxAxis + 1) % 3;
	}
	medAxis = 3 - maxAxis - minAxis;

	s /= btScalar(10216);
	if (((medAxis + 1) % 3) != maxAxis)
	{
		s *= -1;
	}
	scaling = s;

	if (s[0] != 0)
	{
		s[0] = btScalar(1) / s[0];
	}
	if (s[1] != 0)
	{
		s[1] = btScalar(1) / s[1];
	}
	if (s[2] != 0)
	{
		s[2] = btScalar(1) / s[2];
	}

	center = (min + max) * btScalar(0.5);

	btAlignedObjectArray<Point32> points;
	points.resize(count);
	ptr = (const char*)coords;
	if (doubleCoords)
	{
		for (int i = 0; i < count; i++)
		{
			const double* v = (const double*)ptr;
			btVector3 p((btScalar)v[0], (btScalar)v[1], (btScalar)v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	else
	{
		for (int i = 0; i < count; i++)
		{
			const float* v = (const float*)ptr;
			btVector3 p(v[0], v[1], v[2]);
			ptr += stride;
			p = (p - center) * s;
			points[i].x = (int32_t)p[medAxis];
			points[i].y = (int32_t)p[maxAxis];
			points[i].z = (int32_t)p[minAxis];
			points[i].index = i;
		}
	}
	points.quickSort(pointCmp());

	vertexPool.reset();
	vertexPool.setArraySize(count);
	originalVertices.resize(count);
	for (int i = 0; i < count; i++)
	{
		Vertex* v = vertexPool.newObject();
		v->edges = NULL;
		v->point = points[i];
		v->copy = -1;
		originalVertices[i] = v;
	}

	points.clear();

	edgePool.reset();
	edgePool.setArraySize(6 * count);

	usedEdgePairs = 0;
	maxUsedEdgePairs = 0;

	mergeStamp = -3;

	IntermediateHull hull;
	computeInternal(0, count, hull);
	vertexList = hull.minXy;
#ifdef DEBUG_CONVEX_HULL
	printf("max. edges %d (3v = %d)", maxUsedEdgePairs, 3 * count);
#endif
}

btVector3 btConvexHullInternal::toBtVector(const Point32& v)
{
	btVector3 p;
	p[medAxis] = btScalar(v.x);
	p[maxAxis] = btScalar(v.y);
	p[minAxis] = btScalar(v.z);
	return p * scaling;
}

btVector3 btConvexHullInternal::getBtNormal(Face* face)
{
	return toBtVector(face->dir0).cross(toBtVector(face->dir1)).normalized();
}

btVector3 btConvexHullInternal::getCoordinates(const Vertex* v)
{
	btVector3 p;
	p[medAxis] = v->xvalue();
	p[maxAxis] = v->yvalue();
	p[minAxis] = v->zvalue();
	return p * scaling + center;
}

btScalar btConvexHullInternal::shrink(btScalar amount, btScalar clampAmount)
{
	if (!vertexList)
	{
		return 0;
	}
	int stamp = --mergeStamp;
	btAlignedObjectArray<Vertex*> stack;
	vertexList->copy = stamp;
	stack.push_back(vertexList);
	btAlignedObjectArray<Face*> faces;

	Point32 ref = vertexList->point;
	Int128 hullCenterX(0, 0);
	Int128 hullCenterY(0, 0);
	Int128 hullCenterZ(0, 0);
	Int128 volume(0, 0);

	while (stack.size() > 0)
	{
		Vertex* v = stack[stack.size() - 1];
		stack.pop_back();
		Edge* e = v->edges;
		if (e)
		{
			do
			{
				if (e->target->copy != stamp)
				{
					e->target->copy = stamp;
					stack.push_back(e->target);
				}
				if (e->copy != stamp)
				{
					Face* face = facePool.newObject();
					face->init(e->target, e->reverse->prev->target, v);
					faces.push_back(face);
					Edge* f = e;

					Vertex* a = NULL;
					Vertex* b = NULL;
					do
					{
						if (a && b)
						{
							int64_t vol = (v->point - ref).dot((a->point - ref).cross(b->point - ref));
							btAssert(vol >= 0);
							Point32 c = v->point + a->point + b->point + ref;
							hullCenterX += vol * c.x;
							hullCenterY += vol * c.y;
							hullCenterZ += vol * c.z;
							volume += vol;
						}

						btAssert(f->copy != stamp);
						f->copy = stamp;
						f->face = face;

						a = b;
						b = f->target;

						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != v->edges);
		}
	}

	if (volume.getSign() <= 0)
	{
		return 0;
	}

	btVector3 hullCenter;
	hullCenter[medAxis] = hullCenterX.toScalar();
	hullCenter[maxAxis] = hullCenterY.toScalar();
	hullCenter[minAxis] = hullCenterZ.toScalar();
	hullCenter /= 4 * volume.toScalar();
	hullCenter *= scaling;

	int faceCount = faces.size();

	if (clampAmount > 0)
	{
		btScalar minDist = SIMD_INFINITY;
		for (int i = 0; i < faceCount; i++)
		{
			btVector3 normal = getBtNormal(faces[i]);
			btScalar dist = normal.dot(toBtVector(faces[i]->origin) - hullCenter);
			if (dist < minDist)
			{
				minDist = dist;
			}
		}

		if (minDist <= 0)
		{
			return 0;
		}

		amount = btMin(amount, minDist * clampAmount);
	}

	unsigned int seed = 243703;
	for (int i = 0; i < faceCount; i++, seed = 1664525 * seed + 1013904223)
	{
		btSwap(faces[i], faces[seed % faceCount]);
	}

	for (int i = 0; i < faceCount; i++)
	{
		if (!shiftFace(faces[i], amount, stack))
		{
			return -amount;
		}
	}

	return amount;
}

bool btConvexHullInternal::shiftFace(Face* face, btScalar amount, btAlignedObjectArray<Vertex*> stack)
{
	btVector3 origShift = getBtNormal(face) * -amount;
	if (scaling[0] != 0)
	{
		origShift[0] /= scaling[0];
	}
	if (scaling[1] != 0)
	{
		origShift[1] /= scaling[1];
	}
	if (scaling[2] != 0)
	{
		origShift[2] /= scaling[2];
	}
	Point32 shift((int32_t)origShift[medAxis], (int32_t)origShift[maxAxis], (int32_t)origShift[minAxis]);
	if (shift.isZero())
	{
		return true;
	}
	Point64 normal = face->getNormal();
#ifdef DEBUG_CONVEX_HULL
	printf("\nShrinking face (%d %d %d) (%d %d %d) (%d %d %d) by (%d %d %d)\n",
		   face->origin.x, face->origin.y, face->origin.z, face->dir0.x, face->dir0.y, face->dir0.z, face->dir1.x, face->dir1.y, face->dir1.z, shift.x, shift.y, shift.z);
#endif
	int64_t origDot = face->origin.dot(normal);
	Point32 shiftedOrigin = face->origin + shift;
	int64_t shiftedDot = shiftedOrigin.dot(normal);
	btAssert(shiftedDot <= origDot);
	if (shiftedDot >= origDot)
	{
		return false;
	}

	Edge* intersection = NULL;

	Edge* startEdge = face->nearbyVertex->edges;
#ifdef DEBUG_CONVEX_HULL
	printf("Start edge is ");
	startEdge->print();
	printf(", normal is (%lld %lld %lld), shifted dot is %lld\n", normal.x, normal.y, normal.z, shiftedDot);
#endif
	Rational128 optDot = face->nearbyVertex->dot(normal);
	int cmp = optDot.compare(shiftedDot);
#ifdef SHOW_ITERATIONS
	int n = 0;
#endif
	if (cmp >= 0)
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving downwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) < 0)
			{
				int c = dot.compare(shiftedDot);
				optDot = dot;
				e = e->reverse;
				startEdge = e;
				if (c < 0)
				{
					intersection = e;
					break;
				}
				cmp = c;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return false;
		}
	}
	else
	{
		Edge* e = startEdge;
		do
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			Rational128 dot = e->target->dot(normal);
			btAssert(dot.compare(origDot) <= 0);
#ifdef DEBUG_CONVEX_HULL
			printf("Moving upwards, edge is ");
			e->print();
			printf(", dot is %f (%f %lld)\n", (float)dot.toScalar(), (float)optDot.toScalar(), shiftedDot);
#endif
			if (dot.compare(optDot) > 0)
			{
				cmp = dot.compare(shiftedDot);
				if (cmp >= 0)
				{
					intersection = e;
					break;
				}
				optDot = dot;
				e = e->reverse;
				startEdge = e;
			}
			e = e->prev;
		} while (e != startEdge);

		if (!intersection)
		{
			return true;
		}
	}

#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to find initial intersection\n", n);
#endif

	if (cmp == 0)
	{
		Edge* e = intersection->reverse->next;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (e->target->dot(normal).compare(shiftedDot) <= 0)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->next;
			if (e == intersection->reverse)
			{
				return true;
			}
#ifdef DEBUG_CONVEX_HULL
			printf("Checking for outwards edge, current edge is ");
			e->print();
			printf("\n");
#endif
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to check for complete containment\n", n);
#endif
	}

	Edge* firstIntersection = NULL;
	Edge* faceEdge = NULL;
	Edge* firstFaceEdge = NULL;

#ifdef SHOW_ITERATIONS
	int m = 0;
#endif
	while (true)
	{
#ifdef SHOW_ITERATIONS
		m++;
#endif
#ifdef DEBUG_CONVEX_HULL
		printf("Intersecting edge is ");
		intersection->print();
		printf("\n");
#endif
		if (cmp == 0)
		{
			Edge* e = intersection->reverse->next;
			startEdge = e;
#ifdef SHOW_ITERATIONS
			n = 0;
#endif
			while (true)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				if (e->target->dot(normal).compare(shiftedDot) >= 0)
				{
					break;
				}
				intersection = e->reverse;
				e = e->next;
				if (e == startEdge)
				{
					return true;
				}
			}
#ifdef SHOW_ITERATIONS
			printf("Needed %d iterations to advance intersection\n", n);
#endif
		}

#ifdef DEBUG_CONVEX_HULL
		printf("Advanced intersecting edge to ");
		intersection->print();
		printf(", cmp = %d\n", cmp);
#endif

		if (!firstIntersection)
		{
			firstIntersection = intersection;
		}
		else if (intersection == firstIntersection)
		{
			break;
		}

		int prevCmp = cmp;
		Edge* prevIntersection = intersection;
		Edge* prevFaceEdge = faceEdge;

		Edge* e = intersection->reverse;
#ifdef SHOW_ITERATIONS
		n = 0;
#endif
		while (true)
		{
#ifdef SHOW_ITERATIONS
			n++;
#endif
			e = e->reverse->prev;
			btAssert(e != intersection->reverse);
			cmp = e->target->dot(normal).compare(shiftedDot);
#ifdef DEBUG_CONVEX_HULL
			printf("Testing edge ");
			e->print();
			printf(" -> cmp = %d\n", cmp);
#endif
			if (cmp >= 0)
			{
				intersection = e;
				break;
			}
		}
#ifdef SHOW_ITERATIONS
		printf("Needed %d iterations to find other intersection of face\n", n);
#endif

		if (cmp > 0)
		{
			Vertex* removed = intersection->target;
			e = intersection->reverse;
			if (e->prev == e)
			{
				removed->edges = NULL;
			}
			else
			{
				removed->edges = e->prev;
				e->prev->link(e->next);
				e->link(e);
			}
#ifdef DEBUG_CONVEX_HULL
			printf("1: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif

			Point64 n0 = intersection->face->getNormal();
			Point64 n1 = intersection->reverse->face->getNormal();
			int64_t m00 = face->dir0.dot(n0);
			int64_t m01 = face->dir1.dot(n0);
			int64_t m10 = face->dir0.dot(n1);
			int64_t m11 = face->dir1.dot(n1);
			int64_t r0 = (intersection->face->origin - shiftedOrigin).dot(n0);
			int64_t r1 = (intersection->reverse->face->origin - shiftedOrigin).dot(n1);
			Int128 det = Int128::mul(m00, m11) - Int128::mul(m01, m10);
			btAssert(det.getSign() != 0);
			Vertex* v = vertexPool.newObject();
			v->point.index = -1;
			v->copy = -1;
			v->point128 = PointR128(Int128::mul(face->dir0.x * r0, m11) - Int128::mul(face->dir0.x * r1, m01) + Int128::mul(face->dir1.x * r1, m00) - Int128::mul(face->dir1.x * r0, m10) + det * shiftedOrigin.x,
									Int128::mul(face->dir0.y * r0, m11) - Int128::mul(face->dir0.y * r1, m01) + Int128::mul(face->dir1.y * r1, m00) - Int128::mul(face->dir1.y * r0, m10) + det * shiftedOrigin.y,
									Int128::mul(face->dir0.z * r0, m11) - Int128::mul(face->dir0.z * r1, m01) + Int128::mul(face->dir1.z * r1, m00) - Int128::mul(face->dir1.z * r0, m10) + det * shiftedOrigin.z,
									det);
			v->point.x = (int32_t)v->point128.xvalue();
			v->point.y = (int32_t)v->point128.yvalue();
			v->point.z = (int32_t)v->point128.zvalue();
			intersection->target = v;
			v->edges = e;

			stack.push_back(v);
			stack.push_back(removed);
			stack.push_back(NULL);
		}

		if (cmp || prevCmp || (prevIntersection->reverse->next->target != intersection->target))
		{
			faceEdge = newEdgePair(prevIntersection->target, intersection->target);
			if (prevCmp == 0)
			{
				faceEdge->link(prevIntersection->reverse->next);
			}
			if ((prevCmp == 0) || prevFaceEdge)
			{
				prevIntersection->reverse->link(faceEdge);
			}
			if (cmp == 0)
			{
				intersection->reverse->prev->link(faceEdge->reverse);
			}
			faceEdge->reverse->link(intersection->reverse);
		}
		else
		{
			faceEdge = prevIntersection->reverse->next;
		}

		if (prevFaceEdge)
		{
			if (prevCmp > 0)
			{
				faceEdge->link(prevFaceEdge->reverse);
			}
			else if (faceEdge != prevFaceEdge->reverse)
			{
				stack.push_back(prevFaceEdge->target);
				while (faceEdge->next != prevFaceEdge->reverse)
				{
					Vertex* removed = faceEdge->next->target;
					removeEdgePair(faceEdge->next);
					stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
					printf("2: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
				}
				stack.push_back(NULL);
			}
		}
		faceEdge->face = face;
		faceEdge->reverse->face = intersection->face;

		if (!firstFaceEdge)
		{
			firstFaceEdge = faceEdge;
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to process all intersections\n", m);
#endif

	if (cmp > 0)
	{
		firstFaceEdge->reverse->target = faceEdge->target;
		firstIntersection->reverse->link(firstFaceEdge);
		firstFaceEdge->link(faceEdge->reverse);
	}
	else if (firstFaceEdge != faceEdge->reverse)
	{
		stack.push_back(faceEdge->target);
		while (firstFaceEdge->next != faceEdge->reverse)
		{
			Vertex* removed = firstFaceEdge->next->target;
			removeEdgePair(firstFaceEdge->next);
			stack.push_back(removed);
#ifdef DEBUG_CONVEX_HULL
			printf("3: Removed part contains (%d %d %d)\n", removed->point.x, removed->point.y, removed->point.z);
#endif
		}
		stack.push_back(NULL);
	}

	btAssert(stack.size() > 0);
	vertexList = stack[0];

#ifdef DEBUG_CONVEX_HULL
	printf("Removing part\n");
#endif
#ifdef SHOW_ITERATIONS
	n = 0;
#endif
	int pos = 0;
	while (pos < stack.size())
	{
		int end = stack.size();
		while (pos < end)
		{
			Vertex* kept = stack[pos++];
#ifdef DEBUG_CONVEX_HULL
			kept->print();
#endif
			bool deeper = false;
			Vertex* removed;
			while ((removed = stack[pos++]) != NULL)
			{
#ifdef SHOW_ITERATIONS
				n++;
#endif
				kept->receiveNearbyFaces(removed);
				while (removed->edges)
				{
					if (!deeper)
					{
						deeper = true;
						stack.push_back(kept);
					}
					stack.push_back(removed->edges->target);
					removeEdgePair(removed->edges);
				}
			}
			if (deeper)
			{
				stack.push_back(NULL);
			}
		}
	}
#ifdef SHOW_ITERATIONS
	printf("Needed %d iterations to remove part\n", n);
#endif

	stack.resize(0);
	face->origin = shiftedOrigin;

	return true;
}

static int getVertexCopy(btConvexHullInternal::Vertex* vertex, btAlignedObjectArray<btConvexHullInternal::Vertex*>& vertices)
{
	int index = vertex->copy;
	if (index < 0)
	{
		index = vertices.size();
		vertex->copy = index;
		vertices.push_back(vertex);
#ifdef DEBUG_CONVEX_HULL
		printf("Vertex %d gets index *%d\n", vertex->point.index, index);
#endif
	}
	return index;
}

btScalar btConvexHullComputer::compute(const void* coords, bool doubleCoords, int stride, int count, btScalar shrink, btScalar shrinkClamp)
{
	if (count <= 0)
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return 0;
	}

	btConvexHullInternal hull;
	hull.compute(coords, doubleCoords, stride, count);

	btScalar shift = 0;
	if ((shrink > 0) && ((shift = hull.shrink(shrink, shrinkClamp)) < 0))
	{
		vertices.clear();
		edges.clear();
		faces.clear();
		return shift;
	}

	vertices.resize(0);
	original_vertex_index.resize(0);
	edges.resize(0);
	faces.resize(0);

	btAlignedObjectArray<btConvexHullInternal::Vertex*> oldVertices;
	getVertexCopy(hull.vertexList, oldVertices);
	int copied = 0;
	while (copied < oldVertices.size())
	{
		btConvexHullInternal::Vertex* v = oldVertices[copied];
		vertices.push_back(hull.getCoordinates(v));
		original_vertex_index.push_back(v->point.index);
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			int firstCopy = -1;
			int prevCopy = -1;
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy < 0)
				{
					int s = edges.size();
					edges.push_back(Edge());
					edges.push_back(Edge());
					Edge* c = &edges[s];
					Edge* r = &edges[s + 1];
					e->copy = s;
					e->reverse->copy = s + 1;
					c->reverse = 1;
					r->reverse = -1;
					c->targetVertex = getVertexCopy(e->target, oldVertices);
					r->targetVertex = copied;
#ifdef DEBUG_CONVEX_HULL
					printf("      CREATE: Vertex *%d has edge to *%d\n", copied, c->getTargetVertex());
#endif
				}
				if (prevCopy >= 0)
				{
					edges[e->copy].next = prevCopy - e->copy;
				}
				else
				{
					firstCopy = e->copy;
				}
				prevCopy = e->copy;
				e = e->next;
			} while (e != firstEdge);
			edges[firstCopy].next = prevCopy - firstCopy;
		}
		copied++;
	}

	for (int i = 0; i < copied; i++)
	{
		btConvexHullInternal::Vertex* v = oldVertices[i];
		btConvexHullInternal::Edge* firstEdge = v->edges;
		if (firstEdge)
		{
			btConvexHullInternal::Edge* e = firstEdge;
			do
			{
				if (e->copy >= 0)
				{
#ifdef DEBUG_CONVEX_HULL
					printf("Vertex *%d has edge to *%d\n", i, edges[e->copy].getTargetVertex());
#endif
					faces.push_back(e->copy);
					btConvexHullInternal::Edge* f = e;
					do
					{
#ifdef DEBUG_CONVEX_HULL
						printf("   Face *%d\n", edges[f->copy].getTargetVertex());
#endif
						f->copy = -1;
						f = f->reverse->prev;
					} while (f != e);
				}
				e = e->next;
			} while (e != firstEdge);
		}
	}

	return shift;
}





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_GEOMETRY_UTIL_H
#define BT_GEOMETRY_UTIL_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedObjectArray.h"

///The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
class btGeometryUtil
{
public:
	static void getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut);

	static void getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut);

	// static bool isInside(const btAlignedObjectArray<btVector3>& vertices, const btVector3& planeNormal, btScalar margin);

	static bool isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin);

	static bool areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin);
};

#endif  //BT_GEOMETRY_UTIL_H





/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btGeometryUtil.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletMathProbe();

	void btBulletMathProbe() {}
}

bool btGeometryUtil::isPointInsidePlanes(const btAlignedObjectArray<btVector3>& planeEquations, const btVector3& point, btScalar margin)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		btScalar dist = btScalar(N1.dot(point)) + btScalar(N1[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool btGeometryUtil::areVerticesBehindPlane(const btVector3& planeNormal, const btAlignedObjectArray<btVector3>& vertices, btScalar margin)
{
	int numvertices = vertices.size();
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];
		btScalar dist = btScalar(planeNormal.dot(N1)) + btScalar(planeNormal[3]) - margin;
		if (dist > btScalar(0.))
		{
			return false;
		}
	}
	return true;
}

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations);

bool notExist(const btVector3& planeEquation, const btAlignedObjectArray<btVector3>& planeEquations)
{
	int numbrushes = planeEquations.size();
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];
		if (planeEquation.dot(N1) > btScalar(0.999))
		{
			return false;
		}
	}
	return true;
}

void btGeometryUtil::getPlaneEquationsFromVertices(btAlignedObjectArray<btVector3>& vertices, btAlignedObjectArray<btVector3>& planeEquationsOut)
{
	const int numvertices = vertices.size();
	// brute force:
	for (int i = 0; i < numvertices; i++)
	{
		const btVector3& N1 = vertices[i];

		for (int j = i + 1; j < numvertices; j++)
		{
			const btVector3& N2 = vertices[j];

			for (int k = j + 1; k < numvertices; k++)
			{
				const btVector3& N3 = vertices[k];

				btVector3 planeEquation, edge0, edge1;
				edge0 = N2 - N1;
				edge1 = N3 - N1;
				btScalar normalSign = btScalar(1.);
				for (int ww = 0; ww < 2; ww++)
				{
					planeEquation = normalSign * edge0.cross(edge1);
					if (planeEquation.length2() > btScalar(0.0001))
					{
						planeEquation.normalize();
						if (notExist(planeEquation, planeEquationsOut))
						{
							planeEquation[3] = -planeEquation.dot(N1);

							//check if inside, and replace supportingVertexOut if needed
							if (areVerticesBehindPlane(planeEquation, vertices, btScalar(0.01)))
							{
								planeEquationsOut.push_back(planeEquation);
							}
						}
					}
					normalSign = btScalar(-1.);
				}
			}
		}
	}
}

void btGeometryUtil::getVerticesFromPlaneEquations(const btAlignedObjectArray<btVector3>& planeEquations, btAlignedObjectArray<btVector3>& verticesOut)
{
	const int numbrushes = planeEquations.size();
	// brute force:
	for (int i = 0; i < numbrushes; i++)
	{
		const btVector3& N1 = planeEquations[i];

		for (int j = i + 1; j < numbrushes; j++)
		{
			const btVector3& N2 = planeEquations[j];

			for (int k = j + 1; k < numbrushes; k++)
			{
				const btVector3& N3 = planeEquations[k];

				btVector3 n2n3;
				n2n3 = N2.cross(N3);
				btVector3 n3n1;
				n3n1 = N3.cross(N1);
				btVector3 n1n2;
				n1n2 = N1.cross(N2);

				if ((n2n3.length2() > btScalar(0.0001)) &&
					(n3n1.length2() > btScalar(0.0001)) &&
					(n1n2.length2() > btScalar(0.0001)))
				{
					//point P out of 3 plane equations:

					//	d1 ( N2 * N3 ) + d2 ( N3 * N1 ) + d3 ( N1 * N2 )
					//P =  -------------------------------------------------------------------------
					//   N1 . ( N2 * N3 )

					btScalar quotient = (N1.dot(n2n3));
					if (btFabs(quotient) > btScalar(0.000001))
					{
						quotient = btScalar(-1.) / quotient;
						n2n3 *= N1[3];
						n3n1 *= N2[3];
						n1n2 *= N3[3];
						btVector3 potentialVertex = n2n3;
						potentialVertex += n3n1;
						potentialVertex += n1n2;
						potentialVertex *= quotient;

						//check if inside, and replace supportingVertexOut if needed
						if (isPointInsidePlanes(planeEquations, potentialVertex, btScalar(0.01)))
						{
							verticesOut.push_back(potentialVertex);
						}
					}
				}
			}
		}
	}
}






/***************************************************************************************************
**
** Real-Time Hierarchical Profiling for Game Programming Gems 3
**
** by Greg Hjelstrom & Byon Garrabrant
**
***************************************************************************************************/

// Credits: The Clock class was inspired by the Timer classes in
// Ogre (www.ogre3d.org).

#ifndef BT_QUICK_PROF_H
#define BT_QUICK_PROF_H

#include "LinearMath/btScalar.h"
#define USE_BT_CLOCK 1

#ifdef USE_BT_CLOCK

///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
class btClock
{
public:
	btClock();

	btClock(const btClock& other);
	btClock& operator=(const btClock& other);

	~btClock();

	/// Resets the initial reference time.
	void reset();

	/// Returns the time in ms since the last call to reset or since
	/// the btClock was created.
	unsigned long long int getTimeMilliseconds();

	/// Returns the time in us since the last call to reset or since
	/// the Clock was created.
	unsigned long long int getTimeMicroseconds();

	unsigned long long int getTimeNanoseconds();

	/// Returns the time in s since the last call to reset or since
	/// the Clock was created.
	btScalar getTimeSeconds();

private:
	struct btClockData* m_data;
};

#endif  //USE_BT_CLOCK

typedef void(btEnterProfileZoneFunc)(const char* msg);
typedef void(btLeaveProfileZoneFunc)();

btEnterProfileZoneFunc* btGetCurrentEnterProfileZoneFunc();
btLeaveProfileZoneFunc* btGetCurrentLeaveProfileZoneFunc();

void btSetCustomEnterProfileZoneFunc(btEnterProfileZoneFunc* enterFunc);
void btSetCustomLeaveProfileZoneFunc(btLeaveProfileZoneFunc* leaveFunc);

#ifndef BT_ENABLE_PROFILE
#define BT_NO_PROFILE 1
#endif  //BT_NO_PROFILE

const unsigned int BT_QUICKPROF_MAX_THREAD_COUNT = 64;

//btQuickprofGetCurrentThreadIndex will return -1 if thread index cannot be determined,
//otherwise returns thread index in range [0..maxThreads]
unsigned int btQuickprofGetCurrentThreadIndex2();

#ifndef BT_NO_PROFILE



#include "LinearMath/btAlignedAllocator.h"

///A node in the Profile Hierarchy Tree
class CProfileNode
{
public:
	CProfileNode(const char* name, CProfileNode* parent);
	~CProfileNode(void);

	CProfileNode* Get_Sub_Node(const char* name);

	CProfileNode* Get_Parent(void) { return Parent; }
	CProfileNode* Get_Sibling(void) { return Sibling; }
	CProfileNode* Get_Child(void) { return Child; }

	void CleanupMemory();
	void Reset(void);
	void Call(void);
	bool Return(void);

	const char* Get_Name(void) { return Name; }
	int Get_Total_Calls(void) { return TotalCalls; }
	float Get_Total_Time(void) { return TotalTime; }
	void* GetUserPointer() const { return m_userPtr; }
	void SetUserPointer(void* ptr) { m_userPtr = ptr; }

protected:
	const char* Name;
	int TotalCalls;
	float TotalTime;
	unsigned long int StartTime;
	int RecursionCounter;

	CProfileNode* Parent;
	CProfileNode* Child;
	CProfileNode* Sibling;
	void* m_userPtr;
};

///An iterator to navigate through the tree
class CProfileIterator
{
public:
	// Access all the children of the current parent
	void First(void);
	void Next(void);
	bool Is_Done(void);
	bool Is_Root(void) { return (CurrentParent->Get_Parent() == 0); }

	void Enter_Child(int index);     // Make the given child the new parent
	void Enter_Largest_Child(void);  // Make the largest child the new parent
	void Enter_Parent(void);         // Make the current parent's parent the new parent

	// Access the current child
	const char* Get_Current_Name(void) { return CurrentChild->Get_Name(); }
	int Get_Current_Total_Calls(void) { return CurrentChild->Get_Total_Calls(); }
	float Get_Current_Total_Time(void) { return CurrentChild->Get_Total_Time(); }

	void* Get_Current_UserPointer(void) { return CurrentChild->GetUserPointer(); }
	void Set_Current_UserPointer(void* ptr) { CurrentChild->SetUserPointer(ptr); }
	// Access the current parent
	const char* Get_Current_Parent_Name(void) { return CurrentParent->Get_Name(); }
	int Get_Current_Parent_Total_Calls(void) { return CurrentParent->Get_Total_Calls(); }
	float Get_Current_Parent_Total_Time(void) { return CurrentParent->Get_Total_Time(); }

protected:
	CProfileNode* CurrentParent;
	CProfileNode* CurrentChild;

	CProfileIterator(CProfileNode* start);
	friend class CProfileManager;
};

///The Manager for the Profile system
class CProfileManager
{
public:
	static void Start_Profile(const char* name);
	static void Stop_Profile(void);

	static void CleanupMemory(void);
	//	{
	//		Root.CleanupMemory();
	//	}

	static void Reset(void);
	static void Increment_Frame_Counter(void);
	static int Get_Frame_Count_Since_Reset(void) { return FrameCounter; }
	static float Get_Time_Since_Reset(void);

	static CProfileIterator* Get_Iterator(void);
	//	{
	//
	//		return new CProfileIterator( &Root );
	//	}
	static void Release_Iterator(CProfileIterator* iterator) { delete (iterator); }

	static void dumpRecursive(CProfileIterator* profileIterator, int spacing);

	static void dumpAll();

private:
	static int FrameCounter;
	static unsigned long int ResetTime;
};

#endif  //#ifndef BT_NO_PROFILE

// ///ProfileSampleClass is a simple way to profile a function's scope
// ///Use the BT_PROFILE macro at the start of scope to time
// class CProfileSample
// {
// public:
// 	CProfileSample(const char* name);

// 	~CProfileSample(void);
// };

#define BT_PROFILE(name) printf(name)

#endif  //BT_QUICK_PROF_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_BROADPHASE_PROXY_H
#define BT_BROADPHASE_PROXY_H

#include "LinearMath/btScalar.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btAlignedAllocator.h"

/// btDispatcher uses these types
/// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
/// to facilitate type checking
/// CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
enum BroadphaseNativeTypes
{
	// polyhedral convex shapes
	BOX_SHAPE_PROXYTYPE,
	TRIANGLE_SHAPE_PROXYTYPE,
	TETRAHEDRAL_SHAPE_PROXYTYPE,
	CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE,
	CONVEX_HULL_SHAPE_PROXYTYPE,
	CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE,
	CUSTOM_POLYHEDRAL_SHAPE_TYPE,
	//implicit convex shapes
	IMPLICIT_CONVEX_SHAPES_START_HERE,
	SPHERE_SHAPE_PROXYTYPE,
	MULTI_SPHERE_SHAPE_PROXYTYPE,
	CAPSULE_SHAPE_PROXYTYPE,
	CONE_SHAPE_PROXYTYPE,
	CONVEX_SHAPE_PROXYTYPE,
	CYLINDER_SHAPE_PROXYTYPE,
	UNIFORM_SCALING_SHAPE_PROXYTYPE,
	MINKOWSKI_SUM_SHAPE_PROXYTYPE,
	MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE,
	BOX_2D_SHAPE_PROXYTYPE,
	CONVEX_2D_SHAPE_PROXYTYPE,
	CUSTOM_CONVEX_SHAPE_TYPE,
	//concave shapes
	CONCAVE_SHAPES_START_HERE,
	//keep all the convex shapetype below here, for the check IsConvexShape in broadphase proxy!
	TRIANGLE_MESH_SHAPE_PROXYTYPE,
	SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE,
	///used for demo integration FAST/Swift collision library and Bullet
	FAST_CONCAVE_MESH_PROXYTYPE,
	//terrain
	TERRAIN_SHAPE_PROXYTYPE,
	///Used for GIMPACT Trimesh integration
	GIMPACT_SHAPE_PROXYTYPE,
	///Multimaterial mesh
	MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE,

	EMPTY_SHAPE_PROXYTYPE,
	STATIC_PLANE_PROXYTYPE,
	CUSTOM_CONCAVE_SHAPE_TYPE,
	SDF_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE,
	CONCAVE_SHAPES_END_HERE,

	COMPOUND_SHAPE_PROXYTYPE,

	SOFTBODY_SHAPE_PROXYTYPE,
	HFFLUID_SHAPE_PROXYTYPE,
	HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE,
	INVALID_SHAPE_PROXYTYPE,

	MAX_BROADPHASE_COLLISION_TYPES

};

///The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
///It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
ATTRIBUTE_ALIGNED16(struct)
btBroadphaseProxy
{
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///optional filtering to cull potential collisions
	enum CollisionFilterGroups
	{
		DefaultFilter = 1,
		StaticFilter = 2,
		KinematicFilter = 4,
		DebrisFilter = 8,
		SensorTrigger = 16,
		CharacterFilter = 32,
		AllFilter = -1  //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger
	};

	//Usually the client btCollisionObject or Rigidbody class
	void* m_clientObject;
	int m_collisionFilterGroup;
	int m_collisionFilterMask;

	int m_uniqueId;  //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

	btVector3 m_aabbMin;
	btVector3 m_aabbMax;

	SIMD_FORCE_INLINE int getUid() const
	{
		return m_uniqueId;
	}

	//used for memory pools
	btBroadphaseProxy() : m_clientObject(0)
	{
	}

	btBroadphaseProxy(const btVector3& aabbMin, const btVector3& aabbMax, void* userPtr, int collisionFilterGroup, int collisionFilterMask)
		: m_clientObject(userPtr),
		  m_collisionFilterGroup(collisionFilterGroup),
		  m_collisionFilterMask(collisionFilterMask),
		  m_aabbMin(aabbMin),
		  m_aabbMax(aabbMax)
	{
	}

	static SIMD_FORCE_INLINE bool isPolyhedral(int proxyType)
	{
		return (proxyType < IMPLICIT_CONVEX_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isConvex(int proxyType)
	{
		return (proxyType < CONCAVE_SHAPES_START_HERE);
	}

	static SIMD_FORCE_INLINE bool isNonMoving(int proxyType)
	{
		return (isConcave(proxyType) && !(proxyType == GIMPACT_SHAPE_PROXYTYPE));
	}

	static SIMD_FORCE_INLINE bool isConcave(int proxyType)
	{
		return ((proxyType > CONCAVE_SHAPES_START_HERE) &&
				(proxyType < CONCAVE_SHAPES_END_HERE));
	}
	static SIMD_FORCE_INLINE bool isCompound(int proxyType)
	{
		return (proxyType == COMPOUND_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isSoftBody(int proxyType)
	{
		return (proxyType == SOFTBODY_SHAPE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isInfinite(int proxyType)
	{
		return (proxyType == STATIC_PLANE_PROXYTYPE);
	}

	static SIMD_FORCE_INLINE bool isConvex2d(int proxyType)
	{
		return (proxyType == BOX_2D_SHAPE_PROXYTYPE) || (proxyType == CONVEX_2D_SHAPE_PROXYTYPE);
	}
};

class btCollisionAlgorithm;

struct btBroadphaseProxy;

///The btBroadphasePair class contains a pair of aabb-overlapping objects.
///A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
ATTRIBUTE_ALIGNED16(struct)
btBroadphasePair
{
	btBroadphasePair()
		: m_pProxy0(0),
		  m_pProxy1(0),
		  m_algorithm(0),
		  m_internalInfo1(0)
	{
	}

	BT_DECLARE_ALIGNED_ALLOCATOR();

	btBroadphasePair(btBroadphaseProxy & proxy0, btBroadphaseProxy & proxy1)
	{
		//keep them sorted, so the std::set operations work
		if (proxy0.m_uniqueId < proxy1.m_uniqueId)
		{
			m_pProxy0 = &proxy0;
			m_pProxy1 = &proxy1;
		}
		else
		{
			m_pProxy0 = &proxy1;
			m_pProxy1 = &proxy0;
		}

		m_algorithm = 0;
		m_internalInfo1 = 0;
	}

	btBroadphaseProxy* m_pProxy0;
	btBroadphaseProxy* m_pProxy1;

	mutable btCollisionAlgorithm* m_algorithm;
	union {
		void* m_internalInfo1;
		int m_internalTmpValue;
	};  //don't use this data, it will be removed in future version.
};

/*
//comparison for set operation, see Solid DT_Encounter
SIMD_FORCE_INLINE bool operator<(const btBroadphasePair& a, const btBroadphasePair& b) 
{ 
    return a.m_pProxy0 < b.m_pProxy0 || 
        (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 < b.m_pProxy1); 
}
*/

class btBroadphasePairSortPredicate
{
public:
	bool operator()(const btBroadphasePair& a, const btBroadphasePair& b) const
	{
		const int uidA0 = a.m_pProxy0 ? a.m_pProxy0->m_uniqueId : -1;
		const int uidB0 = b.m_pProxy0 ? b.m_pProxy0->m_uniqueId : -1;
		const int uidA1 = a.m_pProxy1 ? a.m_pProxy1->m_uniqueId : -1;
		const int uidB1 = b.m_pProxy1 ? b.m_pProxy1->m_uniqueId : -1;

		return uidA0 > uidB0 ||
			   (a.m_pProxy0 == b.m_pProxy0 && uidA1 > uidB1) ||
			   (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 == b.m_pProxy1 && a.m_algorithm > b.m_algorithm);
	}
};

SIMD_FORCE_INLINE bool operator==(const btBroadphasePair& a, const btBroadphasePair& b)
{
	return (a.m_pProxy0 == b.m_pProxy0) && (a.m_pProxy1 == b.m_pProxy1);
}

#endif  //BT_BROADPHASE_PROXY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_MARGIN_H
#define BT_COLLISION_MARGIN_H

///The CONVEX_DISTANCE_MARGIN is a default collision margin for convex collision shapes derived from btConvexInternalShape.
///This collision margin is used by Gjk and some other algorithms
///Note that when creating small objects, you need to make sure to set a smaller collision margin, using the 'setMargin' API
#define CONVEX_DISTANCE_MARGIN btScalar(0.04)  // btScalar(0.1)//;//btScalar(0.01)

#endif  //BT_COLLISION_MARGIN_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_SHAPE_H
#define BT_COLLISION_SHAPE_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
class btSerializer;

///The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
ATTRIBUTE_ALIGNED16(class)
btCollisionShape
{
protected:
	int m_shapeType;
	void* m_userPointer;
	int m_userIndex;
	int m_userIndex2;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCollisionShape() : m_shapeType(INVALID_SHAPE_PROXYTYPE), m_userPointer(0), m_userIndex(-1), m_userIndex2(-1)
	{
	}

	virtual ~btCollisionShape()
	{
	}

	///getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getBoundingSphere(btVector3 & center, btScalar & radius) const;

	///getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
	virtual btScalar getAngularMotionDisc() const;

	virtual btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;

	///calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
	///result is conservative
	void calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const;

	SIMD_FORCE_INLINE bool isPolyhedral() const
	{
		return btBroadphaseProxy::isPolyhedral(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex2d() const
	{
		return btBroadphaseProxy::isConvex2d(getShapeType());
	}

	SIMD_FORCE_INLINE bool isConvex() const
	{
		return btBroadphaseProxy::isConvex(getShapeType());
	}
	SIMD_FORCE_INLINE bool isNonMoving() const
	{
		return btBroadphaseProxy::isNonMoving(getShapeType());
	}
	SIMD_FORCE_INLINE bool isConcave() const
	{
		return btBroadphaseProxy::isConcave(getShapeType());
	}
	SIMD_FORCE_INLINE bool isCompound() const
	{
		return btBroadphaseProxy::isCompound(getShapeType());
	}

	SIMD_FORCE_INLINE bool isSoftBody() const
	{
		return btBroadphaseProxy::isSoftBody(getShapeType());
	}

	///isInfinite is used to catch simulation error (aabb check)
	SIMD_FORCE_INLINE bool isInfinite() const
	{
		return btBroadphaseProxy::isInfinite(getShapeType());
	}

#ifndef __SPU__
	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const = 0;

	//debugging support
	virtual const char* getName() const = 0;
#endif  //__SPU__

	int getShapeType() const
	{
		return m_shapeType;
	}

	///the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
	///See Bullet/Demos/RollingFrictionDemo for an example
	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		return btVector3(1, 1, 1);
	}
	virtual void setMargin(btScalar margin) = 0;
	virtual btScalar getMargin() const = 0;

	///optional user data pointer
	void setUserPointer(void* userPtr)
	{
		m_userPointer = userPtr;
	}

	void* getUserPointer() const
	{
		return m_userPointer;
	}
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	virtual void serializeSingleShape(btSerializer * serializer) const;
};

// clang-format off
// parser needs * with the name
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionShapeData
{
	char	*m_name;
	int		m_shapeType;
	char	m_padding[4];
};
// clang-format on
SIMD_FORCE_INLINE int btCollisionShape::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionShapeData);
}

#endif  //BT_COLLISION_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "LinearMath/btSerializer.h"

/*
  Make sure this dummy function never changes so that it
  can be used by probes that are checking whether the
  library is actually installed.
*/
extern "C"
{
	void btBulletCollisionProbe();

	void btBulletCollisionProbe() {}
}

void btCollisionShape::getBoundingSphere(btVector3& center, btScalar& radius) const
{
	btTransform tr;
	tr.setIdentity();
	btVector3 aabbMin, aabbMax;

	getAabb(tr, aabbMin, aabbMax);

	radius = (aabbMax - aabbMin).length() * btScalar(0.5);
	center = (aabbMin + aabbMax) * btScalar(0.5);
}

btScalar btCollisionShape::getContactBreakingThreshold(btScalar defaultContactThreshold) const
{
	return getAngularMotionDisc() * defaultContactThreshold;
}

btScalar btCollisionShape::getAngularMotionDisc() const
{
	///@todo cache this value, to improve performance
	btVector3 center;
	btScalar disc;
	getBoundingSphere(center, disc);
	disc += (center).length();
	return disc;
}

void btCollisionShape::calculateTemporalAabb(const btTransform& curTrans, const btVector3& linvel, const btVector3& angvel, btScalar timeStep, btVector3& temporalAabbMin, btVector3& temporalAabbMax) const
{
	//start with static aabb
	getAabb(curTrans, temporalAabbMin, temporalAabbMax);

	btScalar temporalAabbMaxx = temporalAabbMax.getX();
	btScalar temporalAabbMaxy = temporalAabbMax.getY();
	btScalar temporalAabbMaxz = temporalAabbMax.getZ();
	btScalar temporalAabbMinx = temporalAabbMin.getX();
	btScalar temporalAabbMiny = temporalAabbMin.getY();
	btScalar temporalAabbMinz = temporalAabbMin.getZ();

	// add linear motion
	btVector3 linMotion = linvel * timeStep;
	///@todo: simd would have a vector max/min operation, instead of per-element access
	if (linMotion.x() > btScalar(0.))
		temporalAabbMaxx += linMotion.x();
	else
		temporalAabbMinx += linMotion.x();
	if (linMotion.y() > btScalar(0.))
		temporalAabbMaxy += linMotion.y();
	else
		temporalAabbMiny += linMotion.y();
	if (linMotion.z() > btScalar(0.))
		temporalAabbMaxz += linMotion.z();
	else
		temporalAabbMinz += linMotion.z();

	//add conservative angular motion
	btScalar angularMotion = angvel.length() * getAngularMotionDisc() * timeStep;
	btVector3 angularMotion3d(angularMotion, angularMotion, angularMotion);
	temporalAabbMin = btVector3(temporalAabbMinx, temporalAabbMiny, temporalAabbMinz);
	temporalAabbMax = btVector3(temporalAabbMaxx, temporalAabbMaxy, temporalAabbMaxz);

	temporalAabbMin -= angularMotion3d;
	temporalAabbMax += angularMotion3d;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btCollisionShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionShapeData* shapeData = (btCollisionShapeData*)dataBuffer;
	char* name = (char*)serializer->findNameForPointer(this);
	shapeData->m_name = (char*)serializer->getUniquePointer(name);
	if (shapeData->m_name)
	{
		serializer->serializeName(name);
	}
	shapeData->m_shapeType = m_shapeType;

	// Fill padding with zeros to appease msan.
	memset(shapeData->m_padding, 0, sizeof(shapeData->m_padding));

	return "btCollisionShapeData";
}

void btCollisionShape::serializeSingleShape(btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_SHAPE_CODE, (void*)this);
}




/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_SHAPE_INTERFACE1
#define BT_CONVEX_SHAPE_INTERFACE1

#include "BulletCollision/CollisionShapes/btCollisionShape.h"

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "LinearMath/btAlignedAllocator.h"

#define MAX_PREFERRED_PENETRATION_DIRECTIONS 10

/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
ATTRIBUTE_ALIGNED16(class)
btConvexShape : public btCollisionShape
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexShape();

	virtual ~btConvexShape();

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const = 0;

////////
#ifndef __SPU__
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const = 0;
#endif  //#ifndef __SPU__

	btVector3 localGetSupportVertexWithoutMarginNonVirtual(const btVector3& vec) const;
	btVector3 localGetSupportVertexNonVirtual(const btVector3& vec) const;
	btScalar getMarginNonVirtual() const;
	void getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;

	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const = 0;

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const = 0;

	virtual void setLocalScaling(const btVector3& scaling) = 0;
	virtual const btVector3& getLocalScaling() const = 0;

	virtual void setMargin(btScalar margin) = 0;

	virtual btScalar getMargin() const = 0;

	virtual int getNumPreferredPenetrationDirections() const = 0;

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const = 0;
};

#endif  //BT_CONVEX_SHAPE_INTERFACE1





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btConvexHullShape.h"
#include "BulletCollision/CollisionShapes/btConvexPointCloudShape.h"

///not supported on IBM SDK, until we fix the alignment of btVector3
#if defined(__CELLOS_LV2__) && defined(__SPU__)
static inline vec_float4 vec_dot3(vec_float4 vec0, vec_float4 vec1)
{
	vec_float4 result;
	result = spu_mul(vec0, vec1);
	result = spu_madd(spu_rlqwbyte(vec0, 4), spu_rlqwbyte(vec1, 4), result);
	return spu_madd(spu_rlqwbyte(vec0, 8), spu_rlqwbyte(vec1, 8), result);
}
#endif  //__SPU__

btConvexShape::btConvexShape()
{
}

btConvexShape::~btConvexShape()
{
}

void btConvexShape::project(const btTransform& trans, const btVector3& dir, btScalar& min, btScalar& max, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	btVector3 localAxis = dir * trans.getBasis();
	btVector3 vtx1 = trans(localGetSupportingVertex(localAxis));
	btVector3 vtx2 = trans(localGetSupportingVertex(-localAxis));

	min = vtx1.dot(dir);
	max = vtx2.dot(dir);
	witnesPtMax = vtx2;
	witnesPtMin = vtx1;

	if (min > max)
	{
		btScalar tmp = min;
		min = max;
		max = tmp;
		witnesPtMax = vtx1;
		witnesPtMin = vtx2;
	}
}

static btVector3 convexHullSupport(const btVector3& localDirOrg, const btVector3* points, int numPoints, const btVector3& localScaling)
{
	btVector3 vec = localDirOrg * localScaling;

#if defined(__CELLOS_LV2__) && defined(__SPU__)

	btVector3 localDir = vec;

	vec_float4 v_distMax = {-FLT_MAX, 0, 0, 0};
	vec_int4 v_idxMax = {-999, 0, 0, 0};
	int v = 0;
	int numverts = numPoints;

	for (; v < (int)numverts - 4; v += 4)
	{
		vec_float4 p0 = vec_dot3(points[v].get128(), localDir.get128());
		vec_float4 p1 = vec_dot3(points[v + 1].get128(), localDir.get128());
		vec_float4 p2 = vec_dot3(points[v + 2].get128(), localDir.get128());
		vec_float4 p3 = vec_dot3(points[v + 3].get128(), localDir.get128());
		const vec_int4 i0 = {v, 0, 0, 0};
		const vec_int4 i1 = {v + 1, 0, 0, 0};
		const vec_int4 i2 = {v + 2, 0, 0, 0};
		const vec_int4 i3 = {v + 3, 0, 0, 0};
		vec_uint4 retGt01 = spu_cmpgt(p0, p1);
		vec_float4 pmax01 = spu_sel(p1, p0, retGt01);
		vec_int4 imax01 = spu_sel(i1, i0, retGt01);
		vec_uint4 retGt23 = spu_cmpgt(p2, p3);
		vec_float4 pmax23 = spu_sel(p3, p2, retGt23);
		vec_int4 imax23 = spu_sel(i3, i2, retGt23);
		vec_uint4 retGt0123 = spu_cmpgt(pmax01, pmax23);
		vec_float4 pmax0123 = spu_sel(pmax23, pmax01, retGt0123);
		vec_int4 imax0123 = spu_sel(imax23, imax01, retGt0123);
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, pmax0123);
		v_distMax = spu_sel(pmax0123, v_distMax, retGtMax);
		v_idxMax = spu_sel(imax0123, v_idxMax, retGtMax);
	}
	for (; v < (int)numverts; v++)
	{
		vec_float4 p = vec_dot3(points[v].get128(), localDir.get128());
		const vec_int4 i = {v, 0, 0, 0};
		vec_uint4 retGtMax = spu_cmpgt(v_distMax, p);
		v_distMax = spu_sel(p, v_distMax, retGtMax);
		v_idxMax = spu_sel(i, v_idxMax, retGtMax);
	}
	int ptIndex = spu_extract(v_idxMax, 0);
	const btVector3& supVec = points[ptIndex] * localScaling;
	return supVec;
#else

	btScalar maxDot;
	long ptIndex = vec.maxDot(points, numPoints, maxDot);
	btAssert(ptIndex >= 0);
	if (ptIndex < 0)
	{
		ptIndex = 0;
	}
	btVector3 supVec = points[ptIndex] * localScaling;
	return supVec;
#endif  //__SPU__
}

btVector3 btConvexShape::localGetSupportVertexWithoutMarginNonVirtual(const btVector3& localDir) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			return btVector3(0, 0, 0);
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			const btVector3& halfExtents = convexShape->getImplicitShapeDimensions();

#if defined(__APPLE__) && (defined(BT_USE_SSE) || defined(BT_USE_NEON))
#if defined(BT_USE_SSE)
			return btVector3(_mm_xor_ps(_mm_and_ps(localDir.mVec128, (__m128){-0.0f, -0.0f, -0.0f, -0.0f}), halfExtents.mVec128));
#elif defined(BT_USE_NEON)
			return btVector3((float32x4_t)(((uint32x4_t)localDir.mVec128 & (uint32x4_t){0x80000000, 0x80000000, 0x80000000, 0x80000000}) ^ (uint32x4_t)halfExtents.mVec128));
#else
#error unknown vector arch
#endif
#else
			return btVector3(btFsels(localDir.x(), halfExtents.x(), -halfExtents.x()),
							 btFsels(localDir.y(), halfExtents.y(), -halfExtents.y()),
							 btFsels(localDir.z(), halfExtents.z(), -halfExtents.z()));
#endif
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btVector3 dir(localDir.getX(), localDir.getY(), localDir.getZ());
			btVector3* vertices = &triangleShape->m_vertices1[0];
			btVector3 dots = dir.dot3(vertices[0], vertices[1], vertices[2]);
			btVector3 sup = vertices[dots.maxAxis()];
			return btVector3(sup.getX(), sup.getY(), sup.getZ());
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			//mapping of halfextents/dimension onto radius/height depends on how cylinder local orientation is (upAxis)

			btVector3 halfExtents = cylShape->getImplicitShapeDimensions();
			btVector3 v(localDir.getX(), localDir.getY(), localDir.getZ());
			int cylinderUpAxis = cylShape->getUpAxis();
			int XX(1), YY(0), ZZ(2);

			switch (cylinderUpAxis)
			{
				case 0:
				{
					XX = 1;
					YY = 0;
					ZZ = 2;
				}
				break;
				case 1:
				{
					XX = 0;
					YY = 1;
					ZZ = 2;
				}
				break;
				case 2:
				{
					XX = 0;
					YY = 2;
					ZZ = 1;
				}
				break;
				default:
					btAssert(0);
					break;
			};

			btScalar radius = halfExtents[XX];
			btScalar halfHeight = halfExtents[cylinderUpAxis];

			btVector3 tmp;
			btScalar d;

			btScalar s = btSqrt(v[XX] * v[XX] + v[ZZ] * v[ZZ]);
			if (s != btScalar(0.0))
			{
				d = radius / s;
				tmp[XX] = v[XX] * d;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = v[ZZ] * d;
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
			else
			{
				tmp[XX] = radius;
				tmp[YY] = v[YY] < 0.0 ? -halfHeight : halfHeight;
				tmp[ZZ] = btScalar(0.0);
				return btVector3(tmp.getX(), tmp.getY(), tmp.getZ());
			}
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btVector3 vec0(localDir.getX(), localDir.getY(), localDir.getZ());

			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btScalar halfHeight = capsuleShape->getHalfHeight();
			int capsuleUpAxis = capsuleShape->getUpAxis();

			btVector3 supVec(0, 0, 0);

			btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

			btVector3 vec = vec0;
			btScalar lenSqr = vec.length2();
			if (lenSqr < SIMD_EPSILON * SIMD_EPSILON)
			{
				vec.setValue(1, 0, 0);
			}
			else
			{
				btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
				vec *= rlen;
			}
			btVector3 vtx;
			btScalar newDot;
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);

				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			{
				btVector3 pos(0, 0, 0);
				pos[capsuleUpAxis] = -halfHeight;

				vtx = pos;
				newDot = vec.dot(vtx);
				if (newDot > maxDot)
				{
					maxDot = newDot;
					supVec = vtx;
				}
			}
			return btVector3(supVec.getX(), supVec.getY(), supVec.getZ());
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		{
			btConvexPointCloudShape* convexPointCloudShape = (btConvexPointCloudShape*)this;
			btVector3* points = convexPointCloudShape->getUnscaledPoints();
			int numPoints = convexPointCloudShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexPointCloudShape->getLocalScalingNV());
		}
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btConvexHullShape* convexHullShape = (btConvexHullShape*)this;
			btVector3* points = convexHullShape->getUnscaledPoints();
			int numPoints = convexHullShape->getNumPoints();
			return convexHullSupport(localDir, points, numPoints, convexHullShape->getLocalScalingNV());
		}
		default:
#ifndef __SPU__
			return this->localGetSupportingVertexWithoutMargin(localDir);
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btVector3(btScalar(0.0f), btScalar(0.0f), btScalar(0.0f));
}

btVector3 btConvexShape::localGetSupportVertexNonVirtual(const btVector3& localDir) const
{
	btVector3 localDirNorm = localDir;
	if (localDirNorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		localDirNorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	localDirNorm.normalize();

	return localGetSupportVertexWithoutMarginNonVirtual(localDirNorm) + getMarginNonVirtual() * localDirNorm;
}

/* TODO: This should be bumped up to btCollisionShape () */
btScalar btConvexShape::getMarginNonVirtual() const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			return sphereShape->getRadius();
		}
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			return convexShape->getMarginNV();
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			return triangleShape->getMarginNV();
		}
		case CYLINDER_SHAPE_PROXYTYPE:
		{
			btCylinderShape* cylShape = (btCylinderShape*)this;
			return cylShape->getMarginNV();
		}
		case CONE_SHAPE_PROXYTYPE:
		{
			btConeShape* conShape = (btConeShape*)this;
			return conShape->getMarginNV();
		}
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			return capsuleShape->getMarginNV();
		}
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		/* fall through */
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexShape* convexHullShape = (btPolyhedralConvexShape*)this;
			return convexHullShape->getMarginNV();
		}
		default:
#ifndef __SPU__
			return this->getMargin();
#else
			btAssert(0);
#endif
	}

	// should never reach here
	btAssert(0);
	return btScalar(0.0f);
}
#ifndef __SPU__
void btConvexShape::getAabbNonVirtual(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	switch (m_shapeType)
	{
		case SPHERE_SHAPE_PROXYTYPE:
		{
			btSphereShape* sphereShape = (btSphereShape*)this;
			btScalar radius = sphereShape->getImplicitShapeDimensions().getX();  // * convexShape->getLocalScaling().getX();
			btScalar margin = radius + sphereShape->getMarginNonVirtual();
			const btVector3& center = t.getOrigin();
			btVector3 extent(margin, margin, margin);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CYLINDER_SHAPE_PROXYTYPE:
		/* fall through */
		case BOX_SHAPE_PROXYTYPE:
		{
			btBoxShape* convexShape = (btBoxShape*)this;
			btScalar margin = convexShape->getMarginNonVirtual();
			btVector3 halfExtents = convexShape->getImplicitShapeDimensions();
			halfExtents += btVector3(margin, margin, margin);
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

			aabbMin = center - extent;
			aabbMax = center + extent;
			break;
		}
		case TRIANGLE_SHAPE_PROXYTYPE:
		{
			btTriangleShape* triangleShape = (btTriangleShape*)this;
			btScalar margin = triangleShape->getMarginNonVirtual();
			for (int i = 0; i < 3; i++)
			{
				btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
				vec[i] = btScalar(1.);

				btVector3 sv = localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis());

				btVector3 tmp = t(sv);
				aabbMax[i] = tmp[i] + margin;
				vec[i] = btScalar(-1.);
				tmp = t(localGetSupportVertexWithoutMarginNonVirtual(vec * t.getBasis()));
				aabbMin[i] = tmp[i] - margin;
			}
		}
		break;
		case CAPSULE_SHAPE_PROXYTYPE:
		{
			btCapsuleShape* capsuleShape = (btCapsuleShape*)this;
			btVector3 halfExtents(capsuleShape->getRadius(), capsuleShape->getRadius(), capsuleShape->getRadius());
			int m_upAxis = capsuleShape->getUpAxis();
			halfExtents[m_upAxis] = capsuleShape->getRadius() + capsuleShape->getHalfHeight();
			btMatrix3x3 abs_b = t.getBasis().absolute();
			btVector3 center = t.getOrigin();
			btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);
			aabbMin = center - extent;
			aabbMax = center + extent;
		}
		break;
		case CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE:
		case CONVEX_HULL_SHAPE_PROXYTYPE:
		{
			btPolyhedralConvexAabbCachingShape* convexHullShape = (btPolyhedralConvexAabbCachingShape*)this;
			btScalar margin = convexHullShape->getMarginNonVirtual();
			convexHullShape->getNonvirtualAabb(t, aabbMin, aabbMax, margin);
		}
		break;
		default:
#ifndef __SPU__
			this->getAabb(t, aabbMin, aabbMax);
#else
			btAssert(0);
#endif
			break;
	}

	// should never reach here
	btAssert(0);
}

#endif  //__SPU__





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CONVEX_INTERNAL_SHAPE_H
#define BT_CONVEX_INTERNAL_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btAabbUtil2.h"

///The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
///The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
///This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
///Note that when creating small shapes (derived from btConvexInternalShape),
///you need to make sure to set a smaller collision margin, using the 'setMargin' API
///There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
ATTRIBUTE_ALIGNED16(class)
btConvexInternalShape : public btConvexShape
{
protected:
	//local scaling. collisionMargin is not scaled !
	btVector3 m_localScaling;

	btVector3 m_implicitShapeDimensions;

	btScalar m_collisionMargin;

	btScalar m_padding;

	btConvexInternalShape();

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btConvexInternalShape()
	{
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;

	const btVector3& getImplicitShapeDimensions() const
	{
		return m_implicitShapeDimensions;
	}

	///warning: use setImplicitShapeDimensions with care
	///changing a collision shape while the body is in the world is not recommended,
	///it is best to remove the body from the world, then make the change, and re-add it
	///alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'
	void setImplicitShapeDimensions(const btVector3& dimensions)
	{
		m_implicitShapeDimensions = dimensions;
	}

	void setSafeMargin(btScalar minDimension, btScalar defaultMarginMultiplier = 0.1f)
	{
		btScalar safeMargin = defaultMarginMultiplier * minDimension;
		if (safeMargin < getMargin())
		{
			setMargin(safeMargin);
		}
	}
	void setSafeMargin(const btVector3& halfExtents, btScalar defaultMarginMultiplier = 0.1f)
	{
		//see http://code.google.com/p/bullet/issues/detail?id=349
		//this margin check could could be added to other collision shapes too,
		//or add some assert/warning somewhere
		btScalar minDimension = halfExtents[halfExtents.minAxis()];
		setSafeMargin(minDimension, defaultMarginMultiplier);
	}

	///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
	void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		getAabbSlow(t, aabbMin, aabbMax);
	}

	virtual void getAabbSlow(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void setLocalScaling(const btVector3& scaling);
	virtual const btVector3& getLocalScaling() const
	{
		return m_localScaling;
	}

	const btVector3& getLocalScalingNV() const
	{
		return m_localScaling;
	}

	virtual void setMargin(btScalar margin)
	{
		m_collisionMargin = margin;
	}
	virtual btScalar getMargin() const
	{
		return m_collisionMargin;
	}

	btScalar getMarginNV() const
	{
		return m_collisionMargin;
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 0;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		(void)penetrationVector;
		(void)index;
		btAssert(0);
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btConvexInternalShapeData
{
	btCollisionShapeData m_collisionShapeData;

	btVector3FloatData m_localScaling;

	btVector3FloatData m_implicitShapeDimensions;

	float m_collisionMargin;

	int m_padding;
};

SIMD_FORCE_INLINE int btConvexInternalShape::calculateSerializeBufferSize() const
{
	return sizeof(btConvexInternalShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btConvexInternalShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btConvexInternalShapeData* shapeData = (btConvexInternalShapeData*)dataBuffer;
	btCollisionShape::serialize(&shapeData->m_collisionShapeData, serializer);

	m_implicitShapeDimensions.serializeFloat(shapeData->m_implicitShapeDimensions);
	m_localScaling.serializeFloat(shapeData->m_localScaling);
	shapeData->m_collisionMargin = float(m_collisionMargin);

	// Fill padding with zeros to appease msan.
	shapeData->m_padding = 0;

	return "btConvexInternalShapeData";
}

///btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
class btConvexInternalAabbCachingShape : public btConvexInternalShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	btConvexInternalAabbCachingShape();

	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

public:
	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_CONVEX_INTERNAL_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"

btConvexInternalShape::btConvexInternalShape()
	: m_localScaling(btScalar(1.), btScalar(1.), btScalar(1.)),
	  m_collisionMargin(CONVEX_DISTANCE_MARGIN)
{
}

void btConvexInternalShape::setLocalScaling(const btVector3& scaling)
{
	m_localScaling = scaling.absolute();
}

void btConvexInternalShape::getAabbSlow(const btTransform& trans, btVector3& minAabb, btVector3& maxAabb) const
{
#ifndef __SPU__
	//use localGetSupportingVertexWithoutMargin?
	btScalar margin = getMargin();
	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);

		btVector3 sv = localGetSupportingVertex(vec * trans.getBasis());

		btVector3 tmp = trans(sv);
		maxAabb[i] = tmp[i] + margin;
		vec[i] = btScalar(-1.);
		tmp = trans(localGetSupportingVertex(vec * trans.getBasis()));
		minAabb[i] = tmp[i] - margin;
	}
#endif
}

btVector3 btConvexInternalShape::localGetSupportingVertex(const btVector3& vec) const
{
#ifndef __SPU__

	btVector3 supVertex = localGetSupportingVertexWithoutMargin(vec);

	if (getMargin() != btScalar(0.))
	{
		btVector3 vecnorm = vec;
		if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
		{
			vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
		}
		vecnorm.normalize();
		supVertex += getMargin() * vecnorm;
	}
	return supVertex;

#else
	btAssert(0);
	return btVector3(0, 0, 0);
#endif  //__SPU__
}

btConvexInternalAabbCachingShape::btConvexInternalAabbCachingShape()
	: btConvexInternalShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btConvexInternalAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btConvexInternalAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

void btConvexInternalAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i] + m_collisionMargin;
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i] - m_collisionMargin;
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_POLYHEDRAL_CONVEX_SHAPE_H
#define BT_POLYHEDRAL_CONVEX_SHAPE_H

#include "LinearMath/btMatrix3x3.h"
#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
class btConvexPolyhedron;

///The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
ATTRIBUTE_ALIGNED16(class)
btPolyhedralConvexShape : public btConvexInternalShape
{
protected:
	btConvexPolyhedron* m_polyhedron;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btPolyhedralConvexShape();

	virtual ~btPolyhedralConvexShape();

	///optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
	///experimental/work-in-progress
	virtual bool initializePolyhedralFeatures(int shiftVerticesByMargin = 0);

	virtual void setPolyhedralFeatures(btConvexPolyhedron & polyhedron);

	const btConvexPolyhedron* getConvexPolyhedron() const
	{
		return m_polyhedron;
	}

	//brute force implementations

	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual int getNumVertices() const = 0;
	virtual int getNumEdges() const = 0;
	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const = 0;
	virtual void getVertex(int i, btVector3& vtx) const = 0;
	virtual int getNumPlanes() const = 0;
	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const = 0;
	//	virtual int getIndex(int i) const = 0 ;

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const = 0;
};

///The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
class btPolyhedralConvexAabbCachingShape : public btPolyhedralConvexShape
{
	btVector3 m_localAabbMin;
	btVector3 m_localAabbMax;
	bool m_isLocalAabbValid;

protected:
	void setCachedLocalAabb(const btVector3& aabbMin, const btVector3& aabbMax)
	{
		m_isLocalAabbValid = true;
		m_localAabbMin = aabbMin;
		m_localAabbMax = aabbMax;
	}

	inline void getCachedLocalAabb(btVector3& aabbMin, btVector3& aabbMax) const
	{
		btAssert(m_isLocalAabbValid);
		aabbMin = m_localAabbMin;
		aabbMax = m_localAabbMax;
	}

protected:
	btPolyhedralConvexAabbCachingShape();

public:
	inline void getNonvirtualAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax, btScalar margin) const
	{
		//lazy evaluation of local aabb
		btAssert(m_isLocalAabbValid);
		btTransformAabb(m_localAabbMin, m_localAabbMax, margin, trans, aabbMin, aabbMax);
	}

	virtual void setLocalScaling(const btVector3& scaling);

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	void recalcLocalAabb();
};

#endif  //BT_POLYHEDRAL_CONVEX_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#if defined(_WIN32) || defined(__i386__)
#define BT_USE_SSE_IN_API
#endif

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btConvexHullComputer.h"
#include "LinearMath/btGeometryUtil.h"
#include "LinearMath/btGrahamScan2dConvexHull.h"

btPolyhedralConvexShape::btPolyhedralConvexShape() : btConvexInternalShape(),
													 m_polyhedron(0)
{
}

btPolyhedralConvexShape::~btPolyhedralConvexShape()
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}
}

void btPolyhedralConvexShape::setPolyhedralFeatures(btConvexPolyhedron& polyhedron)
{
	if (m_polyhedron)
	{
		*m_polyhedron = polyhedron;
	}
	else
	{
		void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
		m_polyhedron = new (mem) btConvexPolyhedron(polyhedron);
	}
}

bool btPolyhedralConvexShape::initializePolyhedralFeatures(int shiftVerticesByMargin)
{
	if (m_polyhedron)
	{
		m_polyhedron->~btConvexPolyhedron();
		btAlignedFree(m_polyhedron);
	}

	void* mem = btAlignedAlloc(sizeof(btConvexPolyhedron), 16);
	m_polyhedron = new (mem) btConvexPolyhedron;

	btAlignedObjectArray<btVector3> orgVertices;

	for (int i = 0; i < getNumVertices(); i++)
	{
		btVector3& newVertex = orgVertices.expand();
		getVertex(i, newVertex);
	}

	btConvexHullComputer conv;

	if (shiftVerticesByMargin)
	{
		btAlignedObjectArray<btVector3> planeEquations;
		btGeometryUtil::getPlaneEquationsFromVertices(orgVertices, planeEquations);

		btAlignedObjectArray<btVector3> shiftedPlaneEquations;
		for (int p = 0; p < planeEquations.size(); p++)
		{
			btVector3 plane = planeEquations[p];
			//	   btScalar margin = getMargin();
			plane[3] -= getMargin();
			shiftedPlaneEquations.push_back(plane);
		}

		btAlignedObjectArray<btVector3> tmpVertices;

		btGeometryUtil::getVerticesFromPlaneEquations(shiftedPlaneEquations, tmpVertices);

		conv.compute(&tmpVertices[0].getX(), sizeof(btVector3), tmpVertices.size(), 0.f, 0.f);
	}
	else
	{
		conv.compute(&orgVertices[0].getX(), sizeof(btVector3), orgVertices.size(), 0.f, 0.f);
	}

#ifndef BT_RECONSTRUCT_FACES

	int numVertices = conv.vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = conv.vertices[p];
	}

	int v0, v1;
	for (int j = 0; j < conv.faces.size(); j++)
	{
		btVector3 edges[3];
		int numEdges = 0;
		btFace combinedFace;
		const btConvexHullComputer::Edge* edge = &conv.edges[conv.faces[j]];
		v0 = edge->getSourceVertex();
		int prevVertex = v0;
		combinedFace.m_indices.push_back(v0);
		v1 = edge->getTargetVertex();
		while (v1 != v0)
		{
			btVector3 wa = conv.vertices[prevVertex];
			btVector3 wb = conv.vertices[v1];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			//face->addIndex(v1);
			combinedFace.m_indices.push_back(v1);
			edge = edge->getNextEdgeOfFace();
			prevVertex = v1;
			int v01 = edge->getSourceVertex();
			v1 = edge->getTargetVertex();
		}

		btAssert(combinedFace.m_indices.size() > 2);

		btVector3 faceNormal = edges[0].cross(edges[1]);
		faceNormal.normalize();

		btScalar planeEq = 1e30f;

		for (int v = 0; v < combinedFace.m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[combinedFace.m_indices[v]].dot(faceNormal);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		combinedFace.m_plane[0] = faceNormal.getX();
		combinedFace.m_plane[1] = faceNormal.getY();
		combinedFace.m_plane[2] = faceNormal.getZ();
		combinedFace.m_plane[3] = -planeEq;

		m_polyhedron->m_faces.push_back(combinedFace);
	}

#else  //BT_RECONSTRUCT_FACES

	btAlignedObjectArray<btVector3> faceNormals;
	int numFaces = conv.faces.size();
	faceNormals.resize(numFaces);
	btConvexHullComputer* convexUtil = &conv;

	btAlignedObjectArray<btFace> tmpFaces;
	tmpFaces.resize(numFaces);

	int numVertices = convexUtil->vertices.size();
	m_polyhedron->m_vertices.resize(numVertices);
	for (int p = 0; p < numVertices; p++)
	{
		m_polyhedron->m_vertices[p] = convexUtil->vertices[p];
	}

	for (int i = 0; i < numFaces; i++)
	{
		int face = convexUtil->faces[i];
		//printf("face=%d\n",face);
		const btConvexHullComputer::Edge* firstEdge = &convexUtil->edges[face];
		const btConvexHullComputer::Edge* edge = firstEdge;

		btVector3 edges[3];
		int numEdges = 0;
		//compute face normals

		do
		{
			int src = edge->getSourceVertex();
			tmpFaces[i].m_indices.push_back(src);
			int targ = edge->getTargetVertex();
			btVector3 wa = convexUtil->vertices[src];

			btVector3 wb = convexUtil->vertices[targ];
			btVector3 newEdge = wb - wa;
			newEdge.normalize();
			if (numEdges < 2)
				edges[numEdges++] = newEdge;

			edge = edge->getNextEdgeOfFace();
		} while (edge != firstEdge);

		btScalar planeEq = 1e30f;

		if (numEdges == 2)
		{
			faceNormals[i] = edges[0].cross(edges[1]);
			faceNormals[i].normalize();
			tmpFaces[i].m_plane[0] = faceNormals[i].getX();
			tmpFaces[i].m_plane[1] = faceNormals[i].getY();
			tmpFaces[i].m_plane[2] = faceNormals[i].getZ();
			tmpFaces[i].m_plane[3] = planeEq;
		}
		else
		{
			btAssert(0);  //degenerate?
			faceNormals[i].setZero();
		}

		for (int v = 0; v < tmpFaces[i].m_indices.size(); v++)
		{
			btScalar eq = m_polyhedron->m_vertices[tmpFaces[i].m_indices[v]].dot(faceNormals[i]);
			if (planeEq > eq)
			{
				planeEq = eq;
			}
		}
		tmpFaces[i].m_plane[3] = -planeEq;
	}

	//merge coplanar faces and copy them to m_polyhedron

	btScalar faceWeldThreshold = 0.999f;
	btAlignedObjectArray<int> todoFaces;
	for (int i = 0; i < tmpFaces.size(); i++)
		todoFaces.push_back(i);

	while (todoFaces.size())
	{
		btAlignedObjectArray<int> coplanarFaceGroup;
		int refFace = todoFaces[todoFaces.size() - 1];

		coplanarFaceGroup.push_back(refFace);
		btFace& faceA = tmpFaces[refFace];
		todoFaces.pop_back();

		btVector3 faceNormalA(faceA.m_plane[0], faceA.m_plane[1], faceA.m_plane[2]);
		for (int j = todoFaces.size() - 1; j >= 0; j--)
		{
			int i = todoFaces[j];
			btFace& faceB = tmpFaces[i];
			btVector3 faceNormalB(faceB.m_plane[0], faceB.m_plane[1], faceB.m_plane[2]);
			if (faceNormalA.dot(faceNormalB) > faceWeldThreshold)
			{
				coplanarFaceGroup.push_back(i);
				todoFaces.remove(i);
			}
		}

		bool did_merge = false;
		if (coplanarFaceGroup.size() > 1)
		{
			//do the merge: use Graham Scan 2d convex hull

			btAlignedObjectArray<GrahamVector3> orgpoints;
			btVector3 averageFaceNormal(0, 0, 0);

			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				//				m_polyhedron->m_faces.push_back(tmpFaces[coplanarFaceGroup[i]]);

				btFace& face = tmpFaces[coplanarFaceGroup[i]];
				btVector3 faceNormal(face.m_plane[0], face.m_plane[1], face.m_plane[2]);
				averageFaceNormal += faceNormal;
				for (int f = 0; f < face.m_indices.size(); f++)
				{
					int orgIndex = face.m_indices[f];
					btVector3 pt = m_polyhedron->m_vertices[orgIndex];

					bool found = false;

					for (int i = 0; i < orgpoints.size(); i++)
					{
						//if ((orgpoints[i].m_orgIndex == orgIndex) || ((rotatedPt-orgpoints[i]).length2()<0.0001))
						if (orgpoints[i].m_orgIndex == orgIndex)
						{
							found = true;
							break;
						}
					}
					if (!found)
						orgpoints.push_back(GrahamVector3(pt, orgIndex));
				}
			}

			btFace combinedFace;
			for (int i = 0; i < 4; i++)
				combinedFace.m_plane[i] = tmpFaces[coplanarFaceGroup[0]].m_plane[i];

			btAlignedObjectArray<GrahamVector3> hull;

			averageFaceNormal.normalize();
			GrahamScanConvexHull2D(orgpoints, hull, averageFaceNormal);

			for (int i = 0; i < hull.size(); i++)
			{
				combinedFace.m_indices.push_back(hull[i].m_orgIndex);
				for (int k = 0; k < orgpoints.size(); k++)
				{
					if (orgpoints[k].m_orgIndex == hull[i].m_orgIndex)
					{
						orgpoints[k].m_orgIndex = -1;  // invalidate...
						break;
					}
				}
			}

			// are there rejected vertices?
			bool reject_merge = false;

			for (int i = 0; i < orgpoints.size(); i++)
			{
				if (orgpoints[i].m_orgIndex == -1)
					continue;  // this is in the hull...
				// this vertex is rejected -- is anybody else using this vertex?
				for (int j = 0; j < tmpFaces.size(); j++)
				{
					btFace& face = tmpFaces[j];
					// is this a face of the current coplanar group?
					bool is_in_current_group = false;
					for (int k = 0; k < coplanarFaceGroup.size(); k++)
					{
						if (coplanarFaceGroup[k] == j)
						{
							is_in_current_group = true;
							break;
						}
					}
					if (is_in_current_group)  // ignore this face...
						continue;
					// does this face use this rejected vertex?
					for (int v = 0; v < face.m_indices.size(); v++)
					{
						if (face.m_indices[v] == orgpoints[i].m_orgIndex)
						{
							// this rejected vertex is used in another face -- reject merge
							reject_merge = true;
							break;
						}
					}
					if (reject_merge)
						break;
				}
				if (reject_merge)
					break;
			}

			if (!reject_merge)
			{
				// do this merge!
				did_merge = true;
				m_polyhedron->m_faces.push_back(combinedFace);
			}
		}
		if (!did_merge)
		{
			for (int i = 0; i < coplanarFaceGroup.size(); i++)
			{
				btFace face = tmpFaces[coplanarFaceGroup[i]];
				m_polyhedron->m_faces.push_back(face);
			}
		}
	}

#endif  //BT_RECONSTRUCT_FACES

	m_polyhedron->initialize();

	return true;
}

#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#endif

btVector3 btPolyhedralConvexShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);
#ifndef __SPU__
	int i;
	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	for (int k = 0; k < getNumVertices(); k += 128)
	{
		btVector3 temp[128];
		int inner_count = MIN(getNumVertices() - k, 128);
		for (i = 0; i < inner_count; i++)
			getVertex(i, temp[i]);
		i = (int)vec.maxDot(temp, inner_count, newDot);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = temp[i];
		}
	}

#endif  //__SPU__
	return supVec;
}

void btPolyhedralConvexShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
#ifndef __SPU__
	int i;

	btVector3 vtx;
	btScalar newDot;

	for (i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i][3] = btScalar(-BT_LARGE_FLOAT);
	}

	for (int j = 0; j < numVectors; j++)
	{
		const btVector3& vec = vectors[j];

		for (int k = 0; k < getNumVertices(); k += 128)
		{
			btVector3 temp[128];
			int inner_count = MIN(getNumVertices() - k, 128);
			for (i = 0; i < inner_count; i++)
				getVertex(i, temp[i]);
			i = (int)vec.maxDot(temp, inner_count, newDot);
			if (newDot > supportVerticesOut[j][3])
			{
				supportVerticesOut[j] = temp[i];
				supportVerticesOut[j][3] = newDot;
			}
		}
	}

#endif  //__SPU__
}

void btPolyhedralConvexShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
#ifndef __SPU__
	//not yet, return box inertia

	btScalar margin = getMargin();

	btTransform ident;
	ident.setIdentity();
	btVector3 aabbMin, aabbMax;
	getAabb(ident, aabbMin, aabbMax);
	btVector3 halfExtents = (aabbMax - aabbMin) * btScalar(0.5);

	btScalar lx = btScalar(2.) * (halfExtents.x() + margin);
	btScalar ly = btScalar(2.) * (halfExtents.y() + margin);
	btScalar lz = btScalar(2.) * (halfExtents.z() + margin);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(0.08333333);

	inertia = scaledmass * (btVector3(y2 + z2, x2 + z2, x2 + y2));
#endif  //__SPU__
}

void btPolyhedralConvexAabbCachingShape::setLocalScaling(const btVector3& scaling)
{
	btConvexInternalShape::setLocalScaling(scaling);
	recalcLocalAabb();
}

btPolyhedralConvexAabbCachingShape::btPolyhedralConvexAabbCachingShape()
	: btPolyhedralConvexShape(),
	  m_localAabbMin(1, 1, 1),
	  m_localAabbMax(-1, -1, -1),
	  m_isLocalAabbValid(false)
{
}

void btPolyhedralConvexAabbCachingShape::getAabb(const btTransform& trans, btVector3& aabbMin, btVector3& aabbMax) const
{
	getNonvirtualAabb(trans, aabbMin, aabbMax, getMargin());
}

void btPolyhedralConvexAabbCachingShape::recalcLocalAabb()
{
	m_isLocalAabbValid = true;

#if 1
	static const btVector3 _directions[] =
		{
			btVector3(1., 0., 0.),
			btVector3(0., 1., 0.),
			btVector3(0., 0., 1.),
			btVector3(-1., 0., 0.),
			btVector3(0., -1., 0.),
			btVector3(0., 0., -1.)};

	btVector3 _supporting[] =
		{
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.),
			btVector3(0., 0., 0.)};

	batchedUnitVectorGetSupportingVertexWithoutMargin(_directions, _supporting, 6);

	for (int i = 0; i < 3; ++i)
	{
		m_localAabbMax[i] = _supporting[i][i] + m_collisionMargin;
		m_localAabbMin[i] = _supporting[i + 3][i] - m_collisionMargin;
	}

#else

	for (int i = 0; i < 3; i++)
	{
		btVector3 vec(btScalar(0.), btScalar(0.), btScalar(0.));
		vec[i] = btScalar(1.);
		btVector3 tmp = localGetSupportingVertex(vec);
		m_localAabbMax[i] = tmp[i];
		vec[i] = btScalar(-1.);
		tmp = localGetSupportingVertex(vec);
		m_localAabbMin[i] = tmp[i];
	}
#endif
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans

#ifndef _BT_POLYHEDRAL_FEATURES_H
#define _BT_POLYHEDRAL_FEATURES_H

#include "LinearMath/btTransform.h"
#include "LinearMath/btAlignedObjectArray.h"

#define TEST_INTERNAL_OBJECTS 1

struct btFace
{
	btAlignedObjectArray<int> m_indices;
	//	btAlignedObjectArray<int>	m_connectedFaces;
	btScalar m_plane[4];
};

ATTRIBUTE_ALIGNED16(class)
btConvexPolyhedron
{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConvexPolyhedron();
	virtual ~btConvexPolyhedron();

	btAlignedObjectArray<btVector3> m_vertices;
	btAlignedObjectArray<btFace> m_faces;
	btAlignedObjectArray<btVector3> m_uniqueEdges;

	btVector3 m_localCenter;
	btVector3 m_extents;
	btScalar m_radius;
	btVector3 mC;
	btVector3 mE;

	void initialize();
	void initialize2();
	bool testContainment() const;

	void project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const;
};

#endif  //_BT_POLYHEDRAL_FEATURES_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2011 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

///This file was written by Erwin Coumans
///Separating axis rest based on work from Pierre Terdiman, see
///And contact clipping based on work from Simon Hobbs

#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "LinearMath/btHashMap.h"

btConvexPolyhedron::btConvexPolyhedron()
{
}
btConvexPolyhedron::~btConvexPolyhedron()
{
}

inline bool IsAlmostZero1(const btVector3& v)
{
	if (btFabs(v.x()) > 1e-6 || btFabs(v.y()) > 1e-6 || btFabs(v.z()) > 1e-6) return false;
	return true;
}

struct btInternalVertexPair
{
	btInternalVertexPair(short int v0, short int v1)
		: m_v0(v0),
		  m_v1(v1)
	{
		if (m_v1 > m_v0)
			btSwap(m_v0, m_v1);
	}
	short int m_v0;
	short int m_v1;
	int getHash() const
	{
		return m_v0 + (m_v1 << 16);
	}
	bool equals(const btInternalVertexPair& other) const
	{
		return m_v0 == other.m_v0 && m_v1 == other.m_v1;
	}
};

struct btInternalEdge
{
	btInternalEdge()
		: m_face0(-1),
		  m_face1(-1)
	{
	}
	short int m_face0;
	short int m_face1;
};

//

#ifdef TEST_INTERNAL_OBJECTS
bool btConvexPolyhedron::testContainment() const
{
	for (int p = 0; p < 8; p++)
	{
		btVector3 LocalPt;
		if (p == 0)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 1)
			LocalPt = m_localCenter + btVector3(m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 2)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 3)
			LocalPt = m_localCenter + btVector3(m_extents[0], -m_extents[1], -m_extents[2]);
		else if (p == 4)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], m_extents[2]);
		else if (p == 5)
			LocalPt = m_localCenter + btVector3(-m_extents[0], m_extents[1], -m_extents[2]);
		else if (p == 6)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], m_extents[2]);
		else if (p == 7)
			LocalPt = m_localCenter + btVector3(-m_extents[0], -m_extents[1], -m_extents[2]);

		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar d = LocalPt.dot(Normal) + m_faces[i].m_plane[3];
			if (d > 0.0f)
				return false;
		}
	}
	return true;
}
#endif

void btConvexPolyhedron::initialize()
{
	btHashMap<btInternalVertexPair, btInternalEdge> edges;

	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices;
		for (int j = 0; j < NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btVector3 edge = m_vertices[vp.m_v1] - m_vertices[vp.m_v0];
			edge.normalize();

			bool found = false;

			for (int p = 0; p < m_uniqueEdges.size(); p++)
			{
				if (IsAlmostZero1(m_uniqueEdges[p] - edge) ||
					IsAlmostZero1(m_uniqueEdges[p] + edge))
				{
					found = true;
					break;
				}
			}

			if (!found)
			{
				m_uniqueEdges.push_back(edge);
			}

			if (edptr)
			{
				btAssert(edptr->m_face0 >= 0);
				btAssert(edptr->m_face1 < 0);
				edptr->m_face1 = i;
			}
			else
			{
				btInternalEdge ed;
				ed.m_face0 = i;
				edges.insert(vp, ed);
			}
		}
	}

#ifdef USE_CONNECTED_FACES
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		m_faces[i].m_connectedFaces.resize(numVertices);

		for (int j = 0; j < numVertices; j++)
		{
			int k = (j + 1) % numVertices;
			btInternalVertexPair vp(m_faces[i].m_indices[j], m_faces[i].m_indices[k]);
			btInternalEdge* edptr = edges.find(vp);
			btAssert(edptr);
			btAssert(edptr->m_face0 >= 0);
			btAssert(edptr->m_face1 >= 0);

			int connectedFace = (edptr->m_face0 == i) ? edptr->m_face1 : edptr->m_face0;
			m_faces[i].m_connectedFaces[j] = connectedFace;
		}
	}
#endif  //USE_CONNECTED_FACES

	initialize2();
}

void btConvexPolyhedron::initialize2()
{
	m_localCenter.setValue(0, 0, 0);
	btScalar TotalArea = 0.0f;
	for (int i = 0; i < m_faces.size(); i++)
	{
		int numVertices = m_faces[i].m_indices.size();
		int NbTris = numVertices - 2;

		const btVector3& p0 = m_vertices[m_faces[i].m_indices[0]];
		for (int j = 1; j <= NbTris; j++)
		{
			int k = (j + 1) % numVertices;
			const btVector3& p1 = m_vertices[m_faces[i].m_indices[j]];
			const btVector3& p2 = m_vertices[m_faces[i].m_indices[k]];
			btScalar Area = ((p0 - p1).cross(p0 - p2)).length() * 0.5f;
			btVector3 Center = (p0 + p1 + p2) / 3.0f;
			m_localCenter += Area * Center;
			TotalArea += Area;
		}
	}
	m_localCenter /= TotalArea;

#ifdef TEST_INTERNAL_OBJECTS
	if (1)
	{
		m_radius = FLT_MAX;
		for (int i = 0; i < m_faces.size(); i++)
		{
			const btVector3 Normal(m_faces[i].m_plane[0], m_faces[i].m_plane[1], m_faces[i].m_plane[2]);
			const btScalar dist = btFabs(m_localCenter.dot(Normal) + m_faces[i].m_plane[3]);
			if (dist < m_radius)
				m_radius = dist;
		}

		btScalar MinX = FLT_MAX;
		btScalar MinY = FLT_MAX;
		btScalar MinZ = FLT_MAX;
		btScalar MaxX = -FLT_MAX;
		btScalar MaxY = -FLT_MAX;
		btScalar MaxZ = -FLT_MAX;
		for (int i = 0; i < m_vertices.size(); i++)
		{
			const btVector3& pt = m_vertices[i];
			if (pt.x() < MinX) MinX = pt.x();
			if (pt.x() > MaxX) MaxX = pt.x();
			if (pt.y() < MinY) MinY = pt.y();
			if (pt.y() > MaxY) MaxY = pt.y();
			if (pt.z() < MinZ) MinZ = pt.z();
			if (pt.z() > MaxZ) MaxZ = pt.z();
		}
		mC.setValue(MaxX + MinX, MaxY + MinY, MaxZ + MinZ);
		mE.setValue(MaxX - MinX, MaxY - MinY, MaxZ - MinZ);

		//		const btScalar r = m_radius / sqrtf(2.0f);
		const btScalar r = m_radius / sqrtf(3.0f);
		const int LargestExtent = mE.maxAxis();
		const btScalar Step = (mE[LargestExtent] * 0.5f - r) / 1024.0f;
		m_extents[0] = m_extents[1] = m_extents[2] = r;
		m_extents[LargestExtent] = mE[LargestExtent] * 0.5f;
		bool FoundBox = false;
		for (int j = 0; j < 1024; j++)
		{
			if (testContainment())
			{
				FoundBox = true;
				break;
			}

			m_extents[LargestExtent] -= Step;
		}
		if (!FoundBox)
		{
			m_extents[0] = m_extents[1] = m_extents[2] = r;
		}
		else
		{
			// Refine the box
			const btScalar Step = (m_radius - r) / 1024.0f;
			const int e0 = (1 << LargestExtent) & 3;
			const int e1 = (1 << e0) & 3;

			for (int j = 0; j < 1024; j++)
			{
				const btScalar Saved0 = m_extents[e0];
				const btScalar Saved1 = m_extents[e1];
				m_extents[e0] += Step;
				m_extents[e1] += Step;

				if (!testContainment())
				{
					m_extents[e0] = Saved0;
					m_extents[e1] = Saved1;
					break;
				}
			}
		}
	}
#endif
}
void btConvexPolyhedron::project(const btTransform& trans, const btVector3& dir, btScalar& minProj, btScalar& maxProj, btVector3& witnesPtMin, btVector3& witnesPtMax) const
{
	minProj = FLT_MAX;
	maxProj = -FLT_MAX;
	int numVerts = m_vertices.size();
	for (int i = 0; i < numVerts; i++)
	{
		btVector3 pt = trans * m_vertices[i];
		btScalar dp = pt.dot(dir);
		if (dp < minProj)
		{
			minProj = dp;
			witnesPtMin = pt;
		}
		if (dp > maxProj)
		{
			maxProj = dp;
			witnesPtMax = pt;
		}
	}
	if (minProj > maxProj)
	{
		btSwap(minProj, maxProj);
		btSwap(witnesPtMin, witnesPtMax);
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_OBB_BOX_MINKOWSKI_H
#define BT_OBB_BOX_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "LinearMath/btVector3.h"
#include "LinearMath/btMinMax.h"

///The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
ATTRIBUTE_ALIGNED16(class)
btBoxShape : public btPolyhedralConvexShape
{
	//btVector3	m_boxHalfExtents1; //use m_implicitShapeDimensions instead

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btVector3 getHalfExtentsWithMargin() const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;
		return halfExtents;
	}

	const btVector3& getHalfExtentsWithoutMargin() const
	{
		return m_implicitShapeDimensions;  //scaling is included, margin is not
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();
		btVector3 margin(getMargin(), getMargin(), getMargin());
		halfExtents += margin;

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	SIMD_FORCE_INLINE btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		return btVector3(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
						 btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
						 btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
	}

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
	{
		const btVector3& halfExtents = getHalfExtentsWithoutMargin();

		for (int i = 0; i < numVectors; i++)
		{
			const btVector3& vec = vectors[i];
			supportVerticesOut[i].setValue(btFsels(vec.x(), halfExtents.x(), -halfExtents.x()),
										   btFsels(vec.y(), halfExtents.y(), -halfExtents.y()),
										   btFsels(vec.z(), halfExtents.z(), -halfExtents.z()));
		}
	}

	btBoxShape(const btVector3& boxHalfExtents);

	virtual void setMargin(btScalar collisionMargin)
	{
		//correct the m_implicitShapeDimensions for the margin
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;

		btConvexInternalShape::setMargin(collisionMargin);
		btVector3 newMargin(getMargin(), getMargin(), getMargin());
		m_implicitShapeDimensions = implicitShapeDimensionsWithMargin - newMargin;
	}
	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 oldMargin(getMargin(), getMargin(), getMargin());
		btVector3 implicitShapeDimensionsWithMargin = m_implicitShapeDimensions + oldMargin;
		btVector3 unScaledImplicitShapeDimensionsWithMargin = implicitShapeDimensionsWithMargin / m_localScaling;

		btConvexInternalShape::setLocalScaling(scaling);

		m_implicitShapeDimensions = (unScaledImplicitShapeDimensionsWithMargin * m_localScaling) - oldMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getPlane(btVector3 & planeNormal, btVector3 & planeSupport, int i) const
	{
		//this plane might not be aligned...
		btVector4 plane;
		getPlaneEquation(plane, i);
		planeNormal = btVector3(plane.getX(), plane.getY(), plane.getZ());
		planeSupport = localGetSupportingVertex(-planeNormal);
	}

	virtual int getNumPlanes() const
	{
		return 6;
	}

	virtual int getNumVertices() const
	{
		return 8;
	}

	virtual int getNumEdges() const
	{
		return 12;
	}

	virtual void getVertex(int i, btVector3& vtx) const
	{
		btVector3 halfExtents = getHalfExtentsWithMargin();

		vtx = btVector3(
			halfExtents.x() * (1 - (i & 1)) - halfExtents.x() * (i & 1),
			halfExtents.y() * (1 - ((i & 2) >> 1)) - halfExtents.y() * ((i & 2) >> 1),
			halfExtents.z() * (1 - ((i & 4) >> 2)) - halfExtents.z() * ((i & 4) >> 2));
	}

	virtual void getPlaneEquation(btVector4 & plane, int i) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		switch (i)
		{
			case 0:
				plane.setValue(btScalar(1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 1:
				plane.setValue(btScalar(-1.), btScalar(0.), btScalar(0.), -halfExtents.x());
				break;
			case 2:
				plane.setValue(btScalar(0.), btScalar(1.), btScalar(0.), -halfExtents.y());
				break;
			case 3:
				plane.setValue(btScalar(0.), btScalar(-1.), btScalar(0.), -halfExtents.y());
				break;
			case 4:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(1.), -halfExtents.z());
				break;
			case 5:
				plane.setValue(btScalar(0.), btScalar(0.), btScalar(-1.), -halfExtents.z());
				break;
			default:
				btAssert(0);
		}
	}

	virtual void getEdge(int i, btVector3& pa, btVector3& pb) const
	//virtual void getEdge(int i,Edge& edge) const
	{
		int edgeVert0 = 0;
		int edgeVert1 = 0;

		switch (i)
		{
			case 0:
				edgeVert0 = 0;
				edgeVert1 = 1;
				break;
			case 1:
				edgeVert0 = 0;
				edgeVert1 = 2;
				break;
			case 2:
				edgeVert0 = 1;
				edgeVert1 = 3;

				break;
			case 3:
				edgeVert0 = 2;
				edgeVert1 = 3;
				break;
			case 4:
				edgeVert0 = 0;
				edgeVert1 = 4;
				break;
			case 5:
				edgeVert0 = 1;
				edgeVert1 = 5;

				break;
			case 6:
				edgeVert0 = 2;
				edgeVert1 = 6;
				break;
			case 7:
				edgeVert0 = 3;
				edgeVert1 = 7;
				break;
			case 8:
				edgeVert0 = 4;
				edgeVert1 = 5;
				break;
			case 9:
				edgeVert0 = 4;
				edgeVert1 = 6;
				break;
			case 10:
				edgeVert0 = 5;
				edgeVert1 = 7;
				break;
			case 11:
				edgeVert0 = 6;
				edgeVert1 = 7;
				break;
			default:
				btAssert(0);
		}

		getVertex(edgeVert0, pa);
		getVertex(edgeVert1, pb);
	}

	virtual bool isInside(const btVector3& pt, btScalar tolerance) const
	{
		btVector3 halfExtents = getHalfExtentsWithoutMargin();

		//btScalar minDist = 2*tolerance;

		bool result = (pt.x() <= (halfExtents.x() + tolerance)) &&
					  (pt.x() >= (-halfExtents.x() - tolerance)) &&
					  (pt.y() <= (halfExtents.y() + tolerance)) &&
					  (pt.y() >= (-halfExtents.y() - tolerance)) &&
					  (pt.z() <= (halfExtents.z() + tolerance)) &&
					  (pt.z() >= (-halfExtents.z() - tolerance));

		return result;
	}

	//debugging
	virtual const char* getName() const
	{
		return "Box";
	}

	virtual int getNumPreferredPenetrationDirections() const
	{
		return 6;
	}

	virtual void getPreferredPenetrationDirection(int index, btVector3& penetrationVector) const
	{
		switch (index)
		{
			case 0:
				penetrationVector.setValue(btScalar(1.), btScalar(0.), btScalar(0.));
				break;
			case 1:
				penetrationVector.setValue(btScalar(-1.), btScalar(0.), btScalar(0.));
				break;
			case 2:
				penetrationVector.setValue(btScalar(0.), btScalar(1.), btScalar(0.));
				break;
			case 3:
				penetrationVector.setValue(btScalar(0.), btScalar(-1.), btScalar(0.));
				break;
			case 4:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(1.));
				break;
			case 5:
				penetrationVector.setValue(btScalar(0.), btScalar(0.), btScalar(-1.));
				break;
			default:
				btAssert(0);
		}
	}
};

#endif  //BT_OBB_BOX_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#include "BulletCollision/CollisionShapes/btBoxShape.h"

btBoxShape::btBoxShape(const btVector3& boxHalfExtents)
	: btPolyhedralConvexShape()
{
	m_shapeType = BOX_SHAPE_PROXYTYPE;

	btVector3 margin(getMargin(), getMargin(), getMargin());
	m_implicitShapeDimensions = (boxHalfExtents * m_localScaling) - margin;

	setSafeMargin(boxHalfExtents);
};

void btBoxShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	btTransformAabb(getHalfExtentsWithoutMargin(), getMargin(), t, aabbMin, aabbMax);
}

void btBoxShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//btScalar margin = btScalar(0.);
	btVector3 halfExtents = getHalfExtentsWithMargin();

	btScalar lx = btScalar(2.) * (halfExtents.x());
	btScalar ly = btScalar(2.) * (halfExtents.y());
	btScalar lz = btScalar(2.) * (halfExtents.z());

	inertia.setValue(mass / (btScalar(12.0)) * (ly * ly + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + lz * lz),
					 mass / (btScalar(12.0)) * (lx * lx + ly * ly));
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_CAPSULE_SHAPE_H
#define BT_CAPSULE_SHAPE_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
///The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
///The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
ATTRIBUTE_ALIGNED16(class)
btCapsuleShape : public btConvexInternalShape
{
protected:
	int m_upAxis;

protected:
	///only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.
	btCapsuleShape() : btConvexInternalShape() { m_shapeType = CAPSULE_SHAPE_PROXYTYPE; };

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btCapsuleShape(btScalar radius, btScalar height);

	///CollisionShape Interface
	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	/// btConvexShape Interface
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;

	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void setMargin(btScalar collisionMargin)
	{
		//don't override the margin for capsules, their entire radius == margin
		(void)collisionMargin;
	}

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
	{
		btVector3 halfExtents(getRadius(), getRadius(), getRadius());
		halfExtents[m_upAxis] = getRadius() + getHalfHeight();
		btMatrix3x3 abs_b = t.getBasis().absolute();
		btVector3 center = t.getOrigin();
		btVector3 extent = halfExtents.dot3(abs_b[0], abs_b[1], abs_b[2]);

		aabbMin = center - extent;
		aabbMax = center + extent;
	}

	virtual const char* getName() const
	{
		return "CapsuleShape";
	}

	int getUpAxis() const
	{
		return m_upAxis;
	}

	btScalar getRadius() const
	{
		int radiusAxis = (m_upAxis + 2) % 3;
		return m_implicitShapeDimensions[radiusAxis];
	}

	btScalar getHalfHeight() const
	{
		return m_implicitShapeDimensions[m_upAxis];
	}

	virtual void setLocalScaling(const btVector3& scaling)
	{
		btVector3 unScaledImplicitShapeDimensions = m_implicitShapeDimensions / m_localScaling;
		btConvexInternalShape::setLocalScaling(scaling);
		m_implicitShapeDimensions = (unScaledImplicitShapeDimensions * scaling);
		//update m_collisionMargin, since entire radius==margin
		int radiusAxis = (m_upAxis + 2) % 3;
		m_collisionMargin = m_implicitShapeDimensions[radiusAxis];
	}

	virtual btVector3 getAnisotropicRollingFrictionDirection() const
	{
		btVector3 aniDir(0, 0, 0);
		aniDir[getUpAxis()] = 1;
		return aniDir;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;

	SIMD_FORCE_INLINE void deSerializeFloat(struct btCapsuleShapeData * dataBuffer);
};

///btCapsuleShapeX represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeX : public btCapsuleShape
{
public:
	btCapsuleShapeX(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleX";
	}
};

///btCapsuleShapeZ represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
class btCapsuleShapeZ : public btCapsuleShape
{
public:
	btCapsuleShapeZ(btScalar radius, btScalar height);

	//debugging
	virtual const char* getName() const
	{
		return "CapsuleZ";
	}
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btCapsuleShapeData
{
	btConvexInternalShapeData m_convexInternalShapeData;

	int m_upAxis;

	char m_padding[4];
};

SIMD_FORCE_INLINE int btCapsuleShape::calculateSerializeBufferSize() const
{
	return sizeof(btCapsuleShapeData);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btCapsuleShape::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCapsuleShapeData* shapeData = (btCapsuleShapeData*)dataBuffer;

	btConvexInternalShape::serialize(&shapeData->m_convexInternalShapeData, serializer);

	shapeData->m_upAxis = m_upAxis;

	// Fill padding with zeros to appease msan.
	shapeData->m_padding[0] = 0;
	shapeData->m_padding[1] = 0;
	shapeData->m_padding[2] = 0;
	shapeData->m_padding[3] = 0;

	return "btCapsuleShapeData";
}

SIMD_FORCE_INLINE void btCapsuleShape::deSerializeFloat(btCapsuleShapeData* dataBuffer)
{
	m_implicitShapeDimensions.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_implicitShapeDimensions);
	m_collisionMargin = dataBuffer->m_convexInternalShapeData.m_collisionMargin;
	m_localScaling.deSerializeFloat(dataBuffer->m_convexInternalShapeData.m_localScaling);
	//it is best to already pre-allocate the matching btCapsuleShape*(X/Z) version to match m_upAxis
	m_upAxis = dataBuffer->m_upAxis;
}

#endif  //BT_CAPSULE_SHAPE_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btCapsuleShape.h"

#include "LinearMath/btQuaternion.h"

btCapsuleShape::btCapsuleShape(btScalar radius, btScalar height) : btConvexInternalShape()
{
	m_collisionMargin = radius;
	m_shapeType = CAPSULE_SHAPE_PROXYTYPE;
	m_upAxis = 1;
	m_implicitShapeDimensions.setValue(radius, 0.5f * height, radius);
}

btVector3 btCapsuleShape::localGetSupportingVertexWithoutMargin(const btVector3& vec0) const
{
	btVector3 supVec(0, 0, 0);

	btScalar maxDot(btScalar(-BT_LARGE_FLOAT));

	btVector3 vec = vec0;
	btScalar lenSqr = vec.length2();
	if (lenSqr < btScalar(0.0001))
	{
		vec.setValue(1, 0, 0);
	}
	else
	{
		btScalar rlen = btScalar(1.) / btSqrt(lenSqr);
		vec *= rlen;
	}

	btVector3 vtx;
	btScalar newDot;

	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}
	{
		btVector3 pos(0, 0, 0);
		pos[getUpAxis()] = -getHalfHeight();

		vtx = pos;
		newDot = vec.dot(vtx);
		if (newDot > maxDot)
		{
			maxDot = newDot;
			supVec = vtx;
		}
	}

	return supVec;
}

void btCapsuleShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	for (int j = 0; j < numVectors; j++)
	{
		btScalar maxDot(btScalar(-BT_LARGE_FLOAT));
		const btVector3& vec = vectors[j];

		btVector3 vtx;
		btScalar newDot;
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
		{
			btVector3 pos(0, 0, 0);
			pos[getUpAxis()] = -getHalfHeight();
			vtx = pos;
			newDot = vec.dot(vtx);
			if (newDot > maxDot)
			{
				maxDot = newDot;
				supportVerticesOut[j] = vtx;
			}
		}
	}
}

void btCapsuleShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	//as an approximation, take the inertia of the box that bounds the spheres

	btTransform ident;
	ident.setIdentity();

	btScalar radius = getRadius();

	btVector3 halfExtents(radius, radius, radius);
	halfExtents[getUpAxis()] += getHalfHeight();

	btScalar lx = btScalar(2.) * (halfExtents[0]);
	btScalar ly = btScalar(2.) * (halfExtents[1]);
	btScalar lz = btScalar(2.) * (halfExtents[2]);
	const btScalar x2 = lx * lx;
	const btScalar y2 = ly * ly;
	const btScalar z2 = lz * lz;
	const btScalar scaledmass = mass * btScalar(.08333333);

	inertia[0] = scaledmass * (y2 + z2);
	inertia[1] = scaledmass * (x2 + z2);
	inertia[2] = scaledmass * (x2 + y2);
}

btCapsuleShapeX::btCapsuleShapeX(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 0;
	m_implicitShapeDimensions.setValue(0.5f * height, radius, radius);
}

btCapsuleShapeZ::btCapsuleShapeZ(btScalar radius, btScalar height)
{
	m_collisionMargin = radius;
	m_upAxis = 2;
	m_implicitShapeDimensions.setValue(radius, radius, 0.5f * height);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#ifndef BT_SPHERE_MINKOWSKI_H
#define BT_SPHERE_MINKOWSKI_H

#include "BulletCollision/CollisionShapes/btConvexInternalShape.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

///The btSphereShape implements an implicit sphere, centered around a local origin with radius.
ATTRIBUTE_ALIGNED16(class)
btSphereShape : public btConvexInternalShape

{
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btSphereShape(btScalar radius) : btConvexInternalShape()
	{
		m_shapeType = SPHERE_SHAPE_PROXYTYPE;
		m_localScaling.setValue(1.0, 1.0, 1.0);
		m_implicitShapeDimensions.setZero();
		m_implicitShapeDimensions.setX(radius);
		m_collisionMargin = radius;
		m_padding = 0;
	}

	virtual btVector3 localGetSupportingVertex(const btVector3& vec) const;
	virtual btVector3 localGetSupportingVertexWithoutMargin(const btVector3& vec) const;
	//notice that the vectors should be unit length
	virtual void batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const;

	virtual void calculateLocalInertia(btScalar mass, btVector3 & inertia) const;

	virtual void getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const;

	btScalar getRadius() const { return m_implicitShapeDimensions.getX() * m_localScaling.getX(); }

	void setUnscaledRadius(btScalar radius)
	{
		m_implicitShapeDimensions.setX(radius);
		btConvexInternalShape::setMargin(radius);
	}

	//debugging
	virtual const char* getName() const { return "SPHERE"; }

	virtual void setMargin(btScalar margin)
	{
		btConvexInternalShape::setMargin(margin);
	}
	virtual btScalar getMargin() const
	{
		//to improve gjk behaviour, use radius+margin as the full margin, so never get into the penetration case
		//this means, non-uniform scaling is not supported anymore
		return getRadius();
	}
};

#endif  //BT_SPHERE_MINKOWSKI_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btCollisionMargin.h"

#include "LinearMath/btQuaternion.h"

btVector3 btSphereShape::localGetSupportingVertexWithoutMargin(const btVector3& vec) const
{
	(void)vec;
	return btVector3(btScalar(0.), btScalar(0.), btScalar(0.));
}

void btSphereShape::batchedUnitVectorGetSupportingVertexWithoutMargin(const btVector3* vectors, btVector3* supportVerticesOut, int numVectors) const
{
	(void)vectors;

	for (int i = 0; i < numVectors; i++)
	{
		supportVerticesOut[i].setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	}
}

btVector3 btSphereShape::localGetSupportingVertex(const btVector3& vec) const
{
	btVector3 supVertex;
	supVertex = localGetSupportingVertexWithoutMargin(vec);

	btVector3 vecnorm = vec;
	if (vecnorm.length2() < (SIMD_EPSILON * SIMD_EPSILON))
	{
		vecnorm.setValue(btScalar(-1.), btScalar(-1.), btScalar(-1.));
	}
	vecnorm.normalize();
	supVertex += getMargin() * vecnorm;
	return supVertex;
}

//broken due to scaling
void btSphereShape::getAabb(const btTransform& t, btVector3& aabbMin, btVector3& aabbMax) const
{
	const btVector3& center = t.getOrigin();
	btVector3 extent(getMargin(), getMargin(), getMargin());
	aabbMin = center - extent;
	aabbMax = center + extent;
}

void btSphereShape::calculateLocalInertia(btScalar mass, btVector3& inertia) const
{
	btScalar elem = btScalar(0.4) * mass * getMargin() * getMargin();
	inertia.setValue(elem, elem, elem);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_MANIFOLD_RESULT_H
#define BT_MANIFOLD_RESULT_H

class btCollisionObject;
struct btCollisionObjectWrapper;

#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
class btManifoldPoint;

#include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"

#include "LinearMath/btTransform.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

typedef bool (*ContactAddedCallback)(btManifoldPoint& cp, const btCollisionObjectWrapper* colObj0Wrap, int partId0, int index0, const btCollisionObjectWrapper* colObj1Wrap, int partId1, int index1);
extern ContactAddedCallback gContactAddedCallback;

//#define DEBUG_PART_INDEX 1

/// These callbacks are used to customize the algorith that combine restitution, friction, damping, Stiffness
typedef btScalar (*CalculateCombinedCallback)(const btCollisionObject* body0, const btCollisionObject* body1);

extern CalculateCombinedCallback gCalculateCombinedRestitutionCallback;
extern CalculateCombinedCallback gCalculateCombinedFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedRollingFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedSpinningFrictionCallback;
extern CalculateCombinedCallback gCalculateCombinedContactDampingCallback;
extern CalculateCombinedCallback gCalculateCombinedContactStiffnessCallback;

///btManifoldResult is a helper class to manage  contact results.
class btManifoldResult : public btDiscreteCollisionDetectorInterface::Result
{
protected:
	btPersistentManifold* m_manifoldPtr;

	const btCollisionObjectWrapper* m_body0Wrap;
	const btCollisionObjectWrapper* m_body1Wrap;
	int m_partId0;
	int m_partId1;
	int m_index0;
	int m_index1;

public:
	btManifoldResult()
		:
#ifdef DEBUG_PART_INDEX

		  m_partId0(-1),
		  m_partId1(-1),
		  m_index0(-1),
		  m_index1(-1)
#endif  //DEBUG_PART_INDEX
			  m_closestPointDistanceThreshold(0)
	{
	}

	btManifoldResult(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);

	virtual ~btManifoldResult(){};

	void setPersistentManifold(btPersistentManifold* manifoldPtr)
	{
		m_manifoldPtr = manifoldPtr;
	}

	const btPersistentManifold* getPersistentManifold() const
	{
		return m_manifoldPtr;
	}
	btPersistentManifold* getPersistentManifold()
	{
		return m_manifoldPtr;
	}

	virtual void setShapeIdentifiersA(int partId0, int index0)
	{
		m_partId0 = partId0;
		m_index0 = index0;
	}

	virtual void setShapeIdentifiersB(int partId1, int index1)
	{
		m_partId1 = partId1;
		m_index1 = index1;
	}

	virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth);

	SIMD_FORCE_INLINE void refreshContactPoints()
	{
		btAssert(m_manifoldPtr);
		if (!m_manifoldPtr->getNumContacts())
			return;

		bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();

		if (isSwapped)
		{
			m_manifoldPtr->refreshContactPoints(m_body1Wrap->getCollisionObject()->getWorldTransform(), m_body0Wrap->getCollisionObject()->getWorldTransform());
		}
		else
		{
			m_manifoldPtr->refreshContactPoints(m_body0Wrap->getCollisionObject()->getWorldTransform(), m_body1Wrap->getCollisionObject()->getWorldTransform());
		}
	}

	const btCollisionObjectWrapper* getBody0Wrap() const
	{
		return m_body0Wrap;
	}
	const btCollisionObjectWrapper* getBody1Wrap() const
	{
		return m_body1Wrap;
	}

	void setBody0Wrap(const btCollisionObjectWrapper* obj0Wrap)
	{
		m_body0Wrap = obj0Wrap;
	}

	void setBody1Wrap(const btCollisionObjectWrapper* obj1Wrap)
	{
		m_body1Wrap = obj1Wrap;
	}

	const btCollisionObject* getBody0Internal() const
	{
		return m_body0Wrap->getCollisionObject();
	}

	const btCollisionObject* getBody1Internal() const
	{
		return m_body1Wrap->getCollisionObject();
	}

	btScalar m_closestPointDistanceThreshold;

	/// in the future we can let the user override the methods to combine restitution and friction
	static btScalar calculateCombinedRestitution(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedRollingFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedSpinningFriction(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedContactDamping(const btCollisionObject* body0, const btCollisionObject* body1);
	static btScalar calculateCombinedContactStiffness(const btCollisionObject* body0, const btCollisionObject* body1);
};

#endif  //BT_MANIFOLD_RESULT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_COLLISION_OBJECT_H
#define BT_COLLISION_OBJECT_H

#include "LinearMath/btTransform.h"

//island management, m_activationState1
#define ACTIVE_TAG 1
#define ISLAND_SLEEPING 2
#define WANTS_DEACTIVATION 3
#define DISABLE_DEACTIVATION 4
#define DISABLE_SIMULATION 5
#define FIXED_BASE_MULTI_BODY 6

struct btBroadphaseProxy;
class btCollisionShape;
struct btCollisionShapeData;
#include "LinearMath/btMotionState.h"
#include "LinearMath/btAlignedAllocator.h"
#include "LinearMath/btAlignedObjectArray.h"

typedef btAlignedObjectArray<class btCollisionObject*> btCollisionObjectArray;

#ifdef BT_USE_DOUBLE_PRECISION
#define btCollisionObjectData btCollisionObjectDoubleData
#define btCollisionObjectDataName "btCollisionObjectDoubleData"
#else
#define btCollisionObjectData btCollisionObjectFloatData
#define btCollisionObjectDataName "btCollisionObjectFloatData"
#endif

/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
ATTRIBUTE_ALIGNED16(class)
btCollisionObject
{
protected:
	btTransform m_worldTransform;

	///m_interpolationWorldTransform is used for CCD and interpolation
	///it can be either previous or future (predicted) transform
	btTransform m_interpolationWorldTransform;
	//those two are experimental: just added for bullet time effect, so you can still apply impulses (directly modifying velocities)
	//without destroying the continuous interpolated motion (which uses this interpolation velocities)
	btVector3 m_interpolationLinearVelocity;
	btVector3 m_interpolationAngularVelocity;

	btVector3 m_anisotropicFriction;
	int m_hasAnisotropicFriction;
	btScalar m_contactProcessingThreshold;

	btBroadphaseProxy* m_broadphaseHandle;
	btCollisionShape* m_collisionShape;
	///m_extensionPointer is used by some internal low-level Bullet extensions.
	void* m_extensionPointer;

	///m_rootCollisionShape is temporarily used to store the original collision shape
	///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
	///If it is NULL, the m_collisionShape is not temporarily replaced.
	btCollisionShape* m_rootCollisionShape;

	int m_collisionFlags;

	int m_islandTag1;
	int m_companionId;
	int m_worldArrayIndex;  // index of object in world's collisionObjects array

	mutable int m_activationState1;
	mutable btScalar m_deactivationTime;

	btScalar m_friction;
	btScalar m_restitution;
	btScalar m_rollingFriction;   //torsional friction orthogonal to contact normal (useful to stop spheres rolling forever)
	btScalar m_spinningFriction;  // torsional friction around the contact normal (useful for grasping)
	btScalar m_contactDamping;
	btScalar m_contactStiffness;

	///m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
	///do not assign your own m_internalType unless you write a new dynamics object class.
	int m_internalType;

	///users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer

	void* m_userObjectPointer;

	int m_userIndex2;

	int m_userIndex;

	int m_userIndex3;

	///time of impact calculation
	btScalar m_hitFraction;

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar m_ccdSweptSphereRadius;

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	btScalar m_ccdMotionThreshold;

	/// If some object should have elaborate collision filtering by sub-classes
	int m_checkCollideWith;

	btAlignedObjectArray<const btCollisionObject*> m_objectsWithoutCollisionCheck;

	///internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
	int m_updateRevision;

	btVector3 m_customDebugColorRGB;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	enum CollisionFlags
	{
		CF_DYNAMIC_OBJECT = 0,
		CF_STATIC_OBJECT = 1,
		CF_KINEMATIC_OBJECT = 2,
		CF_NO_CONTACT_RESPONSE = 4,
		CF_CUSTOM_MATERIAL_CALLBACK = 8,  //this allows per-triangle material (friction/restitution)
		CF_CHARACTER_OBJECT = 16,
		CF_DISABLE_VISUALIZE_OBJECT = 32,          //disable debug drawing
		CF_DISABLE_SPU_COLLISION_PROCESSING = 64,  //disable parallel/SPU processing
		CF_HAS_CONTACT_STIFFNESS_DAMPING = 128,
		CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR = 256,
		CF_HAS_FRICTION_ANCHOR = 512,
		CF_HAS_COLLISION_SOUND_TRIGGER = 1024
	};

	enum CollisionObjectTypes
	{
		CO_COLLISION_OBJECT = 1,
		CO_RIGID_BODY = 2,
		///CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
		///It is useful for collision sensors, explosion objects, character controller etc.
		CO_GHOST_OBJECT = 4,
		CO_SOFT_BODY = 8,
		CO_HF_FLUID = 16,
		CO_USER_TYPE = 32,
		CO_FEATHERSTONE_LINK = 64
	};

	enum AnisotropicFrictionFlags
	{
		CF_ANISOTROPIC_FRICTION_DISABLED = 0,
		CF_ANISOTROPIC_FRICTION = 1,
		CF_ANISOTROPIC_ROLLING_FRICTION = 2
	};

	SIMD_FORCE_INLINE bool mergesSimulationIslands() const
	{
		///static objects, kinematic and object without contact response don't merge islands
		return ((m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT | CF_NO_CONTACT_RESPONSE)) == 0);
	}

	const btVector3& getAnisotropicFriction() const
	{
		return m_anisotropicFriction;
	}
	void setAnisotropicFriction(const btVector3& anisotropicFriction, int frictionMode = CF_ANISOTROPIC_FRICTION)
	{
		m_anisotropicFriction = anisotropicFriction;
		bool isUnity = (anisotropicFriction[0] != 1.f) || (anisotropicFriction[1] != 1.f) || (anisotropicFriction[2] != 1.f);
		m_hasAnisotropicFriction = isUnity ? frictionMode : 0;
	}
	bool hasAnisotropicFriction(int frictionMode = CF_ANISOTROPIC_FRICTION) const
	{
		return (m_hasAnisotropicFriction & frictionMode) != 0;
	}

	///the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
	///Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges
	void setContactProcessingThreshold(btScalar contactProcessingThreshold)
	{
		m_contactProcessingThreshold = contactProcessingThreshold;
	}
	btScalar getContactProcessingThreshold() const
	{
		return m_contactProcessingThreshold;
	}

	SIMD_FORCE_INLINE bool isStaticObject() const
	{
		return (m_collisionFlags & CF_STATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isKinematicObject() const
	{
		return (m_collisionFlags & CF_KINEMATIC_OBJECT) != 0;
	}

	SIMD_FORCE_INLINE bool isStaticOrKinematicObject() const
	{
		return (m_collisionFlags & (CF_KINEMATIC_OBJECT | CF_STATIC_OBJECT)) != 0;
	}

	SIMD_FORCE_INLINE bool hasContactResponse() const
	{
		return (m_collisionFlags & CF_NO_CONTACT_RESPONSE) == 0;
	}

	btCollisionObject();

	virtual ~btCollisionObject();

	virtual void setCollisionShape(btCollisionShape * collisionShape)
	{
		m_updateRevision++;
		m_collisionShape = collisionShape;
		m_rootCollisionShape = collisionShape;
	}

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setIgnoreCollisionCheck(const btCollisionObject* co, bool ignoreCollisionCheck)
	{
		if (ignoreCollisionCheck)
		{
			//We don't check for duplicates. Is it ok to leave that up to the user of this API?
			//int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
			//if (index == m_objectsWithoutCollisionCheck.size())
			//{
			m_objectsWithoutCollisionCheck.push_back(co);
			//}
		}
		else
		{
			m_objectsWithoutCollisionCheck.remove(co);
		}
		m_checkCollideWith = m_objectsWithoutCollisionCheck.size() > 0;
	}

        int getNumObjectsWithoutCollision() const
	{
		return m_objectsWithoutCollisionCheck.size();
	}

	const btCollisionObject* getObjectWithoutCollision(int index)
	{
		return m_objectsWithoutCollisionCheck[index];
	}

	virtual bool checkCollideWithOverride(const btCollisionObject* co) const
	{
		int index = m_objectsWithoutCollisionCheck.findLinearSearch(co);
		if (index < m_objectsWithoutCollisionCheck.size())
		{
			return false;
		}
		return true;
	}

	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void* internalGetExtensionPointer() const
	{
		return m_extensionPointer;
	}
	///Avoid using this internal API call, the extension pointer is used by some Bullet extensions
	///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
	void internalSetExtensionPointer(void* pointer)
	{
		m_extensionPointer = pointer;
	}

	SIMD_FORCE_INLINE int getActivationState() const { return m_activationState1; }

	void setActivationState(int newState) const;

	void setDeactivationTime(btScalar time)
	{
		m_deactivationTime = time;
	}
	btScalar getDeactivationTime() const
	{
		return m_deactivationTime;
	}

	void forceActivationState(int newState) const;

	void activate(bool forceActivation = false) const;

	SIMD_FORCE_INLINE bool isActive() const
	{
		return ((getActivationState() != FIXED_BASE_MULTI_BODY) && (getActivationState() != ISLAND_SLEEPING) && (getActivationState() != DISABLE_SIMULATION));
	}

	void setRestitution(btScalar rest)
	{
		m_updateRevision++;
		m_restitution = rest;
	}
	btScalar getRestitution() const
	{
		return m_restitution;
	}
	void setFriction(btScalar frict)
	{
		m_updateRevision++;
		m_friction = frict;
	}
	btScalar getFriction() const
	{
		return m_friction;
	}

	void setRollingFriction(btScalar frict)
	{
		m_updateRevision++;
		m_rollingFriction = frict;
	}
	btScalar getRollingFriction() const
	{
		return m_rollingFriction;
	}
	void setSpinningFriction(btScalar frict)
	{
		m_updateRevision++;
		m_spinningFriction = frict;
	}
	btScalar getSpinningFriction() const
	{
		return m_spinningFriction;
	}
	void setContactStiffnessAndDamping(btScalar stiffness, btScalar damping)
	{
		m_updateRevision++;
		m_contactStiffness = stiffness;
		m_contactDamping = damping;

		m_collisionFlags |= CF_HAS_CONTACT_STIFFNESS_DAMPING;

		//avoid divisions by zero...
		if (m_contactStiffness < SIMD_EPSILON)
		{
			m_contactStiffness = SIMD_EPSILON;
		}
	}

	btScalar getContactStiffness() const
	{
		return m_contactStiffness;
	}

	btScalar getContactDamping() const
	{
		return m_contactDamping;
	}

	///reserved for Bullet internal usage
	int getInternalType() const
	{
		return m_internalType;
	}

	btTransform& getWorldTransform()
	{
		return m_worldTransform;
	}

	const btTransform& getWorldTransform() const
	{
		return m_worldTransform;
	}

	void setWorldTransform(const btTransform& worldTrans)
	{
		m_updateRevision++;
		m_worldTransform = worldTrans;
	}

	SIMD_FORCE_INLINE btBroadphaseProxy* getBroadphaseHandle()
	{
		return m_broadphaseHandle;
	}

	SIMD_FORCE_INLINE const btBroadphaseProxy* getBroadphaseHandle() const
	{
		return m_broadphaseHandle;
	}

	void setBroadphaseHandle(btBroadphaseProxy * handle)
	{
		m_broadphaseHandle = handle;
	}

	const btTransform& getInterpolationWorldTransform() const
	{
		return m_interpolationWorldTransform;
	}

	btTransform& getInterpolationWorldTransform()
	{
		return m_interpolationWorldTransform;
	}

	void setInterpolationWorldTransform(const btTransform& trans)
	{
		m_updateRevision++;
		m_interpolationWorldTransform = trans;
	}

	void setInterpolationLinearVelocity(const btVector3& linvel)
	{
		m_updateRevision++;
		m_interpolationLinearVelocity = linvel;
	}

	void setInterpolationAngularVelocity(const btVector3& angvel)
	{
		m_updateRevision++;
		m_interpolationAngularVelocity = angvel;
	}

	const btVector3& getInterpolationLinearVelocity() const
	{
		return m_interpolationLinearVelocity;
	}

	const btVector3& getInterpolationAngularVelocity() const
	{
		return m_interpolationAngularVelocity;
	}

	SIMD_FORCE_INLINE int getIslandTag() const
	{
		return m_islandTag1;
	}

	void setIslandTag(int tag)
	{
		m_islandTag1 = tag;
	}

	SIMD_FORCE_INLINE int getCompanionId() const
	{
		return m_companionId;
	}

	void setCompanionId(int id)
	{
		m_companionId = id;
	}

	SIMD_FORCE_INLINE int getWorldArrayIndex() const
	{
		return m_worldArrayIndex;
	}

	// only should be called by CollisionWorld
	void setWorldArrayIndex(int ix)
	{
		m_worldArrayIndex = ix;
	}

	SIMD_FORCE_INLINE btScalar getHitFraction() const
	{
		return m_hitFraction;
	}

	void setHitFraction(btScalar hitFraction)
	{
		m_hitFraction = hitFraction;
	}

	SIMD_FORCE_INLINE int getCollisionFlags() const
	{
		return m_collisionFlags;
	}

	void setCollisionFlags(int flags)
	{
		m_collisionFlags = flags;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	btScalar getCcdSweptSphereRadius() const
	{
		return m_ccdSweptSphereRadius;
	}

	///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
	void setCcdSweptSphereRadius(btScalar radius)
	{
		m_ccdSweptSphereRadius = radius;
	}

	btScalar getCcdMotionThreshold() const
	{
		return m_ccdMotionThreshold;
	}

	btScalar getCcdSquareMotionThreshold() const
	{
		return m_ccdMotionThreshold * m_ccdMotionThreshold;
	}

	/// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
	void setCcdMotionThreshold(btScalar ccdMotionThreshold)
	{
		m_ccdMotionThreshold = ccdMotionThreshold;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void* getUserPointer() const
	{
		return m_userObjectPointer;
	}

	int getUserIndex() const
	{
		return m_userIndex;
	}

	int getUserIndex2() const
	{
		return m_userIndex2;
	}

	int getUserIndex3() const
	{
		return m_userIndex3;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserPointer(void* userPointer)
	{
		m_userObjectPointer = userPointer;
	}

	///users can point to their objects, userPointer is not used by Bullet
	void setUserIndex(int index)
	{
		m_userIndex = index;
	}

	void setUserIndex2(int index)
	{
		m_userIndex2 = index;
	}

	void setUserIndex3(int index)
	{
		m_userIndex3 = index;
	}

	int getUpdateRevisionInternal() const
	{
		return m_updateRevision;
	}

	void setCustomDebugColor(const btVector3& colorRGB)
	{
		m_customDebugColorRGB = colorRGB;
		m_collisionFlags |= CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	void removeCustomDebugColor()
	{
		m_collisionFlags &= ~CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
	}

	bool getCustomDebugColor(btVector3 & colorRGB) const
	{
		bool hasCustomColor = (0 != (m_collisionFlags & CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR));
		if (hasCustomColor)
		{
			colorRGB = m_customDebugColorRGB;
		}
		return hasCustomColor;
	}

	inline bool checkCollideWith(const btCollisionObject* co) const
	{
		if (m_checkCollideWith)
			return checkCollideWithOverride(co);

		return true;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer * serializer) const;
};

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectDoubleData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformDoubleData	m_worldTransform;
	btTransformDoubleData	m_interpolationWorldTransform;
	btVector3DoubleData		m_interpolationLinearVelocity;
	btVector3DoubleData		m_interpolationAngularVelocity;
	btVector3DoubleData		m_anisotropicFriction;
	double					m_contactProcessingThreshold;	
	double					m_deactivationTime;
	double					m_friction;
	double					m_rollingFriction;
	double                  m_contactDamping;
	double                  m_contactStiffness;
	double					m_restitution;
	double					m_hitFraction; 
	double					m_ccdSweptSphereRadius;
	double					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;//m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btCollisionObjectFloatData
{
	void					*m_broadphaseHandle;
	void					*m_collisionShape;
	btCollisionShapeData	*m_rootCollisionShape;
	char					*m_name;

	btTransformFloatData	m_worldTransform;
	btTransformFloatData	m_interpolationWorldTransform;
	btVector3FloatData		m_interpolationLinearVelocity;
	btVector3FloatData		m_interpolationAngularVelocity;
	btVector3FloatData		m_anisotropicFriction;
	float					m_contactProcessingThreshold;	
	float					m_deactivationTime;
	float					m_friction;
	float					m_rollingFriction;
	float                   m_contactDamping;
    float                   m_contactStiffness;
	float					m_restitution;
	float					m_hitFraction; 
	float					m_ccdSweptSphereRadius;
	float					m_ccdMotionThreshold;
	int						m_hasAnisotropicFriction;
	int						m_collisionFlags;
	int						m_islandTag1;
	int						m_companionId;
	int						m_activationState1;
	int						m_internalType;
	int						m_checkCollideWith;
	int						m_collisionFilterGroup;
	int						m_collisionFilterMask;
	int						m_uniqueId;
};
// clang-format on

SIMD_FORCE_INLINE int btCollisionObject::calculateSerializeBufferSize() const
{
	return sizeof(btCollisionObjectData);
}

#endif  //BT_COLLISION_OBJECT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

btCollisionObject::btCollisionObject()
	: m_interpolationLinearVelocity(0.f, 0.f, 0.f),
	  m_interpolationAngularVelocity(0.f, 0.f, 0.f),
	  m_anisotropicFriction(1.f, 1.f, 1.f),
	  m_hasAnisotropicFriction(false),
	  m_contactProcessingThreshold(BT_LARGE_FLOAT),
	  m_broadphaseHandle(0),
	  m_collisionShape(0),
	  m_extensionPointer(0),
	  m_rootCollisionShape(0),
	  m_collisionFlags(btCollisionObject::CF_STATIC_OBJECT),
	  m_islandTag1(-1),
	  m_companionId(-1),
	  m_worldArrayIndex(-1),
	  m_activationState1(1),
	  m_deactivationTime(btScalar(0.)),
	  m_friction(btScalar(0.5)),
	  m_restitution(btScalar(0.)),
	  m_rollingFriction(0.0f),
	  m_spinningFriction(0.f),
	  m_contactDamping(.1),
	  m_contactStiffness(BT_LARGE_FLOAT),
	  m_internalType(CO_COLLISION_OBJECT),
	  m_userObjectPointer(0),
	  m_userIndex2(-1),
	  m_userIndex(-1),
	  m_userIndex3(-1),
	  m_hitFraction(btScalar(1.)),
	  m_ccdSweptSphereRadius(btScalar(0.)),
	  m_ccdMotionThreshold(btScalar(0.)),
	  m_checkCollideWith(false),
	  m_updateRevision(0)
{
	m_worldTransform.setIdentity();
	m_interpolationWorldTransform.setIdentity();
}

btCollisionObject::~btCollisionObject()
{
}

void btCollisionObject::setActivationState(int newState) const
{
	if ((m_activationState1 != DISABLE_DEACTIVATION) && (m_activationState1 != DISABLE_SIMULATION))
		m_activationState1 = newState;
}

void btCollisionObject::forceActivationState(int newState) const
{
	m_activationState1 = newState;
}

void btCollisionObject::activate(bool forceActivation) const
{
	if (forceActivation || !(m_collisionFlags & (CF_STATIC_OBJECT | CF_KINEMATIC_OBJECT)))
	{
		setActivationState(ACTIVE_TAG);
		m_deactivationTime = btScalar(0.);
	}
}

const char* btCollisionObject::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btCollisionObjectData* dataOut = (btCollisionObjectData*)dataBuffer;

	m_worldTransform.serialize(dataOut->m_worldTransform);
	m_interpolationWorldTransform.serialize(dataOut->m_interpolationWorldTransform);
	m_interpolationLinearVelocity.serialize(dataOut->m_interpolationLinearVelocity);
	m_interpolationAngularVelocity.serialize(dataOut->m_interpolationAngularVelocity);
	m_anisotropicFriction.serialize(dataOut->m_anisotropicFriction);
	dataOut->m_hasAnisotropicFriction = m_hasAnisotropicFriction;
	dataOut->m_contactProcessingThreshold = m_contactProcessingThreshold;
	dataOut->m_broadphaseHandle = 0;
	dataOut->m_collisionShape = serializer->getUniquePointer(m_collisionShape);
	dataOut->m_rootCollisionShape = 0;  //@todo
	dataOut->m_collisionFlags = m_collisionFlags;
	dataOut->m_islandTag1 = m_islandTag1;
	dataOut->m_companionId = m_companionId;
	dataOut->m_activationState1 = m_activationState1;
	dataOut->m_deactivationTime = m_deactivationTime;
	dataOut->m_friction = m_friction;
	dataOut->m_rollingFriction = m_rollingFriction;
	dataOut->m_contactDamping = m_contactDamping;
	dataOut->m_contactStiffness = m_contactStiffness;
	dataOut->m_restitution = m_restitution;
	dataOut->m_internalType = m_internalType;

	char* name = (char*)serializer->findNameForPointer(this);
	dataOut->m_name = (char*)serializer->getUniquePointer(name);
	if (dataOut->m_name)
	{
		serializer->serializeName(name);
	}
	dataOut->m_hitFraction = m_hitFraction;
	dataOut->m_ccdSweptSphereRadius = m_ccdSweptSphereRadius;
	dataOut->m_ccdMotionThreshold = m_ccdMotionThreshold;
	dataOut->m_checkCollideWith = m_checkCollideWith;
	if (m_broadphaseHandle)
	{
		dataOut->m_collisionFilterGroup = m_broadphaseHandle->m_collisionFilterGroup;
		dataOut->m_collisionFilterMask = m_broadphaseHandle->m_collisionFilterMask;
		dataOut->m_uniqueId = m_broadphaseHandle->m_uniqueId;
	}
	else
	{
		dataOut->m_collisionFilterGroup = 0;
		dataOut->m_collisionFilterMask = 0;
		dataOut->m_uniqueId = -1;
	}
	return btCollisionObjectDataName;
}

void btCollisionObject::serializeSingleObject(class btSerializer* serializer) const
{
	int len = calculateSerializeBufferSize();
	btChunk* chunk = serializer->allocate(len, 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_COLLISIONOBJECT_CODE, (void*)this);
}





#ifndef BT_COLLISION_OBJECT_WRAPPER_H
#define BT_COLLISION_OBJECT_WRAPPER_H

///btCollisionObjectWrapperis an internal data structure.
///Most users can ignore this and use btCollisionObject and btCollisionShape instead
class btCollisionShape;
class btCollisionObject;
class btTransform;
#include "LinearMath/btScalar.h"

#define BT_DECLARE_STACK_ONLY_OBJECT \
private:                             \
	void* operator new(size_t size); \
	void operator delete(void*);

struct btCollisionObjectWrapper;
struct btCollisionObjectWrapper
{
	BT_DECLARE_STACK_ONLY_OBJECT

private:
	btCollisionObjectWrapper(const btCollisionObjectWrapper&);  // not implemented. Not allowed.
	btCollisionObjectWrapper* operator=(const btCollisionObjectWrapper&);

public:
	const btCollisionObjectWrapper* m_parent;
	const btCollisionShape* m_shape;
	const btCollisionObject* m_collisionObject;
	const btTransform& m_worldTransform;
    const btTransform* m_preTransform;
	int m_partId;
	int m_index;

	btCollisionObjectWrapper(const btCollisionObjectWrapper* parent, const btCollisionShape* shape, const btCollisionObject* collisionObject, const btTransform& worldTransform, int partId, int index)
		: m_parent(parent), m_shape(shape), m_collisionObject(collisionObject), m_worldTransform(worldTransform), m_preTransform(NULL), m_partId(partId), m_index(index)
	{
	}
    
    btCollisionObjectWrapper(const btCollisionObjectWrapper* parent, const btCollisionShape* shape, const btCollisionObject* collisionObject, const btTransform& worldTransform, const btTransform& preTransform, int partId, int index)
    : m_parent(parent), m_shape(shape), m_collisionObject(collisionObject), m_worldTransform(worldTransform), m_preTransform(&preTransform), m_partId(partId), m_index(index)
    {
    }

	SIMD_FORCE_INLINE const btTransform& getWorldTransform() const { return m_worldTransform; }
	SIMD_FORCE_INLINE const btCollisionObject* getCollisionObject() const { return m_collisionObject; }
	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const { return m_shape; }
};

#endif  //BT_COLLISION_OBJECT_WRAPPER_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_SIMULATION_ISLAND_MANAGER_H
#define BT_SIMULATION_ISLAND_MANAGER_H

#include "BulletCollision/CollisionDispatch/btUnionFind.h"
#include "BulletCollision/CollisionDispatch/btCollisionCreateFunc.h"
#include "LinearMath/btAlignedObjectArray.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

class btCollisionObject;
class btCollisionWorld;
class btDispatcher;
class btPersistentManifold;

///SimulationIslandManager creates and handles simulation islands, using btUnionFind
class btSimulationIslandManager
{
	btUnionFind m_unionFind;

	btAlignedObjectArray<btPersistentManifold*> m_islandmanifold;
	btAlignedObjectArray<btCollisionObject*> m_islandBodies;

	bool m_splitIslands;

public:
	btSimulationIslandManager();
	virtual ~btSimulationIslandManager();

	void initUnionFind(int n);

	btUnionFind& getUnionFind() { return m_unionFind; }

	virtual void updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher);
	virtual void storeIslandActivationState(btCollisionWorld* world);

	void findUnions(btDispatcher* dispatcher, btCollisionWorld* colWorld);

	struct IslandCallback
	{
		virtual ~IslandCallback(){};

		virtual void processIsland(btCollisionObject** bodies, int numBodies, class btPersistentManifold** manifolds, int numManifolds, int islandId) = 0;
	};

	void buildAndProcessIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback);
    
	void buildIslands(btDispatcher* dispatcher, btCollisionWorld* colWorld);

    void processIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback);
    
	bool getSplitIslands()
	{
		return m_splitIslands;
	}
	void setSplitIslands(bool doSplitIslands)
	{
		m_splitIslands = doSplitIslands;
	}
};

#endif  //BT_SIMULATION_ISLAND_MANAGER_H






/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "LinearMath/btScalar.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "BulletCollision/BroadphaseCollision/btDispatcher.h"
#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"

#include "LinearMath/btQuickprof.h"

btSimulationIslandManager::btSimulationIslandManager() : m_splitIslands(true)
{
}

btSimulationIslandManager::~btSimulationIslandManager()
{
}

void btSimulationIslandManager::initUnionFind(int n)
{
	m_unionFind.reset(n);
}

void btSimulationIslandManager::findUnions(btDispatcher* /* dispatcher */, btCollisionWorld* colWorld)
{
	{
		btOverlappingPairCache* pairCachePtr = colWorld->getPairCache();
		const int numOverlappingPairs = pairCachePtr->getNumOverlappingPairs();
		if (numOverlappingPairs)
		{
			btBroadphasePair* pairPtr = pairCachePtr->getOverlappingPairArrayPtr();

			for (int i = 0; i < numOverlappingPairs; i++)
			{
				const btBroadphasePair& collisionPair = pairPtr[i];
				btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
				btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;

				if (((colObj0) && ((colObj0)->mergesSimulationIslands())) &&
					((colObj1) && ((colObj1)->mergesSimulationIslands())))
				{
					m_unionFind.unite((colObj0)->getIslandTag(),
									  (colObj1)->getIslandTag());
				}
			}
		}
	}
}

#ifdef STATIC_SIMULATION_ISLAND_OPTIMIZATION
void btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{
	// put the index into m_controllers into m_tag
	int index = 0;
	{
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			//Adding filtering here
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(index++);
			}
			collisionObject->setCompanionId(-1);
			collisionObject->setHitFraction(btScalar(1.));
		}
	}
	// do the union find

	initUnionFind(index);

	findUnions(dispatcher, colWorld);
}

void btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
	// put the islandId ('find' value) into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(m_unionFind.find(index));
				//Set the correct object offset in Collision Object Array
				m_unionFind.getElement(index).m_sz = i;
				collisionObject->setCompanionId(-1);
				index++;
			}
			else
			{
				collisionObject->setIslandTag(-1);
				collisionObject->setCompanionId(-2);
			}
		}
	}
}

#else  //STATIC_SIMULATION_ISLAND_OPTIMIZATION
void btSimulationIslandManager::updateActivationState(btCollisionWorld* colWorld, btDispatcher* dispatcher)
{
	initUnionFind(int(colWorld->getCollisionObjectArray().size()));

	// put the index into m_controllers into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			collisionObject->setIslandTag(index);
			collisionObject->setCompanionId(-1);
			collisionObject->setHitFraction(btScalar(1.));
			index++;
		}
	}
	// do the union find

	findUnions(dispatcher, colWorld);
}

void btSimulationIslandManager::storeIslandActivationState(btCollisionWorld* colWorld)
{
	// put the islandId ('find' value) into m_tag
	{
		int index = 0;
		int i;
		for (i = 0; i < colWorld->getCollisionObjectArray().size(); i++)
		{
			btCollisionObject* collisionObject = colWorld->getCollisionObjectArray()[i];
			if (!collisionObject->isStaticOrKinematicObject())
			{
				collisionObject->setIslandTag(m_unionFind.find(index));
				collisionObject->setCompanionId(-1);
			}
			else
			{
				collisionObject->setIslandTag(-1);
				collisionObject->setCompanionId(-2);
			}
			index++;
		}
	}
}

#endif  //STATIC_SIMULATION_ISLAND_OPTIMIZATION

inline int getIslandId(const btPersistentManifold* lhs)
{
	int islandId;
	const btCollisionObject* rcolObj0 = static_cast<const btCollisionObject*>(lhs->getBody0());
	const btCollisionObject* rcolObj1 = static_cast<const btCollisionObject*>(lhs->getBody1());
	islandId = rcolObj0->getIslandTag() >= 0 ? rcolObj0->getIslandTag() : rcolObj1->getIslandTag();
	return islandId;
}

/// function object that routes calls to operator<
class btPersistentManifoldSortPredicate
{
public:
	SIMD_FORCE_INLINE bool operator()(const btPersistentManifold* lhs, const btPersistentManifold* rhs) const
	{
		return getIslandId(lhs) < getIslandId(rhs);
	}
};

class btPersistentManifoldSortPredicateDeterministic
{
public:
	SIMD_FORCE_INLINE bool operator()(const btPersistentManifold* lhs, const btPersistentManifold* rhs) const
	{
		return (
			(getIslandId(lhs) < getIslandId(rhs)) || ((getIslandId(lhs) == getIslandId(rhs)) && lhs->getBody0()->getBroadphaseHandle()->m_uniqueId < rhs->getBody0()->getBroadphaseHandle()->m_uniqueId) || ((getIslandId(lhs) == getIslandId(rhs)) && (lhs->getBody0()->getBroadphaseHandle()->m_uniqueId == rhs->getBody0()->getBroadphaseHandle()->m_uniqueId) && (lhs->getBody1()->getBroadphaseHandle()->m_uniqueId < rhs->getBody1()->getBroadphaseHandle()->m_uniqueId)));
	}
};

void btSimulationIslandManager::buildIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld)
{
	BT_PROFILE("islandUnionFindAndQuickSort");

	btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();

	m_islandmanifold.resize(0);

	//we are going to sort the unionfind array, and store the element id in the size
	//afterwards, we clean unionfind, to make sure no-one uses it anymore

	getUnionFind().sortIslands();
	int numElem = getUnionFind().getNumElements();

	int endIslandIndex = 1;
	int startIslandIndex;

	//update the sleeping state for bodies, if all are sleeping
	for (startIslandIndex = 0; startIslandIndex < numElem; startIslandIndex = endIslandIndex)
	{
		int islandId = getUnionFind().getElement(startIslandIndex).m_id;
		for (endIslandIndex = startIslandIndex + 1; (endIslandIndex < numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
		{
		}

		//int numSleeping = 0;

		bool allSleeping = true;

		int idx;
		for (idx = startIslandIndex; idx < endIslandIndex; idx++)
		{
			int i = getUnionFind().getElement(idx).m_sz;

			btCollisionObject* colObj0 = collisionObjects[i];
			if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
			{
				//				printf("error in island management\n");
			}

            btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));
			if (colObj0->getIslandTag() == islandId)
			{
				if (colObj0->getActivationState() == ACTIVE_TAG ||
					colObj0->getActivationState() == DISABLE_DEACTIVATION)
				{
					allSleeping = false;
					break;
				}
			}
		}

		if (allSleeping)
		{
			int idx;
			for (idx = startIslandIndex; idx < endIslandIndex; idx++)
			{
				int i = getUnionFind().getElement(idx).m_sz;
				btCollisionObject* colObj0 = collisionObjects[i];
				if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
				{
					//					printf("error in island management\n");
				}

                btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));

				if (colObj0->getIslandTag() == islandId)
				{
					colObj0->setActivationState(ISLAND_SLEEPING);
				}
			}
		}
		else
		{
			int idx;
			for (idx = startIslandIndex; idx < endIslandIndex; idx++)
			{
				int i = getUnionFind().getElement(idx).m_sz;

				btCollisionObject* colObj0 = collisionObjects[i];
				if ((colObj0->getIslandTag() != islandId) && (colObj0->getIslandTag() != -1))
				{
					//					printf("error in island management\n");
				}

                 btAssert((colObj0->getIslandTag() == islandId) || (colObj0->getIslandTag() == -1));


				if (colObj0->getIslandTag() == islandId)
				{
					if (colObj0->getActivationState() == ISLAND_SLEEPING)
					{
						colObj0->setActivationState(WANTS_DEACTIVATION);
						colObj0->setDeactivationTime(0.f);
					}
				}
			}
		}
	}

	int i;
	int maxNumManifolds = dispatcher->getNumManifolds();

	//#define SPLIT_ISLANDS 1
	//#ifdef SPLIT_ISLANDS

	//#endif //SPLIT_ISLANDS

	for (i = 0; i < maxNumManifolds; i++)
	{
		btPersistentManifold* manifold = dispatcher->getManifoldByIndexInternal(i);
		if (collisionWorld->getDispatchInfo().m_deterministicOverlappingPairs)
		{
			if (manifold->getNumContacts() == 0)
				continue;
		}

		const btCollisionObject* colObj0 = static_cast<const btCollisionObject*>(manifold->getBody0());
		const btCollisionObject* colObj1 = static_cast<const btCollisionObject*>(manifold->getBody1());

		///@todo: check sleeping conditions!
		if (((colObj0) && colObj0->getActivationState() != ISLAND_SLEEPING) ||
			((colObj1) && colObj1->getActivationState() != ISLAND_SLEEPING))
		{
			//kinematic objects don't merge islands, but wake up all connected objects
			if (colObj0->isKinematicObject() && colObj0->getActivationState() != ISLAND_SLEEPING)
			{
				if (colObj0->hasContactResponse())
					colObj1->activate();
			}
			if (colObj1->isKinematicObject() && colObj1->getActivationState() != ISLAND_SLEEPING)
			{
				if (colObj1->hasContactResponse())
					colObj0->activate();
			}
			if (m_splitIslands)
			{
				//filtering for response
				if (dispatcher->needsResponse(colObj0, colObj1))
					m_islandmanifold.push_back(manifold);
			}
		}
	}
}


///@todo: this is random access, it can be walked 'cache friendly'!
void btSimulationIslandManager::buildAndProcessIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback)
{
	buildIslands(dispatcher, collisionWorld);
    processIslands(dispatcher, collisionWorld, callback);
}

void btSimulationIslandManager::processIslands(btDispatcher* dispatcher, btCollisionWorld* collisionWorld, IslandCallback* callback)
{
    btCollisionObjectArray& collisionObjects = collisionWorld->getCollisionObjectArray();
	int endIslandIndex = 1;
	int startIslandIndex;
	int numElem = getUnionFind().getNumElements();

	BT_PROFILE("processIslands");

	if (!m_splitIslands)
	{
		btPersistentManifold** manifold = dispatcher->getInternalManifoldPointer();
		int maxNumManifolds = dispatcher->getNumManifolds();
		callback->processIsland(&collisionObjects[0], collisionObjects.size(), manifold, maxNumManifolds, -1);
	}
	else
	{
		// Sort manifolds, based on islands
		// Sort the vector using predicate and std::sort
		//std::sort(islandmanifold.begin(), islandmanifold.end(), btPersistentManifoldSortPredicate);

		int numManifolds = int(m_islandmanifold.size());

		//tried a radix sort, but quicksort/heapsort seems still faster
		//@todo rewrite island management
		//btPersistentManifoldSortPredicateDeterministic sorts contact manifolds based on islandid,
		//but also based on object0 unique id and object1 unique id
		if (collisionWorld->getDispatchInfo().m_deterministicOverlappingPairs)
		{
			m_islandmanifold.quickSort(btPersistentManifoldSortPredicateDeterministic());
		}
		else
		{
			m_islandmanifold.quickSort(btPersistentManifoldSortPredicate());
		}

		//m_islandmanifold.heapSort(btPersistentManifoldSortPredicate());

		//now process all active islands (sets of manifolds for now)

		int startManifoldIndex = 0;
		int endManifoldIndex = 1;

		//int islandId;

		//	printf("Start Islands\n");

		//traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
		for (startIslandIndex = 0; startIslandIndex < numElem; startIslandIndex = endIslandIndex)
		{
			int islandId = getUnionFind().getElement(startIslandIndex).m_id;

			bool islandSleeping = true;

			for (endIslandIndex = startIslandIndex; (endIslandIndex < numElem) && (getUnionFind().getElement(endIslandIndex).m_id == islandId); endIslandIndex++)
			{
				int i = getUnionFind().getElement(endIslandIndex).m_sz;
				btCollisionObject* colObj0 = collisionObjects[i];
				m_islandBodies.push_back(colObj0);
				if (colObj0->isActive())
					islandSleeping = false;
			}

			//find the accompanying contact manifold for this islandId
			int numIslandManifolds = 0;
			btPersistentManifold** startManifold = 0;

			if (startManifoldIndex < numManifolds)
			{
				int curIslandId = getIslandId(m_islandmanifold[startManifoldIndex]);
				if (curIslandId == islandId)
				{
					startManifold = &m_islandmanifold[startManifoldIndex];

					for (endManifoldIndex = startManifoldIndex + 1; (endManifoldIndex < numManifolds) && (islandId == getIslandId(m_islandmanifold[endManifoldIndex])); endManifoldIndex++)
					{
					}
					/// Process the actual simulation, only if not sleeping/deactivated
					numIslandManifolds = endManifoldIndex - startManifoldIndex;
				}
			}

			if (!islandSleeping)
			{
				callback->processIsland(&m_islandBodies[0], m_islandBodies.size(), startManifold, numIslandManifolds, islandId);
				//			printf("Island callback of size:%d bodies, %d manifolds\n",islandBodies.size(),numIslandManifolds);
			}

			if (numIslandManifolds)
			{
				startManifoldIndex = endManifoldIndex;
			}

			m_islandBodies.resize(0);
		}
	}  // else if(!splitIslands)
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/**
 * @mainpage Bullet Documentation
 *
 * @section intro_sec Introduction
 * Bullet is a Collision Detection and Rigid Body Dynamics Library. The Library is Open Source and free for commercial use, under the ZLib license ( http://opensource.org/licenses/zlib-license.php ).
 *
 * The main documentation is Bullet_User_Manual.pdf, included in the source code distribution.
 * There is the Physics Forum for feedback and general Collision Detection and Physics discussions.
 * Please visit http://www.bulletphysics.org
 *
 * @section install_sec Installation
 *
 * @subsection step1 Step 1: Download
 * You can download the Bullet Physics Library from the github repository: https://github.com/bulletphysics/bullet3/releases 
 *
 * @subsection step2 Step 2: Building
 * Bullet has multiple build systems, including premake, cmake and autotools. Premake and cmake support all platforms.
 * Premake is included in the Bullet/build folder for Windows, Mac OSX and Linux. 
 * Under Windows you can click on Bullet/build/vs2010.bat to create Microsoft Visual Studio projects. 
 * On Mac OSX and Linux you can open a terminal and generate Makefile, codeblocks or Xcode4 projects:
 * cd Bullet/build
 * ./premake4_osx gmake or ./premake4_linux gmake or ./premake4_linux64 gmake or (for Mac) ./premake4_osx xcode4
 * cd Bullet/build/gmake
 * make
 * 
 * An alternative to premake is cmake. You can download cmake from http://www.cmake.org
 * cmake can autogenerate projectfiles for Microsoft Visual Studio, Apple Xcode, KDevelop and Unix Makefiles.
 * The easiest is to run the CMake cmake-gui graphical user interface and choose the options and generate projectfiles.
 * You can also use cmake in the command-line. Here are some examples for various platforms:
 * cmake . -G "Visual Studio 9 2008"
 * cmake . -G Xcode
 * cmake . -G "Unix Makefiles"
 * Although cmake is recommended, you can also use autotools for UNIX: ./autogen.sh ./configure to create a Makefile and then run make.
 * 
 * @subsection step3 Step 3: Testing demos
 * Try to run and experiment with BasicDemo executable as a starting point.
 * Bullet can be used in several ways, as Full Rigid Body simulation, as Collision Detector Library or Low Level / Snippets like the GJK Closest Point calculation.
 * The Dependencies can be seen in this documentation under Directories
 * 
 * @subsection step4 Step 4: Integrating in your application, full Rigid Body and Soft Body simulation
 * Check out BasicDemo how to create a btDynamicsWorld, btRigidBody and btCollisionShape, Stepping the simulation and synchronizing your graphics object transform.
 * Check out SoftDemo how to use soft body dynamics, using btSoftRigidDynamicsWorld.
 * @subsection step5 Step 5 : Integrate the Collision Detection Library (without Dynamics and other Extras)
 * Bullet Collision Detection can also be used without the Dynamics/Extras.
 * Check out btCollisionWorld and btCollisionObject, and the CollisionInterfaceDemo.
 * @subsection step6 Step 6 : Use Snippets like the GJK Closest Point calculation.
 * Bullet has been designed in a modular way keeping dependencies to a minimum. The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
 *
 * @section copyright Copyright
 * For up-to-data information and copyright and contributors list check out the Bullet_User_Manual.pdf
 * 
 */

#ifndef BT_COLLISION_WORLD_H
#define BT_COLLISION_WORLD_H

class btCollisionShape;
class btConvexShape;
class btBroadphaseInterface;
class btSerializer;

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
#include "LinearMath/btAlignedObjectArray.h"

///CollisionWorld is interface and container for the collision detection
class btCollisionWorld
{
protected:
	btAlignedObjectArray<btCollisionObject*> m_collisionObjects;

	btDispatcher* m_dispatcher1;

	btDispatcherInfo m_dispatchInfo;

	btBroadphaseInterface* m_broadphasePairCache;

	btIDebugDraw* m_debugDrawer;

	///m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
	///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
	bool m_forceUpdateAllAabbs;

	void serializeCollisionObjects(btSerializer* serializer);

	void serializeContactManifolds(btSerializer* serializer);

public:
	//this constructor doesn't own the dispatcher and paircache/broadphase
	btCollisionWorld(btDispatcher* dispatcher, btBroadphaseInterface* broadphasePairCache, btCollisionConfiguration* collisionConfiguration);

	virtual ~btCollisionWorld();

	void setBroadphase(btBroadphaseInterface* pairCache)
	{
		m_broadphasePairCache = pairCache;
	}

	const btBroadphaseInterface* getBroadphase() const
	{
		return m_broadphasePairCache;
	}

	btBroadphaseInterface* getBroadphase()
	{
		return m_broadphasePairCache;
	}

	btOverlappingPairCache* getPairCache()
	{
		return m_broadphasePairCache->getOverlappingPairCache();
	}

	btDispatcher* getDispatcher()
	{
		return m_dispatcher1;
	}

	const btDispatcher* getDispatcher() const
	{
		return m_dispatcher1;
	}

	void updateSingleAabb(btCollisionObject* colObj);

	virtual void updateAabbs();

	///the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
	///it can be useful to use if you perform ray tests without collision detection/simulation
	virtual void computeOverlappingPairs();

	virtual void setDebugDrawer(btIDebugDraw* debugDrawer)
	{
		m_debugDrawer = debugDrawer;
	}

	virtual btIDebugDraw* getDebugDrawer()
	{
		return m_debugDrawer;
	}

	virtual void debugDrawWorld();

	virtual void debugDrawObject(const btTransform& worldTransform, const btCollisionShape* shape, const btVector3& color);

	///LocalShapeInfo gives extra information for complex shapes
	///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
	struct LocalShapeInfo
	{
		int m_shapePart;
		int m_triangleIndex;

		//const btCollisionShape*	m_shapeTemp;
		//const btTransform*	m_shapeLocalTransform;
	};

	struct LocalRayResult
	{
		LocalRayResult(const btCollisionObject* collisionObject,
					   LocalShapeInfo* localShapeInfo,
					   const btVector3& hitNormalLocal,
					   btScalar hitFraction)
			: m_collisionObject(collisionObject),
			  m_localShapeInfo(localShapeInfo),
			  m_hitNormalLocal(hitNormalLocal),
			  m_hitFraction(hitFraction)
		{
		}

		const btCollisionObject* m_collisionObject;
		LocalShapeInfo* m_localShapeInfo;
		btVector3 m_hitNormalLocal;
		btScalar m_hitFraction;
	};

	///RayResultCallback is used to report new raycast results
	struct RayResultCallback
	{
		btScalar m_closestHitFraction;
		const btCollisionObject* m_collisionObject;
		int m_collisionFilterGroup;
		int m_collisionFilterMask;
		//@BP Mod - Custom flags, currently used to enable backface culling on tri-meshes, see btRaycastCallback.h. Apply any of the EFlags defined there on m_flags here to invoke.
		unsigned int m_flags;

		virtual ~RayResultCallback()
		{
		}
		bool hasHit() const
		{
			return (m_collisionObject != 0);
		}

		RayResultCallback()
			: m_closestHitFraction(btScalar(1.)),
			  m_collisionObject(0),
			  m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter),
			  //@BP Mod
			  m_flags(0)
		{
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace) = 0;
	};

	struct ClosestRayResultCallback : public RayResultCallback
	{
		ClosestRayResultCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld)
			: m_rayFromWorld(rayFromWorld),
			  m_rayToWorld(rayToWorld)
		{
		}

		btVector3 m_rayFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_rayToWorld;

		btVector3 m_hitNormalWorld;
		btVector3 m_hitPointWorld;

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace)
		{
			//caller already does the filter on the m_closestHitFraction
			btAssert(rayResult.m_hitFraction <= m_closestHitFraction);

			m_closestHitFraction = rayResult.m_hitFraction;
			m_collisionObject = rayResult.m_collisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = rayResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				m_hitNormalWorld = m_collisionObject->getWorldTransform().getBasis() * rayResult.m_hitNormalLocal;
			}
			m_hitPointWorld.setInterpolate3(m_rayFromWorld, m_rayToWorld, rayResult.m_hitFraction);
			return rayResult.m_hitFraction;
		}
	};

	struct AllHitsRayResultCallback : public RayResultCallback
	{
		AllHitsRayResultCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld)
			: m_rayFromWorld(rayFromWorld),
			  m_rayToWorld(rayToWorld)
		{
		}

		btAlignedObjectArray<const btCollisionObject*> m_collisionObjects;

		btVector3 m_rayFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_rayToWorld;

		btAlignedObjectArray<btVector3> m_hitNormalWorld;
		btAlignedObjectArray<btVector3> m_hitPointWorld;
		btAlignedObjectArray<btScalar> m_hitFractions;

		virtual btScalar addSingleResult(LocalRayResult& rayResult, bool normalInWorldSpace)
		{
			m_collisionObject = rayResult.m_collisionObject;
			m_collisionObjects.push_back(rayResult.m_collisionObject);
			btVector3 hitNormalWorld;
			if (normalInWorldSpace)
			{
				hitNormalWorld = rayResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				hitNormalWorld = m_collisionObject->getWorldTransform().getBasis() * rayResult.m_hitNormalLocal;
			}
			m_hitNormalWorld.push_back(hitNormalWorld);
			btVector3 hitPointWorld;
			hitPointWorld.setInterpolate3(m_rayFromWorld, m_rayToWorld, rayResult.m_hitFraction);
			m_hitPointWorld.push_back(hitPointWorld);
			m_hitFractions.push_back(rayResult.m_hitFraction);
			return m_closestHitFraction;
		}
	};

	struct LocalConvexResult
	{
		LocalConvexResult(const btCollisionObject* hitCollisionObject,
						  LocalShapeInfo* localShapeInfo,
						  const btVector3& hitNormalLocal,
						  const btVector3& hitPointLocal,
						  btScalar hitFraction)
			: m_hitCollisionObject(hitCollisionObject),
			  m_localShapeInfo(localShapeInfo),
			  m_hitNormalLocal(hitNormalLocal),
			  m_hitPointLocal(hitPointLocal),
			  m_hitFraction(hitFraction)
		{
		}

		const btCollisionObject* m_hitCollisionObject;
		LocalShapeInfo* m_localShapeInfo;
		btVector3 m_hitNormalLocal;
		btVector3 m_hitPointLocal;
		btScalar m_hitFraction;
	};

	///RayResultCallback is used to report new raycast results
	struct ConvexResultCallback
	{
		btScalar m_closestHitFraction;
		int m_collisionFilterGroup;
		int m_collisionFilterMask;

		ConvexResultCallback()
			: m_closestHitFraction(btScalar(1.)),
			  m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter)
		{
		}

		virtual ~ConvexResultCallback()
		{
		}

		bool hasHit() const
		{
			return (m_closestHitFraction < btScalar(1.));
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(LocalConvexResult& convexResult, bool normalInWorldSpace) = 0;
	};

	struct ClosestConvexResultCallback : public ConvexResultCallback
	{
		ClosestConvexResultCallback(const btVector3& convexFromWorld, const btVector3& convexToWorld)
			: m_convexFromWorld(convexFromWorld),
			  m_convexToWorld(convexToWorld),
			  m_hitCollisionObject(0)
		{
		}

		btVector3 m_convexFromWorld;  //used to calculate hitPointWorld from hitFraction
		btVector3 m_convexToWorld;

		btVector3 m_hitNormalWorld;
		btVector3 m_hitPointWorld;
		const btCollisionObject* m_hitCollisionObject;

		virtual btScalar addSingleResult(LocalConvexResult& convexResult, bool normalInWorldSpace)
		{
			//caller already does the filter on the m_closestHitFraction
			btAssert(convexResult.m_hitFraction <= m_closestHitFraction);

			m_closestHitFraction = convexResult.m_hitFraction;
			m_hitCollisionObject = convexResult.m_hitCollisionObject;
			if (normalInWorldSpace)
			{
				m_hitNormalWorld = convexResult.m_hitNormalLocal;
			}
			else
			{
				///need to transform normal into worldspace
				m_hitNormalWorld = m_hitCollisionObject->getWorldTransform().getBasis() * convexResult.m_hitNormalLocal;
			}
			m_hitPointWorld = convexResult.m_hitPointLocal;
			return convexResult.m_hitFraction;
		}
	};

	///ContactResultCallback is used to report contact points
	struct ContactResultCallback
	{
		int m_collisionFilterGroup;
		int m_collisionFilterMask;
		btScalar m_closestDistanceThreshold;

		ContactResultCallback()
			: m_collisionFilterGroup(btBroadphaseProxy::DefaultFilter),
			  m_collisionFilterMask(btBroadphaseProxy::AllFilter),
			  m_closestDistanceThreshold(0)
		{
		}

		virtual ~ContactResultCallback()
		{
		}

		virtual bool needsCollision(btBroadphaseProxy* proxy0) const
		{
			bool collides = (proxy0->m_collisionFilterGroup & m_collisionFilterMask) != 0;
			collides = collides && (m_collisionFilterGroup & proxy0->m_collisionFilterMask);
			return collides;
		}

		virtual btScalar addSingleResult(btManifoldPoint& cp, const btCollisionObjectWrapper* colObj0Wrap, int partId0, int index0, const btCollisionObjectWrapper* colObj1Wrap, int partId1, int index1) = 0;
	};

	int getNumCollisionObjects() const
	{
		return int(m_collisionObjects.size());
	}

	/// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
	/// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
	virtual void rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const;

	/// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
	/// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
	void convexSweepTest(const btConvexShape* castShape, const btTransform& from, const btTransform& to, ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration = btScalar(0.)) const;

	///contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
	///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
	void contactTest(btCollisionObject* colObj, ContactResultCallback& resultCallback);

	///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
	///it reports one or more contact points (including the one with deepest penetration)
	void contactPairTest(btCollisionObject* colObjA, btCollisionObject* colObjB, ContactResultCallback& resultCallback);

	/// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
	/// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
	/// This allows more customization.
	static void rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
							  btCollisionObject* collisionObject,
							  const btCollisionShape* collisionShape,
							  const btTransform& colObjWorldTransform,
							  RayResultCallback& resultCallback);

	static void rayTestSingleInternal(const btTransform& rayFromTrans, const btTransform& rayToTrans,
									  const btCollisionObjectWrapper* collisionObjectWrap,
									  RayResultCallback& resultCallback);

	/// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
	static void objectQuerySingle(const btConvexShape* castShape, const btTransform& rayFromTrans, const btTransform& rayToTrans,
								  btCollisionObject* collisionObject,
								  const btCollisionShape* collisionShape,
								  const btTransform& colObjWorldTransform,
								  ConvexResultCallback& resultCallback, btScalar allowedPenetration);

	static void objectQuerySingleInternal(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
										  const btCollisionObjectWrapper* colObjWrap,
										  ConvexResultCallback& resultCallback, btScalar allowedPenetration);

	virtual void addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup = btBroadphaseProxy::DefaultFilter, int collisionFilterMask = btBroadphaseProxy::AllFilter);

	virtual void refreshBroadphaseProxy(btCollisionObject* collisionObject);

	btCollisionObjectArray& getCollisionObjectArray()
	{
		return m_collisionObjects;
	}

	const btCollisionObjectArray& getCollisionObjectArray() const
	{
		return m_collisionObjects;
	}

	virtual void removeCollisionObject(btCollisionObject* collisionObject);

	virtual void performDiscreteCollisionDetection();

	btDispatcherInfo& getDispatchInfo()
	{
		return m_dispatchInfo;
	}

	const btDispatcherInfo& getDispatchInfo() const
	{
		return m_dispatchInfo;
	}

	bool getForceUpdateAllAabbs() const
	{
		return m_forceUpdateAllAabbs;
	}
	void setForceUpdateAllAabbs(bool forceUpdateAllAabbs)
	{
		m_forceUpdateAllAabbs = forceUpdateAllAabbs;
	}

	///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
	virtual void serialize(btSerializer* serializer);
};

#endif  //BT_COLLISION_WORLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h"
#include "BulletCollision/NarrowPhaseCollision/btRaycastCallback.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/NarrowPhaseCollision/btSubSimplexConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btGjkConvexCast.h"
#include "BulletCollision/NarrowPhaseCollision/btContinuousConvexCollision.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseInterface.h"
#include "BulletCollision/BroadphaseCollision/btDbvt.h"
#include "LinearMath/btAabbUtil2.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btSerializer.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"

//#define DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION

//#define USE_BRUTEFORCE_RAYBROADPHASE 1
//RECALCULATE_AABB is slower, but benefit is that you don't need to call 'stepSimulation'  or 'updateAabbs' before using a rayTest
//#define RECALCULATE_AABB_RAYCAST 1

//When the user doesn't provide dispatcher or broadphase, create basic versions (and delete them in destructor)
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"

///for debug drawing

//for debug rendering
#include "BulletCollision/CollisionShapes/btBoxShape.h"
#include "BulletCollision/CollisionShapes/btCapsuleShape.h"
#include "BulletCollision/CollisionShapes/btCompoundShape.h"
#include "BulletCollision/CollisionShapes/btConeShape.h"
#include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btCylinderShape.h"
#include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"
#include "BulletCollision/CollisionShapes/btTriangleCallback.h"
#include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
#include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"

btCollisionWorld::btCollisionWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btCollisionConfiguration* collisionConfiguration)
	: m_dispatcher1(dispatcher),
	  m_broadphasePairCache(pairCache),
	  m_debugDrawer(0),
	  m_forceUpdateAllAabbs(true)
{
}

btCollisionWorld::~btCollisionWorld()
{
	//clean up remaining objects
	int i;
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* collisionObject = m_collisionObjects[i];

		btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
		if (bp)
		{
			//
			// only clear the cached algorithms
			//
			getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
			getBroadphase()->destroyProxy(bp, m_dispatcher1);
			collisionObject->setBroadphaseHandle(0);
		}
	}
}

void btCollisionWorld::refreshBroadphaseProxy(btCollisionObject* collisionObject)
{
	if (collisionObject->getBroadphaseHandle())
	{
		int collisionFilterGroup = collisionObject->getBroadphaseHandle()->m_collisionFilterGroup;
		int collisionFilterMask = collisionObject->getBroadphaseHandle()->m_collisionFilterMask;

		getBroadphase()->destroyProxy(collisionObject->getBroadphaseHandle(), getDispatcher());

		//calculate new AABB
		btTransform trans = collisionObject->getWorldTransform();

		btVector3 minAabb;
		btVector3 maxAabb;
		collisionObject->getCollisionShape()->getAabb(trans, minAabb, maxAabb);

		int type = collisionObject->getCollisionShape()->getShapeType();
		collisionObject->setBroadphaseHandle(getBroadphase()->createProxy(
			minAabb,
			maxAabb,
			type,
			collisionObject,
			collisionFilterGroup,
			collisionFilterMask,
			m_dispatcher1));
	}
}

void btCollisionWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{
	btAssert(collisionObject);

	//check that the object isn't already added
	btAssert(m_collisionObjects.findLinearSearch(collisionObject) == m_collisionObjects.size());
	btAssert(collisionObject->getWorldArrayIndex() == -1);  // do not add the same object to more than one collision world

	collisionObject->setWorldArrayIndex(m_collisionObjects.size());
	m_collisionObjects.push_back(collisionObject);

	//calculate new AABB
	btTransform trans = collisionObject->getWorldTransform();

	btVector3 minAabb;
	btVector3 maxAabb;
	collisionObject->getCollisionShape()->getAabb(trans, minAabb, maxAabb);

	int type = collisionObject->getCollisionShape()->getShapeType();
	collisionObject->setBroadphaseHandle(getBroadphase()->createProxy(
		minAabb,
		maxAabb,
		type,
		collisionObject,
		collisionFilterGroup,
		collisionFilterMask,
		m_dispatcher1));
}

void btCollisionWorld::updateSingleAabb(btCollisionObject* colObj)
{
	btVector3 minAabb, maxAabb;
	colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
	//need to increase the aabb for contact thresholds
	btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
	minAabb -= contactThreshold;
	maxAabb += contactThreshold;

	if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
	{
		btVector3 minAabb2, maxAabb2;
		colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
		minAabb2 -= contactThreshold;
		maxAabb2 += contactThreshold;
		minAabb.setMin(minAabb2);
		maxAabb.setMax(maxAabb2);
	}

	btBroadphaseInterface* bp = (btBroadphaseInterface*)m_broadphasePairCache;

	//moving objects should be moderately sized, probably something wrong if not
	if (colObj->isStaticObject() || ((maxAabb - minAabb).length2() < btScalar(1e12)))
	{
		bp->setAabb(colObj->getBroadphaseHandle(), minAabb, maxAabb, m_dispatcher1);
	}
	else
	{
		//something went wrong, investigate
		//this assert is unwanted in 3D modelers (danger of loosing work)
		colObj->setActivationState(DISABLE_SIMULATION);

		static bool reportMe = true;
		if (reportMe && m_debugDrawer)
		{
			reportMe = false;
			m_debugDrawer->reportErrorWarning("Overflow in AABB, object removed from simulation");
			m_debugDrawer->reportErrorWarning("If you can reproduce this, please email bugs@continuousphysics.com\n");
			m_debugDrawer->reportErrorWarning("Please include above information, your Platform, version of OS.\n");
			m_debugDrawer->reportErrorWarning("Thanks.\n");
		}
	}
}

void btCollisionWorld::updateAabbs()
{
	BT_PROFILE("updateAabbs");

	for (int i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btAssert(colObj->getWorldArrayIndex() == i);

		//only update aabb of active objects
		if (m_forceUpdateAllAabbs || colObj->isActive())
		{
			updateSingleAabb(colObj);
		}
	}
}

void btCollisionWorld::computeOverlappingPairs()
{
	BT_PROFILE("calculateOverlappingPairs");
	m_broadphasePairCache->calculateOverlappingPairs(m_dispatcher1);
}

void btCollisionWorld::performDiscreteCollisionDetection()
{
	BT_PROFILE("performDiscreteCollisionDetection");

	btDispatcherInfo& dispatchInfo = getDispatchInfo();

	updateAabbs();

	computeOverlappingPairs();

	btDispatcher* dispatcher = getDispatcher();
	{
		BT_PROFILE("dispatchAllCollisionPairs");
		if (dispatcher)
			dispatcher->dispatchAllCollisionPairs(m_broadphasePairCache->getOverlappingPairCache(), dispatchInfo, m_dispatcher1);
	}
}

void btCollisionWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
	//bool removeFromBroadphase = false;

	{
		btBroadphaseProxy* bp = collisionObject->getBroadphaseHandle();
		if (bp)
		{
			//
			// only clear the cached algorithms
			//
			getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(bp, m_dispatcher1);
			getBroadphase()->destroyProxy(bp, m_dispatcher1);
			collisionObject->setBroadphaseHandle(0);
		}
	}

	int iObj = collisionObject->getWorldArrayIndex();
	//    btAssert(iObj >= 0 && iObj < m_collisionObjects.size()); // trying to remove an object that was never added or already removed previously?
	if (iObj >= 0 && iObj < m_collisionObjects.size())
	{
		btAssert(collisionObject == m_collisionObjects[iObj]);
		m_collisionObjects.swap(iObj, m_collisionObjects.size() - 1);
		m_collisionObjects.pop_back();
		if (iObj < m_collisionObjects.size())
		{
			m_collisionObjects[iObj]->setWorldArrayIndex(iObj);
		}
	}
	else
	{
		// slow linear search
		//swapremove
		m_collisionObjects.remove(collisionObject);
	}
	collisionObject->setWorldArrayIndex(-1);
}

void btCollisionWorld::rayTestSingle(const btTransform& rayFromTrans, const btTransform& rayToTrans,
									 btCollisionObject* collisionObject,
									 const btCollisionShape* collisionShape,
									 const btTransform& colObjWorldTransform,
									 RayResultCallback& resultCallback)
{
	btCollisionObjectWrapper colObWrap(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
	btCollisionWorld::rayTestSingleInternal(rayFromTrans, rayToTrans, &colObWrap, resultCallback);
}

void btCollisionWorld::rayTestSingleInternal(const btTransform& rayFromTrans, const btTransform& rayToTrans,
											 const btCollisionObjectWrapper* collisionObjectWrap,
											 RayResultCallback& resultCallback)
{
	btSphereShape pointShape(btScalar(0.0));
	pointShape.setMargin(0.f);
	const btConvexShape* castShape = &pointShape;
	const btCollisionShape* collisionShape = collisionObjectWrap->getCollisionShape();
	const btTransform& colObjWorldTransform = collisionObjectWrap->getWorldTransform();

	if (collisionShape->isConvex())
	{
		//		BT_PROFILE("rayTestConvex");
		btConvexCast::CastResult castResult;
		castResult.m_fraction = resultCallback.m_closestHitFraction;

		btConvexShape* convexShape = (btConvexShape*)collisionShape;
		btVoronoiSimplexSolver simplexSolver;
		btSubsimplexConvexCast subSimplexConvexCaster(castShape, convexShape, &simplexSolver);

		btGjkConvexCast gjkConvexCaster(castShape, convexShape, &simplexSolver);

		//btContinuousConvexCollision convexCaster(castShape,convexShape,&simplexSolver,0);

		btConvexCast* convexCasterPtr = 0;
		//use kF_UseSubSimplexConvexCastRaytest by default
		if (resultCallback.m_flags & btTriangleRaycastCallback::kF_UseGjkConvexCastRaytest)
			convexCasterPtr = &gjkConvexCaster;
		else
			convexCasterPtr = &subSimplexConvexCaster;

		btConvexCast& convexCaster = *convexCasterPtr;

		if (convexCaster.calcTimeOfImpact(rayFromTrans, rayToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
		{
			//add hit
			if (castResult.m_normal.length2() > btScalar(0.0001))
			{
				if (castResult.m_fraction < resultCallback.m_closestHitFraction)
				{
					//todo: figure out what this is about. When is rayFromTest.getBasis() not identity?
#ifdef USE_SUBSIMPLEX_CONVEX_CAST
					//rotate normal into worldspace
					castResult.m_normal = rayFromTrans.getBasis() * castResult.m_normal;
#endif  //USE_SUBSIMPLEX_CONVEX_CAST

					castResult.m_normal.normalize();
					btCollisionWorld::LocalRayResult localRayResult(
						collisionObjectWrap->getCollisionObject(),
						0,
						castResult.m_normal,
						castResult.m_fraction);

					bool normalInWorldSpace = true;
					resultCallback.addSingleResult(localRayResult, normalInWorldSpace);
				}
			}
		}
	}
	else
	{
		if (collisionShape->isConcave())
		{
			//ConvexCast::CastResult
			struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
			{
				btCollisionWorld::RayResultCallback* m_resultCallback;
				const btCollisionObject* m_collisionObject;
				const btConcaveShape* m_triangleMesh;

				btTransform m_colObjWorldTransform;

				BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
											  btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, const btConcaveShape* triangleMesh, const btTransform& colObjWorldTransform) :  //@BP Mod
																																																							btTriangleRaycastCallback(from, to, resultCallback->m_flags),
																																																							m_resultCallback(resultCallback),
																																																							m_collisionObject(collisionObject),
																																																							m_triangleMesh(triangleMesh),
																																																							m_colObjWorldTransform(colObjWorldTransform)
				{
				}

				virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
				{
					btCollisionWorld::LocalShapeInfo shapeInfo;
					shapeInfo.m_shapePart = partId;
					shapeInfo.m_triangleIndex = triangleIndex;

					btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

					btCollisionWorld::LocalRayResult rayResult(m_collisionObject,
															   &shapeInfo,
															   hitNormalWorld,
															   hitFraction);

					bool normalInWorldSpace = true;
					return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
				}
			};

			btTransform worldTocollisionObject = colObjWorldTransform.inverse();
			btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
			btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

			//			BT_PROFILE("rayTestConcave");
			if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				///optimized version for btBvhTriangleMeshShape
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				triangleMesh->performRaycast(&rcb, rayFromLocal, rayToLocal);
			}
			else if (collisionShape->getShapeType() == SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				///optimized version for btScaledBvhTriangleMeshShape
				btScaledBvhTriangleMeshShape* scaledTriangleMesh = (btScaledBvhTriangleMeshShape*)collisionShape;
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)scaledTriangleMesh->getChildShape();

				//scale the ray positions
				btVector3 scale = scaledTriangleMesh->getLocalScaling();
				btVector3 rayFromLocalScaled = rayFromLocal / scale;
				btVector3 rayToLocalScaled = rayToLocal / scale;

				//perform raycast in the underlying btBvhTriangleMeshShape
				BridgeTriangleRaycastCallback rcb(rayFromLocalScaled, rayToLocalScaled, &resultCallback, collisionObjectWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				triangleMesh->performRaycast(&rcb, rayFromLocalScaled, rayToLocalScaled);
			}
			else if (((resultCallback.m_flags&btTriangleRaycastCallback::kF_DisableHeightfieldAccelerator)==0) 
				&& collisionShape->getShapeType() == TERRAIN_SHAPE_PROXYTYPE 
				)
			{
				///optimized version for btHeightfieldTerrainShape
				btHeightfieldTerrainShape* heightField = (btHeightfieldTerrainShape*)collisionShape;
				btTransform worldTocollisionObject = colObjWorldTransform.inverse();
				btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
				btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), heightField, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;
				heightField->performRaycast(&rcb, rayFromLocal, rayToLocal);
			}
			else
			{
				//generic (slower) case
				btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;

				btTransform worldTocollisionObject = colObjWorldTransform.inverse();

				btVector3 rayFromLocal = worldTocollisionObject * rayFromTrans.getOrigin();
				btVector3 rayToLocal = worldTocollisionObject * rayToTrans.getOrigin();

				//ConvexCast::CastResult

				struct BridgeTriangleRaycastCallback : public btTriangleRaycastCallback
				{
					btCollisionWorld::RayResultCallback* m_resultCallback;
					const btCollisionObject* m_collisionObject;
					btConcaveShape* m_triangleMesh;

					btTransform m_colObjWorldTransform;

					BridgeTriangleRaycastCallback(const btVector3& from, const btVector3& to,
												  btCollisionWorld::RayResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape* triangleMesh, const btTransform& colObjWorldTransform) :  //@BP Mod
																																																						  btTriangleRaycastCallback(from, to, resultCallback->m_flags),
																																																						  m_resultCallback(resultCallback),
																																																						  m_collisionObject(collisionObject),
																																																						  m_triangleMesh(triangleMesh),
																																																						  m_colObjWorldTransform(colObjWorldTransform)
					{
					}

					virtual btScalar reportHit(const btVector3& hitNormalLocal, btScalar hitFraction, int partId, int triangleIndex)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = partId;
						shapeInfo.m_triangleIndex = triangleIndex;

						btVector3 hitNormalWorld = m_colObjWorldTransform.getBasis() * hitNormalLocal;

						btCollisionWorld::LocalRayResult rayResult(m_collisionObject,
																   &shapeInfo,
																   hitNormalWorld,
																   hitFraction);

						bool normalInWorldSpace = true;
						return m_resultCallback->addSingleResult(rayResult, normalInWorldSpace);
					}
				};

				BridgeTriangleRaycastCallback rcb(rayFromLocal, rayToLocal, &resultCallback, collisionObjectWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
				rcb.m_hitFraction = resultCallback.m_closestHitFraction;

				btVector3 rayAabbMinLocal = rayFromLocal;
				rayAabbMinLocal.setMin(rayToLocal);
				btVector3 rayAabbMaxLocal = rayFromLocal;
				rayAabbMaxLocal.setMax(rayToLocal);

				concaveShape->processAllTriangles(&rcb, rayAabbMinLocal, rayAabbMaxLocal);
			}
		}
		else
		{
			//			BT_PROFILE("rayTestCompound");
			if (collisionShape->isCompound())
			{
				struct LocalInfoAdder2 : public RayResultCallback
				{
					RayResultCallback* m_userCallback;
					int m_i;

					LocalInfoAdder2(int i, RayResultCallback* user)
						: m_userCallback(user), m_i(i)
					{
						m_closestHitFraction = m_userCallback->m_closestHitFraction;
						m_flags = m_userCallback->m_flags;
					}
					virtual bool needsCollision(btBroadphaseProxy* p) const
					{
						return m_userCallback->needsCollision(p);
					}

					virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& r, bool b)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = -1;
						shapeInfo.m_triangleIndex = m_i;
						if (r.m_localShapeInfo == NULL)
							r.m_localShapeInfo = &shapeInfo;

						const btScalar result = m_userCallback->addSingleResult(r, b);
						m_closestHitFraction = m_userCallback->m_closestHitFraction;
						return result;
					}
				};

				struct RayTester : btDbvt::ICollide
				{
					const btCollisionObject* m_collisionObject;
					const btCompoundShape* m_compoundShape;
					const btTransform& m_colObjWorldTransform;
					const btTransform& m_rayFromTrans;
					const btTransform& m_rayToTrans;
					RayResultCallback& m_resultCallback;

					RayTester(const btCollisionObject* collisionObject,
							  const btCompoundShape* compoundShape,
							  const btTransform& colObjWorldTransform,
							  const btTransform& rayFromTrans,
							  const btTransform& rayToTrans,
							  RayResultCallback& resultCallback) : m_collisionObject(collisionObject),
																   m_compoundShape(compoundShape),
																   m_colObjWorldTransform(colObjWorldTransform),
																   m_rayFromTrans(rayFromTrans),
																   m_rayToTrans(rayToTrans),
																   m_resultCallback(resultCallback)
					{
					}

					void ProcessLeaf(int i)
					{
						const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(i);
						const btTransform& childTrans = m_compoundShape->getChildTransform(i);
						btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

						btCollisionObjectWrapper tmpOb(0, childCollisionShape, m_collisionObject, childWorldTrans, -1, i);
						// replace collision shape so that callback can determine the triangle

						LocalInfoAdder2 my_cb(i, &m_resultCallback);

						rayTestSingleInternal(
							m_rayFromTrans,
							m_rayToTrans,
							&tmpOb,
							my_cb);
					}

					void Process(const btDbvtNode* leaf)
					{
						ProcessLeaf(leaf->dataAsInt);
					}
				};

				const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);
				const btDbvt* dbvt = compoundShape->getDynamicAabbTree();

				RayTester rayCB(
					collisionObjectWrap->getCollisionObject(),
					compoundShape,
					colObjWorldTransform,
					rayFromTrans,
					rayToTrans,
					resultCallback);
#ifndef DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
				if (dbvt)
				{
					btVector3 localRayFrom = colObjWorldTransform.inverseTimes(rayFromTrans).getOrigin();
					btVector3 localRayTo = colObjWorldTransform.inverseTimes(rayToTrans).getOrigin();
					btDbvt::rayTest(dbvt->m_root, localRayFrom, localRayTo, rayCB);
				}
				else
#endif  //DISABLE_DBVT_COMPOUNDSHAPE_RAYCAST_ACCELERATION
				{
					for (int i = 0, n = compoundShape->getNumChildShapes(); i < n; ++i)
					{
						rayCB.ProcessLeaf(i);
					}
				}
			}
		}
	}
}

void btCollisionWorld::objectQuerySingle(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
										 btCollisionObject* collisionObject,
										 const btCollisionShape* collisionShape,
										 const btTransform& colObjWorldTransform,
										 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
	btCollisionObjectWrapper tmpOb(0, collisionShape, collisionObject, colObjWorldTransform, -1, -1);
	btCollisionWorld::objectQuerySingleInternal(castShape, convexFromTrans, convexToTrans, &tmpOb, resultCallback, allowedPenetration);
}

void btCollisionWorld::objectQuerySingleInternal(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans,
												 const btCollisionObjectWrapper* colObjWrap,
												 ConvexResultCallback& resultCallback, btScalar allowedPenetration)
{
	const btCollisionShape* collisionShape = colObjWrap->getCollisionShape();
	const btTransform& colObjWorldTransform = colObjWrap->getWorldTransform();

	if (collisionShape->isConvex())
	{
		//BT_PROFILE("convexSweepConvex");
		btConvexCast::CastResult castResult;
		castResult.m_allowedPenetration = allowedPenetration;
		castResult.m_fraction = resultCallback.m_closestHitFraction;  //btScalar(1.);//??

		btConvexShape* convexShape = (btConvexShape*)collisionShape;
		btVoronoiSimplexSolver simplexSolver;
		btGjkEpaPenetrationDepthSolver gjkEpaPenetrationSolver;

		btContinuousConvexCollision convexCaster1(castShape, convexShape, &simplexSolver, &gjkEpaPenetrationSolver);
		//btGjkConvexCast convexCaster2(castShape,convexShape,&simplexSolver);
		//btSubsimplexConvexCast convexCaster3(castShape,convexShape,&simplexSolver);

		btConvexCast* castPtr = &convexCaster1;

		if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
		{
			//add hit
			if (castResult.m_normal.length2() > btScalar(0.0001))
			{
				if (castResult.m_fraction < resultCallback.m_closestHitFraction)
				{
					castResult.m_normal.normalize();
					btCollisionWorld::LocalConvexResult localConvexResult(
						colObjWrap->getCollisionObject(),
						0,
						castResult.m_normal,
						castResult.m_hitPoint,
						castResult.m_fraction);

					bool normalInWorldSpace = true;
					resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);
				}
			}
		}
	}
	else
	{
		if (collisionShape->isConcave())
		{
			if (collisionShape->getShapeType() == TRIANGLE_MESH_SHAPE_PROXYTYPE)
			{
				//BT_PROFILE("convexSweepbtBvhTriangleMesh");
				btBvhTriangleMeshShape* triangleMesh = (btBvhTriangleMeshShape*)collisionShape;
				btTransform worldTocollisionObject = colObjWorldTransform.inverse();
				btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
				btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
				// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
				btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

				//ConvexCast::CastResult
				struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
				{
					btCollisionWorld::ConvexResultCallback* m_resultCallback;
					const btCollisionObject* m_collisionObject;
					btTriangleMeshShape* m_triangleMesh;

					BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
													 btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btTriangleMeshShape* triangleMesh, const btTransform& triangleToWorld) : btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
																																																								m_resultCallback(resultCallback),
																																																								m_collisionObject(collisionObject),
																																																								m_triangleMesh(triangleMesh)
					{
					}

					virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
					{
						btCollisionWorld::LocalShapeInfo shapeInfo;
						shapeInfo.m_shapePart = partId;
						shapeInfo.m_triangleIndex = triangleIndex;
						if (hitFraction <= m_resultCallback->m_closestHitFraction)
						{
							btCollisionWorld::LocalConvexResult convexResult(m_collisionObject,
																			 &shapeInfo,
																			 hitNormalLocal,
																			 hitPointLocal,
																			 hitFraction);

							bool normalInWorldSpace = true;

							return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
						}
						return hitFraction;
					}
				};

				BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), triangleMesh, colObjWorldTransform);
				tccb.m_hitFraction = resultCallback.m_closestHitFraction;
				tccb.m_allowedPenetration = allowedPenetration;
				btVector3 boxMinLocal, boxMaxLocal;
				castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);
				triangleMesh->performConvexcast(&tccb, convexFromLocal, convexToLocal, boxMinLocal, boxMaxLocal);
			}
			else
			{
				if (collisionShape->getShapeType() == STATIC_PLANE_PROXYTYPE)
				{
					btConvexCast::CastResult castResult;
					castResult.m_allowedPenetration = allowedPenetration;
					castResult.m_fraction = resultCallback.m_closestHitFraction;
					btStaticPlaneShape* planeShape = (btStaticPlaneShape*)collisionShape;
					btContinuousConvexCollision convexCaster1(castShape, planeShape);
					btConvexCast* castPtr = &convexCaster1;

					if (castPtr->calcTimeOfImpact(convexFromTrans, convexToTrans, colObjWorldTransform, colObjWorldTransform, castResult))
					{
						//add hit
						if (castResult.m_normal.length2() > btScalar(0.0001))
						{
							if (castResult.m_fraction < resultCallback.m_closestHitFraction)
							{
								castResult.m_normal.normalize();
								btCollisionWorld::LocalConvexResult localConvexResult(
									colObjWrap->getCollisionObject(),
									0,
									castResult.m_normal,
									castResult.m_hitPoint,
									castResult.m_fraction);

								bool normalInWorldSpace = true;
								resultCallback.addSingleResult(localConvexResult, normalInWorldSpace);
							}
						}
					}
				}
				else
				{
					//BT_PROFILE("convexSweepConcave");
					btConcaveShape* concaveShape = (btConcaveShape*)collisionShape;
					btTransform worldTocollisionObject = colObjWorldTransform.inverse();
					btVector3 convexFromLocal = worldTocollisionObject * convexFromTrans.getOrigin();
					btVector3 convexToLocal = worldTocollisionObject * convexToTrans.getOrigin();
					// rotation of box in local mesh space = MeshRotation^-1 * ConvexToRotation
					btTransform rotationXform = btTransform(worldTocollisionObject.getBasis() * convexToTrans.getBasis());

					//ConvexCast::CastResult
					struct BridgeTriangleConvexcastCallback : public btTriangleConvexcastCallback
					{
						btCollisionWorld::ConvexResultCallback* m_resultCallback;
						const btCollisionObject* m_collisionObject;
						btConcaveShape* m_triangleMesh;

						BridgeTriangleConvexcastCallback(const btConvexShape* castShape, const btTransform& from, const btTransform& to,
														 btCollisionWorld::ConvexResultCallback* resultCallback, const btCollisionObject* collisionObject, btConcaveShape* triangleMesh, const btTransform& triangleToWorld) : btTriangleConvexcastCallback(castShape, from, to, triangleToWorld, triangleMesh->getMargin()),
																																																							   m_resultCallback(resultCallback),
																																																							   m_collisionObject(collisionObject),
																																																							   m_triangleMesh(triangleMesh)
						{
						}

						virtual btScalar reportHit(const btVector3& hitNormalLocal, const btVector3& hitPointLocal, btScalar hitFraction, int partId, int triangleIndex)
						{
							btCollisionWorld::LocalShapeInfo shapeInfo;
							shapeInfo.m_shapePart = partId;
							shapeInfo.m_triangleIndex = triangleIndex;
							if (hitFraction <= m_resultCallback->m_closestHitFraction)
							{
								btCollisionWorld::LocalConvexResult convexResult(m_collisionObject,
																				 &shapeInfo,
																				 hitNormalLocal,
																				 hitPointLocal,
																				 hitFraction);

								bool normalInWorldSpace = true;

								return m_resultCallback->addSingleResult(convexResult, normalInWorldSpace);
							}
							return hitFraction;
						}
					};

					BridgeTriangleConvexcastCallback tccb(castShape, convexFromTrans, convexToTrans, &resultCallback, colObjWrap->getCollisionObject(), concaveShape, colObjWorldTransform);
					tccb.m_hitFraction = resultCallback.m_closestHitFraction;
					tccb.m_allowedPenetration = allowedPenetration;
					btVector3 boxMinLocal, boxMaxLocal;
					castShape->getAabb(rotationXform, boxMinLocal, boxMaxLocal);

					btVector3 rayAabbMinLocal = convexFromLocal;
					rayAabbMinLocal.setMin(convexToLocal);
					btVector3 rayAabbMaxLocal = convexFromLocal;
					rayAabbMaxLocal.setMax(convexToLocal);
					rayAabbMinLocal += boxMinLocal;
					rayAabbMaxLocal += boxMaxLocal;
					concaveShape->processAllTriangles(&tccb, rayAabbMinLocal, rayAabbMaxLocal);
				}
			}
		}
		else
		{
			if (collisionShape->isCompound())
			{
				struct btCompoundLeafCallback : btDbvt::ICollide
				{
					btCompoundLeafCallback(
						const btCollisionObjectWrapper* colObjWrap,
						const btConvexShape* castShape,
						const btTransform& convexFromTrans,
						const btTransform& convexToTrans,
						btScalar allowedPenetration,
						const btCompoundShape* compoundShape,
						const btTransform& colObjWorldTransform,
						ConvexResultCallback& resultCallback)
						: m_colObjWrap(colObjWrap),
						  m_castShape(castShape),
						  m_convexFromTrans(convexFromTrans),
						  m_convexToTrans(convexToTrans),
						  m_allowedPenetration(allowedPenetration),
						  m_compoundShape(compoundShape),
						  m_colObjWorldTransform(colObjWorldTransform),
						  m_resultCallback(resultCallback)
					{
					}

					const btCollisionObjectWrapper* m_colObjWrap;
					const btConvexShape* m_castShape;
					const btTransform& m_convexFromTrans;
					const btTransform& m_convexToTrans;
					btScalar m_allowedPenetration;
					const btCompoundShape* m_compoundShape;
					const btTransform& m_colObjWorldTransform;
					ConvexResultCallback& m_resultCallback;

				public:
					void ProcessChild(int index, const btTransform& childTrans, const btCollisionShape* childCollisionShape)
					{
						btTransform childWorldTrans = m_colObjWorldTransform * childTrans;

						struct LocalInfoAdder : public ConvexResultCallback
						{
							ConvexResultCallback* m_userCallback;
							int m_i;

							LocalInfoAdder(int i, ConvexResultCallback* user)
								: m_userCallback(user), m_i(i)
							{
								m_closestHitFraction = m_userCallback->m_closestHitFraction;
							}
							virtual bool needsCollision(btBroadphaseProxy* p) const
							{
								return m_userCallback->needsCollision(p);
							}
							virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& r, bool b)
							{
								btCollisionWorld::LocalShapeInfo shapeInfo;
								shapeInfo.m_shapePart = -1;
								shapeInfo.m_triangleIndex = m_i;
								if (r.m_localShapeInfo == NULL)
									r.m_localShapeInfo = &shapeInfo;
								const btScalar result = m_userCallback->addSingleResult(r, b);
								m_closestHitFraction = m_userCallback->m_closestHitFraction;
								return result;
							}
						};

						LocalInfoAdder my_cb(index, &m_resultCallback);

						btCollisionObjectWrapper tmpObj(m_colObjWrap, childCollisionShape, m_colObjWrap->getCollisionObject(), childWorldTrans, -1, index);

						objectQuerySingleInternal(m_castShape, m_convexFromTrans, m_convexToTrans, &tmpObj, my_cb, m_allowedPenetration);
					}

					void Process(const btDbvtNode* leaf)
					{
						// Processing leaf node
						int index = leaf->dataAsInt;

						btTransform childTrans = m_compoundShape->getChildTransform(index);
						const btCollisionShape* childCollisionShape = m_compoundShape->getChildShape(index);

						ProcessChild(index, childTrans, childCollisionShape);
					}
				};

				BT_PROFILE("convexSweepCompound");
				const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(collisionShape);

				btVector3 fromLocalAabbMin, fromLocalAabbMax;
				btVector3 toLocalAabbMin, toLocalAabbMax;

				castShape->getAabb(colObjWorldTransform.inverse() * convexFromTrans, fromLocalAabbMin, fromLocalAabbMax);
				castShape->getAabb(colObjWorldTransform.inverse() * convexToTrans, toLocalAabbMin, toLocalAabbMax);

				fromLocalAabbMin.setMin(toLocalAabbMin);
				fromLocalAabbMax.setMax(toLocalAabbMax);

				btCompoundLeafCallback callback(colObjWrap, castShape, convexFromTrans, convexToTrans,
												allowedPenetration, compoundShape, colObjWorldTransform, resultCallback);

				const btDbvt* tree = compoundShape->getDynamicAabbTree();
				if (tree)
				{
					const ATTRIBUTE_ALIGNED16(btDbvtVolume) bounds = btDbvtVolume::FromMM(fromLocalAabbMin, fromLocalAabbMax);
					tree->collideTV(tree->m_root, bounds, callback);
				}
				else
				{
					int i;
					for (i = 0; i < compoundShape->getNumChildShapes(); i++)
					{
						const btCollisionShape* childCollisionShape = compoundShape->getChildShape(i);
						btTransform childTrans = compoundShape->getChildTransform(i);
						callback.ProcessChild(i, childTrans, childCollisionShape);
					}
				}
			}
		}
	}
}

struct btSingleRayCallback : public btBroadphaseRayCallback
{
	btVector3 m_rayFromWorld;
	btVector3 m_rayToWorld;
	btTransform m_rayFromTrans;
	btTransform m_rayToTrans;
	btVector3 m_hitNormal;

	const btCollisionWorld* m_world;
	btCollisionWorld::RayResultCallback& m_resultCallback;

	btSingleRayCallback(const btVector3& rayFromWorld, const btVector3& rayToWorld, const btCollisionWorld* world, btCollisionWorld::RayResultCallback& resultCallback)
		: m_rayFromWorld(rayFromWorld),
		  m_rayToWorld(rayToWorld),
		  m_world(world),
		  m_resultCallback(resultCallback)
	{
		m_rayFromTrans.setIdentity();
		m_rayFromTrans.setOrigin(m_rayFromWorld);
		m_rayToTrans.setIdentity();
		m_rayToTrans.setOrigin(m_rayToWorld);

		btVector3 rayDir = (rayToWorld - rayFromWorld);

		rayDir.normalize();
		///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
		m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
		m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
		m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
		m_signs[0] = m_rayDirectionInverse[0] < 0.0;
		m_signs[1] = m_rayDirectionInverse[1] < 0.0;
		m_signs[2] = m_rayDirectionInverse[2] < 0.0;

		m_lambda_max = rayDir.dot(m_rayToWorld - m_rayFromWorld);
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		///terminate further ray tests, once the closestHitFraction reached zero
		if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
			return false;

		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			//btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
#if 0
#ifdef RECALCULATE_AABB
			btVector3 collisionObjectAabbMin,collisionObjectAabbMax;
			collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(),collisionObjectAabbMin,collisionObjectAabbMax);
#else
			//getBroadphase()->getAabb(collisionObject->getBroadphaseHandle(),collisionObjectAabbMin,collisionObjectAabbMax);
			const btVector3& collisionObjectAabbMin = collisionObject->getBroadphaseHandle()->m_aabbMin;
			const btVector3& collisionObjectAabbMax = collisionObject->getBroadphaseHandle()->m_aabbMax;
#endif
#endif
			//btScalar hitLambda = m_resultCallback.m_closestHitFraction;
			//culling already done by broadphase
			//if (btRayAabb(m_rayFromWorld,m_rayToWorld,collisionObjectAabbMin,collisionObjectAabbMax,hitLambda,m_hitNormal))
			{
				m_world->rayTestSingle(m_rayFromTrans, m_rayToTrans,
									   collisionObject,
									   collisionObject->getCollisionShape(),
									   collisionObject->getWorldTransform(),
									   m_resultCallback);
			}
		}
		return true;
	}
};

void btCollisionWorld::rayTest(const btVector3& rayFromWorld, const btVector3& rayToWorld, RayResultCallback& resultCallback) const
{
	//BT_PROFILE("rayTest");
	/// use the broadphase to accelerate the search for objects, based on their aabb
	/// and for each object with ray-aabb overlap, perform an exact ray test
	btSingleRayCallback rayCB(rayFromWorld, rayToWorld, this, resultCallback);

#ifndef USE_BRUTEFORCE_RAYBROADPHASE
	m_broadphasePairCache->rayTest(rayFromWorld, rayToWorld, rayCB);
#else
	for (int i = 0; i < this->getNumCollisionObjects(); i++)
	{
		rayCB.process(m_collisionObjects[i]->getBroadphaseHandle());
	}
#endif  //USE_BRUTEFORCE_RAYBROADPHASE
}

struct btSingleSweepCallback : public btBroadphaseRayCallback
{
	btTransform m_convexFromTrans;
	btTransform m_convexToTrans;
	btVector3 m_hitNormal;
	const btCollisionWorld* m_world;
	btCollisionWorld::ConvexResultCallback& m_resultCallback;
	btScalar m_allowedCcdPenetration;
	const btConvexShape* m_castShape;

	btSingleSweepCallback(const btConvexShape* castShape, const btTransform& convexFromTrans, const btTransform& convexToTrans, const btCollisionWorld* world, btCollisionWorld::ConvexResultCallback& resultCallback, btScalar allowedPenetration)
		: m_convexFromTrans(convexFromTrans),
		  m_convexToTrans(convexToTrans),
		  m_world(world),
		  m_resultCallback(resultCallback),
		  m_allowedCcdPenetration(allowedPenetration),
		  m_castShape(castShape)
	{
		btVector3 unnormalizedRayDir = (m_convexToTrans.getOrigin() - m_convexFromTrans.getOrigin());
		btVector3 rayDir = unnormalizedRayDir.fuzzyZero() ? btVector3(btScalar(0.0), btScalar(0.0), btScalar(0.0)) : unnormalizedRayDir.normalized();
		///what about division by zero? --> just set rayDirection[i] to INF/BT_LARGE_FLOAT
		m_rayDirectionInverse[0] = rayDir[0] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[0];
		m_rayDirectionInverse[1] = rayDir[1] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[1];
		m_rayDirectionInverse[2] = rayDir[2] == btScalar(0.0) ? btScalar(BT_LARGE_FLOAT) : btScalar(1.0) / rayDir[2];
		m_signs[0] = m_rayDirectionInverse[0] < 0.0;
		m_signs[1] = m_rayDirectionInverse[1] < 0.0;
		m_signs[2] = m_rayDirectionInverse[2] < 0.0;

		m_lambda_max = rayDir.dot(unnormalizedRayDir);
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		///terminate further convex sweep tests, once the closestHitFraction reached zero
		if (m_resultCallback.m_closestHitFraction == btScalar(0.f))
			return false;

		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			m_world->objectQuerySingle(m_castShape, m_convexFromTrans, m_convexToTrans,
									   collisionObject,
									   collisionObject->getCollisionShape(),
									   collisionObject->getWorldTransform(),
									   m_resultCallback,
									   m_allowedCcdPenetration);
		}

		return true;
	}
};

void btCollisionWorld::convexSweepTest(const btConvexShape* castShape, const btTransform& convexFromWorld, const btTransform& convexToWorld, ConvexResultCallback& resultCallback, btScalar allowedCcdPenetration) const
{
	BT_PROFILE("convexSweepTest");
	/// use the broadphase to accelerate the search for objects, based on their aabb
	/// and for each object with ray-aabb overlap, perform an exact ray test
	/// unfortunately the implementation for rayTest and convexSweepTest duplicated, albeit practically identical

	btTransform convexFromTrans, convexToTrans;
	convexFromTrans = convexFromWorld;
	convexToTrans = convexToWorld;
	btVector3 castShapeAabbMin, castShapeAabbMax;
	/* Compute AABB that encompasses angular movement */
	{
		btVector3 linVel, angVel;
		btTransformUtil::calculateVelocity(convexFromTrans, convexToTrans, 1.0f, linVel, angVel);
		btVector3 zeroLinVel;
		zeroLinVel.setValue(0, 0, 0);
		btTransform R;
		R.setIdentity();
		R.setRotation(convexFromTrans.getRotation());
		castShape->calculateTemporalAabb(R, zeroLinVel, angVel, 1.0f, castShapeAabbMin, castShapeAabbMax);
	}

#ifndef USE_BRUTEFORCE_RAYBROADPHASE

	btSingleSweepCallback convexCB(castShape, convexFromWorld, convexToWorld, this, resultCallback, allowedCcdPenetration);

	m_broadphasePairCache->rayTest(convexFromTrans.getOrigin(), convexToTrans.getOrigin(), convexCB, castShapeAabbMin, castShapeAabbMax);

#else
	/// go over all objects, and if the ray intersects their aabb + cast shape aabb,
	// do a ray-shape query using convexCaster (CCD)
	int i;
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* collisionObject = m_collisionObjects[i];
		//only perform raycast if filterMask matches
		if (resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			//RigidcollisionObject* collisionObject = ctrl->GetRigidcollisionObject();
			btVector3 collisionObjectAabbMin, collisionObjectAabbMax;
			collisionObject->getCollisionShape()->getAabb(collisionObject->getWorldTransform(), collisionObjectAabbMin, collisionObjectAabbMax);
			AabbExpand(collisionObjectAabbMin, collisionObjectAabbMax, castShapeAabbMin, castShapeAabbMax);
			btScalar hitLambda = btScalar(1.);  //could use resultCallback.m_closestHitFraction, but needs testing
			btVector3 hitNormal;
			if (btRayAabb(convexFromWorld.getOrigin(), convexToWorld.getOrigin(), collisionObjectAabbMin, collisionObjectAabbMax, hitLambda, hitNormal))
			{
				objectQuerySingle(castShape, convexFromTrans, convexToTrans,
								  collisionObject,
								  collisionObject->getCollisionShape(),
								  collisionObject->getWorldTransform(),
								  resultCallback,
								  allowedCcdPenetration);
			}
		}
	}
#endif  //USE_BRUTEFORCE_RAYBROADPHASE
}

struct btBridgedManifoldResult : public btManifoldResult
{
	btCollisionWorld::ContactResultCallback& m_resultCallback;

	btBridgedManifoldResult(const btCollisionObjectWrapper* obj0Wrap, const btCollisionObjectWrapper* obj1Wrap, btCollisionWorld::ContactResultCallback& resultCallback)
		: btManifoldResult(obj0Wrap, obj1Wrap),
		  m_resultCallback(resultCallback)
	{
	}

	virtual void addContactPoint(const btVector3& normalOnBInWorld, const btVector3& pointInWorld, btScalar depth)
	{
		bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
		btVector3 pointA = pointInWorld + normalOnBInWorld * depth;
		btVector3 localA;
		btVector3 localB;
		if (isSwapped)
		{
			localA = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
			localB = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
		}
		else
		{
			localA = m_body0Wrap->getCollisionObject()->getWorldTransform().invXform(pointA);
			localB = m_body1Wrap->getCollisionObject()->getWorldTransform().invXform(pointInWorld);
		}

		btManifoldPoint newPt(localA, localB, normalOnBInWorld, depth);
		newPt.m_positionWorldOnA = pointA;
		newPt.m_positionWorldOnB = pointInWorld;

		//BP mod, store contact triangles.
		if (isSwapped)
		{
			newPt.m_partId0 = m_partId1;
			newPt.m_partId1 = m_partId0;
			newPt.m_index0 = m_index1;
			newPt.m_index1 = m_index0;
		}
		else
		{
			newPt.m_partId0 = m_partId0;
			newPt.m_partId1 = m_partId1;
			newPt.m_index0 = m_index0;
			newPt.m_index1 = m_index1;
		}

		//experimental feature info, for per-triangle material etc.
		const btCollisionObjectWrapper* obj0Wrap = isSwapped ? m_body1Wrap : m_body0Wrap;
		const btCollisionObjectWrapper* obj1Wrap = isSwapped ? m_body0Wrap : m_body1Wrap;
		m_resultCallback.addSingleResult(newPt, obj0Wrap, newPt.m_partId0, newPt.m_index0, obj1Wrap, newPt.m_partId1, newPt.m_index1);
	}
};

struct btSingleContactCallback : public btBroadphaseAabbCallback
{
	btCollisionObject* m_collisionObject;
	btCollisionWorld* m_world;
	btCollisionWorld::ContactResultCallback& m_resultCallback;

	btSingleContactCallback(btCollisionObject* collisionObject, btCollisionWorld* world, btCollisionWorld::ContactResultCallback& resultCallback)
		: m_collisionObject(collisionObject),
		  m_world(world),
		  m_resultCallback(resultCallback)
	{
	}

	virtual bool process(const btBroadphaseProxy* proxy)
	{
		btCollisionObject* collisionObject = (btCollisionObject*)proxy->m_clientObject;
		if (collisionObject == m_collisionObject)
			return true;

		//only perform raycast if filterMask matches
		if (m_resultCallback.needsCollision(collisionObject->getBroadphaseHandle()))
		{
			btCollisionObjectWrapper ob0(0, m_collisionObject->getCollisionShape(), m_collisionObject, m_collisionObject->getWorldTransform(), -1, -1);
			btCollisionObjectWrapper ob1(0, collisionObject->getCollisionShape(), collisionObject, collisionObject->getWorldTransform(), -1, -1);

			btCollisionAlgorithm* algorithm = m_world->getDispatcher()->findAlgorithm(&ob0, &ob1, 0, BT_CLOSEST_POINT_ALGORITHMS);
			if (algorithm)
			{
				btBridgedManifoldResult contactPointResult(&ob0, &ob1, m_resultCallback);
				//discrete collision detection query

				algorithm->processCollision(&ob0, &ob1, m_world->getDispatchInfo(), &contactPointResult);

				algorithm->~btCollisionAlgorithm();
				m_world->getDispatcher()->freeCollisionAlgorithm(algorithm);
			}
		}
		return true;
	}
};

///contactTest performs a discrete collision test against all objects in the btCollisionWorld, and calls the resultCallback.
///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
void btCollisionWorld::contactTest(btCollisionObject* colObj, ContactResultCallback& resultCallback)
{
	btVector3 aabbMin, aabbMax;
	colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), aabbMin, aabbMax);
	btSingleContactCallback contactCB(colObj, this, resultCallback);

	m_broadphasePairCache->aabbTest(aabbMin, aabbMax, contactCB);
}

///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
///it reports one or more contact points (including the one with deepest penetration)
void btCollisionWorld::contactPairTest(btCollisionObject* colObjA, btCollisionObject* colObjB, ContactResultCallback& resultCallback)
{
	btCollisionObjectWrapper obA(0, colObjA->getCollisionShape(), colObjA, colObjA->getWorldTransform(), -1, -1);
	btCollisionObjectWrapper obB(0, colObjB->getCollisionShape(), colObjB, colObjB->getWorldTransform(), -1, -1);

	btCollisionAlgorithm* algorithm = getDispatcher()->findAlgorithm(&obA, &obB, 0, BT_CLOSEST_POINT_ALGORITHMS);
	if (algorithm)
	{
		btBridgedManifoldResult contactPointResult(&obA, &obB, resultCallback);
		contactPointResult.m_closestPointDistanceThreshold = resultCallback.m_closestDistanceThreshold;
		//discrete collision detection query
		algorithm->processCollision(&obA, &obB, getDispatchInfo(), &contactPointResult);

		algorithm->~btCollisionAlgorithm();
		getDispatcher()->freeCollisionAlgorithm(algorithm);
	}
}

class DebugDrawcallback : public btTriangleCallback, public btInternalTriangleIndexCallback
{
	btIDebugDraw* m_debugDrawer;
	btVector3 m_color;
	btTransform m_worldTrans;

public:
	DebugDrawcallback(btIDebugDraw* debugDrawer, const btTransform& worldTrans, const btVector3& color) : m_debugDrawer(debugDrawer),
																										  m_color(color),
																										  m_worldTrans(worldTrans)
	{
	}

	virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex)
	{
		processTriangle(triangle, partId, triangleIndex);
	}

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
	{
		(void)partId;
		(void)triangleIndex;

		btVector3 wv0, wv1, wv2;
		wv0 = m_worldTrans * triangle[0];
		wv1 = m_worldTrans * triangle[1];
		wv2 = m_worldTrans * triangle[2];
		btVector3 center = (wv0 + wv1 + wv2) * btScalar(1. / 3.);

		if (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
		{
			btVector3 normal = (wv1 - wv0).cross(wv2 - wv0);
			normal.normalize();
			btVector3 normalColor(1, 1, 0);
			m_debugDrawer->drawLine(center, center + normal, normalColor);
		}
		m_debugDrawer->drawTriangle(wv0, wv1, wv2, m_color, 1.0);
	}
};

void btCollisionWorld::debugDrawObject(const btTransform& worldTransform, const btCollisionShape* shape, const btVector3& color)
{
	// Draw a small simplex at the center of the object
	if (getDebugDrawer() && getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawFrames)
	{
		getDebugDrawer()->drawTransform(worldTransform, .1);
	}

	if (shape->getShapeType() == COMPOUND_SHAPE_PROXYTYPE)
	{
		const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(shape);
		for (int i = compoundShape->getNumChildShapes() - 1; i >= 0; i--)
		{
			btTransform childTrans = compoundShape->getChildTransform(i);
			const btCollisionShape* colShape = compoundShape->getChildShape(i);
			debugDrawObject(worldTransform * childTrans, colShape, color);
		}
	}
	else
	{
		switch (shape->getShapeType())
		{
			case BOX_SHAPE_PROXYTYPE:
			{
				const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
				btVector3 halfExtents = boxShape->getHalfExtentsWithMargin();
				getDebugDrawer()->drawBox(-halfExtents, halfExtents, worldTransform, color);
				break;
			}

			case SPHERE_SHAPE_PROXYTYPE:
			{
				const btSphereShape* sphereShape = static_cast<const btSphereShape*>(shape);
				btScalar radius = sphereShape->getMargin();  //radius doesn't include the margin, so draw with margin

				getDebugDrawer()->drawSphere(radius, worldTransform, color);
				break;
			}
			case MULTI_SPHERE_SHAPE_PROXYTYPE:
			{
				const btMultiSphereShape* multiSphereShape = static_cast<const btMultiSphereShape*>(shape);

				btTransform childTransform;
				childTransform.setIdentity();

				for (int i = multiSphereShape->getSphereCount() - 1; i >= 0; i--)
				{
					childTransform.setOrigin(multiSphereShape->getSpherePosition(i));
					getDebugDrawer()->drawSphere(multiSphereShape->getSphereRadius(i), worldTransform * childTransform, color);
				}

				break;
			}
			case CAPSULE_SHAPE_PROXYTYPE:
			{
				const btCapsuleShape* capsuleShape = static_cast<const btCapsuleShape*>(shape);

				btScalar radius = capsuleShape->getRadius();
				btScalar halfHeight = capsuleShape->getHalfHeight();

				int upAxis = capsuleShape->getUpAxis();
				getDebugDrawer()->drawCapsule(radius, halfHeight, upAxis, worldTransform, color);
				break;
			}
			case CONE_SHAPE_PROXYTYPE:
			{
				const btConeShape* coneShape = static_cast<const btConeShape*>(shape);
				btScalar radius = coneShape->getRadius();  //+coneShape->getMargin();
				btScalar height = coneShape->getHeight();  //+coneShape->getMargin();

				int upAxis = coneShape->getConeUpIndex();
				getDebugDrawer()->drawCone(radius, height, upAxis, worldTransform, color);
				break;
			}
			case CYLINDER_SHAPE_PROXYTYPE:
			{
				const btCylinderShape* cylinder = static_cast<const btCylinderShape*>(shape);
				int upAxis = cylinder->getUpAxis();
				btScalar radius = cylinder->getRadius();
				btScalar halfHeight = cylinder->getHalfExtentsWithMargin()[upAxis];
				getDebugDrawer()->drawCylinder(radius, halfHeight, upAxis, worldTransform, color);
				break;
			}

			case STATIC_PLANE_PROXYTYPE:
			{
				const btStaticPlaneShape* staticPlaneShape = static_cast<const btStaticPlaneShape*>(shape);
				btScalar planeConst = staticPlaneShape->getPlaneConstant();
				const btVector3& planeNormal = staticPlaneShape->getPlaneNormal();
				getDebugDrawer()->drawPlane(planeNormal, planeConst, worldTransform, color);
				break;
			}
			default:
			{
				/// for polyhedral shapes
				if (shape->isPolyhedral())
				{
					btPolyhedralConvexShape* polyshape = (btPolyhedralConvexShape*)shape;

					int i;
					if (polyshape->getConvexPolyhedron())
					{
						const btConvexPolyhedron* poly = polyshape->getConvexPolyhedron();
						for (i = 0; i < poly->m_faces.size(); i++)
						{
							btVector3 centroid(0, 0, 0);
							int numVerts = poly->m_faces[i].m_indices.size();
							if (numVerts)
							{
								int lastV = poly->m_faces[i].m_indices[numVerts - 1];
								for (int v = 0; v < poly->m_faces[i].m_indices.size(); v++)
								{
									int curVert = poly->m_faces[i].m_indices[v];
									centroid += poly->m_vertices[curVert];
									getDebugDrawer()->drawLine(worldTransform * poly->m_vertices[lastV], worldTransform * poly->m_vertices[curVert], color);
									lastV = curVert;
								}
							}
							centroid *= btScalar(1.f) / btScalar(numVerts);
							if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawNormals)
							{
								btVector3 normalColor(1, 1, 0);
								btVector3 faceNormal(poly->m_faces[i].m_plane[0], poly->m_faces[i].m_plane[1], poly->m_faces[i].m_plane[2]);
								getDebugDrawer()->drawLine(worldTransform * centroid, worldTransform * (centroid + faceNormal), normalColor);
							}
						}
					}
					else
					{
						for (i = 0; i < polyshape->getNumEdges(); i++)
						{
							btVector3 a, b;
							polyshape->getEdge(i, a, b);
							btVector3 wa = worldTransform * a;
							btVector3 wb = worldTransform * b;
							getDebugDrawer()->drawLine(wa, wb, color);
						}
					}
				}

				if (shape->isConcave())
				{
					btConcaveShape* concaveMesh = (btConcaveShape*)shape;

					///@todo pass camera, for some culling? no -> we are not a graphics lib
					btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
					btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));

					DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
					concaveMesh->processAllTriangles(&drawCallback, aabbMin, aabbMax);
				}

				if (shape->getShapeType() == CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE)
				{
					btConvexTriangleMeshShape* convexMesh = (btConvexTriangleMeshShape*)shape;
					//todo: pass camera for some culling
					btVector3 aabbMax(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
					btVector3 aabbMin(btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT), btScalar(-BT_LARGE_FLOAT));
					//DebugDrawcallback drawCallback;
					DebugDrawcallback drawCallback(getDebugDrawer(), worldTransform, color);
					convexMesh->getMeshInterface()->InternalProcessAllTriangles(&drawCallback, aabbMin, aabbMax);
				}
			}
		}
	}
}

void btCollisionWorld::debugDrawWorld()
{
	if (getDebugDrawer())
	{
		getDebugDrawer()->clearLines();

		btIDebugDraw::DefaultColors defaultColors = getDebugDrawer()->getDefaultColors();

		if (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawContactPoints)
		{
			if (getDispatcher())
			{
				int numManifolds = getDispatcher()->getNumManifolds();

				for (int i = 0; i < numManifolds; i++)
				{
					btPersistentManifold* contactManifold = getDispatcher()->getManifoldByIndexInternal(i);
					//btCollisionObject* obA = static_cast<btCollisionObject*>(contactManifold->getBody0());
					//btCollisionObject* obB = static_cast<btCollisionObject*>(contactManifold->getBody1());

					int numContacts = contactManifold->getNumContacts();
					for (int j = 0; j < numContacts; j++)
					{
						btManifoldPoint& cp = contactManifold->getContactPoint(j);
						getDebugDrawer()->drawContactPoint(cp.m_positionWorldOnB, cp.m_normalWorldOnB, cp.getDistance(), cp.getLifeTime(), defaultColors.m_contactPoint);
					}
				}
			}
		}

		if ((getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb)))
		{
			int i;

			for (i = 0; i < m_collisionObjects.size(); i++)
			{
				btCollisionObject* colObj = m_collisionObjects[i];
				if ((colObj->getCollisionFlags() & btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT) == 0)
				{
					if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawWireframe))
					{
						btVector3 color(btScalar(0.4), btScalar(0.4), btScalar(0.4));

						switch (colObj->getActivationState())
						{
							case ACTIVE_TAG:
								color = defaultColors.m_activeObject;
								break;
							case ISLAND_SLEEPING:
								color = defaultColors.m_deactivatedObject;
								break;
							case WANTS_DEACTIVATION:
								color = defaultColors.m_wantsDeactivationObject;
								break;
							case DISABLE_DEACTIVATION:
								color = defaultColors.m_disabledDeactivationObject;
								break;
							case DISABLE_SIMULATION:
								color = defaultColors.m_disabledSimulationObject;
								break;
							default:
							{
								color = btVector3(btScalar(.3), btScalar(0.3), btScalar(0.3));
							}
						};

						colObj->getCustomDebugColor(color);

						debugDrawObject(colObj->getWorldTransform(), colObj->getCollisionShape(), color);
					}
					if (m_debugDrawer && (m_debugDrawer->getDebugMode() & btIDebugDraw::DBG_DrawAabb))
					{
						btVector3 minAabb, maxAabb;
						btVector3 colorvec = defaultColors.m_aabb;
						colObj->getCollisionShape()->getAabb(colObj->getWorldTransform(), minAabb, maxAabb);
						btVector3 contactThreshold(gContactBreakingThreshold, gContactBreakingThreshold, gContactBreakingThreshold);
						minAabb -= contactThreshold;
						maxAabb += contactThreshold;

						btVector3 minAabb2, maxAabb2;

						if (getDispatchInfo().m_useContinuous && colObj->getInternalType() == btCollisionObject::CO_RIGID_BODY && !colObj->isStaticOrKinematicObject())
						{
							colObj->getCollisionShape()->getAabb(colObj->getInterpolationWorldTransform(), minAabb2, maxAabb2);
							minAabb2 -= contactThreshold;
							maxAabb2 += contactThreshold;
							minAabb.setMin(minAabb2);
							maxAabb.setMax(maxAabb2);
						}

						m_debugDrawer->drawAabb(minAabb, maxAabb, colorvec);
					}
				}
			}
		}
	}
}

void btCollisionWorld::serializeCollisionObjects(btSerializer* serializer)
{
	int i;

	///keep track of shapes already serialized
	btHashMap<btHashPtr, btCollisionShape*> serializedShapes;

	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btCollisionShape* shape = colObj->getCollisionShape();

		if (!serializedShapes.find(shape))
		{
			serializedShapes.insert(shape, shape);
			shape->serializeSingleShape(serializer);
		}
	}

	//serialize all collision objects
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		if (colObj->getInternalType() == btCollisionObject::CO_COLLISION_OBJECT)
		{
			colObj->serializeSingleObject(serializer);
		}
	}
}

void btCollisionWorld::serializeContactManifolds(btSerializer* serializer)
{
	if (serializer->getSerializationFlags() & BT_SERIALIZE_CONTACT_MANIFOLDS)
	{
		int numManifolds = getDispatcher()->getNumManifolds();
		for (int i = 0; i < numManifolds; i++)
		{
			const btPersistentManifold* manifold = getDispatcher()->getInternalManifoldPointer()[i];
			//don't serialize empty manifolds, they just take space
			//(may have to do it anyway if it destroys determinism)
			if (manifold->getNumContacts() == 0)
				continue;

			btChunk* chunk = serializer->allocate(manifold->calculateSerializeBufferSize(), 1);
			const char* structType = manifold->serialize(manifold, chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_CONTACTMANIFOLD_CODE, (void*)manifold);
		}
	}
}

void btCollisionWorld::serialize(btSerializer* serializer)
{
	serializer->startSerialization();

	serializeCollisionObjects(serializer);

	serializeContactManifolds(serializer);

	serializer->finishSerialization();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TRIANGLE_CALLBACK_H
#define BT_TRIANGLE_CALLBACK_H

#include "LinearMath/btVector3.h"

///The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
///This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
class btTriangleCallback
{
public:
	virtual ~btTriangleCallback();
	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex) = 0;
};

class btInternalTriangleIndexCallback
{
public:
	virtual ~btInternalTriangleIndexCallback();
	virtual void internalProcessTriangleIndex(btVector3* triangle, int partId, int triangleIndex) = 0;
};

#endif  //BT_TRIANGLE_CALLBACK_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/CollisionShapes/btTriangleCallback.h"

btTriangleCallback::~btTriangleCallback()
{
}

btInternalTriangleIndexCallback::~btInternalTriangleIndexCallback()
{
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2010 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_TYPED_CONSTRAINT_H
#define BT_TYPED_CONSTRAINT_H

#include "LinearMath/btScalar.h"
#include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btTypedConstraintData2 btTypedConstraintDoubleData
#define btTypedConstraintDataName "btTypedConstraintDoubleData"
#else
#define btTypedConstraintData2 btTypedConstraintFloatData
#define btTypedConstraintDataName "btTypedConstraintFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

class btSerializer;

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
enum btTypedConstraintType
{
	POINT2POINT_CONSTRAINT_TYPE = 3,
	HINGE_CONSTRAINT_TYPE,
	CONETWIST_CONSTRAINT_TYPE,
	D6_CONSTRAINT_TYPE,
	SLIDER_CONSTRAINT_TYPE,
	CONTACT_CONSTRAINT_TYPE,
	D6_SPRING_CONSTRAINT_TYPE,
	GEAR_CONSTRAINT_TYPE,
	FIXED_CONSTRAINT_TYPE,
	D6_SPRING_2_CONSTRAINT_TYPE,
	MAX_CONSTRAINT_TYPE
};

enum btConstraintParams
{
	BT_CONSTRAINT_ERP = 1,
	BT_CONSTRAINT_STOP_ERP,
	BT_CONSTRAINT_CFM,
	BT_CONSTRAINT_STOP_CFM
};

#if 1
#define btAssertConstrParams(_par) btAssert(_par)
#else
#define btAssertConstrParams(_par)
#endif

ATTRIBUTE_ALIGNED16(struct)
btJointFeedback
{
	BT_DECLARE_ALIGNED_ALLOCATOR();
	btVector3 m_appliedForceBodyA;
	btVector3 m_appliedTorqueBodyA;
	btVector3 m_appliedForceBodyB;
	btVector3 m_appliedTorqueBodyB;
};

///TypedConstraint is the baseclass for Bullet constraints and vehicles
ATTRIBUTE_ALIGNED16(class)
btTypedConstraint : public btTypedObject
{
	int m_userConstraintType;

	union {
		int m_userConstraintId;
		void* m_userConstraintPtr;
	};

	btScalar m_breakingImpulseThreshold;
	bool m_isEnabled;
	bool m_needsFeedback;
	int m_overrideNumSolverIterations;

	btTypedConstraint& operator=(btTypedConstraint& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

protected:
	btRigidBody& m_rbA;
	btRigidBody& m_rbB;
	btScalar m_appliedImpulse;
	btScalar m_dbgDrawSize;
	btJointFeedback* m_jointFeedback;

	///internal method used by the constraint solver, don't use them directly
	btScalar getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	virtual ~btTypedConstraint(){};
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA);
	btTypedConstraint(btTypedConstraintType type, btRigidBody & rbA, btRigidBody & rbB);

	struct btConstraintInfo1
	{
		int m_numConstraintRows, nub;
	};

	static btRigidBody& getFixedBody();

	struct btConstraintInfo2
	{
		// integrator parameters: frames per second (1/stepsize), default error
		// reduction parameter (0..1).
		btScalar fps, erp;

		// for the first and second body, pointers to two (linear and angular)
		// n*3 jacobian sub matrices, stored by rows. these matrices will have
		// been initialized to 0 on entry. if the second body is zero then the
		// J2xx pointers may be 0.
		btScalar *m_J1linearAxis, *m_J1angularAxis, *m_J2linearAxis, *m_J2angularAxis;

		// elements to jump from one row to the next in J's
		int rowskip;

		// right hand sides of the equation J*v = c + cfm * lambda. cfm is the
		// "constraint force mixing" vector. c is set to zero on entry, cfm is
		// set to a constant value (typically very small or zero) value on entry.
		btScalar *m_constraintError, *cfm;

		// lo and hi limits for variables (set to -/+ infinity on entry).
		btScalar *m_lowerLimit, *m_upperLimit;

		// number of solver iterations
		int m_numIterations;

		//damping of the velocity
		btScalar m_damping;
	};

	int getOverrideNumSolverIterations() const
	{
		return m_overrideNumSolverIterations;
	}

	///override the number of constraint solver iterations used to solve this constraint
	///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
	void setOverrideNumSolverIterations(int overideNumIterations)
	{
		m_overrideNumSolverIterations = overideNumIterations;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void buildJacobian(){};

	///internal method used by the constraint solver, don't use them directly
	virtual void setupSolverConstraint(btConstraintArray & ca, int solverBodyA, int solverBodyB, btScalar timeStep)
	{
		(void)ca;
		(void)solverBodyA;
		(void)solverBodyB;
		(void)timeStep;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo1(btConstraintInfo1 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	virtual void getInfo2(btConstraintInfo2 * info) = 0;

	///internal method used by the constraint solver, don't use them directly
	void internalSetAppliedImpulse(btScalar appliedImpulse)
	{
		m_appliedImpulse = appliedImpulse;
	}
	///internal method used by the constraint solver, don't use them directly
	btScalar internalGetAppliedImpulse()
	{
		return m_appliedImpulse;
	}

	btScalar getBreakingImpulseThreshold() const
	{
		return m_breakingImpulseThreshold;
	}

	void setBreakingImpulseThreshold(btScalar threshold)
	{
		m_breakingImpulseThreshold = threshold;
	}

	bool isEnabled() const
	{
		return m_isEnabled;
	}

	void setEnabled(bool enabled)
	{
		m_isEnabled = enabled;
	}

	///internal method used by the constraint solver, don't use them directly
	virtual void solveConstraintObsolete(btSolverBody& /*bodyA*/, btSolverBody& /*bodyB*/, btScalar /*timeStep*/){};

	const btRigidBody& getRigidBodyA() const
	{
		return m_rbA;
	}
	const btRigidBody& getRigidBodyB() const
	{
		return m_rbB;
	}

	btRigidBody& getRigidBodyA()
	{
		return m_rbA;
	}
	btRigidBody& getRigidBodyB()
	{
		return m_rbB;
	}

	int getUserConstraintType() const
	{
		return m_userConstraintType;
	}

	void setUserConstraintType(int userConstraintType)
	{
		m_userConstraintType = userConstraintType;
	};

	void setUserConstraintId(int uid)
	{
		m_userConstraintId = uid;
	}

	int getUserConstraintId() const
	{
		return m_userConstraintId;
	}

	void setUserConstraintPtr(void* ptr)
	{
		m_userConstraintPtr = ptr;
	}

	void* getUserConstraintPtr()
	{
		return m_userConstraintPtr;
	}

	void setJointFeedback(btJointFeedback * jointFeedback)
	{
		m_jointFeedback = jointFeedback;
	}

	const btJointFeedback* getJointFeedback() const
	{
		return m_jointFeedback;
	}

	btJointFeedback* getJointFeedback()
	{
		return m_jointFeedback;
	}

	int getUid() const
	{
		return m_userConstraintId;
	}

	bool needsFeedback() const
	{
		return m_needsFeedback;
	}

	///enableFeedback will allow to read the applied linear and angular impulse
	///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
	void enableFeedback(bool needsFeedback)
	{
		m_needsFeedback = needsFeedback;
	}

	///getAppliedImpulse is an estimated total applied impulse.
	///This feedback could be used to determine breaking constraints or playing sounds.
	btScalar getAppliedImpulse() const
	{
		btAssert(m_needsFeedback);
		return m_appliedImpulse;
	}

	btTypedConstraintType getConstraintType() const
	{
		return btTypedConstraintType(m_objectType);
	}

	void setDbgDrawSize(btScalar dbgDrawSize)
	{
		m_dbgDrawSize = dbgDrawSize;
	}
	btScalar getDbgDrawSize()
	{
		return m_dbgDrawSize;
	}

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1) = 0;

	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const = 0;

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

// returns angle in range [-SIMD_2_PI, SIMD_2_PI], closest to one of the limits
// all arguments should be normalized angles (i.e. in range [-SIMD_PI, SIMD_PI])
SIMD_FORCE_INLINE btScalar btAdjustAngleToLimits(btScalar angleInRadians, btScalar angleLowerLimitInRadians, btScalar angleUpperLimitInRadians)
{
	if (angleLowerLimitInRadians >= angleUpperLimitInRadians)
	{
		return angleInRadians;
	}
	else if (angleInRadians < angleLowerLimitInRadians)
	{
		btScalar diffLo = btFabs(btNormalizeAngle(angleLowerLimitInRadians - angleInRadians));
		btScalar diffHi = btFabs(btNormalizeAngle(angleUpperLimitInRadians - angleInRadians));
		return (diffLo < diffHi) ? angleInRadians : (angleInRadians + SIMD_2_PI);
	}
	else if (angleInRadians > angleUpperLimitInRadians)
	{
		btScalar diffHi = btFabs(btNormalizeAngle(angleInRadians - angleUpperLimitInRadians));
		btScalar diffLo = btFabs(btNormalizeAngle(angleInRadians - angleLowerLimitInRadians));
		return (diffLo < diffHi) ? (angleInRadians - SIMD_2_PI) : angleInRadians;
	}
	else
	{
		return angleInRadians;
	}
}

// clang-format off

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct	btTypedConstraintFloatData
{
	btRigidBodyFloatData		*m_rbA;
	btRigidBodyFloatData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64

#define BT_BACKWARDS_COMPATIBLE_SERIALIZATION
#ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
///this structure is not used, except for loading pre-2.82 .bullet files
struct	btTypedConstraintData
{
	btRigidBodyData		*m_rbA;
	btRigidBodyData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	float	m_appliedImpulse;
	float	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	float	m_breakingImpulseThreshold;
	int		m_isEnabled;
	
};
#endif //BACKWARDS_COMPATIBLE

struct	btTypedConstraintDoubleData
{
	btRigidBodyDoubleData		*m_rbA;
	btRigidBodyDoubleData		*m_rbB;
	char	*m_name;

	int	m_objectType;
	int	m_userConstraintType;
	int	m_userConstraintId;
	int	m_needsFeedback;

	double	m_appliedImpulse;
	double	m_dbgDrawSize;

	int	m_disableCollisionsBetweenLinkedBodies;
	int	m_overrideNumSolverIterations;

	double	m_breakingImpulseThreshold;
	int		m_isEnabled;
	char	padding[4];
	
};

// clang-format on

SIMD_FORCE_INLINE int btTypedConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btTypedConstraintData2);
}

class btAngularLimit
{
private:
	btScalar
		m_center,
		m_halfRange,
		m_softness,
		m_biasFactor,
		m_relaxationFactor,
		m_correction,
		m_sign;

	bool
		m_solveLimit;

public:
	/// Default constructor initializes limit as inactive, allowing free constraint movement
	btAngularLimit()
		: m_center(0.0f),
		  m_halfRange(-1.0f),
		  m_softness(0.9f),
		  m_biasFactor(0.3f),
		  m_relaxationFactor(1.0f),
		  m_correction(0.0f),
		  m_sign(0.0f),
		  m_solveLimit(false)
	{
	}

	/// Sets all limit's parameters.
	/// When low > high limit becomes inactive.
	/// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
	void set(btScalar low, btScalar high, btScalar _softness = 0.9f, btScalar _biasFactor = 0.3f, btScalar _relaxationFactor = 1.0f);

	/// Checks conastaint angle against limit. If limit is active and the angle violates the limit
	/// correction is calculated.
	void test(const btScalar angle);

	/// Returns limit's softness
	inline btScalar getSoftness() const
	{
		return m_softness;
	}

	/// Returns limit's bias factor
	inline btScalar getBiasFactor() const
	{
		return m_biasFactor;
	}

	/// Returns limit's relaxation factor
	inline btScalar getRelaxationFactor() const
	{
		return m_relaxationFactor;
	}

	/// Returns correction value evaluated when test() was invoked
	inline btScalar getCorrection() const
	{
		return m_correction;
	}

	/// Returns sign value evaluated when test() was invoked
	inline btScalar getSign() const
	{
		return m_sign;
	}

	/// Gives half of the distance between min and max limit angle
	inline btScalar getHalfRange() const
	{
		return m_halfRange;
	}

	/// Returns true when the last test() invocation recognized limit violation
	inline bool isLimit() const
	{
		return m_solveLimit;
	}

	/// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
	/// returned is modified so it equals to the limit closest to given angle.
	void fit(btScalar& angle) const;

	/// Returns correction value multiplied by sign value
	btScalar getError() const;

	btScalar getLow() const;

	btScalar getHigh() const;
};

#endif  //BT_TYPED_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btSerializer.h"

#define DEFAULT_DEBUGDRAW_SIZE btScalar(0.05f)

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(getFixedBody()),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btTypedConstraint::btTypedConstraint(btTypedConstraintType type, btRigidBody& rbA, btRigidBody& rbB)
	: btTypedObject(type),
	  m_userConstraintType(-1),
	  m_userConstraintPtr((void*)-1),
	  m_breakingImpulseThreshold(SIMD_INFINITY),
	  m_isEnabled(true),
	  m_needsFeedback(false),
	  m_overrideNumSolverIterations(-1),
	  m_rbA(rbA),
	  m_rbB(rbB),
	  m_appliedImpulse(btScalar(0.)),
	  m_dbgDrawSize(DEFAULT_DEBUGDRAW_SIZE),
	  m_jointFeedback(0)
{
}

btScalar btTypedConstraint::getMotorFactor(btScalar pos, btScalar lowLim, btScalar uppLim, btScalar vel, btScalar timeFact)
{
	if (lowLim > uppLim)
	{
		return btScalar(1.0f);
	}
	else if (lowLim == uppLim)
	{
		return btScalar(0.0f);
	}
	btScalar lim_fact = btScalar(1.0f);
	btScalar delta_max = vel / timeFact;
	if (delta_max < btScalar(0.0f))
	{
		if ((pos >= lowLim) && (pos < (lowLim - delta_max)))
		{
			lim_fact = (lowLim - pos) / delta_max;
		}
		else if (pos < lowLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else if (delta_max > btScalar(0.0f))
	{
		if ((pos <= uppLim) && (pos > (uppLim - delta_max)))
		{
			lim_fact = (uppLim - pos) / delta_max;
		}
		else if (pos > uppLim)
		{
			lim_fact = btScalar(0.0f);
		}
		else
		{
			lim_fact = btScalar(1.0f);
		}
	}
	else
	{
		lim_fact = btScalar(0.0f);
	}
	return lim_fact;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btTypedConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btTypedConstraintData2* tcd = (btTypedConstraintData2*)dataBuffer;

	tcd->m_rbA = (btRigidBodyData*)serializer->getUniquePointer(&m_rbA);
	tcd->m_rbB = (btRigidBodyData*)serializer->getUniquePointer(&m_rbB);
	char* name = (char*)serializer->findNameForPointer(this);
	tcd->m_name = (char*)serializer->getUniquePointer(name);
	if (tcd->m_name)
	{
		serializer->serializeName(name);
	}

	tcd->m_objectType = m_objectType;
	tcd->m_needsFeedback = m_needsFeedback;
	tcd->m_overrideNumSolverIterations = m_overrideNumSolverIterations;
	tcd->m_breakingImpulseThreshold = m_breakingImpulseThreshold;
	tcd->m_isEnabled = m_isEnabled ? 1 : 0;

	tcd->m_userConstraintId = m_userConstraintId;
	tcd->m_userConstraintType = m_userConstraintType;

	tcd->m_appliedImpulse = m_appliedImpulse;
	tcd->m_dbgDrawSize = m_dbgDrawSize;

	tcd->m_disableCollisionsBetweenLinkedBodies = false;

	int i;
	for (i = 0; i < m_rbA.getNumConstraintRefs(); i++)
		if (m_rbA.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;
	for (i = 0; i < m_rbB.getNumConstraintRefs(); i++)
		if (m_rbB.getConstraintRef(i) == this)
			tcd->m_disableCollisionsBetweenLinkedBodies = true;

	return btTypedConstraintDataName;
}

btRigidBody& btTypedConstraint::getFixedBody()
{
	static btRigidBody s_fixed(0, 0, 0);
	s_fixed.setMassProps(btScalar(0.), btVector3(btScalar(0.), btScalar(0.), btScalar(0.)));
	return s_fixed;
}

void btAngularLimit::set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor)
{
	m_halfRange = (high - low) / 2.0f;
	m_center = btNormalizeAngle(low + m_halfRange);
	m_softness = _softness;
	m_biasFactor = _biasFactor;
	m_relaxationFactor = _relaxationFactor;
}

void btAngularLimit::test(const btScalar angle)
{
	m_correction = 0.0f;
	m_sign = 0.0f;
	m_solveLimit = false;

	if (m_halfRange >= 0.0f)
	{
		btScalar deviation = btNormalizeAngle(angle - m_center);
		if (deviation < -m_halfRange)
		{
			m_solveLimit = true;
			m_correction = -(deviation + m_halfRange);
			m_sign = +1.0f;
		}
		else if (deviation > m_halfRange)
		{
			m_solveLimit = true;
			m_correction = m_halfRange - deviation;
			m_sign = -1.0f;
		}
	}
}

btScalar btAngularLimit::getError() const
{
	return m_correction * m_sign;
}

void btAngularLimit::fit(btScalar& angle) const
{
	if (m_halfRange > 0.0f)
	{
		btScalar relativeAngle = btNormalizeAngle(angle - m_center);
		if (!btEqual(relativeAngle, m_halfRange))
		{
			if (relativeAngle > 0.0f)
			{
				angle = getHigh();
			}
			else
			{
				angle = getLow();
			}
		}
	}
}

btScalar btAngularLimit::getLow() const
{
	return btNormalizeAngle(m_center - m_halfRange);
}

btScalar btAngularLimit::getHigh() const
{
	return btNormalizeAngle(m_center + m_halfRange);
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/// 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/// Added support for generic constraint solver through getInfo1/getInfo2 methods

/*
2007-09-09
btGeneric6DofConstraint Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#ifndef BT_GENERIC_6DOF_CONSTRAINT_H
#define BT_GENERIC_6DOF_CONSTRAINT_H

#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

class btRigidBody;

#ifdef BT_USE_DOUBLE_PRECISION
#define btGeneric6DofConstraintData2 btGeneric6DofConstraintDoubleData2
#define btGeneric6DofConstraintDataName "btGeneric6DofConstraintDoubleData2"
#else
#define btGeneric6DofConstraintData2 btGeneric6DofConstraintData
#define btGeneric6DofConstraintDataName "btGeneric6DofConstraintData"
#endif  //BT_USE_DOUBLE_PRECISION

//! Rotation Limit structure for generic joints
class btRotationalLimitMotor
{
public:
	//! limit_parameters
	//!@{
	btScalar m_loLimit;         //!< joint limit
	btScalar m_hiLimit;         //!< joint limit
	btScalar m_targetVelocity;  //!< target motor velocity
	btScalar m_maxMotorForce;   //!< max force on motor
	btScalar m_maxLimitForce;   //!< max force on limit
	btScalar m_damping;         //!< Damping.
	btScalar m_limitSoftness;   //! Relaxation factor
	btScalar m_normalCFM;       //!< Constraint force mixing factor
	btScalar m_stopERP;         //!< Error tolerance factor when joint is at limit
	btScalar m_stopCFM;         //!< Constraint force mixing factor when joint is at limit
	btScalar m_bounce;          //!< restitution factor
	bool m_enableMotor;

	//!@}

	//! temp_variables
	//!@{
	btScalar m_currentLimitError;  //!  How much is violated this limit
	btScalar m_currentPosition;    //!  current value of angle
	int m_currentLimit;            //!< 0=free, 1=at lo limit, 2=at hi limit
	btScalar m_accumulatedImpulse;
	//!@}

	btRotationalLimitMotor()
	{
		m_accumulatedImpulse = 0.f;
		m_targetVelocity = 0;
		m_maxMotorForce = 6.0f;
		m_maxLimitForce = 300.0f;
		m_loLimit = 1.0f;
		m_hiLimit = -1.0f;
		m_normalCFM = 0.f;
		m_stopERP = 0.2f;
		m_stopCFM = 0.f;
		m_bounce = 0.0f;
		m_damping = 1.0f;
		m_limitSoftness = 0.5f;
		m_currentLimit = 0;
		m_currentLimitError = 0;
		m_enableMotor = false;
	}

	btRotationalLimitMotor(const btRotationalLimitMotor& limot)
	{
		m_targetVelocity = limot.m_targetVelocity;
		m_maxMotorForce = limot.m_maxMotorForce;
		m_limitSoftness = limot.m_limitSoftness;
		m_loLimit = limot.m_loLimit;
		m_hiLimit = limot.m_hiLimit;
		m_normalCFM = limot.m_normalCFM;
		m_stopERP = limot.m_stopERP;
		m_stopCFM = limot.m_stopCFM;
		m_bounce = limot.m_bounce;
		m_currentLimit = limot.m_currentLimit;
		m_currentLimitError = limot.m_currentLimitError;
		m_enableMotor = limot.m_enableMotor;
	}

	//! Is limited
	bool isLimited() const
	{
		if (m_loLimit > m_hiLimit) return false;
		return true;
	}

	//! Need apply correction
	bool needApplyTorques() const
	{
		if (m_currentLimit == 0 && m_enableMotor == false) return false;
		return true;
	}

	//! calculates  error
	/*!
	calculates m_currentLimit and m_currentLimitError.
	*/
	int testLimitValue(btScalar test_value);

	//! apply the correction impulses for two bodies
	btScalar solveAngularLimits(btScalar timeStep, btVector3& axis, btScalar jacDiagABInv, btRigidBody* body0, btRigidBody* body1);
};

class btTranslationalLimitMotor
{
public:
	btVector3 m_lowerLimit;  //!< the constraint lower limits
	btVector3 m_upperLimit;  //!< the constraint upper limits
	btVector3 m_accumulatedImpulse;
	//! Linear_Limit_parameters
	//!@{
	btScalar m_limitSoftness;  //!< Softness for linear limit
	btScalar m_damping;        //!< Damping for linear limit
	btScalar m_restitution;    //! Bounce parameter for linear limit
	btVector3 m_normalCFM;     //!< Constraint force mixing factor
	btVector3 m_stopERP;       //!< Error tolerance factor when joint is at limit
	btVector3 m_stopCFM;       //!< Constraint force mixing factor when joint is at limit
							   //!@}
	bool m_enableMotor[3];
	btVector3 m_targetVelocity;     //!< target motor velocity
	btVector3 m_maxMotorForce;      //!< max force on motor
	btVector3 m_currentLimitError;  //!  How much is violated this limit
	btVector3 m_currentLinearDiff;  //!  Current relative offset of constraint frames
	int m_currentLimit[3];          //!< 0=free, 1=at lower limit, 2=at upper limit

	btTranslationalLimitMotor()
	{
		m_lowerLimit.setValue(0.f, 0.f, 0.f);
		m_upperLimit.setValue(0.f, 0.f, 0.f);
		m_accumulatedImpulse.setValue(0.f, 0.f, 0.f);
		m_normalCFM.setValue(0.f, 0.f, 0.f);
		m_stopERP.setValue(0.2f, 0.2f, 0.2f);
		m_stopCFM.setValue(0.f, 0.f, 0.f);

		m_limitSoftness = 0.7f;
		m_damping = btScalar(1.0f);
		m_restitution = btScalar(0.5f);
		for (int i = 0; i < 3; i++)
		{
			m_enableMotor[i] = false;
			m_targetVelocity[i] = btScalar(0.f);
			m_maxMotorForce[i] = btScalar(0.f);
		}
	}

	btTranslationalLimitMotor(const btTranslationalLimitMotor& other)
	{
		m_lowerLimit = other.m_lowerLimit;
		m_upperLimit = other.m_upperLimit;
		m_accumulatedImpulse = other.m_accumulatedImpulse;

		m_limitSoftness = other.m_limitSoftness;
		m_damping = other.m_damping;
		m_restitution = other.m_restitution;
		m_normalCFM = other.m_normalCFM;
		m_stopERP = other.m_stopERP;
		m_stopCFM = other.m_stopCFM;

		for (int i = 0; i < 3; i++)
		{
			m_enableMotor[i] = other.m_enableMotor[i];
			m_targetVelocity[i] = other.m_targetVelocity[i];
			m_maxMotorForce[i] = other.m_maxMotorForce[i];
		}
	}

	//! Test limit
	/*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	inline bool isLimited(int limitIndex) const
	{
		return (m_upperLimit[limitIndex] >= m_lowerLimit[limitIndex]);
	}
	inline bool needApplyForce(int limitIndex) const
	{
		if (m_currentLimit[limitIndex] == 0 && m_enableMotor[limitIndex] == false) return false;
		return true;
	}
	int testLimitValue(int limitIndex, btScalar test_value);

	btScalar solveLinearAxis(
		btScalar timeStep,
		btScalar jacDiagABInv,
		btRigidBody& body1, const btVector3& pointInA,
		btRigidBody& body2, const btVector3& pointInB,
		int limit_index,
		const btVector3& axis_normal_on_a,
		const btVector3& anchorPos);
};

enum bt6DofFlags
{
	BT_6DOF_FLAGS_CFM_NORM = 1,
	BT_6DOF_FLAGS_CFM_STOP = 2,
	BT_6DOF_FLAGS_ERP_STOP = 4
};
#define BT_6DOF_FLAGS_AXIS_SHIFT 3  // bits per axis

/// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/*!
btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
currently this limit supports rotational motors<br>
<ul>
<li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
At this moment translational motors are not supported. May be in the future. </li>

<li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
This is accessible through btGeneric6DofConstraint.getLimitMotor method,
This brings support for limit parameters and motors. </li>

<li> Angulars limits have these possible ranges:
<table border=1 >
<tr>
	<td><b>AXIS</b></td>
	<td><b>MIN ANGLE</b></td>
	<td><b>MAX ANGLE</b></td>
</tr><tr>
	<td>X</td>
	<td>-PI</td>
	<td>PI</td>
</tr><tr>
	<td>Y</td>
	<td>-PI/2</td>
	<td>PI/2</td>
</tr><tr>
	<td>Z</td>
	<td>-PI</td>
	<td>PI</td>
</tr>
</table>
</li>
</ul>

*/
ATTRIBUTE_ALIGNED16(class)
btGeneric6DofConstraint : public btTypedConstraint
{
protected:
	//! relative_frames
	//!@{
	btTransform m_frameInA;  //!< the constraint space w.r.t body A
	btTransform m_frameInB;  //!< the constraint space w.r.t body B
	//!@}

	//! Jacobians
	//!@{
	btJacobianEntry m_jacLinear[3];  //!< 3 orthogonal linear constraints
	btJacobianEntry m_jacAng[3];     //!< 3 orthogonal angular constraints
	//!@}

	//! Linear_Limit_parameters
	//!@{
	btTranslationalLimitMotor m_linearLimits;
	//!@}

	//! hinge_parameters
	//!@{
	btRotationalLimitMotor m_angularLimits[3];
	//!@}

protected:
	//! temporal variables
	//!@{
	btScalar m_timeStep;
	btTransform m_calculatedTransformA;
	btTransform m_calculatedTransformB;
	btVector3 m_calculatedAxisAngleDiff;
	btVector3 m_calculatedAxis[3];
	btVector3 m_calculatedLinearDiff;
	btScalar m_factA;
	btScalar m_factB;
	bool m_hasStaticBody;

	btVector3 m_AnchorPos;  // point betwen pivots of bodies A and B to solve linear axes

	bool m_useLinearReferenceFrameA;
	bool m_useOffsetForConstraintFrame;

	int m_flags;

	//!@}

	btGeneric6DofConstraint& operator=(btGeneric6DofConstraint& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

	int setAngularLimits(btConstraintInfo2 * info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	int setLinearLimits(btConstraintInfo2 * info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	void buildLinearJacobian(
		btJacobianEntry & jacLinear, const btVector3& normalWorld,
		const btVector3& pivotAInW, const btVector3& pivotBInW);

	void buildAngularJacobian(btJacobianEntry & jacAngular, const btVector3& jointAxisW);

	// tests linear limits
	void calculateLinearInfo();

	//! calcs the euler angles between the two bodies.
	void calculateAngleInfo();

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///for backwards compatibility during the transition to 'getInfo/getInfo2'
	bool m_useSolveConstraintObsolete;

	btGeneric6DofConstraint(btRigidBody & rbA, btRigidBody & rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA);
	btGeneric6DofConstraint(btRigidBody & rbB, const btTransform& frameInB, bool useLinearReferenceFrameB);

	//! Calcs global transform of the offsets
	/*!
	Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
	\sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
	*/
	void calculateTransforms(const btTransform& transA, const btTransform& transB);

	void calculateTransforms();

	//! Gets the global transform of the offset for body A
	/*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	const btTransform& getCalculatedTransformA() const
	{
		return m_calculatedTransformA;
	}

	//! Gets the global transform of the offset for body B
	/*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	const btTransform& getCalculatedTransformB() const
	{
		return m_calculatedTransformB;
	}

	const btTransform& getFrameOffsetA() const
	{
		return m_frameInA;
	}

	const btTransform& getFrameOffsetB() const
	{
		return m_frameInB;
	}

	btTransform& getFrameOffsetA()
	{
		return m_frameInA;
	}

	btTransform& getFrameOffsetB()
	{
		return m_frameInB;
	}

	//! performs Jacobian calculation, and also calculates angle differences and axis
	virtual void buildJacobian();

	virtual void getInfo1(btConstraintInfo1 * info);

	void getInfo1NonVirtual(btConstraintInfo1 * info);

	virtual void getInfo2(btConstraintInfo2 * info);

	void getInfo2NonVirtual(btConstraintInfo2 * info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB);

	void updateRHS(btScalar timeStep);

	//! Get the rotation axis in global coordinates
	/*!
	\pre btGeneric6DofConstraint.buildJacobian must be called previously.
	*/
	btVector3 getAxis(int axis_index) const;

	//! Get the relative Euler angle
	/*!
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	btScalar getAngle(int axis_index) const;

	//! Get the relative position of the constraint pivot
	/*!
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	btScalar getRelativePivotPosition(int axis_index) const;

	void setFrames(const btTransform& frameA, const btTransform& frameB);

	//! Test angular limit.
	/*!
	Calculates angular correction and returns true if limit needs to be corrected.
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	bool testAngularLimitMotor(int axis_index);

	void setLinearLowerLimit(const btVector3& linearLower)
	{
		m_linearLimits.m_lowerLimit = linearLower;
	}

	void getLinearLowerLimit(btVector3 & linearLower) const
	{
		linearLower = m_linearLimits.m_lowerLimit;
	}

	void setLinearUpperLimit(const btVector3& linearUpper)
	{
		m_linearLimits.m_upperLimit = linearUpper;
	}

	void getLinearUpperLimit(btVector3 & linearUpper) const
	{
		linearUpper = m_linearLimits.m_upperLimit;
	}

	void setAngularLowerLimit(const btVector3& angularLower)
	{
		for (int i = 0; i < 3; i++)
			m_angularLimits[i].m_loLimit = btNormalizeAngle(angularLower[i]);
	}

	void getAngularLowerLimit(btVector3 & angularLower) const
	{
		for (int i = 0; i < 3; i++)
			angularLower[i] = m_angularLimits[i].m_loLimit;
	}

	void setAngularUpperLimit(const btVector3& angularUpper)
	{
		for (int i = 0; i < 3; i++)
			m_angularLimits[i].m_hiLimit = btNormalizeAngle(angularUpper[i]);
	}

	void getAngularUpperLimit(btVector3 & angularUpper) const
	{
		for (int i = 0; i < 3; i++)
			angularUpper[i] = m_angularLimits[i].m_hiLimit;
	}

	//! Retrieves the angular limit informacion
	btRotationalLimitMotor* getRotationalLimitMotor(int index)
	{
		return &m_angularLimits[index];
	}

	//! Retrieves the  limit informacion
	btTranslationalLimitMotor* getTranslationalLimitMotor()
	{
		return &m_linearLimits;
	}

	//first 3 are linear, next 3 are angular
	void setLimit(int axis, btScalar lo, btScalar hi)
	{
		if (axis < 3)
		{
			m_linearLimits.m_lowerLimit[axis] = lo;
			m_linearLimits.m_upperLimit[axis] = hi;
		}
		else
		{
			lo = btNormalizeAngle(lo);
			hi = btNormalizeAngle(hi);
			m_angularLimits[axis - 3].m_loLimit = lo;
			m_angularLimits[axis - 3].m_hiLimit = hi;
		}
	}

	//! Test limit
	/*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	bool isLimited(int limitIndex) const
	{
		if (limitIndex < 3)
		{
			return m_linearLimits.isLimited(limitIndex);
		}
		return m_angularLimits[limitIndex - 3].isLimited();
	}

	virtual void calcAnchorPos(void);  // overridable

	int get_limit_motor_info2(btRotationalLimitMotor * limot,
							  const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
							  btConstraintInfo2* info, int row, btVector3& ax1, int rotational, int rotAllowed = false);

	// access for UseFrameOffset
	bool getUseFrameOffset() const { return m_useOffsetForConstraintFrame; }
	void setUseFrameOffset(bool frameOffsetOnOff) { m_useOffsetForConstraintFrame = frameOffsetOnOff; }

	bool getUseLinearReferenceFrameA() const { return m_useLinearReferenceFrameA; }
	void setUseLinearReferenceFrameA(bool linearReferenceFrameA) { m_useLinearReferenceFrameA = linearReferenceFrameA; }

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1);
	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const;

	void setAxis(const btVector3& axis1, const btVector3& axis2);

	virtual int getFlags() const
	{
		return m_flags;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

struct btGeneric6DofConstraintData
{
	btTypedConstraintData m_typeConstraintData;
	btTransformFloatData m_rbAFrame;  // constraint axii. Assumes z is hinge axis.
	btTransformFloatData m_rbBFrame;

	btVector3FloatData m_linearUpperLimit;
	btVector3FloatData m_linearLowerLimit;

	btVector3FloatData m_angularUpperLimit;
	btVector3FloatData m_angularLowerLimit;

	int m_useLinearReferenceFrameA;
	int m_useOffsetForConstraintFrame;
};

struct btGeneric6DofConstraintDoubleData2
{
	btTypedConstraintDoubleData m_typeConstraintData;
	btTransformDoubleData m_rbAFrame;  // constraint axii. Assumes z is hinge axis.
	btTransformDoubleData m_rbBFrame;

	btVector3DoubleData m_linearUpperLimit;
	btVector3DoubleData m_linearLowerLimit;

	btVector3DoubleData m_angularUpperLimit;
	btVector3DoubleData m_angularLowerLimit;

	int m_useLinearReferenceFrameA;
	int m_useOffsetForConstraintFrame;
};

SIMD_FORCE_INLINE int btGeneric6DofConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btGeneric6DofConstraintData2);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btGeneric6DofConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btGeneric6DofConstraintData2* dof = (btGeneric6DofConstraintData2*)dataBuffer;
	btTypedConstraint::serialize(&dof->m_typeConstraintData, serializer);

	m_frameInA.serialize(dof->m_rbAFrame);
	m_frameInB.serialize(dof->m_rbBFrame);

	int i;
	for (i = 0; i < 3; i++)
	{
		dof->m_angularLowerLimit.m_floats[i] = m_angularLimits[i].m_loLimit;
		dof->m_angularUpperLimit.m_floats[i] = m_angularLimits[i].m_hiLimit;
		dof->m_linearLowerLimit.m_floats[i] = m_linearLimits.m_lowerLimit[i];
		dof->m_linearUpperLimit.m_floats[i] = m_linearLimits.m_upperLimit[i];
	}

	dof->m_useLinearReferenceFrameA = m_useLinearReferenceFrameA ? 1 : 0;
	dof->m_useOffsetForConstraintFrame = m_useOffsetForConstraintFrame ? 1 : 0;

	return btGeneric6DofConstraintDataName;
}

#endif  //BT_GENERIC_6DOF_CONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
/*
2007-09-09
Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btTransformUtil.h"

#define D6_USE_OBSOLETE_METHOD false
#define D6_USE_FRAME_OFFSET true

btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbA, btRigidBody& rbB, const btTransform& frameInA, const btTransform& frameInB, bool useLinearReferenceFrameA)
	: btTypedConstraint(D6_CONSTRAINT_TYPE, rbA, rbB), m_frameInA(frameInA), m_frameInB(frameInB), m_useLinearReferenceFrameA(useLinearReferenceFrameA), m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET), m_flags(0), m_useSolveConstraintObsolete(D6_USE_OBSOLETE_METHOD)
{
	calculateTransforms();
}

btGeneric6DofConstraint::btGeneric6DofConstraint(btRigidBody& rbB, const btTransform& frameInB, bool useLinearReferenceFrameB)
	: btTypedConstraint(D6_CONSTRAINT_TYPE, getFixedBody(), rbB),
	  m_frameInB(frameInB),
	  m_useLinearReferenceFrameA(useLinearReferenceFrameB),
	  m_useOffsetForConstraintFrame(D6_USE_FRAME_OFFSET),
	  m_flags(0),
	  m_useSolveConstraintObsolete(false)
{
	///not providing rigidbody A means implicitly using worldspace for body A
	m_frameInA = rbB.getCenterOfMassTransform() * m_frameInB;
	calculateTransforms();
}

#define GENERIC_D6_DISABLE_WARMSTARTING 1

btScalar btGetMatrixElem(const btMatrix3x3& mat, int index);
btScalar btGetMatrixElem(const btMatrix3x3& mat, int index)
{
	int i = index % 3;
	int j = index / 3;
	return mat[i][j];
}

///MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html
bool matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz);
bool matrixToEulerXYZ(const btMatrix3x3& mat, btVector3& xyz)
{
	//	// rot =  cy*cz          -cy*sz           sy
	//	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
	//	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
	//

	btScalar fi = btGetMatrixElem(mat, 2);
	if (fi < btScalar(1.0f))
	{
		if (fi > btScalar(-1.0f))
		{
			xyz[0] = btAtan2(-btGetMatrixElem(mat, 5), btGetMatrixElem(mat, 8));
			xyz[1] = btAsin(btGetMatrixElem(mat, 2));
			xyz[2] = btAtan2(-btGetMatrixElem(mat, 1), btGetMatrixElem(mat, 0));
			return true;
		}
		else
		{
			// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
			xyz[0] = -btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
			xyz[1] = -SIMD_HALF_PI;
			xyz[2] = btScalar(0.0);
			return false;
		}
	}
	else
	{
		// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
		xyz[0] = btAtan2(btGetMatrixElem(mat, 3), btGetMatrixElem(mat, 4));
		xyz[1] = SIMD_HALF_PI;
		xyz[2] = 0.0;
	}
	return false;
}

//////////////////////////// btRotationalLimitMotor ////////////////////////////////////

int btRotationalLimitMotor::testLimitValue(btScalar test_value)
{
	if (m_loLimit > m_hiLimit)
	{
		m_currentLimit = 0;  //Free from violation
		return 0;
	}
	if (test_value < m_loLimit)
	{
		m_currentLimit = 1;  //low limit violation
		m_currentLimitError = test_value - m_loLimit;
		if (m_currentLimitError > SIMD_PI)
			m_currentLimitError -= SIMD_2_PI;
		else if (m_currentLimitError < -SIMD_PI)
			m_currentLimitError += SIMD_2_PI;
		return 1;
	}
	else if (test_value > m_hiLimit)
	{
		m_currentLimit = 2;  //High limit violation
		m_currentLimitError = test_value - m_hiLimit;
		if (m_currentLimitError > SIMD_PI)
			m_currentLimitError -= SIMD_2_PI;
		else if (m_currentLimitError < -SIMD_PI)
			m_currentLimitError += SIMD_2_PI;
		return 2;
	};

	m_currentLimit = 0;  //Free from violation
	return 0;
}

btScalar btRotationalLimitMotor::solveAngularLimits(
	btScalar timeStep, btVector3& axis, btScalar jacDiagABInv,
	btRigidBody* body0, btRigidBody* body1)
{
	if (needApplyTorques() == false) return 0.0f;

	btScalar target_velocity = m_targetVelocity;
	btScalar maxMotorForce = m_maxMotorForce;

	//current error correction
	if (m_currentLimit != 0)
	{
		target_velocity = -m_stopERP * m_currentLimitError / (timeStep);
		maxMotorForce = m_maxLimitForce;
	}

	maxMotorForce *= timeStep;

	// current velocity difference

	btVector3 angVelA = body0->getAngularVelocity();
	btVector3 angVelB = body1->getAngularVelocity();

	btVector3 vel_diff;
	vel_diff = angVelA - angVelB;

	btScalar rel_vel = axis.dot(vel_diff);

	// correction velocity
	btScalar motor_relvel = m_limitSoftness * (target_velocity - m_damping * rel_vel);

	if (motor_relvel < SIMD_EPSILON && motor_relvel > -SIMD_EPSILON)
	{
		return 0.0f;  //no need for applying force
	}

	// correction impulse
	btScalar unclippedMotorImpulse = (1 + m_bounce) * motor_relvel * jacDiagABInv;

	// clip correction impulse
	btScalar clippedMotorImpulse;

	///@todo: should clip against accumulated impulse
	if (unclippedMotorImpulse > 0.0f)
	{
		clippedMotorImpulse = unclippedMotorImpulse > maxMotorForce ? maxMotorForce : unclippedMotorImpulse;
	}
	else
	{
		clippedMotorImpulse = unclippedMotorImpulse < -maxMotorForce ? -maxMotorForce : unclippedMotorImpulse;
	}

	// sort with accumulated impulses
	btScalar lo = btScalar(-BT_LARGE_FLOAT);
	btScalar hi = btScalar(BT_LARGE_FLOAT);

	btScalar oldaccumImpulse = m_accumulatedImpulse;
	btScalar sum = oldaccumImpulse + clippedMotorImpulse;
	m_accumulatedImpulse = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;

	clippedMotorImpulse = m_accumulatedImpulse - oldaccumImpulse;

	btVector3 motorImp = clippedMotorImpulse * axis;

	body0->applyTorqueImpulse(motorImp);
	body1->applyTorqueImpulse(-motorImp);

	return clippedMotorImpulse;
}

//////////////////////////// End btRotationalLimitMotor ////////////////////////////////////

//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////

int btTranslationalLimitMotor::testLimitValue(int limitIndex, btScalar test_value)
{
	btScalar loLimit = m_lowerLimit[limitIndex];
	btScalar hiLimit = m_upperLimit[limitIndex];
	if (loLimit > hiLimit)
	{
		m_currentLimit[limitIndex] = 0;  //Free from violation
		m_currentLimitError[limitIndex] = btScalar(0.f);
		return 0;
	}

	if (test_value < loLimit)
	{
		m_currentLimit[limitIndex] = 2;  //low limit violation
		m_currentLimitError[limitIndex] = test_value - loLimit;
		return 2;
	}
	else if (test_value > hiLimit)
	{
		m_currentLimit[limitIndex] = 1;  //High limit violation
		m_currentLimitError[limitIndex] = test_value - hiLimit;
		return 1;
	};

	m_currentLimit[limitIndex] = 0;  //Free from violation
	m_currentLimitError[limitIndex] = btScalar(0.f);
	return 0;
}

btScalar btTranslationalLimitMotor::solveLinearAxis(
	btScalar timeStep,
	btScalar jacDiagABInv,
	btRigidBody& body1, const btVector3& pointInA,
	btRigidBody& body2, const btVector3& pointInB,
	int limit_index,
	const btVector3& axis_normal_on_a,
	const btVector3& anchorPos)
{
	///find relative velocity
	//    btVector3 rel_pos1 = pointInA - body1.getCenterOfMassPosition();
	//    btVector3 rel_pos2 = pointInB - body2.getCenterOfMassPosition();
	btVector3 rel_pos1 = anchorPos - body1.getCenterOfMassPosition();
	btVector3 rel_pos2 = anchorPos - body2.getCenterOfMassPosition();

	btVector3 vel1 = body1.getVelocityInLocalPoint(rel_pos1);
	btVector3 vel2 = body2.getVelocityInLocalPoint(rel_pos2);
	btVector3 vel = vel1 - vel2;

	btScalar rel_vel = axis_normal_on_a.dot(vel);

	/// apply displacement correction

	//positional error (zeroth order error)
	btScalar depth = -(pointInA - pointInB).dot(axis_normal_on_a);
	btScalar lo = btScalar(-BT_LARGE_FLOAT);
	btScalar hi = btScalar(BT_LARGE_FLOAT);

	btScalar minLimit = m_lowerLimit[limit_index];
	btScalar maxLimit = m_upperLimit[limit_index];

	//handle the limits
	if (minLimit < maxLimit)
	{
		{
			if (depth > maxLimit)
			{
				depth -= maxLimit;
				lo = btScalar(0.);
			}
			else
			{
				if (depth < minLimit)
				{
					depth -= minLimit;
					hi = btScalar(0.);
				}
				else
				{
					return 0.0f;
				}
			}
		}
	}

	btScalar normalImpulse = m_limitSoftness * (m_restitution * depth / timeStep - m_damping * rel_vel) * jacDiagABInv;

	btScalar oldNormalImpulse = m_accumulatedImpulse[limit_index];
	btScalar sum = oldNormalImpulse + normalImpulse;
	m_accumulatedImpulse[limit_index] = sum > hi ? btScalar(0.) : sum < lo ? btScalar(0.) : sum;
	normalImpulse = m_accumulatedImpulse[limit_index] - oldNormalImpulse;

	btVector3 impulse_vector = axis_normal_on_a * normalImpulse;
	body1.applyImpulse(impulse_vector, rel_pos1);
	body2.applyImpulse(-impulse_vector, rel_pos2);

	return normalImpulse;
}

//////////////////////////// btTranslationalLimitMotor ////////////////////////////////////

void btGeneric6DofConstraint::calculateAngleInfo()
{
	btMatrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse() * m_calculatedTransformB.getBasis();
	matrixToEulerXYZ(relative_frame, m_calculatedAxisAngleDiff);
	// in euler angle mode we do not actually constrain the angular velocity
	// along the axes axis[0] and axis[2] (although we do use axis[1]) :
	//
	//    to get			constrain w2-w1 along		...not
	//    ------			---------------------		------
	//    d(angle[0])/dt = 0	ax[1] x ax[2]			ax[0]
	//    d(angle[1])/dt = 0	ax[1]
	//    d(angle[2])/dt = 0	ax[0] x ax[1]			ax[2]
	//
	// constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.
	// to prove the result for angle[0], write the expression for angle[0] from
	// GetInfo1 then take the derivative. to prove this for angle[2] it is
	// easier to take the euler rate expression for d(angle[2])/dt with respect
	// to the components of w and set that to 0.
	btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
	btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);

	m_calculatedAxis[1] = axis2.cross(axis0);
	m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
	m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);

	m_calculatedAxis[0].normalize();
	m_calculatedAxis[1].normalize();
	m_calculatedAxis[2].normalize();
}

void btGeneric6DofConstraint::calculateTransforms()
{
	calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
}

void btGeneric6DofConstraint::calculateTransforms(const btTransform& transA, const btTransform& transB)
{
	m_calculatedTransformA = transA * m_frameInA;
	m_calculatedTransformB = transB * m_frameInB;
	calculateLinearInfo();
	calculateAngleInfo();
	if (m_useOffsetForConstraintFrame)
	{  //  get weight factors depending on masses
		btScalar miA = getRigidBodyA().getInvMass();
		btScalar miB = getRigidBodyB().getInvMass();
		m_hasStaticBody = (miA < SIMD_EPSILON) || (miB < SIMD_EPSILON);
		btScalar miS = miA + miB;
		if (miS > btScalar(0.f))
		{
			m_factA = miB / miS;
		}
		else
		{
			m_factA = btScalar(0.5f);
		}
		m_factB = btScalar(1.0f) - m_factA;
	}
}

void btGeneric6DofConstraint::buildLinearJacobian(
	btJacobianEntry& jacLinear, const btVector3& normalWorld,
	const btVector3& pivotAInW, const btVector3& pivotBInW)
{
	new (&jacLinear) btJacobianEntry(
		m_rbA.getCenterOfMassTransform().getBasis().transpose(),
		m_rbB.getCenterOfMassTransform().getBasis().transpose(),
		pivotAInW - m_rbA.getCenterOfMassPosition(),
		pivotBInW - m_rbB.getCenterOfMassPosition(),
		normalWorld,
		m_rbA.getInvInertiaDiagLocal(),
		m_rbA.getInvMass(),
		m_rbB.getInvInertiaDiagLocal(),
		m_rbB.getInvMass());
}

void btGeneric6DofConstraint::buildAngularJacobian(
	btJacobianEntry& jacAngular, const btVector3& jointAxisW)
{
	new (&jacAngular) btJacobianEntry(jointAxisW,
									  m_rbA.getCenterOfMassTransform().getBasis().transpose(),
									  m_rbB.getCenterOfMassTransform().getBasis().transpose(),
									  m_rbA.getInvInertiaDiagLocal(),
									  m_rbB.getInvInertiaDiagLocal());
}

bool btGeneric6DofConstraint::testAngularLimitMotor(int axis_index)
{
	btScalar angle = m_calculatedAxisAngleDiff[axis_index];
	angle = btAdjustAngleToLimits(angle, m_angularLimits[axis_index].m_loLimit, m_angularLimits[axis_index].m_hiLimit);
	m_angularLimits[axis_index].m_currentPosition = angle;
	//test limits
	m_angularLimits[axis_index].testLimitValue(angle);
	return m_angularLimits[axis_index].needApplyTorques();
}

void btGeneric6DofConstraint::buildJacobian()
{
#ifndef __SPU__
	if (m_useSolveConstraintObsolete)
	{
		// Clear accumulated impulses for the next simulation step
		m_linearLimits.m_accumulatedImpulse.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
		int i;
		for (i = 0; i < 3; i++)
		{
			m_angularLimits[i].m_accumulatedImpulse = btScalar(0.);
		}
		//calculates transform
		calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());

		//  const btVector3& pivotAInW = m_calculatedTransformA.getOrigin();
		//  const btVector3& pivotBInW = m_calculatedTransformB.getOrigin();
		calcAnchorPos();
		btVector3 pivotAInW = m_AnchorPos;
		btVector3 pivotBInW = m_AnchorPos;

		// not used here
		//    btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
		//    btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

		btVector3 normalWorld;
		//linear part
		for (i = 0; i < 3; i++)
		{
			if (m_linearLimits.isLimited(i))
			{
				if (m_useLinearReferenceFrameA)
					normalWorld = m_calculatedTransformA.getBasis().getColumn(i);
				else
					normalWorld = m_calculatedTransformB.getBasis().getColumn(i);

				buildLinearJacobian(
					m_jacLinear[i], normalWorld,
					pivotAInW, pivotBInW);
			}
		}

		// angular part
		for (i = 0; i < 3; i++)
		{
			//calculates error angle
			if (testAngularLimitMotor(i))
			{
				normalWorld = this->getAxis(i);
				// Create angular atom
				buildAngularJacobian(m_jacAng[i], normalWorld);
			}
		}
	}
#endif  //__SPU__
}

void btGeneric6DofConstraint::getInfo1(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		//prepare constraint
		calculateTransforms(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform());
		info->m_numConstraintRows = 0;
		info->nub = 6;
		int i;
		//test linear limits
		for (i = 0; i < 3; i++)
		{
			if (m_linearLimits.needApplyForce(i))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
		//test angular limits
		for (i = 0; i < 3; i++)
		{
			if (testAngularLimitMotor(i))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
	}
}

void btGeneric6DofConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		//pre-allocate all 6
		info->m_numConstraintRows = 6;
		info->nub = 0;
	}
}

void btGeneric6DofConstraint::getInfo2(btConstraintInfo2* info)
{
	btAssert(!m_useSolveConstraintObsolete);

	const btTransform& transA = m_rbA.getCenterOfMassTransform();
	const btTransform& transB = m_rbB.getCenterOfMassTransform();
	const btVector3& linVelA = m_rbA.getLinearVelocity();
	const btVector3& linVelB = m_rbB.getLinearVelocity();
	const btVector3& angVelA = m_rbA.getAngularVelocity();
	const btVector3& angVelB = m_rbB.getAngularVelocity();

	if (m_useOffsetForConstraintFrame)
	{  // for stability better to solve angular limits first
		int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
	else
	{  // leave old version for compatibility
		int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
}

void btGeneric6DofConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	btAssert(!m_useSolveConstraintObsolete);
	//prepare constraint
	calculateTransforms(transA, transB);

	int i;
	for (i = 0; i < 3; i++)
	{
		testAngularLimitMotor(i);
	}

	if (m_useOffsetForConstraintFrame)
	{  // for stability better to solve angular limits first
		int row = setAngularLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setLinearLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
	else
	{  // leave old version for compatibility
		int row = setLinearLimits(info, 0, transA, transB, linVelA, linVelB, angVelA, angVelB);
		setAngularLimits(info, row, transA, transB, linVelA, linVelB, angVelA, angVelB);
	}
}

int btGeneric6DofConstraint::setLinearLimits(btConstraintInfo2* info, int row, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	//	int row = 0;
	//solve linear limits
	btRotationalLimitMotor limot;
	for (int i = 0; i < 3; i++)
	{
		if (m_linearLimits.needApplyForce(i))
		{  // re-use rotational motor code
			limot.m_bounce = btScalar(0.f);
			limot.m_currentLimit = m_linearLimits.m_currentLimit[i];
			limot.m_currentPosition = m_linearLimits.m_currentLinearDiff[i];
			limot.m_currentLimitError = m_linearLimits.m_currentLimitError[i];
			limot.m_damping = m_linearLimits.m_damping;
			limot.m_enableMotor = m_linearLimits.m_enableMotor[i];
			limot.m_hiLimit = m_linearLimits.m_upperLimit[i];
			limot.m_limitSoftness = m_linearLimits.m_limitSoftness;
			limot.m_loLimit = m_linearLimits.m_lowerLimit[i];
			limot.m_maxLimitForce = btScalar(0.f);
			limot.m_maxMotorForce = m_linearLimits.m_maxMotorForce[i];
			limot.m_targetVelocity = m_linearLimits.m_targetVelocity[i];
			btVector3 axis = m_calculatedTransformA.getBasis().getColumn(i);
			int flags = m_flags >> (i * BT_6DOF_FLAGS_AXIS_SHIFT);
			limot.m_normalCFM = (flags & BT_6DOF_FLAGS_CFM_NORM) ? m_linearLimits.m_normalCFM[i] : info->cfm[0];
			limot.m_stopCFM = (flags & BT_6DOF_FLAGS_CFM_STOP) ? m_linearLimits.m_stopCFM[i] : info->cfm[0];
			limot.m_stopERP = (flags & BT_6DOF_FLAGS_ERP_STOP) ? m_linearLimits.m_stopERP[i] : info->erp;
			if (m_useOffsetForConstraintFrame)
			{
				int indx1 = (i + 1) % 3;
				int indx2 = (i + 2) % 3;
				int rotAllowed = 1;  // rotations around orthos to current axis
				if (m_angularLimits[indx1].m_currentLimit && m_angularLimits[indx2].m_currentLimit)
				{
					rotAllowed = 0;
				}
				row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0, rotAllowed);
			}
			else
			{
				row += get_limit_motor_info2(&limot, transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 0);
			}
		}
	}
	return row;
}

int btGeneric6DofConstraint::setAngularLimits(btConstraintInfo2* info, int row_offset, const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB)
{
	btGeneric6DofConstraint* d6constraint = this;
	int row = row_offset;
	//solve angular limits
	for (int i = 0; i < 3; i++)
	{
		if (d6constraint->getRotationalLimitMotor(i)->needApplyTorques())
		{
			btVector3 axis = d6constraint->getAxis(i);
			int flags = m_flags >> ((i + 3) * BT_6DOF_FLAGS_AXIS_SHIFT);
			if (!(flags & BT_6DOF_FLAGS_CFM_NORM))
			{
				m_angularLimits[i].m_normalCFM = info->cfm[0];
			}
			if (!(flags & BT_6DOF_FLAGS_CFM_STOP))
			{
				m_angularLimits[i].m_stopCFM = info->cfm[0];
			}
			if (!(flags & BT_6DOF_FLAGS_ERP_STOP))
			{
				m_angularLimits[i].m_stopERP = info->erp;
			}
			row += get_limit_motor_info2(d6constraint->getRotationalLimitMotor(i),
										 transA, transB, linVelA, linVelB, angVelA, angVelB, info, row, axis, 1);
		}
	}

	return row;
}

void btGeneric6DofConstraint::updateRHS(btScalar timeStep)
{
	(void)timeStep;
}

void btGeneric6DofConstraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
	m_frameInA = frameA;
	m_frameInB = frameB;
	buildJacobian();
	calculateTransforms();
}

btVector3 btGeneric6DofConstraint::getAxis(int axis_index) const
{
	return m_calculatedAxis[axis_index];
}

btScalar btGeneric6DofConstraint::getRelativePivotPosition(int axisIndex) const
{
	return m_calculatedLinearDiff[axisIndex];
}

btScalar btGeneric6DofConstraint::getAngle(int axisIndex) const
{
	return m_calculatedAxisAngleDiff[axisIndex];
}

void btGeneric6DofConstraint::calcAnchorPos(void)
{
	btScalar imA = m_rbA.getInvMass();
	btScalar imB = m_rbB.getInvMass();
	btScalar weight;
	if (imB == btScalar(0.0))
	{
		weight = btScalar(1.0);
	}
	else
	{
		weight = imA / (imA + imB);
	}
	const btVector3& pA = m_calculatedTransformA.getOrigin();
	const btVector3& pB = m_calculatedTransformB.getOrigin();
	m_AnchorPos = pA * weight + pB * (btScalar(1.0) - weight);
	return;
}

void btGeneric6DofConstraint::calculateLinearInfo()
{
	m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
	m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
	for (int i = 0; i < 3; i++)
	{
		m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
		m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
	}
}

int btGeneric6DofConstraint::get_limit_motor_info2(
	btRotationalLimitMotor* limot,
	const btTransform& transA, const btTransform& transB, const btVector3& linVelA, const btVector3& linVelB, const btVector3& angVelA, const btVector3& angVelB,
	btConstraintInfo2* info, int row, btVector3& ax1, int rotational, int rotAllowed)
{
	int srow = row * info->rowskip;
	bool powered = limot->m_enableMotor;
	int limit = limot->m_currentLimit;
	if (powered || limit)
	{  // if the joint is powered, or has joint limits, add in the extra row
		btScalar* J1 = rotational ? info->m_J1angularAxis : info->m_J1linearAxis;
		btScalar* J2 = rotational ? info->m_J2angularAxis : info->m_J2linearAxis;
		J1[srow + 0] = ax1[0];
		J1[srow + 1] = ax1[1];
		J1[srow + 2] = ax1[2];

		J2[srow + 0] = -ax1[0];
		J2[srow + 1] = -ax1[1];
		J2[srow + 2] = -ax1[2];

		if ((!rotational))
		{
			if (m_useOffsetForConstraintFrame)
			{
				btVector3 tmpA, tmpB, relA, relB;
				// get vector from bodyB to frameB in WCS
				relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
				// get its projection to constraint axis
				btVector3 projB = ax1 * relB.dot(ax1);
				// get vector directed from bodyB to constraint axis (and orthogonal to it)
				btVector3 orthoB = relB - projB;
				// same for bodyA
				relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
				btVector3 projA = ax1 * relA.dot(ax1);
				btVector3 orthoA = relA - projA;
				// get desired offset between frames A and B along constraint axis
				btScalar desiredOffs = limot->m_currentPosition - limot->m_currentLimitError;
				// desired vector from projection of center of bodyA to projection of center of bodyB to constraint axis
				btVector3 totalDist = projA + ax1 * desiredOffs - projB;
				// get offset vectors relA and relB
				relA = orthoA + totalDist * m_factA;
				relB = orthoB - totalDist * m_factB;
				tmpA = relA.cross(ax1);
				tmpB = relB.cross(ax1);
				if (m_hasStaticBody && (!rotAllowed))
				{
					tmpA *= m_factA;
					tmpB *= m_factB;
				}
				int i;
				for (i = 0; i < 3; i++) info->m_J1angularAxis[srow + i] = tmpA[i];
				for (i = 0; i < 3; i++) info->m_J2angularAxis[srow + i] = -tmpB[i];
			}
			else
			{
				btVector3 ltd;  // Linear Torque Decoupling vector
				btVector3 c = m_calculatedTransformB.getOrigin() - transA.getOrigin();
				ltd = c.cross(ax1);
				info->m_J1angularAxis[srow + 0] = ltd[0];
				info->m_J1angularAxis[srow + 1] = ltd[1];
				info->m_J1angularAxis[srow + 2] = ltd[2];

				c = m_calculatedTransformB.getOrigin() - transB.getOrigin();
				ltd = -c.cross(ax1);
				info->m_J2angularAxis[srow + 0] = ltd[0];
				info->m_J2angularAxis[srow + 1] = ltd[1];
				info->m_J2angularAxis[srow + 2] = ltd[2];
			}
		}
		// if we're limited low and high simultaneously, the joint motor is
		// ineffective
		if (limit && (limot->m_loLimit == limot->m_hiLimit)) powered = false;
		info->m_constraintError[srow] = btScalar(0.f);
		if (powered)
		{
			info->cfm[srow] = limot->m_normalCFM;
			if (!limit)
			{
				btScalar tag_vel = rotational ? limot->m_targetVelocity : -limot->m_targetVelocity;

				btScalar mot_fact = getMotorFactor(limot->m_currentPosition,
												   limot->m_loLimit,
												   limot->m_hiLimit,
												   tag_vel,
												   info->fps * limot->m_stopERP);
				info->m_constraintError[srow] += mot_fact * limot->m_targetVelocity;
				info->m_lowerLimit[srow] = -limot->m_maxMotorForce / info->fps;
				info->m_upperLimit[srow] = limot->m_maxMotorForce / info->fps;
			}
		}
		if (limit)
		{
			btScalar k = info->fps * limot->m_stopERP;
			if (!rotational)
			{
				info->m_constraintError[srow] += k * limot->m_currentLimitError;
			}
			else
			{
				info->m_constraintError[srow] += -k * limot->m_currentLimitError;
			}
			info->cfm[srow] = limot->m_stopCFM;
			if (limot->m_loLimit == limot->m_hiLimit)
			{  // limited low and high simultaneously
				info->m_lowerLimit[srow] = -SIMD_INFINITY;
				info->m_upperLimit[srow] = SIMD_INFINITY;
			}
			else
			{
				if (limit == 1)
				{
					info->m_lowerLimit[srow] = 0;
					info->m_upperLimit[srow] = SIMD_INFINITY;
				}
				else
				{
					info->m_lowerLimit[srow] = -SIMD_INFINITY;
					info->m_upperLimit[srow] = 0;
				}
				// deal with bounce
				if (limot->m_bounce > 0)
				{
					// calculate joint velocity
					btScalar vel;
					if (rotational)
					{
						vel = angVelA.dot(ax1);
						//make sure that if no body -> angVelB == zero vec
						//                        if (body1)
						vel -= angVelB.dot(ax1);
					}
					else
					{
						vel = linVelA.dot(ax1);
						//make sure that if no body -> angVelB == zero vec
						//                        if (body1)
						vel -= linVelB.dot(ax1);
					}
					// only apply bounce if the velocity is incoming, and if the
					// resulting c[] exceeds what we already have.
					if (limit == 1)
					{
						if (vel < 0)
						{
							btScalar newc = -limot->m_bounce * vel;
							if (newc > info->m_constraintError[srow])
								info->m_constraintError[srow] = newc;
						}
					}
					else
					{
						if (vel > 0)
						{
							btScalar newc = -limot->m_bounce * vel;
							if (newc < info->m_constraintError[srow])
								info->m_constraintError[srow] = newc;
						}
					}
				}
			}
		}
		return 1;
	}
	else
		return 0;
}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
void btGeneric6DofConstraint::setParam(int num, btScalar value, int axis)
{
	if ((axis >= 0) && (axis < 3))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				m_linearLimits.m_stopERP[axis] = value;
				m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_STOP_CFM:
				m_linearLimits.m_stopCFM[axis] = value;
				m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_CFM:
				m_linearLimits.m_normalCFM[axis] = value;
				m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else if ((axis >= 3) && (axis < 6))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				m_angularLimits[axis - 3].m_stopERP = value;
				m_flags |= BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_STOP_CFM:
				m_angularLimits[axis - 3].m_stopCFM = value;
				m_flags |= BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			case BT_CONSTRAINT_CFM:
				m_angularLimits[axis - 3].m_normalCFM = value;
				m_flags |= BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT);
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else
	{
		btAssertConstrParams(0);
	}
}

///return the local value of parameter
btScalar btGeneric6DofConstraint::getParam(int num, int axis) const
{
	btScalar retVal = 0;
	if ((axis >= 0) && (axis < 3))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_stopERP[axis];
				break;
			case BT_CONSTRAINT_STOP_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_stopCFM[axis];
				break;
			case BT_CONSTRAINT_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_linearLimits.m_normalCFM[axis];
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else if ((axis >= 3) && (axis < 6))
	{
		switch (num)
		{
			case BT_CONSTRAINT_STOP_ERP:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_ERP_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_stopERP;
				break;
			case BT_CONSTRAINT_STOP_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_STOP << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_stopCFM;
				break;
			case BT_CONSTRAINT_CFM:
				btAssertConstrParams(m_flags & (BT_6DOF_FLAGS_CFM_NORM << (axis * BT_6DOF_FLAGS_AXIS_SHIFT)));
				retVal = m_angularLimits[axis - 3].m_normalCFM;
				break;
			default:
				btAssertConstrParams(0);
		}
	}
	else
	{
		btAssertConstrParams(0);
	}
	return retVal;
}

void btGeneric6DofConstraint::setAxis(const btVector3& axis1, const btVector3& axis2)
{
	btVector3 zAxis = axis1.normalized();
	btVector3 yAxis = axis2.normalized();
	btVector3 xAxis = yAxis.cross(zAxis);  // we want right coordinate system

	btTransform frameInW;
	frameInW.setIdentity();
	frameInW.getBasis().setValue(xAxis[0], yAxis[0], zAxis[0],
								 xAxis[1], yAxis[1], zAxis[1],
								 xAxis[2], yAxis[2], zAxis[2]);

	// now get constraint frame in local coordinate systems
	m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
	m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;

	calculateTransforms();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_PERSISTENT_MANIFOLD_H
#define BT_PERSISTENT_MANIFOLD_H

#include "LinearMath/btVector3.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
class btCollisionObject;
#include "LinearMath/btAlignedAllocator.h"

struct btCollisionResult;
struct btCollisionObjectDoubleData;
struct btCollisionObjectFloatData;

///maximum contact breaking and merging threshold
extern btScalar gContactBreakingThreshold;

#ifndef SWIG
class btPersistentManifold;

typedef bool (*ContactDestroyedCallback)(void* userPersistentData);
typedef bool (*ContactProcessedCallback)(btManifoldPoint& cp, void* body0, void* body1);
typedef void (*ContactStartedCallback)(btPersistentManifold* const& manifold);
typedef void (*ContactEndedCallback)(btPersistentManifold* const& manifold);
extern ContactDestroyedCallback gContactDestroyedCallback;
extern ContactProcessedCallback gContactProcessedCallback;
extern ContactStartedCallback gContactStartedCallback;
extern ContactEndedCallback gContactEndedCallback;
#endif  //SWIG

//the enum starts at 1024 to avoid type conflicts with btTypedConstraint
enum btContactManifoldTypes
{
	MIN_CONTACT_MANIFOLD_TYPE = 1024,
	BT_PERSISTENT_MANIFOLD_TYPE
};

#define MANIFOLD_CACHE_SIZE 4

///btPersistentManifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
///Those contact points are created by the collision narrow phase.
///The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
///updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
///reduces the cache to 4 points, when more then 4 points are added, using following rules:
///the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
///note that some pairs of objects might have more then one contact manifold.

//ATTRIBUTE_ALIGNED128( class) btPersistentManifold : public btTypedObject
ATTRIBUTE_ALIGNED16(class)
btPersistentManifold : public btTypedObject
{
	btManifoldPoint m_pointCache[MANIFOLD_CACHE_SIZE];

	/// this two body pointers can point to the physics rigidbody class.
	const btCollisionObject* m_body0;
	const btCollisionObject* m_body1;

	int m_cachedPoints;

	btScalar m_contactBreakingThreshold;
	btScalar m_contactProcessingThreshold;

	/// sort cached points so most isolated points come first
	int sortCachedPoints(const btManifoldPoint& pt);

	int findContactPoint(const btManifoldPoint* unUsed, int numUnused, const btManifoldPoint& pt);

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	int m_companionIdA;
	int m_companionIdB;

	int m_index1a;

	btPersistentManifold();

	btPersistentManifold(const btCollisionObject* body0, const btCollisionObject* body1, int, btScalar contactBreakingThreshold, btScalar contactProcessingThreshold)
		: btTypedObject(BT_PERSISTENT_MANIFOLD_TYPE),
		  m_body0(body0),
		  m_body1(body1),
		  m_cachedPoints(0),
		  m_contactBreakingThreshold(contactBreakingThreshold),
		  m_contactProcessingThreshold(contactProcessingThreshold),
		  m_companionIdA(0),
		  m_companionIdB(0),
		  m_index1a(0)
	{
	}

	SIMD_FORCE_INLINE const btCollisionObject* getBody0() const { return m_body0; }
	SIMD_FORCE_INLINE const btCollisionObject* getBody1() const { return m_body1; }

	void setBodies(const btCollisionObject* body0, const btCollisionObject* body1)
	{
		m_body0 = body0;
		m_body1 = body1;
	}

	void clearUserCache(btManifoldPoint & pt);

#ifdef DEBUG_PERSISTENCY
	void DebugPersistency();
#endif  //

	SIMD_FORCE_INLINE int getNumContacts() const
	{
		return m_cachedPoints;
	}
	/// the setNumContacts API is usually not used, except when you gather/fill all contacts manually
	void setNumContacts(int cachedPoints)
	{
		m_cachedPoints = cachedPoints;
	}

	SIMD_FORCE_INLINE const btManifoldPoint& getContactPoint(int index) const
	{
		btAssert(index < m_cachedPoints);
		return m_pointCache[index];
	}

	SIMD_FORCE_INLINE btManifoldPoint& getContactPoint(int index)
	{
		btAssert(index < m_cachedPoints);
		return m_pointCache[index];
	}

	///@todo: get this margin from the current physics / collision environment
	btScalar getContactBreakingThreshold() const;

	btScalar getContactProcessingThreshold() const
	{
		return m_contactProcessingThreshold;
	}

	void setContactBreakingThreshold(btScalar contactBreakingThreshold)
	{
		m_contactBreakingThreshold = contactBreakingThreshold;
	}

	void setContactProcessingThreshold(btScalar contactProcessingThreshold)
	{
		m_contactProcessingThreshold = contactProcessingThreshold;
	}

	int getCacheEntry(const btManifoldPoint& newPoint) const;

	int addManifoldPoint(const btManifoldPoint& newPoint, bool isPredictive = false);

	void removeContactPoint(int index)
	{
		clearUserCache(m_pointCache[index]);

		int lastUsedIndex = getNumContacts() - 1;
		//		m_pointCache[index] = m_pointCache[lastUsedIndex];
		if (index != lastUsedIndex)
		{
			m_pointCache[index] = m_pointCache[lastUsedIndex];
			//get rid of duplicated userPersistentData pointer
			m_pointCache[lastUsedIndex].m_userPersistentData = 0;
			m_pointCache[lastUsedIndex].m_appliedImpulse = 0.f;
			m_pointCache[lastUsedIndex].m_prevRHS = 0.f;
			m_pointCache[lastUsedIndex].m_contactPointFlags = 0;
			m_pointCache[lastUsedIndex].m_appliedImpulseLateral1 = 0.f;
			m_pointCache[lastUsedIndex].m_appliedImpulseLateral2 = 0.f;
			m_pointCache[lastUsedIndex].m_lifeTime = 0;
		}

		btAssert(m_pointCache[lastUsedIndex].m_userPersistentData == 0);
		m_cachedPoints--;

		if (gContactEndedCallback && m_cachedPoints == 0)
		{
			gContactEndedCallback(this);
		}
	}
	void replaceContactPoint(const btManifoldPoint& newPoint, int insertIndex)
	{
		btAssert(validContactDistance(newPoint));

#define MAINTAIN_PERSISTENCY 1
#ifdef MAINTAIN_PERSISTENCY
		int lifeTime = m_pointCache[insertIndex].getLifeTime();
		btScalar appliedImpulse = m_pointCache[insertIndex].m_appliedImpulse;
		btScalar prevRHS = m_pointCache[insertIndex].m_prevRHS;
		btScalar appliedLateralImpulse1 = m_pointCache[insertIndex].m_appliedImpulseLateral1;
		btScalar appliedLateralImpulse2 = m_pointCache[insertIndex].m_appliedImpulseLateral2;

		bool replacePoint = true;
		///we keep existing contact points for friction anchors
		///if the friction force is within the Coulomb friction cone
		if (newPoint.m_contactPointFlags & BT_CONTACT_FLAG_FRICTION_ANCHOR)
		{
			//   printf("appliedImpulse=%f\n", appliedImpulse);
			//   printf("appliedLateralImpulse1=%f\n", appliedLateralImpulse1);
			//   printf("appliedLateralImpulse2=%f\n", appliedLateralImpulse2);
			//   printf("mu = %f\n", m_pointCache[insertIndex].m_combinedFriction);
			btScalar mu = m_pointCache[insertIndex].m_combinedFriction;
			btScalar eps = 0;  //we could allow to enlarge or shrink the tolerance to check against the friction cone a bit, say 1e-7
			btScalar a = appliedLateralImpulse1 * appliedLateralImpulse1 + appliedLateralImpulse2 * appliedLateralImpulse2;
			btScalar b = eps + mu * appliedImpulse;
			b = b * b;
			replacePoint = (a) > (b);
		}

		if (replacePoint)
		{
			btAssert(lifeTime >= 0);
			void* cache = m_pointCache[insertIndex].m_userPersistentData;

			m_pointCache[insertIndex] = newPoint;
			m_pointCache[insertIndex].m_userPersistentData = cache;
			m_pointCache[insertIndex].m_appliedImpulse = appliedImpulse;
			m_pointCache[insertIndex].m_prevRHS = prevRHS;
			m_pointCache[insertIndex].m_appliedImpulseLateral1 = appliedLateralImpulse1;
			m_pointCache[insertIndex].m_appliedImpulseLateral2 = appliedLateralImpulse2;
		}

		m_pointCache[insertIndex].m_lifeTime = lifeTime;
#else
		clearUserCache(m_pointCache[insertIndex]);
		m_pointCache[insertIndex] = newPoint;

#endif
	}

	bool validContactDistance(const btManifoldPoint& pt) const
	{
		return pt.m_distance1 <= getContactBreakingThreshold();
	}
	/// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
	void refreshContactPoints(const btTransform& trA, const btTransform& trB);

	SIMD_FORCE_INLINE void clearManifold()
	{
		int i;
		for (i = 0; i < m_cachedPoints; i++)
		{
			clearUserCache(m_pointCache[i]);
		}

		if (gContactEndedCallback && m_cachedPoints)
		{
			gContactEndedCallback(this);
		}
		m_cachedPoints = 0;
	}

	int calculateSerializeBufferSize() const;
	const char* serialize(const class btPersistentManifold* manifold, void* dataBuffer, class btSerializer* serializer) const;
	void deSerialize(const struct btPersistentManifoldDoubleData* manifoldDataPtr);
	void deSerialize(const struct btPersistentManifoldFloatData* manifoldDataPtr);
};

// clang-format off

struct btPersistentManifoldDoubleData
{
	btVector3DoubleData m_pointCacheLocalPointA[4];
	btVector3DoubleData m_pointCacheLocalPointB[4];
	btVector3DoubleData m_pointCachePositionWorldOnA[4];
	btVector3DoubleData m_pointCachePositionWorldOnB[4];
	btVector3DoubleData m_pointCacheNormalWorldOnB[4];
	btVector3DoubleData	m_pointCacheLateralFrictionDir1[4];
	btVector3DoubleData	m_pointCacheLateralFrictionDir2[4];
	double m_pointCacheDistance[4];
	double m_pointCacheAppliedImpulse[4];
	double m_pointCachePrevRHS[4];
	 double m_pointCacheCombinedFriction[4];
	double m_pointCacheCombinedRollingFriction[4];
	double m_pointCacheCombinedSpinningFriction[4];
	double m_pointCacheCombinedRestitution[4];
	int	m_pointCachePartId0[4];
	int	m_pointCachePartId1[4];
	int	m_pointCacheIndex0[4];
	int	m_pointCacheIndex1[4];
	int m_pointCacheContactPointFlags[4];
	double m_pointCacheAppliedImpulseLateral1[4];
	double m_pointCacheAppliedImpulseLateral2[4];
	double m_pointCacheContactMotion1[4];
	double m_pointCacheContactMotion2[4];
	double m_pointCacheContactCFM[4];
	double m_pointCacheCombinedContactStiffness1[4];
	double m_pointCacheContactERP[4];
	double m_pointCacheCombinedContactDamping1[4];
	double m_pointCacheFrictionCFM[4];
	int m_pointCacheLifeTime[4];

	int m_numCachedPoints;
	int m_companionIdA;
	int m_companionIdB;
	int m_index1a;

	int m_objectType;
	double	m_contactBreakingThreshold;
	double	m_contactProcessingThreshold;
	int m_padding;

	btCollisionObjectDoubleData *m_body0;
	btCollisionObjectDoubleData *m_body1;
};


struct btPersistentManifoldFloatData
{
	btVector3FloatData m_pointCacheLocalPointA[4];
	btVector3FloatData m_pointCacheLocalPointB[4];
	btVector3FloatData m_pointCachePositionWorldOnA[4];
	btVector3FloatData m_pointCachePositionWorldOnB[4];
	btVector3FloatData m_pointCacheNormalWorldOnB[4];
	btVector3FloatData	m_pointCacheLateralFrictionDir1[4];
	btVector3FloatData	m_pointCacheLateralFrictionDir2[4];
	float m_pointCacheDistance[4];
	float m_pointCacheAppliedImpulse[4];
	float m_pointCachePrevRHS[4];
	float m_pointCacheCombinedFriction[4];
	float m_pointCacheCombinedRollingFriction[4];
	float m_pointCacheCombinedSpinningFriction[4];
	float m_pointCacheCombinedRestitution[4];
	int	m_pointCachePartId0[4];
	int	m_pointCachePartId1[4];
	int	m_pointCacheIndex0[4];
	int	m_pointCacheIndex1[4];
	int m_pointCacheContactPointFlags[4];
	float m_pointCacheAppliedImpulseLateral1[4];
	float m_pointCacheAppliedImpulseLateral2[4];
	float m_pointCacheContactMotion1[4];
	float m_pointCacheContactMotion2[4];
	float m_pointCacheContactCFM[4];
	float m_pointCacheCombinedContactStiffness1[4];
	float m_pointCacheContactERP[4];
	float m_pointCacheCombinedContactDamping1[4];
	float m_pointCacheFrictionCFM[4];
	int m_pointCacheLifeTime[4];

	int m_numCachedPoints;
	int m_companionIdA;
	int m_companionIdB;
	int m_index1a;

	int m_objectType;
	float	m_contactBreakingThreshold;
	float	m_contactProcessingThreshold;
	int m_padding;

	btCollisionObjectFloatData *m_body0;
	btCollisionObjectFloatData *m_body1;
};

// clang-format on

#ifdef BT_USE_DOUBLE_PRECISION
#define btPersistentManifoldData btPersistentManifoldDoubleData
#define btPersistentManifoldDataName "btPersistentManifoldDoubleData"
#else
#define btPersistentManifoldData btPersistentManifoldFloatData
#define btPersistentManifoldDataName "btPersistentManifoldFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

#endif  //BT_PERSISTENT_MANIFOLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"
#include "LinearMath/btTransform.h"
#include "LinearMath/btSerializer.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btCollisionObjectData btCollisionObjectDoubleData
#else
#define btCollisionObjectData btCollisionObjectFloatData
#endif

btScalar gContactBreakingThreshold = btScalar(0.02);
ContactDestroyedCallback gContactDestroyedCallback = 0;
ContactProcessedCallback gContactProcessedCallback = 0;
ContactStartedCallback gContactStartedCallback = 0;
ContactEndedCallback gContactEndedCallback = 0;
///gContactCalcArea3Points will approximate the convex hull area using 3 points
///when setting it to false, it will use 4 points to compute the area: it is more accurate but slower
bool gContactCalcArea3Points = true;

btPersistentManifold::btPersistentManifold()
	: btTypedObject(BT_PERSISTENT_MANIFOLD_TYPE),
	  m_body0(0),
	  m_body1(0),
	  m_cachedPoints(0),
	  m_companionIdA(0),
	  m_companionIdB(0),
	  m_index1a(0)
{
}

#ifdef DEBUG_PERSISTENCY
void btPersistentManifold::DebugPersistency()
{
	int i;
	printf("DebugPersistency : numPoints %d\n", m_cachedPoints);
	for (i = 0; i < m_cachedPoints; i++)
	{
		printf("m_pointCache[%d].m_userPersistentData = %x\n", i, m_pointCache[i].m_userPersistentData);
	}
}
#endif  //DEBUG_PERSISTENCY

void btPersistentManifold::clearUserCache(btManifoldPoint& pt)
{
	void* oldPtr = pt.m_userPersistentData;
	if (oldPtr)
	{
#ifdef DEBUG_PERSISTENCY
		int i;
		int occurance = 0;
		for (i = 0; i < m_cachedPoints; i++)
		{
			if (m_pointCache[i].m_userPersistentData == oldPtr)
			{
				occurance++;
				if (occurance > 1)
					printf("error in clearUserCache\n");
			}
		}
		btAssert(occurance <= 0);
#endif  //DEBUG_PERSISTENCY

		if (pt.m_userPersistentData && gContactDestroyedCallback)
		{
			(*gContactDestroyedCallback)(pt.m_userPersistentData);
			pt.m_userPersistentData = 0;
		}

#ifdef DEBUG_PERSISTENCY
		DebugPersistency();
#endif
	}
}

static inline btScalar calcArea4Points(const btVector3& p0, const btVector3& p1, const btVector3& p2, const btVector3& p3)
{
	// It calculates possible 3 area constructed from random 4 points and returns the biggest one.

	btVector3 a[3], b[3];
	a[0] = p0 - p1;
	a[1] = p0 - p2;
	a[2] = p0 - p3;
	b[0] = p2 - p3;
	b[1] = p1 - p3;
	b[2] = p1 - p2;

	//todo: Following 3 cross production can be easily optimized by SIMD.
	btVector3 tmp0 = a[0].cross(b[0]);
	btVector3 tmp1 = a[1].cross(b[1]);
	btVector3 tmp2 = a[2].cross(b[2]);

	return btMax(btMax(tmp0.length2(), tmp1.length2()), tmp2.length2());
}

int btPersistentManifold::sortCachedPoints(const btManifoldPoint& pt)
{
	//calculate 4 possible cases areas, and take biggest area
	//also need to keep 'deepest'

	int maxPenetrationIndex = -1;
#define KEEP_DEEPEST_POINT 1
#ifdef KEEP_DEEPEST_POINT
	btScalar maxPenetration = pt.getDistance();
	for (int i = 0; i < 4; i++)
	{
		if (m_pointCache[i].getDistance() < maxPenetration)
		{
			maxPenetrationIndex = i;
			maxPenetration = m_pointCache[i].getDistance();
		}
	}
#endif  //KEEP_DEEPEST_POINT

	btScalar res0(btScalar(0.)), res1(btScalar(0.)), res2(btScalar(0.)), res3(btScalar(0.));

	if (gContactCalcArea3Points)
	{
		if (maxPenetrationIndex != 0)
		{
			btVector3 a0 = pt.m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 b0 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
			btVector3 cross = a0.cross(b0);
			res0 = cross.length2();
		}
		if (maxPenetrationIndex != 1)
		{
			btVector3 a1 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b1 = m_pointCache[3].m_localPointA - m_pointCache[2].m_localPointA;
			btVector3 cross = a1.cross(b1);
			res1 = cross.length2();
		}

		if (maxPenetrationIndex != 2)
		{
			btVector3 a2 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b2 = m_pointCache[3].m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 cross = a2.cross(b2);
			res2 = cross.length2();
		}

		if (maxPenetrationIndex != 3)
		{
			btVector3 a3 = pt.m_localPointA - m_pointCache[0].m_localPointA;
			btVector3 b3 = m_pointCache[2].m_localPointA - m_pointCache[1].m_localPointA;
			btVector3 cross = a3.cross(b3);
			res3 = cross.length2();
		}
	}
	else
	{
		if (maxPenetrationIndex != 0)
		{
			res0 = calcArea4Points(pt.m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 1)
		{
			res1 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[2].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 2)
		{
			res2 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[3].m_localPointA);
		}

		if (maxPenetrationIndex != 3)
		{
			res3 = calcArea4Points(pt.m_localPointA, m_pointCache[0].m_localPointA, m_pointCache[1].m_localPointA, m_pointCache[2].m_localPointA);
		}
	}
	btVector4 maxvec(res0, res1, res2, res3);
	int biggestarea = maxvec.closestAxis4();
	return biggestarea;
}

int btPersistentManifold::getCacheEntry(const btManifoldPoint& newPoint) const
{
	btScalar shortestDist = getContactBreakingThreshold() * getContactBreakingThreshold();
	int size = getNumContacts();
	int nearestPoint = -1;
	for (int i = 0; i < size; i++)
	{
		const btManifoldPoint& mp = m_pointCache[i];

		btVector3 diffA = mp.m_localPointA - newPoint.m_localPointA;
		const btScalar distToManiPoint = diffA.dot(diffA);
		if (distToManiPoint < shortestDist)
		{
			shortestDist = distToManiPoint;
			nearestPoint = i;
		}
	}
	return nearestPoint;
}

int btPersistentManifold::addManifoldPoint(const btManifoldPoint& newPoint, bool isPredictive)
{
	if (!isPredictive)
	{
		btAssert(validContactDistance(newPoint));
	}

	int insertIndex = getNumContacts();
	if (insertIndex == MANIFOLD_CACHE_SIZE)
	{
#if MANIFOLD_CACHE_SIZE >= 4
		//sort cache so best points come first, based on area
		insertIndex = sortCachedPoints(newPoint);
#else
		insertIndex = 0;
#endif
		clearUserCache(m_pointCache[insertIndex]);
	}
	else
	{
		m_cachedPoints++;
	}
	if (insertIndex < 0)
		insertIndex = 0;

	btAssert(m_pointCache[insertIndex].m_userPersistentData == 0);
	m_pointCache[insertIndex] = newPoint;
	return insertIndex;
}

btScalar btPersistentManifold::getContactBreakingThreshold() const
{
	return m_contactBreakingThreshold;
}

void btPersistentManifold::refreshContactPoints(const btTransform& trA, const btTransform& trB)
{
	int i;
#ifdef DEBUG_PERSISTENCY
	printf("refreshContactPoints posA = (%f,%f,%f) posB = (%f,%f,%f)\n",
		   trA.getOrigin().getX(),
		   trA.getOrigin().getY(),
		   trA.getOrigin().getZ(),
		   trB.getOrigin().getX(),
		   trB.getOrigin().getY(),
		   trB.getOrigin().getZ());
#endif  //DEBUG_PERSISTENCY
	/// first refresh worldspace positions and distance
	for (i = getNumContacts() - 1; i >= 0; i--)
	{
		btManifoldPoint& manifoldPoint = m_pointCache[i];
		manifoldPoint.m_positionWorldOnA = trA(manifoldPoint.m_localPointA);
		manifoldPoint.m_positionWorldOnB = trB(manifoldPoint.m_localPointB);
		manifoldPoint.m_distance1 = (manifoldPoint.m_positionWorldOnA - manifoldPoint.m_positionWorldOnB).dot(manifoldPoint.m_normalWorldOnB);
		manifoldPoint.m_lifeTime++;
	}

	/// then
	btScalar distance2d;
	btVector3 projectedDifference, projectedPoint;
	for (i = getNumContacts() - 1; i >= 0; i--)
	{
		btManifoldPoint& manifoldPoint = m_pointCache[i];
		//contact becomes invalid when signed distance exceeds margin (projected on contactnormal direction)
		if (!validContactDistance(manifoldPoint))
		{
			removeContactPoint(i);
		}
		else
		{
			//todo: friction anchor may require the contact to be around a bit longer
			//contact also becomes invalid when relative movement orthogonal to normal exceeds margin
			projectedPoint = manifoldPoint.m_positionWorldOnA - manifoldPoint.m_normalWorldOnB * manifoldPoint.m_distance1;
			projectedDifference = manifoldPoint.m_positionWorldOnB - projectedPoint;
			distance2d = projectedDifference.dot(projectedDifference);
			if (distance2d > getContactBreakingThreshold() * getContactBreakingThreshold())
			{
				removeContactPoint(i);
			}
			else
			{
				//contact point processed callback
				if (gContactProcessedCallback)
					(*gContactProcessedCallback)(manifoldPoint, (void*)m_body0, (void*)m_body1);
			}
		}
	}
#ifdef DEBUG_PERSISTENCY
	DebugPersistency();
#endif  //
}

int btPersistentManifold::calculateSerializeBufferSize() const
{
	return sizeof(btPersistentManifoldData);
}

const char* btPersistentManifold::serialize(const class btPersistentManifold* manifold, void* dataBuffer, class btSerializer* serializer) const
{
	btPersistentManifoldData* dataOut = (btPersistentManifoldData*)dataBuffer;
	memset(dataOut, 0, sizeof(btPersistentManifoldData));

	dataOut->m_body0 = (btCollisionObjectData*)serializer->getUniquePointer((void*)manifold->getBody0());
	dataOut->m_body1 = (btCollisionObjectData*)serializer->getUniquePointer((void*)manifold->getBody1());
	dataOut->m_contactBreakingThreshold = manifold->getContactBreakingThreshold();
	dataOut->m_contactProcessingThreshold = manifold->getContactProcessingThreshold();
	dataOut->m_numCachedPoints = manifold->getNumContacts();
	dataOut->m_companionIdA = manifold->m_companionIdA;
	dataOut->m_companionIdB = manifold->m_companionIdB;
	dataOut->m_index1a = manifold->m_index1a;
	dataOut->m_objectType = manifold->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		const btManifoldPoint& pt = manifold->getContactPoint(i);
		dataOut->m_pointCacheAppliedImpulse[i] = pt.m_appliedImpulse;
		dataOut->m_pointCachePrevRHS[i] = pt.m_prevRHS;
		dataOut->m_pointCacheAppliedImpulseLateral1[i] = pt.m_appliedImpulseLateral1;
		dataOut->m_pointCacheAppliedImpulseLateral2[i] = pt.m_appliedImpulseLateral2;
		pt.m_localPointA.serialize(dataOut->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.serialize(dataOut->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.serialize(dataOut->m_pointCacheNormalWorldOnB[i]);
		dataOut->m_pointCacheDistance[i] = pt.m_distance1;
		dataOut->m_pointCacheCombinedContactDamping1[i] = pt.m_combinedContactDamping1;
		dataOut->m_pointCacheCombinedContactStiffness1[i] = pt.m_combinedContactStiffness1;
		dataOut->m_pointCacheLifeTime[i] = pt.m_lifeTime;
		dataOut->m_pointCacheFrictionCFM[i] = pt.m_frictionCFM;
		dataOut->m_pointCacheContactERP[i] = pt.m_contactERP;
		dataOut->m_pointCacheContactCFM[i] = pt.m_contactCFM;
		dataOut->m_pointCacheContactPointFlags[i] = pt.m_contactPointFlags;
		dataOut->m_pointCacheIndex0[i] = pt.m_index0;
		dataOut->m_pointCacheIndex1[i] = pt.m_index1;
		dataOut->m_pointCachePartId0[i] = pt.m_partId0;
		dataOut->m_pointCachePartId1[i] = pt.m_partId1;
		pt.m_positionWorldOnA.serialize(dataOut->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.serialize(dataOut->m_pointCachePositionWorldOnB[i]);
		dataOut->m_pointCacheCombinedFriction[i] = pt.m_combinedFriction;
		pt.m_lateralFrictionDir1.serialize(dataOut->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.serialize(dataOut->m_pointCacheLateralFrictionDir2[i]);
		dataOut->m_pointCacheCombinedRollingFriction[i] = pt.m_combinedRollingFriction;
		dataOut->m_pointCacheCombinedSpinningFriction[i] = pt.m_combinedSpinningFriction;
		dataOut->m_pointCacheCombinedRestitution[i] = pt.m_combinedRestitution;
		dataOut->m_pointCacheContactMotion1[i] = pt.m_contactMotion1;
		dataOut->m_pointCacheContactMotion2[i] = pt.m_contactMotion2;
	}
	return btPersistentManifoldDataName;
}

void btPersistentManifold::deSerialize(const struct btPersistentManifoldDoubleData* manifoldDataPtr)
{
	m_contactBreakingThreshold = manifoldDataPtr->m_contactBreakingThreshold;
	m_contactProcessingThreshold = manifoldDataPtr->m_contactProcessingThreshold;
	m_cachedPoints = manifoldDataPtr->m_numCachedPoints;
	m_companionIdA = manifoldDataPtr->m_companionIdA;
	m_companionIdB = manifoldDataPtr->m_companionIdB;
	//m_index1a = manifoldDataPtr->m_index1a;
	m_objectType = manifoldDataPtr->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		btManifoldPoint& pt = m_pointCache[i];

		pt.m_appliedImpulse = manifoldDataPtr->m_pointCacheAppliedImpulse[i];
		pt.m_prevRHS = manifoldDataPtr->m_pointCachePrevRHS[i];
		pt.m_appliedImpulseLateral1 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral1[i];
		pt.m_appliedImpulseLateral2 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral2[i];
		pt.m_localPointA.deSerializeDouble(manifoldDataPtr->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.deSerializeDouble(manifoldDataPtr->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.deSerializeDouble(manifoldDataPtr->m_pointCacheNormalWorldOnB[i]);
		pt.m_distance1 = manifoldDataPtr->m_pointCacheDistance[i];
		pt.m_combinedContactDamping1 = manifoldDataPtr->m_pointCacheCombinedContactDamping1[i];
		pt.m_combinedContactStiffness1 = manifoldDataPtr->m_pointCacheCombinedContactStiffness1[i];
		pt.m_lifeTime = manifoldDataPtr->m_pointCacheLifeTime[i];
		pt.m_frictionCFM = manifoldDataPtr->m_pointCacheFrictionCFM[i];
		pt.m_contactERP = manifoldDataPtr->m_pointCacheContactERP[i];
		pt.m_contactCFM = manifoldDataPtr->m_pointCacheContactCFM[i];
		pt.m_contactPointFlags = manifoldDataPtr->m_pointCacheContactPointFlags[i];
		pt.m_index0 = manifoldDataPtr->m_pointCacheIndex0[i];
		pt.m_index1 = manifoldDataPtr->m_pointCacheIndex1[i];
		pt.m_partId0 = manifoldDataPtr->m_pointCachePartId0[i];
		pt.m_partId1 = manifoldDataPtr->m_pointCachePartId1[i];
		pt.m_positionWorldOnA.deSerializeDouble(manifoldDataPtr->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.deSerializeDouble(manifoldDataPtr->m_pointCachePositionWorldOnB[i]);
		pt.m_combinedFriction = manifoldDataPtr->m_pointCacheCombinedFriction[i];
		pt.m_lateralFrictionDir1.deSerializeDouble(manifoldDataPtr->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.deSerializeDouble(manifoldDataPtr->m_pointCacheLateralFrictionDir2[i]);
		pt.m_combinedRollingFriction = manifoldDataPtr->m_pointCacheCombinedRollingFriction[i];
		pt.m_combinedSpinningFriction = manifoldDataPtr->m_pointCacheCombinedSpinningFriction[i];
		pt.m_combinedRestitution = manifoldDataPtr->m_pointCacheCombinedRestitution[i];
		pt.m_contactMotion1 = manifoldDataPtr->m_pointCacheContactMotion1[i];
		pt.m_contactMotion2 = manifoldDataPtr->m_pointCacheContactMotion2[i];
	}
}

void btPersistentManifold::deSerialize(const struct btPersistentManifoldFloatData* manifoldDataPtr)
{
	m_contactBreakingThreshold = manifoldDataPtr->m_contactBreakingThreshold;
	m_contactProcessingThreshold = manifoldDataPtr->m_contactProcessingThreshold;
	m_cachedPoints = manifoldDataPtr->m_numCachedPoints;
	m_companionIdA = manifoldDataPtr->m_companionIdA;
	m_companionIdB = manifoldDataPtr->m_companionIdB;
	//m_index1a = manifoldDataPtr->m_index1a;
	m_objectType = manifoldDataPtr->m_objectType;

	for (int i = 0; i < this->getNumContacts(); i++)
	{
		btManifoldPoint& pt = m_pointCache[i];

		pt.m_appliedImpulse = manifoldDataPtr->m_pointCacheAppliedImpulse[i];
		pt.m_prevRHS = manifoldDataPtr->m_pointCachePrevRHS[i];
		pt.m_appliedImpulseLateral1 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral1[i];
		pt.m_appliedImpulseLateral2 = manifoldDataPtr->m_pointCacheAppliedImpulseLateral2[i];
		pt.m_localPointA.deSerialize(manifoldDataPtr->m_pointCacheLocalPointA[i]);
		pt.m_localPointB.deSerialize(manifoldDataPtr->m_pointCacheLocalPointB[i]);
		pt.m_normalWorldOnB.deSerialize(manifoldDataPtr->m_pointCacheNormalWorldOnB[i]);
		pt.m_distance1 = manifoldDataPtr->m_pointCacheDistance[i];
		pt.m_combinedContactDamping1 = manifoldDataPtr->m_pointCacheCombinedContactDamping1[i];
		pt.m_combinedContactStiffness1 = manifoldDataPtr->m_pointCacheCombinedContactStiffness1[i];
		pt.m_lifeTime = manifoldDataPtr->m_pointCacheLifeTime[i];
		pt.m_frictionCFM = manifoldDataPtr->m_pointCacheFrictionCFM[i];
		pt.m_contactERP = manifoldDataPtr->m_pointCacheContactERP[i];
		pt.m_contactCFM = manifoldDataPtr->m_pointCacheContactCFM[i];
		pt.m_contactPointFlags = manifoldDataPtr->m_pointCacheContactPointFlags[i];
		pt.m_index0 = manifoldDataPtr->m_pointCacheIndex0[i];
		pt.m_index1 = manifoldDataPtr->m_pointCacheIndex1[i];
		pt.m_partId0 = manifoldDataPtr->m_pointCachePartId0[i];
		pt.m_partId1 = manifoldDataPtr->m_pointCachePartId1[i];
		pt.m_positionWorldOnA.deSerialize(manifoldDataPtr->m_pointCachePositionWorldOnA[i]);
		pt.m_positionWorldOnB.deSerialize(manifoldDataPtr->m_pointCachePositionWorldOnB[i]);
		pt.m_combinedFriction = manifoldDataPtr->m_pointCacheCombinedFriction[i];
		pt.m_lateralFrictionDir1.deSerialize(manifoldDataPtr->m_pointCacheLateralFrictionDir1[i]);
		pt.m_lateralFrictionDir2.deSerialize(manifoldDataPtr->m_pointCacheLateralFrictionDir2[i]);
		pt.m_combinedRollingFriction = manifoldDataPtr->m_pointCacheCombinedRollingFriction[i];
		pt.m_combinedSpinningFriction = manifoldDataPtr->m_pointCacheCombinedSpinningFriction[i];
		pt.m_combinedRestitution = manifoldDataPtr->m_pointCacheCombinedRestitution[i];
		pt.m_contactMotion1 = manifoldDataPtr->m_pointCacheContactMotion1[i];
		pt.m_contactMotion2 = manifoldDataPtr->m_pointCacheContactMotion2[i];
	}
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_RIGIDBODY_H
#define BT_RIGIDBODY_H

#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btTransform.h"
#include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
#include "BulletCollision/CollisionDispatch/btCollisionObject.h"

class btCollisionShape;
class btMotionState;
class btTypedConstraint;

extern btScalar gDeactivationTime;
extern bool gDisableDeactivation;

#ifdef BT_USE_DOUBLE_PRECISION
#define btRigidBodyData btRigidBodyDoubleData
#define btRigidBodyDataName "btRigidBodyDoubleData"
#else
#define btRigidBodyData btRigidBodyFloatData
#define btRigidBodyDataName "btRigidBodyFloatData"
#endif  //BT_USE_DOUBLE_PRECISION

enum btRigidBodyFlags
{
	BT_DISABLE_WORLD_GRAVITY = 1,
	///BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
	///and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
	///See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit
	BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT = 2,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD = 4,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY = 8,
	BT_ENABLE_GYROPSCOPIC_FORCE = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY,
};

///The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
///It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
///There are 3 types of rigid bodies:
///- A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
///- B) Fixed objects with zero mass. They are not moving (basically collision objects)
///- C) Kinematic objects, which are objects without mass, but the user can move them. There is one-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
///Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
///Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
class btRigidBody : public btCollisionObject
{
	btMatrix3x3 m_invInertiaTensorWorld;
	btVector3 m_linearVelocity;
	btVector3 m_angularVelocity;
	btScalar m_inverseMass;
	btVector3 m_linearFactor;

	btVector3 m_gravity;
	btVector3 m_gravity_acceleration;
	btVector3 m_invInertiaLocal;
	btVector3 m_totalForce;
	btVector3 m_totalTorque;

	btScalar m_linearDamping;
	btScalar m_angularDamping;

	bool m_additionalDamping;
	btScalar m_additionalDampingFactor;
	btScalar m_additionalLinearDampingThresholdSqr;
	btScalar m_additionalAngularDampingThresholdSqr;
	btScalar m_additionalAngularDampingFactor;

	btScalar m_linearSleepingThreshold;
	btScalar m_angularSleepingThreshold;

	//m_optionalMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* m_optionalMotionState;

	//keep track of typed constraints referencing this rigid body, to disable collision between linked bodies
	btAlignedObjectArray<btTypedConstraint*> m_constraintRefs;

	int m_rigidbodyFlags;

	int m_debugBodyId;

protected:
	ATTRIBUTE_ALIGNED16(btVector3 m_deltaLinearVelocity);
	btVector3 m_deltaAngularVelocity;
	btVector3 m_angularFactor;
	btVector3 m_invMass;
	btVector3 m_pushVelocity;
	btVector3 m_turnVelocity;

public:
	///The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
	///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
	///You can use the motion state to synchronize the world transform between physics and graphics objects.
	///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
	///m_startWorldTransform is only used when you don't provide a motion state.
	struct btRigidBodyConstructionInfo
	{
		btScalar m_mass;

		///When a motionState is provided, the rigid body will initialize its world transform from the motion state
		///In this case, m_startWorldTransform is ignored.
		btMotionState* m_motionState;
		btTransform m_startWorldTransform;

		btCollisionShape* m_collisionShape;
		btVector3 m_localInertia;
		btScalar m_linearDamping;
		btScalar m_angularDamping;

		///best simulation results when friction is non-zero
		btScalar m_friction;
		///the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
		///See Bullet/Demos/RollingFrictionDemo for usage
		btScalar m_rollingFriction;
		btScalar m_spinningFriction;  //torsional friction around contact normal

		///best simulation results using zero restitution.
		btScalar m_restitution;

		btScalar m_linearSleepingThreshold;
		btScalar m_angularSleepingThreshold;

		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		bool m_additionalDamping;
		btScalar m_additionalDampingFactor;
		btScalar m_additionalLinearDampingThresholdSqr;
		btScalar m_additionalAngularDampingThresholdSqr;
		btScalar m_additionalAngularDampingFactor;

		btRigidBodyConstructionInfo(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0)) : m_mass(mass),
																																									   m_motionState(motionState),
																																									   m_collisionShape(collisionShape),
																																									   m_localInertia(localInertia),
																																									   m_linearDamping(btScalar(0.)),
																																									   m_angularDamping(btScalar(0.)),
																																									   m_friction(btScalar(0.5)),
																																									   m_rollingFriction(btScalar(0)),
																																									   m_spinningFriction(btScalar(0)),
																																									   m_restitution(btScalar(0.)),
																																									   m_linearSleepingThreshold(btScalar(0.8)),
																																									   m_angularSleepingThreshold(btScalar(1.f)),
																																									   m_additionalDamping(false),
																																									   m_additionalDampingFactor(btScalar(0.005)),
																																									   m_additionalLinearDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingThresholdSqr(btScalar(0.01)),
																																									   m_additionalAngularDampingFactor(btScalar(0.01))
		{
			m_startWorldTransform.setIdentity();
		}
	};

	///btRigidBody constructor using construction info
	btRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

	///btRigidBody constructor for backwards compatibility.
	///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
	btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia = btVector3(0, 0, 0));

	virtual ~btRigidBody()
	{
		//No constraints should point to this rigidbody
		//Remove constraints from the dynamics world before you delete the related rigidbodies.
		btAssert(m_constraintRefs.size() == 0);
	}

protected:
	///setupRigidBody is only used internally by the constructor
	void setupRigidBody(const btRigidBodyConstructionInfo& constructionInfo);

public:
	void proceedToTransform(const btTransform& newTrans);

	///to keep collision detection and dynamics separate we don't store a rigidbody pointer
	///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
	static const btRigidBody* upcast(const btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (const btRigidBody*)colObj;
		return 0;
	}
	static btRigidBody* upcast(btCollisionObject* colObj)
	{
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
			return (btRigidBody*)colObj;
		return 0;
	}

	/// continuous collision detection needs prediction
	void predictIntegratedTransform(btScalar step, btTransform& predictedTransform);

	void saveKinematicState(btScalar step);

	void applyGravity();
    
    void clearGravity();

	void setGravity(const btVector3& acceleration);

	const btVector3& getGravity() const
	{
		return m_gravity_acceleration;
	}

	void setDamping(btScalar lin_damping, btScalar ang_damping);

	btScalar getLinearDamping() const
	{
		return m_linearDamping;
	}

	btScalar getAngularDamping() const
	{
		return m_angularDamping;
	}

	btScalar getLinearSleepingThreshold() const
	{
		return m_linearSleepingThreshold;
	}

	btScalar getAngularSleepingThreshold() const
	{
		return m_angularSleepingThreshold;
	}

	void applyDamping(btScalar timeStep);

	SIMD_FORCE_INLINE const btCollisionShape* getCollisionShape() const
	{
		return m_collisionShape;
	}

	SIMD_FORCE_INLINE btCollisionShape* getCollisionShape()
	{
		return m_collisionShape;
	}

	void setMassProps(btScalar mass, const btVector3& inertia);

	const btVector3& getLinearFactor() const
	{
		return m_linearFactor;
	}
	void setLinearFactor(const btVector3& linearFactor)
	{
		m_linearFactor = linearFactor;
		m_invMass = m_linearFactor * m_inverseMass;
	}
	btScalar getInvMass() const { return m_inverseMass; }
	btScalar getMass() const { return m_inverseMass == btScalar(0.) ? btScalar(0.) : btScalar(1.0) / m_inverseMass; }
	const btMatrix3x3& getInvInertiaTensorWorld() const
	{
		return m_invInertiaTensorWorld;
	}

	void integrateVelocities(btScalar step);

	void setCenterOfMassTransform(const btTransform& xform);

	void applyCentralForce(const btVector3& force)
	{
		m_totalForce += force * m_linearFactor;
	}

	const btVector3& getTotalForce() const
	{
		return m_totalForce;
	};

	const btVector3& getTotalTorque() const
	{
		return m_totalTorque;
	};

	const btVector3& getInvInertiaDiagLocal() const
	{
		return m_invInertiaLocal;
	};

	void setInvInertiaDiagLocal(const btVector3& diagInvInertia)
	{
		m_invInertiaLocal = diagInvInertia;
	}

	void setSleepingThresholds(btScalar linear, btScalar angular)
	{
		m_linearSleepingThreshold = linear;
		m_angularSleepingThreshold = angular;
	}

	void applyTorque(const btVector3& torque)
	{
		m_totalTorque += torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_totalTorque);
		#endif
	}

	void applyForce(const btVector3& force, const btVector3& rel_pos)
	{
		applyCentralForce(force);
		applyTorque(rel_pos.cross(force * m_linearFactor));
	}

	void applyCentralImpulse(const btVector3& impulse)
	{
		m_linearVelocity += impulse * m_linearFactor * m_inverseMass;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	void applyTorqueImpulse(const btVector3& torque)
	{
		m_angularVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	void applyImpulse(const btVector3& impulse, const btVector3& rel_pos)
	{
		if (m_inverseMass != btScalar(0.))
		{
			applyCentralImpulse(impulse);
			if (m_angularFactor)
			{
				applyTorqueImpulse(rel_pos.cross(impulse * m_linearFactor));
			}
		}
	}
    
    void applyPushImpulse(const btVector3& impulse, const btVector3& rel_pos)
    {
        if (m_inverseMass != btScalar(0.))
        {
            applyCentralPushImpulse(impulse);
            if (m_angularFactor)
            {
                applyTorqueTurnImpulse(rel_pos.cross(impulse * m_linearFactor));
            }
        }
    }
    
    btVector3 getPushVelocity() const
    {
        return m_pushVelocity;
    }
    
    btVector3 getTurnVelocity() const
    {
        return m_turnVelocity;
    }
    
    void setPushVelocity(const btVector3& v)
    {
        m_pushVelocity = v;
    }

    #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
    void clampVelocity(btVector3& v) const {
        v.setX(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getX()))
        );
        v.setY(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getY()))
        );
        v.setZ(
            fmax(-BT_CLAMP_VELOCITY_TO,
                 fmin(BT_CLAMP_VELOCITY_TO, v.getZ()))
        );
    }
    #endif

    void setTurnVelocity(const btVector3& v)
    {
        m_turnVelocity = v;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }
    
    void applyCentralPushImpulse(const btVector3& impulse)
    {
        m_pushVelocity += impulse * m_linearFactor * m_inverseMass;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_pushVelocity);
        #endif
    }
    
    void applyTorqueTurnImpulse(const btVector3& torque)
    {
        m_turnVelocity += m_invInertiaTensorWorld * torque * m_angularFactor;
        #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
        clampVelocity(m_turnVelocity);
        #endif
    }

	void clearForces()
	{
		m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
		m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	}

	void updateInertiaTensor();

	const btVector3& getCenterOfMassPosition() const
	{
		return m_worldTransform.getOrigin();
	}
	btQuaternion getOrientation() const;

	const btTransform& getCenterOfMassTransform() const
	{
		return m_worldTransform;
	}
	const btVector3& getLinearVelocity() const
	{
		return m_linearVelocity;
	}
	const btVector3& getAngularVelocity() const
	{
		return m_angularVelocity;
	}

	inline void setLinearVelocity(const btVector3& lin_vel)
	{
		m_updateRevision++;
		m_linearVelocity = lin_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_linearVelocity);
		#endif
	}

	inline void setAngularVelocity(const btVector3& ang_vel)
	{
		m_updateRevision++;
		m_angularVelocity = ang_vel;
		#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
		clampVelocity(m_angularVelocity);
		#endif
	}

	btVector3 getVelocityInLocalPoint(const btVector3& rel_pos) const
	{
		//we also calculate lin/ang velocity for kinematic objects
		return m_linearVelocity + m_angularVelocity.cross(rel_pos);

		//for kinematic objects, we could also use use:
		//		return 	(m_worldTransform(rel_pos) - m_interpolationWorldTransform(rel_pos)) / m_kinematicTimeStep;
	}
    
    btVector3 getPushVelocityInLocalPoint(const btVector3& rel_pos) const
    {
        //we also calculate lin/ang velocity for kinematic objects
        return m_pushVelocity + m_turnVelocity.cross(rel_pos);
    }

	void translate(const btVector3& v)
	{
		m_worldTransform.getOrigin() += v;
	}

	void getAabb(btVector3& aabbMin, btVector3& aabbMax) const;

	SIMD_FORCE_INLINE btScalar computeImpulseDenominator(const btVector3& pos, const btVector3& normal) const
	{
		btVector3 r0 = pos - getCenterOfMassPosition();

		btVector3 c0 = (r0).cross(normal);

		btVector3 vec = (c0 * getInvInertiaTensorWorld()).cross(r0);

		return m_inverseMass + normal.dot(vec);
	}

	SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis) const
	{
		btVector3 vec = axis * getInvInertiaTensorWorld();
		return axis.dot(vec);
	}

	SIMD_FORCE_INLINE void updateDeactivation(btScalar timeStep)
	{
		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == DISABLE_DEACTIVATION))
			return;

		if ((getLinearVelocity().length2() < m_linearSleepingThreshold * m_linearSleepingThreshold) &&
			(getAngularVelocity().length2() < m_angularSleepingThreshold * m_angularSleepingThreshold))
		{
			m_deactivationTime += timeStep;
		}
		else
		{
			m_deactivationTime = btScalar(0.);
			setActivationState(0);
		}
	}

	SIMD_FORCE_INLINE bool wantsSleeping()
	{
		if (getActivationState() == DISABLE_DEACTIVATION)
			return false;

		//disable deactivation
		if (gDisableDeactivation || (gDeactivationTime == btScalar(0.)))
			return false;

		if ((getActivationState() == ISLAND_SLEEPING) || (getActivationState() == WANTS_DEACTIVATION))
			return true;

		if (m_deactivationTime > gDeactivationTime)
		{
			return true;
		}
		return false;
	}

	const btBroadphaseProxy* getBroadphaseProxy() const
	{
		return m_broadphaseHandle;
	}
	btBroadphaseProxy* getBroadphaseProxy()
	{
		return m_broadphaseHandle;
	}
	void setNewBroadphaseProxy(btBroadphaseProxy* broadphaseProxy)
	{
		m_broadphaseHandle = broadphaseProxy;
	}

	//btMotionState allows to automatic synchronize the world transform for active objects
	btMotionState* getMotionState()
	{
		return m_optionalMotionState;
	}
	const btMotionState* getMotionState() const
	{
		return m_optionalMotionState;
	}
	void setMotionState(btMotionState* motionState)
	{
		m_optionalMotionState = motionState;
		if (m_optionalMotionState)
			motionState->getWorldTransform(m_worldTransform);
	}

	//for experimental overriding of friction/contact solver func
	int m_contactSolverType;
	int m_frictionSolverType;

	void setAngularFactor(const btVector3& angFac)
	{
		m_updateRevision++;
		m_angularFactor = angFac;
	}

	void setAngularFactor(btScalar angFac)
	{
		m_updateRevision++;
		m_angularFactor.setValue(angFac, angFac, angFac);
	}
	const btVector3& getAngularFactor() const
	{
		return m_angularFactor;
	}

	//is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
	bool isInWorld() const
	{
		return (getBroadphaseProxy() != 0);
	}

	void addConstraintRef(btTypedConstraint* c);
	void removeConstraintRef(btTypedConstraint* c);

	btTypedConstraint* getConstraintRef(int index)
	{
		return m_constraintRefs[index];
	}

	int getNumConstraintRefs() const
	{
		return m_constraintRefs.size();
	}

	void setFlags(int flags)
	{
		m_rigidbodyFlags = flags;
	}

	int getFlags() const
	{
		return m_rigidbodyFlags;
	}

	///perform implicit force computation in world space
	btVector3 computeGyroscopicImpulseImplicit_World(btScalar dt) const;

	///perform implicit force computation in body space (inertial frame)
	btVector3 computeGyroscopicImpulseImplicit_Body(btScalar step) const;

	///explicit version is best avoided, it gains energy
	btVector3 computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const;
	btVector3 getLocalInertia() const;

	///////////////////////////////////////////////

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, class btSerializer* serializer) const;

	virtual void serializeSingleObject(class btSerializer* serializer) const;
};

//@todo add m_optionalMotionState and m_constraintRefs to btRigidBodyData
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyFloatData
{
	btCollisionObjectFloatData m_collisionObjectData;
	btMatrix3x3FloatData m_invInertiaTensorWorld;
	btVector3FloatData m_linearVelocity;
	btVector3FloatData m_angularVelocity;
	btVector3FloatData m_angularFactor;
	btVector3FloatData m_linearFactor;
	btVector3FloatData m_gravity;
	btVector3FloatData m_gravity_acceleration;
	btVector3FloatData m_invInertiaLocal;
	btVector3FloatData m_totalForce;
	btVector3FloatData m_totalTorque;
	float m_inverseMass;
	float m_linearDamping;
	float m_angularDamping;
	float m_additionalDampingFactor;
	float m_additionalLinearDampingThresholdSqr;
	float m_additionalAngularDampingThresholdSqr;
	float m_additionalAngularDampingFactor;
	float m_linearSleepingThreshold;
	float m_angularSleepingThreshold;
	int m_additionalDamping;
};

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
struct btRigidBodyDoubleData
{
	btCollisionObjectDoubleData m_collisionObjectData;
	btMatrix3x3DoubleData m_invInertiaTensorWorld;
	btVector3DoubleData m_linearVelocity;
	btVector3DoubleData m_angularVelocity;
	btVector3DoubleData m_angularFactor;
	btVector3DoubleData m_linearFactor;
	btVector3DoubleData m_gravity;
	btVector3DoubleData m_gravity_acceleration;
	btVector3DoubleData m_invInertiaLocal;
	btVector3DoubleData m_totalForce;
	btVector3DoubleData m_totalTorque;
	double m_inverseMass;
	double m_linearDamping;
	double m_angularDamping;
	double m_additionalDampingFactor;
	double m_additionalLinearDampingThresholdSqr;
	double m_additionalAngularDampingThresholdSqr;
	double m_additionalAngularDampingFactor;
	double m_linearSleepingThreshold;
	double m_angularSleepingThreshold;
	int m_additionalDamping;
	char m_padding[4];
};

#endif  //BT_RIGIDBODY_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletCollision/CollisionShapes/btConvexShape.h"
#include "LinearMath/btMinMax.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMotionState.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "LinearMath/btSerializer.h"

//'temporarily' global variables
btScalar gDeactivationTime = btScalar(2.);
bool gDisableDeactivation = false;
static int uniqueId = 0;

btRigidBody::btRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	setupRigidBody(constructionInfo);
}

btRigidBody::btRigidBody(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia)
{
	btRigidBodyConstructionInfo cinfo(mass, motionState, collisionShape, localInertia);
	setupRigidBody(cinfo);
}

void btRigidBody::setupRigidBody(const btRigidBody::btRigidBodyConstructionInfo& constructionInfo)
{
	m_internalType = CO_RIGID_BODY;

	m_linearVelocity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
	m_angularFactor.setValue(1, 1, 1);
	m_linearFactor.setValue(1, 1, 1);
	m_gravity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_gravity_acceleration.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
	m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0)),
		setDamping(constructionInfo.m_linearDamping, constructionInfo.m_angularDamping);

	m_linearSleepingThreshold = constructionInfo.m_linearSleepingThreshold;
	m_angularSleepingThreshold = constructionInfo.m_angularSleepingThreshold;
	m_optionalMotionState = constructionInfo.m_motionState;
	m_contactSolverType = 0;
	m_frictionSolverType = 0;
	m_additionalDamping = constructionInfo.m_additionalDamping;
	m_additionalDampingFactor = constructionInfo.m_additionalDampingFactor;
	m_additionalLinearDampingThresholdSqr = constructionInfo.m_additionalLinearDampingThresholdSqr;
	m_additionalAngularDampingThresholdSqr = constructionInfo.m_additionalAngularDampingThresholdSqr;
	m_additionalAngularDampingFactor = constructionInfo.m_additionalAngularDampingFactor;

	if (m_optionalMotionState)
	{
		m_optionalMotionState->getWorldTransform(m_worldTransform);
	}
	else
	{
		m_worldTransform = constructionInfo.m_startWorldTransform;
	}

	m_interpolationWorldTransform = m_worldTransform;
	m_interpolationLinearVelocity.setValue(0, 0, 0);
	m_interpolationAngularVelocity.setValue(0, 0, 0);

	//moved to btCollisionObject
	m_friction = constructionInfo.m_friction;
	m_rollingFriction = constructionInfo.m_rollingFriction;
	m_spinningFriction = constructionInfo.m_spinningFriction;

	m_restitution = constructionInfo.m_restitution;

	setCollisionShape(constructionInfo.m_collisionShape);
	m_debugBodyId = uniqueId++;

	setMassProps(constructionInfo.m_mass, constructionInfo.m_localInertia);
	updateInertiaTensor();

	m_rigidbodyFlags = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;

	m_deltaLinearVelocity.setZero();
	m_deltaAngularVelocity.setZero();
	m_invMass = m_inverseMass * m_linearFactor;
	m_pushVelocity.setZero();
	m_turnVelocity.setZero();
}

void btRigidBody::predictIntegratedTransform(btScalar timeStep, btTransform& predictedTransform)
{
	btTransformUtil::integrateTransform(m_worldTransform, m_linearVelocity, m_angularVelocity, timeStep, predictedTransform);
}

void btRigidBody::saveKinematicState(btScalar timeStep)
{
	//todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities
	if (timeStep != btScalar(0.))
	{
		//if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform
		if (getMotionState())
			getMotionState()->getWorldTransform(m_worldTransform);
		btVector3 linVel, angVel;

		btTransformUtil::calculateVelocity(m_interpolationWorldTransform, m_worldTransform, timeStep, m_linearVelocity, m_angularVelocity);
		m_interpolationLinearVelocity = m_linearVelocity;
		m_interpolationAngularVelocity = m_angularVelocity;
		m_interpolationWorldTransform = m_worldTransform;
		//printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());
	}
}

void btRigidBody::getAabb(btVector3& aabbMin, btVector3& aabbMax) const
{
	getCollisionShape()->getAabb(m_worldTransform, aabbMin, aabbMax);
}

void btRigidBody::setGravity(const btVector3& acceleration)
{
	if (m_inverseMass != btScalar(0.0))
	{
		m_gravity = acceleration * (btScalar(1.0) / m_inverseMass);
	}
	m_gravity_acceleration = acceleration;
}

void btRigidBody::setDamping(btScalar lin_damping, btScalar ang_damping)
{
#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearDamping = btMax(lin_damping, btScalar(0.0));
	m_angularDamping = btMax(ang_damping, btScalar(0.0));
#else
	m_linearDamping = btClamped(lin_damping, btScalar(0.0), btScalar(1.0));
	m_angularDamping = btClamped(ang_damping, btScalar(0.0), btScalar(1.0));
#endif
}

///applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping
void btRigidBody::applyDamping(btScalar timeStep)
{
	//On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74
	//todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway

#ifdef BT_USE_OLD_DAMPING_METHOD
	m_linearVelocity *= btMax((btScalar(1.0) - timeStep * m_linearDamping), btScalar(0.0));
	m_angularVelocity *= btMax((btScalar(1.0) - timeStep * m_angularDamping), btScalar(0.0));
#else
	m_linearVelocity *= btPow(btScalar(1) - m_linearDamping, timeStep);
	m_angularVelocity *= btPow(btScalar(1) - m_angularDamping, timeStep);
#endif

	if (m_additionalDamping)
	{
		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		if ((m_angularVelocity.length2() < m_additionalAngularDampingThresholdSqr) &&
			(m_linearVelocity.length2() < m_additionalLinearDampingThresholdSqr))
		{
			m_angularVelocity *= m_additionalDampingFactor;
			m_linearVelocity *= m_additionalDampingFactor;
		}

		btScalar speed = m_linearVelocity.length();
		if (speed < m_linearDamping)
		{
			btScalar dampVel = btScalar(0.005);
			if (speed > dampVel)
			{
				btVector3 dir = m_linearVelocity.normalized();
				m_linearVelocity -= dir * dampVel;
			}
			else
			{
				m_linearVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}

		btScalar angSpeed = m_angularVelocity.length();
		if (angSpeed < m_angularDamping)
		{
			btScalar angDampVel = btScalar(0.005);
			if (angSpeed > angDampVel)
			{
				btVector3 dir = m_angularVelocity.normalized();
				m_angularVelocity -= dir * angDampVel;
			}
			else
			{
				m_angularVelocity.setValue(btScalar(0.), btScalar(0.), btScalar(0.));
			}
		}
	}
}

void btRigidBody::applyGravity()
{
	if (isStaticOrKinematicObject())
		return;

	applyCentralForce(m_gravity);
}

void btRigidBody::clearGravity()
{
    if (isStaticOrKinematicObject())
        return;
    
    applyCentralForce(-m_gravity);
}

void btRigidBody::proceedToTransform(const btTransform& newTrans)
{
	setCenterOfMassTransform(newTrans);
}

void btRigidBody::setMassProps(btScalar mass, const btVector3& inertia)
{
	if (mass == btScalar(0.))
	{
		m_collisionFlags |= btCollisionObject::CF_STATIC_OBJECT;
		m_inverseMass = btScalar(0.);
	}
	else
	{
		m_collisionFlags &= (~btCollisionObject::CF_STATIC_OBJECT);
		m_inverseMass = btScalar(1.0) / mass;
	}

	//Fg = m * a
	m_gravity = mass * m_gravity_acceleration;

	m_invInertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
							   inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
							   inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));

	m_invMass = m_linearFactor * m_inverseMass;
}

void btRigidBody::updateInertiaTensor()
{
	m_invInertiaTensorWorld = m_worldTransform.getBasis().scaled(m_invInertiaLocal) * m_worldTransform.getBasis().transpose();
}

btVector3 btRigidBody::getLocalInertia() const
{
	btVector3 inertiaLocal;
	const btVector3 inertia = m_invInertiaLocal;
	inertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
						  inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
						  inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));
	return inertiaLocal;
}

inline btVector3 evalEulerEqn(const btVector3& w1, const btVector3& w0, const btVector3& T, const btScalar dt,
							  const btMatrix3x3& I)
{
	const btVector3 w2 = I * w1 + w1.cross(I * w1) * dt - (T * dt + I * w0);
	return w2;
}

inline btMatrix3x3 evalEulerEqnDeriv(const btVector3& w1, const btVector3& w0, const btScalar dt,
									 const btMatrix3x3& I)
{
	btMatrix3x3 w1x, Iw1x;
	const btVector3 Iwi = (I * w1);
	w1.getSkewSymmetricMatrix(&w1x[0], &w1x[1], &w1x[2]);
	Iwi.getSkewSymmetricMatrix(&Iw1x[0], &Iw1x[1], &Iw1x[2]);

	const btMatrix3x3 dfw1 = I + (w1x * I - Iw1x) * dt;
	return dfw1;
}

btVector3 btRigidBody::computeGyroscopicForceExplicit(btScalar maxGyroscopicForce) const
{
	btVector3 inertiaLocal = getLocalInertia();
	btMatrix3x3 inertiaTensorWorld = getWorldTransform().getBasis().scaled(inertiaLocal) * getWorldTransform().getBasis().transpose();
	btVector3 tmp = inertiaTensorWorld * getAngularVelocity();
	btVector3 gf = getAngularVelocity().cross(tmp);
	btScalar l2 = gf.length2();
	if (l2 > maxGyroscopicForce * maxGyroscopicForce)
	{
		gf *= btScalar(1.) / btSqrt(l2) * maxGyroscopicForce;
	}
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_Body(btScalar step) const
{
	btVector3 idl = getLocalInertia();
	btVector3 omega1 = getAngularVelocity();
	btQuaternion q = getWorldTransform().getRotation();

	// Convert to body coordinates
	btVector3 omegab = quatRotate(q.inverse(), omega1);
	btMatrix3x3 Ib;
	Ib.setValue(idl.x(), 0, 0,
				0, idl.y(), 0,
				0, 0, idl.z());

	btVector3 ibo = Ib * omegab;

	// Residual vector
	btVector3 f = step * omegab.cross(ibo);

	btMatrix3x3 skew0;
	omegab.getSkewSymmetricMatrix(&skew0[0], &skew0[1], &skew0[2]);
	btVector3 om = Ib * omegab;
	btMatrix3x3 skew1;
	om.getSkewSymmetricMatrix(&skew1[0], &skew1[1], &skew1[2]);

	// Jacobian
	btMatrix3x3 J = Ib + (skew0 * Ib - skew1) * step;

	//	btMatrix3x3 Jinv = J.inverse();
	//	btVector3 omega_div = Jinv*f;
	btVector3 omega_div = J.solve33(f);

	// Single Newton-Raphson update
	omegab = omegab - omega_div;  //Solve33(J, f);
	// Back to world coordinates
	btVector3 omega2 = quatRotate(q, omegab);
	btVector3 gf = omega2 - omega1;
	return gf;
}

btVector3 btRigidBody::computeGyroscopicImpulseImplicit_World(btScalar step) const
{
	// use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.
	// calculate using implicit euler step so it's stable.

	const btVector3 inertiaLocal = getLocalInertia();
	const btVector3 w0 = getAngularVelocity();

	btMatrix3x3 I;

	I = m_worldTransform.getBasis().scaled(inertiaLocal) *
		m_worldTransform.getBasis().transpose();

	// use newtons method to find implicit solution for new angular velocity (w')
	// f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0
	// df/dw' = I + 1xIw'*step + w'xI*step

	btVector3 w1 = w0;

	// one step of newton's method
	{
		const btVector3 fw = evalEulerEqn(w1, w0, btVector3(0, 0, 0), step, I);
		const btMatrix3x3 dfw = evalEulerEqnDeriv(w1, w0, step, I);

		btVector3 dw;
		dw = dfw.solve33(fw);
		//const btMatrix3x3 dfw_inv = dfw.inverse();
		//dw = dfw_inv*fw;

		w1 -= dw;
	}

	btVector3 gf = (w1 - w0);
	return gf;
}

void btRigidBody::integrateVelocities(btScalar step)
{
	if (isStaticOrKinematicObject())
		return;

	m_linearVelocity += m_totalForce * (m_inverseMass * step);
	m_angularVelocity += m_invInertiaTensorWorld * m_totalTorque * step;

#define MAX_ANGVEL SIMD_HALF_PI
	/// clamp angular velocity. collision calculations will fail on higher angular velocities
	btScalar angvel = m_angularVelocity.length();
	if (angvel * step > MAX_ANGVEL)
	{
		m_angularVelocity *= (MAX_ANGVEL / step) / angvel;
	}
	#if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
	clampVelocity(m_angularVelocity);
	#endif
}

btQuaternion btRigidBody::getOrientation() const
{
	btQuaternion orn;
	m_worldTransform.getBasis().getRotation(orn);
	return orn;
}

void btRigidBody::setCenterOfMassTransform(const btTransform& xform)
{
	if (isKinematicObject())
	{
		m_interpolationWorldTransform = m_worldTransform;
	}
	else
	{
		m_interpolationWorldTransform = xform;
	}
	m_interpolationLinearVelocity = getLinearVelocity();
	m_interpolationAngularVelocity = getAngularVelocity();
	m_worldTransform = xform;
	updateInertiaTensor();
}

void btRigidBody::addConstraintRef(btTypedConstraint* c)
{
	///disable collision with the 'other' body

	int index = m_constraintRefs.findLinearSearch(c);
	//don't add constraints that are already referenced
	//btAssert(index == m_constraintRefs.size());
	if (index == m_constraintRefs.size())
	{
		m_constraintRefs.push_back(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, true);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, true);
		}
	}
}

void btRigidBody::removeConstraintRef(btTypedConstraint* c)
{
	int index = m_constraintRefs.findLinearSearch(c);
	//don't remove constraints that are not referenced
	if (index < m_constraintRefs.size())
	{
		m_constraintRefs.remove(c);
		btCollisionObject* colObjA = &c->getRigidBodyA();
		btCollisionObject* colObjB = &c->getRigidBodyB();
		if (colObjA == this)
		{
			colObjA->setIgnoreCollisionCheck(colObjB, false);
		}
		else
		{
			colObjB->setIgnoreCollisionCheck(colObjA, false);
		}
	}
}

int btRigidBody::calculateSerializeBufferSize() const
{
	int sz = sizeof(btRigidBodyData);
	return sz;
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
const char* btRigidBody::serialize(void* dataBuffer, class btSerializer* serializer) const
{
	btRigidBodyData* rbd = (btRigidBodyData*)dataBuffer;

	btCollisionObject::serialize(&rbd->m_collisionObjectData, serializer);

	m_invInertiaTensorWorld.serialize(rbd->m_invInertiaTensorWorld);
	m_linearVelocity.serialize(rbd->m_linearVelocity);
	m_angularVelocity.serialize(rbd->m_angularVelocity);
	rbd->m_inverseMass = m_inverseMass;
	m_angularFactor.serialize(rbd->m_angularFactor);
	m_linearFactor.serialize(rbd->m_linearFactor);
	m_gravity.serialize(rbd->m_gravity);
	m_gravity_acceleration.serialize(rbd->m_gravity_acceleration);
	m_invInertiaLocal.serialize(rbd->m_invInertiaLocal);
	m_totalForce.serialize(rbd->m_totalForce);
	m_totalTorque.serialize(rbd->m_totalTorque);
	rbd->m_linearDamping = m_linearDamping;
	rbd->m_angularDamping = m_angularDamping;
	rbd->m_additionalDamping = m_additionalDamping;
	rbd->m_additionalDampingFactor = m_additionalDampingFactor;
	rbd->m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;
	rbd->m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;
	rbd->m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;
	rbd->m_linearSleepingThreshold = m_linearSleepingThreshold;
	rbd->m_angularSleepingThreshold = m_angularSleepingThreshold;

	// Fill padding with zeros to appease msan.
#ifdef BT_USE_DOUBLE_PRECISION
	memset(rbd->m_padding, 0, sizeof(rbd->m_padding));
#endif

	return btRigidBodyDataName;
}

void btRigidBody::serializeSingleObject(class btSerializer* serializer) const
{
	btChunk* chunk = serializer->allocate(calculateSerializeBufferSize(), 1);
	const char* structType = serialize(chunk->m_oldPtr, serializer);
	serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, (void*)this);
}





/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/

/*
Overview:

btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc).
It is a fixed translation, 3 degree-of-freedom (DOF) rotational "joint".
It divides the 3 rotational DOFs into swing (movement within a cone) and twist.
Swing is divided into swing1 and swing2 which can have different limits, giving an elliptical shape.
(Note: the cone's base isn't flat, so this ellipse is "embedded" on the surface of a sphere.)

In the contraint's frame of reference:
twist is along the x-axis,
and swing 1 and 2 are along the z and y axes respectively.
*/

#ifndef BT_CONETWISTCONSTRAINT_H
#define BT_CONETWISTCONSTRAINT_H

#include "LinearMath/btVector3.h"
#include "BulletDynamics/ConstraintSolver/btJacobianEntry.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

#ifdef BT_USE_DOUBLE_PRECISION
#define btConeTwistConstraintData2 btConeTwistConstraintDoubleData
#define btConeTwistConstraintDataName "btConeTwistConstraintDoubleData"
#else
#define btConeTwistConstraintData2 btConeTwistConstraintData
#define btConeTwistConstraintDataName "btConeTwistConstraintData"
#endif  //BT_USE_DOUBLE_PRECISION

class btRigidBody;

enum btConeTwistFlags
{
	BT_CONETWIST_FLAGS_LIN_CFM = 1,
	BT_CONETWIST_FLAGS_LIN_ERP = 2,
	BT_CONETWIST_FLAGS_ANG_CFM = 4
};

///btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
ATTRIBUTE_ALIGNED16(class)
btConeTwistConstraint : public btTypedConstraint
{
#ifdef IN_PARALLELL_SOLVER
public:
#endif
	btJacobianEntry m_jac[3];  //3 orthogonal linear constraints

	btTransform m_rbAFrame;
	btTransform m_rbBFrame;

	btScalar m_limitSoftness;
	btScalar m_biasFactor;
	btScalar m_relaxationFactor;

	btScalar m_damping;

	btScalar m_swingSpan1;
	btScalar m_swingSpan2;
	btScalar m_twistSpan;

	btScalar m_fixThresh;

	btVector3 m_swingAxis;
	btVector3 m_twistAxis;

	btScalar m_kSwing;
	btScalar m_kTwist;

	btScalar m_twistLimitSign;
	btScalar m_swingCorrection;
	btScalar m_twistCorrection;

	btScalar m_twistAngle;

	btScalar m_accSwingLimitImpulse;
	btScalar m_accTwistLimitImpulse;

	bool m_angularOnly;
	bool m_solveTwistLimit;
	bool m_solveSwingLimit;

	bool m_useSolveConstraintObsolete;

	// not yet used...
	btScalar m_swingLimitRatio;
	btScalar m_twistLimitRatio;
	btVector3 m_twistAxisA;

	// motor
	bool m_bMotorEnabled;
	bool m_bNormalizedMotorStrength;
	btQuaternion m_qTarget;
	btScalar m_maxMotorImpulse;
	btVector3 m_accMotorImpulse;

	// parameters
	int m_flags;
	btScalar m_linCFM;
	btScalar m_linERP;
	btScalar m_angCFM;

protected:
	void init();

	void computeConeLimitInfo(const btQuaternion& qCone,                                           // in
							  btScalar& swingAngle, btVector3& vSwingAxis, btScalar& swingLimit);  // all outs

	void computeTwistLimitInfo(const btQuaternion& qTwist,                    // in
							   btScalar& twistAngle, btVector3& vTwistAxis);  // all outs

	void adjustSwingAxisToUseEllipseNormal(btVector3 & vSwingAxis) const;

public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	btConeTwistConstraint(btRigidBody & rbA, btRigidBody & rbB, const btTransform& rbAFrame, const btTransform& rbBFrame);

	btConeTwistConstraint(btRigidBody & rbA, const btTransform& rbAFrame);

	virtual void buildJacobian();

	virtual void getInfo1(btConstraintInfo1 * info);

	void getInfo1NonVirtual(btConstraintInfo1 * info);

	virtual void getInfo2(btConstraintInfo2 * info);

	void getInfo2NonVirtual(btConstraintInfo2 * info, const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB);

	virtual void solveConstraintObsolete(btSolverBody & bodyA, btSolverBody & bodyB, btScalar timeStep);

	void updateRHS(btScalar timeStep);

	const btRigidBody& getRigidBodyA() const
	{
		return m_rbA;
	}
	const btRigidBody& getRigidBodyB() const
	{
		return m_rbB;
	}

	void setAngularOnly(bool angularOnly)
	{
		m_angularOnly = angularOnly;
	}

	bool getAngularOnly() const
	{
		return m_angularOnly;
	}

	void setLimit(int limitIndex, btScalar limitValue)
	{
		switch (limitIndex)
		{
			case 3:
			{
				m_twistSpan = limitValue;
				break;
			}
			case 4:
			{
				m_swingSpan2 = limitValue;
				break;
			}
			case 5:
			{
				m_swingSpan1 = limitValue;
				break;
			}
			default:
			{
			}
		};
	}

	btScalar getLimit(int limitIndex) const
	{
		switch (limitIndex)
		{
			case 3:
			{
				return m_twistSpan;
				break;
			}
			case 4:
			{
				return m_swingSpan2;
				break;
			}
			case 5:
			{
				return m_swingSpan1;
				break;
			}
			default:
			{
				btAssert(0 && "Invalid limitIndex specified for btConeTwistConstraint");
				return 0.0;
			}
		};
	}

	// setLimit(), a few notes:
	// _softness:
	//		0->1, recommend ~0.8->1.
	//		describes % of limits where movement is free.
	//		beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.
	// _biasFactor:
	//		0->1?, recommend 0.3 +/-0.3 or so.
	//		strength with which constraint resists zeroth order (angular, not angular velocity) limit violation.
	// __relaxationFactor:
	//		0->1, recommend to stay near 1.
	//		the lower the value, the less the constraint will fight velocities which violate the angular limits.
	void setLimit(btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness = 1.f, btScalar _biasFactor = 0.3f, btScalar _relaxationFactor = 1.0f)
	{
		m_swingSpan1 = _swingSpan1;
		m_swingSpan2 = _swingSpan2;
		m_twistSpan = _twistSpan;

		m_limitSoftness = _softness;
		m_biasFactor = _biasFactor;
		m_relaxationFactor = _relaxationFactor;
	}

	const btTransform& getAFrame() const { return m_rbAFrame; };
	const btTransform& getBFrame() const { return m_rbBFrame; };

	inline int getSolveTwistLimit()
	{
		return m_solveTwistLimit;
	}

	inline int getSolveSwingLimit()
	{
		return m_solveSwingLimit;
	}

	inline btScalar getTwistLimitSign()
	{
		return m_twistLimitSign;
	}

	void calcAngleInfo();
	void calcAngleInfo2(const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB);

	inline btScalar getSwingSpan1() const
	{
		return m_swingSpan1;
	}
	inline btScalar getSwingSpan2() const
	{
		return m_swingSpan2;
	}
	inline btScalar getTwistSpan() const
	{
		return m_twistSpan;
	}
	inline btScalar getLimitSoftness() const
	{
		return m_limitSoftness;
	}
	inline btScalar getBiasFactor() const
	{
		return m_biasFactor;
	}
	inline btScalar getRelaxationFactor() const
	{
		return m_relaxationFactor;
	}
	inline btScalar getTwistAngle() const
	{
		return m_twistAngle;
	}
	bool isPastSwingLimit() { return m_solveSwingLimit; }

	btScalar getDamping() const { return m_damping; }
	void setDamping(btScalar damping) { m_damping = damping; }

	void enableMotor(bool b) { m_bMotorEnabled = b; }
	bool isMotorEnabled() const { return m_bMotorEnabled; }
	btScalar getMaxMotorImpulse() const { return m_maxMotorImpulse; }
	bool isMaxMotorImpulseNormalized() const { return m_bNormalizedMotorStrength; }
	void setMaxMotorImpulse(btScalar maxMotorImpulse)
	{
		m_maxMotorImpulse = maxMotorImpulse;
		m_bNormalizedMotorStrength = false;
	}
	void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse)
	{
		m_maxMotorImpulse = maxMotorImpulse;
		m_bNormalizedMotorStrength = true;
	}

	btScalar getFixThresh() { return m_fixThresh; }
	void setFixThresh(btScalar fixThresh) { m_fixThresh = fixThresh; }

	// setMotorTarget:
	// q: the desired rotation of bodyA wrt bodyB.
	// note: if q violates the joint limits, the internal target is clamped to avoid conflicting impulses (very bad for stability)
	// note: don't forget to enableMotor()
	void setMotorTarget(const btQuaternion& q);
	const btQuaternion& getMotorTarget() const { return m_qTarget; }

	// same as above, but q is the desired rotation of frameA wrt frameB in constraint space
	void setMotorTargetInConstraintSpace(const btQuaternion& q);

	btVector3 GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const;

	///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	///If no axis is provided, it uses the default axis for this constraint.
	virtual void setParam(int num, btScalar value, int axis = -1);

	virtual void setFrames(const btTransform& frameA, const btTransform& frameB);

	const btTransform& getFrameOffsetA() const
	{
		return m_rbAFrame;
	}

	const btTransform& getFrameOffsetB() const
	{
		return m_rbBFrame;
	}

	///return the local value of parameter
	virtual btScalar getParam(int num, int axis = -1) const;

	int getFlags() const
	{
		return m_flags;
	}

	virtual int calculateSerializeBufferSize() const;

	///fills the dataBuffer and returns the struct name (and 0 on failure)
	virtual const char* serialize(void* dataBuffer, btSerializer* serializer) const;
};

struct btConeTwistConstraintDoubleData
{
	btTypedConstraintDoubleData m_typeConstraintData;
	btTransformDoubleData m_rbAFrame;
	btTransformDoubleData m_rbBFrame;

	//limits
	double m_swingSpan1;
	double m_swingSpan2;
	double m_twistSpan;
	double m_limitSoftness;
	double m_biasFactor;
	double m_relaxationFactor;

	double m_damping;
};

#ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
///this structure is not used, except for loading pre-2.82 .bullet files
struct btConeTwistConstraintData
{
	btTypedConstraintData m_typeConstraintData;
	btTransformFloatData m_rbAFrame;
	btTransformFloatData m_rbBFrame;

	//limits
	float m_swingSpan1;
	float m_swingSpan2;
	float m_twistSpan;
	float m_limitSoftness;
	float m_biasFactor;
	float m_relaxationFactor;

	float m_damping;

	char m_pad[4];
};
#endif  //BT_BACKWARDS_COMPATIBLE_SERIALIZATION
//

SIMD_FORCE_INLINE int btConeTwistConstraint::calculateSerializeBufferSize() const
{
	return sizeof(btConeTwistConstraintData2);
}

///fills the dataBuffer and returns the struct name (and 0 on failure)
SIMD_FORCE_INLINE const char* btConeTwistConstraint::serialize(void* dataBuffer, btSerializer* serializer) const
{
	btConeTwistConstraintData2* cone = (btConeTwistConstraintData2*)dataBuffer;
	btTypedConstraint::serialize(&cone->m_typeConstraintData, serializer);

	m_rbAFrame.serialize(cone->m_rbAFrame);
	m_rbBFrame.serialize(cone->m_rbBFrame);

	cone->m_swingSpan1 = m_swingSpan1;
	cone->m_swingSpan2 = m_swingSpan2;
	cone->m_twistSpan = m_twistSpan;
	cone->m_limitSoftness = m_limitSoftness;
	cone->m_biasFactor = m_biasFactor;
	cone->m_relaxationFactor = m_relaxationFactor;
	cone->m_damping = m_damping;

	return btConeTwistConstraintDataName;
}

#endif  //BT_CONETWISTCONSTRAINT_H





/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/

#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btMinMax.h"

//#define CONETWIST_USE_OBSOLETE_SOLVER true
#define CONETWIST_USE_OBSOLETE_SOLVER false
#define CONETWIST_DEF_FIX_THRESH btScalar(.05f)

SIMD_FORCE_INLINE btScalar computeAngularImpulseDenominator(const btVector3& axis, const btMatrix3x3& invInertiaWorld)
{
	btVector3 vec = axis * invInertiaWorld;
	return axis.dot(vec);
}

btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, btRigidBody& rbB,
											 const btTransform& rbAFrame, const btTransform& rbBFrame)
	: btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA, rbB), m_rbAFrame(rbAFrame), m_rbBFrame(rbBFrame), m_angularOnly(false), m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
	init();
}

btConeTwistConstraint::btConeTwistConstraint(btRigidBody& rbA, const btTransform& rbAFrame)
	: btTypedConstraint(CONETWIST_CONSTRAINT_TYPE, rbA), m_rbAFrame(rbAFrame), m_angularOnly(false), m_useSolveConstraintObsolete(CONETWIST_USE_OBSOLETE_SOLVER)
{
	m_rbBFrame = m_rbAFrame;
	m_rbBFrame.setOrigin(btVector3(0., 0., 0.));
	init();
}

void btConeTwistConstraint::init()
{
	m_angularOnly = false;
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;
	m_bMotorEnabled = false;
	m_maxMotorImpulse = btScalar(-1);

	setLimit(btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT), btScalar(BT_LARGE_FLOAT));
	m_damping = btScalar(0.01);
	m_fixThresh = CONETWIST_DEF_FIX_THRESH;
	m_flags = 0;
	m_linCFM = btScalar(0.f);
	m_linERP = btScalar(0.7f);
	m_angCFM = btScalar(0.f);
}

void btConeTwistConstraint::getInfo1(btConstraintInfo1* info)
{
	if (m_useSolveConstraintObsolete)
	{
		info->m_numConstraintRows = 0;
		info->nub = 0;
	}
	else
	{
		info->m_numConstraintRows = 3;
		info->nub = 3;
		calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
		if (m_solveSwingLimit)
		{
			info->m_numConstraintRows++;
			info->nub--;
			if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
			{
				info->m_numConstraintRows++;
				info->nub--;
			}
		}
		if (m_solveTwistLimit)
		{
			info->m_numConstraintRows++;
			info->nub--;
		}
	}
}

void btConeTwistConstraint::getInfo1NonVirtual(btConstraintInfo1* info)
{
	//always reserve 6 rows: object transform is not available on SPU
	info->m_numConstraintRows = 6;
	info->nub = 0;
}

void btConeTwistConstraint::getInfo2(btConstraintInfo2* info)
{
	getInfo2NonVirtual(info, m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
}

void btConeTwistConstraint::getInfo2NonVirtual(btConstraintInfo2* info, const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
	calcAngleInfo2(transA, transB, invInertiaWorldA, invInertiaWorldB);

	btAssert(!m_useSolveConstraintObsolete);
	// set jacobian
	info->m_J1linearAxis[0] = 1;
	info->m_J1linearAxis[info->rowskip + 1] = 1;
	info->m_J1linearAxis[2 * info->rowskip + 2] = 1;
	btVector3 a1 = transA.getBasis() * m_rbAFrame.getOrigin();
	{
		btVector3* angular0 = (btVector3*)(info->m_J1angularAxis);
		btVector3* angular1 = (btVector3*)(info->m_J1angularAxis + info->rowskip);
		btVector3* angular2 = (btVector3*)(info->m_J1angularAxis + 2 * info->rowskip);
		btVector3 a1neg = -a1;
		a1neg.getSkewSymmetricMatrix(angular0, angular1, angular2);
	}
	info->m_J2linearAxis[0] = -1;
	info->m_J2linearAxis[info->rowskip + 1] = -1;
	info->m_J2linearAxis[2 * info->rowskip + 2] = -1;
	btVector3 a2 = transB.getBasis() * m_rbBFrame.getOrigin();
	{
		btVector3* angular0 = (btVector3*)(info->m_J2angularAxis);
		btVector3* angular1 = (btVector3*)(info->m_J2angularAxis + info->rowskip);
		btVector3* angular2 = (btVector3*)(info->m_J2angularAxis + 2 * info->rowskip);
		a2.getSkewSymmetricMatrix(angular0, angular1, angular2);
	}
	// set right hand side
	btScalar linERP = (m_flags & BT_CONETWIST_FLAGS_LIN_ERP) ? m_linERP : info->erp;
	btScalar k = info->fps * linERP;
	int j;
	for (j = 0; j < 3; j++)
	{
		info->m_constraintError[j * info->rowskip] = k * (a2[j] + transB.getOrigin()[j] - a1[j] - transA.getOrigin()[j]);
		info->m_lowerLimit[j * info->rowskip] = -SIMD_INFINITY;
		info->m_upperLimit[j * info->rowskip] = SIMD_INFINITY;
		if (m_flags & BT_CONETWIST_FLAGS_LIN_CFM)
		{
			info->cfm[j * info->rowskip] = m_linCFM;
		}
	}
	int row = 3;
	int srow = row * info->rowskip;
	btVector3 ax1;
	// angular limits
	if (m_solveSwingLimit)
	{
		btScalar* J1 = info->m_J1angularAxis;
		btScalar* J2 = info->m_J2angularAxis;
		if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
		{
			btTransform trA = transA * m_rbAFrame;
			btVector3 p = trA.getBasis().getColumn(1);
			btVector3 q = trA.getBasis().getColumn(2);
			int srow1 = srow + info->rowskip;
			J1[srow + 0] = p[0];
			J1[srow + 1] = p[1];
			J1[srow + 2] = p[2];
			J1[srow1 + 0] = q[0];
			J1[srow1 + 1] = q[1];
			J1[srow1 + 2] = q[2];
			J2[srow + 0] = -p[0];
			J2[srow + 1] = -p[1];
			J2[srow + 2] = -p[2];
			J2[srow1 + 0] = -q[0];
			J2[srow1 + 1] = -q[1];
			J2[srow1 + 2] = -q[2];
			btScalar fact = info->fps * m_relaxationFactor;
			info->m_constraintError[srow] = fact * m_swingAxis.dot(p);
			info->m_constraintError[srow1] = fact * m_swingAxis.dot(q);
			info->m_lowerLimit[srow] = -SIMD_INFINITY;
			info->m_upperLimit[srow] = SIMD_INFINITY;
			info->m_lowerLimit[srow1] = -SIMD_INFINITY;
			info->m_upperLimit[srow1] = SIMD_INFINITY;
			srow = srow1 + info->rowskip;
		}
		else
		{
			ax1 = m_swingAxis * m_relaxationFactor * m_relaxationFactor;
			J1[srow + 0] = ax1[0];
			J1[srow + 1] = ax1[1];
			J1[srow + 2] = ax1[2];
			J2[srow + 0] = -ax1[0];
			J2[srow + 1] = -ax1[1];
			J2[srow + 2] = -ax1[2];
			btScalar k = info->fps * m_biasFactor;

			info->m_constraintError[srow] = k * m_swingCorrection;
			if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
			{
				info->cfm[srow] = m_angCFM;
			}
			// m_swingCorrection is always positive or 0
			info->m_lowerLimit[srow] = 0;
			info->m_upperLimit[srow] = (m_bMotorEnabled && m_maxMotorImpulse >= 0.0f) ? m_maxMotorImpulse : SIMD_INFINITY;
			srow += info->rowskip;
		}
	}
	if (m_solveTwistLimit)
	{
		ax1 = m_twistAxis * m_relaxationFactor * m_relaxationFactor;
		btScalar* J1 = info->m_J1angularAxis;
		btScalar* J2 = info->m_J2angularAxis;
		J1[srow + 0] = ax1[0];
		J1[srow + 1] = ax1[1];
		J1[srow + 2] = ax1[2];
		J2[srow + 0] = -ax1[0];
		J2[srow + 1] = -ax1[1];
		J2[srow + 2] = -ax1[2];
		btScalar k = info->fps * m_biasFactor;
		info->m_constraintError[srow] = k * m_twistCorrection;
		if (m_flags & BT_CONETWIST_FLAGS_ANG_CFM)
		{
			info->cfm[srow] = m_angCFM;
		}
		if (m_twistSpan > 0.0f)
		{
			if (m_twistCorrection > 0.0f)
			{
				info->m_lowerLimit[srow] = 0;
				info->m_upperLimit[srow] = SIMD_INFINITY;
			}
			else
			{
				info->m_lowerLimit[srow] = -SIMD_INFINITY;
				info->m_upperLimit[srow] = 0;
			}
		}
		else
		{
			info->m_lowerLimit[srow] = -SIMD_INFINITY;
			info->m_upperLimit[srow] = SIMD_INFINITY;
		}
		srow += info->rowskip;
	}
}

void btConeTwistConstraint::buildJacobian()
{
	if (m_useSolveConstraintObsolete)
	{
		m_appliedImpulse = btScalar(0.);
		m_accTwistLimitImpulse = btScalar(0.);
		m_accSwingLimitImpulse = btScalar(0.);
		m_accMotorImpulse = btVector3(0., 0., 0.);

		if (!m_angularOnly)
		{
			btVector3 pivotAInW = m_rbA.getCenterOfMassTransform() * m_rbAFrame.getOrigin();
			btVector3 pivotBInW = m_rbB.getCenterOfMassTransform() * m_rbBFrame.getOrigin();
			btVector3 relPos = pivotBInW - pivotAInW;

			btVector3 normal[3];
			if (relPos.length2() > SIMD_EPSILON)
			{
				normal[0] = relPos.normalized();
			}
			else
			{
				normal[0].setValue(btScalar(1.0), 0, 0);
			}

			btPlaneSpace1(normal[0], normal[1], normal[2]);

			for (int i = 0; i < 3; i++)
			{
				new (&m_jac[i]) btJacobianEntry(
					m_rbA.getCenterOfMassTransform().getBasis().transpose(),
					m_rbB.getCenterOfMassTransform().getBasis().transpose(),
					pivotAInW - m_rbA.getCenterOfMassPosition(),
					pivotBInW - m_rbB.getCenterOfMassPosition(),
					normal[i],
					m_rbA.getInvInertiaDiagLocal(),
					m_rbA.getInvMass(),
					m_rbB.getInvInertiaDiagLocal(),
					m_rbB.getInvMass());
			}
		}

		calcAngleInfo2(m_rbA.getCenterOfMassTransform(), m_rbB.getCenterOfMassTransform(), m_rbA.getInvInertiaTensorWorld(), m_rbB.getInvInertiaTensorWorld());
	}
}

void btConeTwistConstraint::solveConstraintObsolete(btSolverBody& bodyA, btSolverBody& bodyB, btScalar timeStep)
{
#ifndef __SPU__
	if (m_useSolveConstraintObsolete)
	{
		btVector3 pivotAInW = m_rbA.getCenterOfMassTransform() * m_rbAFrame.getOrigin();
		btVector3 pivotBInW = m_rbB.getCenterOfMassTransform() * m_rbBFrame.getOrigin();

		btScalar tau = btScalar(0.3);

		//linear part
		if (!m_angularOnly)
		{
			btVector3 rel_pos1 = pivotAInW - m_rbA.getCenterOfMassPosition();
			btVector3 rel_pos2 = pivotBInW - m_rbB.getCenterOfMassPosition();

			btVector3 vel1;
			bodyA.internalGetVelocityInLocalPointObsolete(rel_pos1, vel1);
			btVector3 vel2;
			bodyB.internalGetVelocityInLocalPointObsolete(rel_pos2, vel2);
			btVector3 vel = vel1 - vel2;

			for (int i = 0; i < 3; i++)
			{
				const btVector3& normal = m_jac[i].m_linearJointAxis;
				btScalar jacDiagABInv = btScalar(1.) / m_jac[i].getDiagonal();

				btScalar rel_vel;
				rel_vel = normal.dot(vel);
				//positional error (zeroth order error)
				btScalar depth = -(pivotAInW - pivotBInW).dot(normal);  //this is the error projected on the normal
				btScalar impulse = depth * tau / timeStep * jacDiagABInv - rel_vel * jacDiagABInv;
				m_appliedImpulse += impulse;

				btVector3 ftorqueAxis1 = rel_pos1.cross(normal);
				btVector3 ftorqueAxis2 = rel_pos2.cross(normal);
				bodyA.internalApplyImpulse(normal * m_rbA.getInvMass(), m_rbA.getInvInertiaTensorWorld() * ftorqueAxis1, impulse);
				bodyB.internalApplyImpulse(normal * m_rbB.getInvMass(), m_rbB.getInvInertiaTensorWorld() * ftorqueAxis2, -impulse);
			}
		}

		// apply motor
		if (m_bMotorEnabled)
		{
			// compute current and predicted transforms
			btTransform trACur = m_rbA.getCenterOfMassTransform();
			btTransform trBCur = m_rbB.getCenterOfMassTransform();
			btVector3 omegaA;
			bodyA.internalGetAngularVelocity(omegaA);
			btVector3 omegaB;
			bodyB.internalGetAngularVelocity(omegaB);
			btTransform trAPred;
			trAPred.setIdentity();
			btVector3 zerovec(0, 0, 0);
			btTransformUtil::integrateTransform(
				trACur, zerovec, omegaA, timeStep, trAPred);
			btTransform trBPred;
			trBPred.setIdentity();
			btTransformUtil::integrateTransform(
				trBCur, zerovec, omegaB, timeStep, trBPred);

			// compute desired transforms in world
			btTransform trPose(m_qTarget);
			btTransform trABDes = m_rbBFrame * trPose * m_rbAFrame.inverse();
			btTransform trADes = trBPred * trABDes;
			btTransform trBDes = trAPred * trABDes.inverse();

			// compute desired omegas in world
			btVector3 omegaADes, omegaBDes;

			btTransformUtil::calculateVelocity(trACur, trADes, timeStep, zerovec, omegaADes);
			btTransformUtil::calculateVelocity(trBCur, trBDes, timeStep, zerovec, omegaBDes);

			// compute delta omegas
			btVector3 dOmegaA = omegaADes - omegaA;
			btVector3 dOmegaB = omegaBDes - omegaB;

			// compute weighted avg axis of dOmega (weighting based on inertias)
			btVector3 axisA, axisB;
			btScalar kAxisAInv = 0, kAxisBInv = 0;

			if (dOmegaA.length2() > SIMD_EPSILON)
			{
				axisA = dOmegaA.normalized();
				kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(axisA);
			}

			if (dOmegaB.length2() > SIMD_EPSILON)
			{
				axisB = dOmegaB.normalized();
				kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(axisB);
			}

			btVector3 avgAxis = kAxisAInv * axisA + kAxisBInv * axisB;

			static bool bDoTorque = true;
			if (bDoTorque && avgAxis.length2() > SIMD_EPSILON)
			{
				avgAxis.normalize();
				kAxisAInv = getRigidBodyA().computeAngularImpulseDenominator(avgAxis);
				kAxisBInv = getRigidBodyB().computeAngularImpulseDenominator(avgAxis);
				btScalar kInvCombined = kAxisAInv + kAxisBInv;

				btVector3 impulse = (kAxisAInv * dOmegaA - kAxisBInv * dOmegaB) /
									(kInvCombined * kInvCombined);

				if (m_maxMotorImpulse >= 0)
				{
					btScalar fMaxImpulse = m_maxMotorImpulse;
					if (m_bNormalizedMotorStrength)
						fMaxImpulse = fMaxImpulse / kAxisAInv;

					btVector3 newUnclampedAccImpulse = m_accMotorImpulse + impulse;
					btScalar newUnclampedMag = newUnclampedAccImpulse.length();
					if (newUnclampedMag > fMaxImpulse)
					{
						newUnclampedAccImpulse.normalize();
						newUnclampedAccImpulse *= fMaxImpulse;
						impulse = newUnclampedAccImpulse - m_accMotorImpulse;
					}
					m_accMotorImpulse += impulse;
				}

				btScalar impulseMag = impulse.length();
				btVector3 impulseAxis = impulse / impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * impulseAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * impulseAxis, -impulseMag);
			}
		}
		else if (m_damping > SIMD_EPSILON)  // no motor: do a little damping
		{
			btVector3 angVelA;
			bodyA.internalGetAngularVelocity(angVelA);
			btVector3 angVelB;
			bodyB.internalGetAngularVelocity(angVelB);
			btVector3 relVel = angVelB - angVelA;
			if (relVel.length2() > SIMD_EPSILON)
			{
				btVector3 relVelAxis = relVel.normalized();
				btScalar m_kDamping = btScalar(1.) /
									  (getRigidBodyA().computeAngularImpulseDenominator(relVelAxis) +
									   getRigidBodyB().computeAngularImpulseDenominator(relVelAxis));
				btVector3 impulse = m_damping * m_kDamping * relVel;

				btScalar impulseMag = impulse.length();
				btVector3 impulseAxis = impulse / impulseMag;
				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * impulseAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * impulseAxis, -impulseMag);
			}
		}

		// joint limits
		{
			///solve angular part
			btVector3 angVelA;
			bodyA.internalGetAngularVelocity(angVelA);
			btVector3 angVelB;
			bodyB.internalGetAngularVelocity(angVelB);

			// solve swing limit
			if (m_solveSwingLimit)
			{
				btScalar amplitude = m_swingLimitRatio * m_swingCorrection * m_biasFactor / timeStep;
				btScalar relSwingVel = (angVelB - angVelA).dot(m_swingAxis);
				if (relSwingVel > 0)
					amplitude += m_swingLimitRatio * relSwingVel * m_relaxationFactor;
				btScalar impulseMag = amplitude * m_kSwing;

				// Clamp the accumulated impulse
				btScalar temp = m_accSwingLimitImpulse;
				m_accSwingLimitImpulse = btMax(m_accSwingLimitImpulse + impulseMag, btScalar(0.0));
				impulseMag = m_accSwingLimitImpulse - temp;

				btVector3 impulse = m_swingAxis * impulseMag;

				// don't let cone response affect twist
				// (this can happen since body A's twist doesn't match body B's AND we use an elliptical cone limit)
				{
					btVector3 impulseTwistCouple = impulse.dot(m_twistAxisA) * m_twistAxisA;
					btVector3 impulseNoTwistCouple = impulse - impulseTwistCouple;
					impulse = impulseNoTwistCouple;
				}

				impulseMag = impulse.length();
				btVector3 noTwistSwingAxis = impulse / impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * noTwistSwingAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * noTwistSwingAxis, -impulseMag);
			}

			// solve twist limit
			if (m_solveTwistLimit)
			{
				btScalar amplitude = m_twistLimitRatio * m_twistCorrection * m_biasFactor / timeStep;
				btScalar relTwistVel = (angVelB - angVelA).dot(m_twistAxis);
				if (relTwistVel > 0)  // only damp when moving towards limit (m_twistAxis flipping is important)
					amplitude += m_twistLimitRatio * relTwistVel * m_relaxationFactor;
				btScalar impulseMag = amplitude * m_kTwist;

				// Clamp the accumulated impulse
				btScalar temp = m_accTwistLimitImpulse;
				m_accTwistLimitImpulse = btMax(m_accTwistLimitImpulse + impulseMag, btScalar(0.0));
				impulseMag = m_accTwistLimitImpulse - temp;

				//		btVector3 impulse = m_twistAxis * impulseMag;

				bodyA.internalApplyImpulse(btVector3(0, 0, 0), m_rbA.getInvInertiaTensorWorld() * m_twistAxis, impulseMag);
				bodyB.internalApplyImpulse(btVector3(0, 0, 0), m_rbB.getInvInertiaTensorWorld() * m_twistAxis, -impulseMag);
			}
		}
	}
#else
	btAssert(0);
#endif  //__SPU__
}

void btConeTwistConstraint::updateRHS(btScalar timeStep)
{
	(void)timeStep;
}

#ifndef __SPU__
void btConeTwistConstraint::calcAngleInfo()
{
	m_swingCorrection = btScalar(0.);
	m_twistLimitSign = btScalar(0.);
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;

	btVector3 b1Axis1(0, 0, 0), b1Axis2(0, 0, 0), b1Axis3(0, 0, 0);
	btVector3 b2Axis1(0, 0, 0), b2Axis2(0, 0, 0);

	b1Axis1 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(0);
	b2Axis1 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(0);

	btScalar swing1 = btScalar(0.), swing2 = btScalar(0.);

	btScalar swx = btScalar(0.), swy = btScalar(0.);
	btScalar thresh = btScalar(10.);
	btScalar fact;

	// Get Frame into world space
	if (m_swingSpan1 >= btScalar(0.05f))
	{
		b1Axis2 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(1);
		swx = b2Axis1.dot(b1Axis1);
		swy = b2Axis1.dot(b1Axis2);
		swing1 = btAtan2Fast(swy, swx);
		fact = (swy * swy + swx * swx) * thresh * thresh;
		fact = fact / (fact + btScalar(1.0));
		swing1 *= fact;
	}

	if (m_swingSpan2 >= btScalar(0.05f))
	{
		b1Axis3 = getRigidBodyA().getCenterOfMassTransform().getBasis() * this->m_rbAFrame.getBasis().getColumn(2);
		swx = b2Axis1.dot(b1Axis1);
		swy = b2Axis1.dot(b1Axis3);
		swing2 = btAtan2Fast(swy, swx);
		fact = (swy * swy + swx * swx) * thresh * thresh;
		fact = fact / (fact + btScalar(1.0));
		swing2 *= fact;
	}

	btScalar RMaxAngle1Sq = 1.0f / (m_swingSpan1 * m_swingSpan1);
	btScalar RMaxAngle2Sq = 1.0f / (m_swingSpan2 * m_swingSpan2);
	btScalar EllipseAngle = btFabs(swing1 * swing1) * RMaxAngle1Sq + btFabs(swing2 * swing2) * RMaxAngle2Sq;

	if (EllipseAngle > 1.0f)
	{
		m_swingCorrection = EllipseAngle - 1.0f;
		m_solveSwingLimit = true;
		// Calculate necessary axis & factors
		m_swingAxis = b2Axis1.cross(b1Axis2 * b2Axis1.dot(b1Axis2) + b1Axis3 * b2Axis1.dot(b1Axis3));
		m_swingAxis.normalize();
		btScalar swingAxisSign = (b2Axis1.dot(b1Axis1) >= 0.0f) ? 1.0f : -1.0f;
		m_swingAxis *= swingAxisSign;
	}

	// Twist limits
	if (m_twistSpan >= btScalar(0.))
	{
		btVector3 b2Axis2 = getRigidBodyB().getCenterOfMassTransform().getBasis() * this->m_rbBFrame.getBasis().getColumn(1);
		btQuaternion rotationArc = shortestArcQuat(b2Axis1, b1Axis1);
		btVector3 TwistRef = quatRotate(rotationArc, b2Axis2);
		btScalar twist = btAtan2Fast(TwistRef.dot(b1Axis3), TwistRef.dot(b1Axis2));
		m_twistAngle = twist;

		//		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? m_limitSoftness : btScalar(0.);
		btScalar lockedFreeFactor = (m_twistSpan > btScalar(0.05f)) ? btScalar(1.0f) : btScalar(0.);
		if (twist <= -m_twistSpan * lockedFreeFactor)
		{
			m_twistCorrection = -(twist + m_twistSpan);
			m_solveTwistLimit = true;
			m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
			m_twistAxis.normalize();
			m_twistAxis *= -1.0f;
		}
		else if (twist > m_twistSpan * lockedFreeFactor)
		{
			m_twistCorrection = (twist - m_twistSpan);
			m_solveTwistLimit = true;
			m_twistAxis = (b2Axis1 + b1Axis1) * 0.5f;
			m_twistAxis.normalize();
		}
	}
}
#endif  //__SPU__

static btVector3 vTwist(1, 0, 0);  // twist axis in constraint's space

void btConeTwistConstraint::calcAngleInfo2(const btTransform& transA, const btTransform& transB, const btMatrix3x3& invInertiaWorldA, const btMatrix3x3& invInertiaWorldB)
{
	m_swingCorrection = btScalar(0.);
	m_twistLimitSign = btScalar(0.);
	m_solveTwistLimit = false;
	m_solveSwingLimit = false;
	// compute rotation of A wrt B (in constraint space)
	if (m_bMotorEnabled && (!m_useSolveConstraintObsolete))
	{  // it is assumed that setMotorTarget() was alredy called
		// and motor target m_qTarget is within constraint limits
		// TODO : split rotation to pure swing and pure twist
		// compute desired transforms in world
		btTransform trPose(m_qTarget);
		btTransform trA = transA * m_rbAFrame;
		btTransform trB = transB * m_rbBFrame;
		btTransform trDeltaAB = trB * trPose * trA.inverse();
		btQuaternion qDeltaAB = trDeltaAB.getRotation();
		btVector3 swingAxis = btVector3(qDeltaAB.x(), qDeltaAB.y(), qDeltaAB.z());
		btScalar swingAxisLen2 = swingAxis.length2();
		if (btFuzzyZero(swingAxisLen2))
		{
			return;
		}
		m_swingAxis = swingAxis;
		m_swingAxis.normalize();
		m_swingCorrection = qDeltaAB.getAngle();
		if (!btFuzzyZero(m_swingCorrection))
		{
			m_solveSwingLimit = true;
		}
		return;
	}

	{
		// compute rotation of A wrt B (in constraint space)
		btQuaternion qA = transA.getRotation() * m_rbAFrame.getRotation();
		btQuaternion qB = transB.getRotation() * m_rbBFrame.getRotation();
		btQuaternion qAB = qB.inverse() * qA;
		// split rotation into cone and twist
		// (all this is done from B's perspective. Maybe I should be averaging axes...)
		btVector3 vConeNoTwist = quatRotate(qAB, vTwist);
		vConeNoTwist.normalize();
		btQuaternion qABCone = shortestArcQuat(vTwist, vConeNoTwist);
		qABCone.normalize();
		btQuaternion qABTwist = qABCone.inverse() * qAB;
		qABTwist.normalize();

		if (m_swingSpan1 >= m_fixThresh && m_swingSpan2 >= m_fixThresh)
		{
			btScalar swingAngle, swingLimit = 0;
			btVector3 swingAxis;
			computeConeLimitInfo(qABCone, swingAngle, swingAxis, swingLimit);

			if (swingAngle > swingLimit * m_limitSoftness)
			{
				m_solveSwingLimit = true;

				// compute limit ratio: 0->1, where
				// 0 == beginning of soft limit
				// 1 == hard/real limit
				m_swingLimitRatio = 1.f;
				if (swingAngle < swingLimit && m_limitSoftness < 1.f - SIMD_EPSILON)
				{
					m_swingLimitRatio = (swingAngle - swingLimit * m_limitSoftness) /
										(swingLimit - swingLimit * m_limitSoftness);
				}

				// swing correction tries to get back to soft limit
				m_swingCorrection = swingAngle - (swingLimit * m_limitSoftness);

				// adjustment of swing axis (based on ellipse normal)
				adjustSwingAxisToUseEllipseNormal(swingAxis);

				// Calculate necessary axis & factors
				m_swingAxis = quatRotate(qB, -swingAxis);

				m_twistAxisA.setValue(0, 0, 0);

				m_kSwing = btScalar(1.) /
						   (computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldA) +
							computeAngularImpulseDenominator(m_swingAxis, invInertiaWorldB));
			}
		}
		else
		{
			// you haven't set any limits;
			// or you're trying to set at least one of the swing limits too small. (if so, do you really want a conetwist constraint?)
			// anyway, we have either hinge or fixed joint
			btVector3 ivA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(0);
			btVector3 jvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(1);
			btVector3 kvA = transA.getBasis() * m_rbAFrame.getBasis().getColumn(2);
			btVector3 ivB = transB.getBasis() * m_rbBFrame.getBasis().getColumn(0);
			btVector3 target;
			btScalar x = ivB.dot(ivA);
			btScalar y = ivB.dot(jvA);
			btScalar z = ivB.dot(kvA);
			if ((m_swingSpan1 < m_fixThresh) && (m_swingSpan2 < m_fixThresh))
			{  // fixed. We'll need to add one more row to constraint
				if ((!btFuzzyZero(y)) || (!(btFuzzyZero(z))))
				{
					m_solveSwingLimit = true;
					m_swingAxis = -ivB.cross(ivA);
				}
			}
			else
			{
				if (m_swingSpan1 < m_fixThresh)
				{  // hinge around Y axis
					//					if(!(btFuzzyZero(y)))
					if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(z))))
					{
						m_solveSwingLimit = true;
						if (m_swingSpan2 >= m_fixThresh)
						{
							y = btScalar(0.f);
							btScalar span2 = btAtan2(z, x);
							if (span2 > m_swingSpan2)
							{
								x = btCos(m_swingSpan2);
								z = btSin(m_swingSpan2);
							}
							else if (span2 < -m_swingSpan2)
							{
								x = btCos(m_swingSpan2);
								z = -btSin(m_swingSpan2);
							}
						}
					}
				}
				else
				{  // hinge around Z axis
					//					if(!btFuzzyZero(z))
					if ((!(btFuzzyZero(x))) || (!(btFuzzyZero(y))))
					{
						m_solveSwingLimit = true;
						if (m_swingSpan1 >= m_fixThresh)
						{
							z = btScalar(0.f);
							btScalar span1 = btAtan2(y, x);
							if (span1 > m_swingSpan1)
							{
								x = btCos(m_swingSpan1);
								y = btSin(m_swingSpan1);
							}
							else if (span1 < -m_swingSpan1)
							{
								x = btCos(m_swingSpan1);
								y = -btSin(m_swingSpan1);
							}
						}
					}
				}
				target[0] = x * ivA[0] + y * jvA[0] + z * kvA[0];
				target[1] = x * ivA[1] + y * jvA[1] + z * kvA[1];
				target[2] = x * ivA[2] + y * jvA[2] + z * kvA[2];
				target.normalize();
				m_swingAxis = -ivB.cross(target);
				m_swingCorrection = m_swingAxis.length();

				if (!btFuzzyZero(m_swingCorrection))
					m_swingAxis.normalize();
			}
		}

		if (m_twistSpan >= btScalar(0.f))
		{
			btVector3 twistAxis;
			computeTwistLimitInfo(qABTwist, m_twistAngle, twistAxis);

			if (m_twistAngle > m_twistSpan * m_limitSoftness)
			{
				m_solveTwistLimit = true;

				m_twistLimitRatio = 1.f;
				if (m_twistAngle < m_twistSpan && m_limitSoftness < 1.f - SIMD_EPSILON)
				{
					m_twistLimitRatio = (m_twistAngle - m_twistSpan * m_limitSoftness) /
										(m_twistSpan - m_twistSpan * m_limitSoftness);
				}

				// twist correction tries to get back to soft limit
				m_twistCorrection = m_twistAngle - (m_twistSpan * m_limitSoftness);

				m_twistAxis = quatRotate(qB, -twistAxis);

				m_kTwist = btScalar(1.) /
						   (computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldA) +
							computeAngularImpulseDenominator(m_twistAxis, invInertiaWorldB));
			}

			if (m_solveSwingLimit)
				m_twistAxisA = quatRotate(qA, -twistAxis);
		}
		else
		{
			m_twistAngle = btScalar(0.f);
		}
	}
}

// given a cone rotation in constraint space, (pre: twist must already be removed)
// this method computes its corresponding swing angle and axis.
// more interestingly, it computes the cone/swing limit (angle) for this cone "pose".
void btConeTwistConstraint::computeConeLimitInfo(const btQuaternion& qCone,
												 btScalar& swingAngle,   // out
												 btVector3& vSwingAxis,  // out
												 btScalar& swingLimit)   // out
{
	swingAngle = qCone.getAngle();
	if (swingAngle > SIMD_EPSILON)
	{
		vSwingAxis = btVector3(qCone.x(), qCone.y(), qCone.z());
		vSwingAxis.normalize();
#if 0
        // non-zero twist?! this should never happen.
       btAssert(fabs(vSwingAxis.x()) <= SIMD_EPSILON));
#endif

		// Compute limit for given swing. tricky:
		// Given a swing axis, we're looking for the intersection with the bounding cone ellipse.
		// (Since we're dealing with angles, this ellipse is embedded on the surface of a sphere.)

		// For starters, compute the direction from center to surface of ellipse.
		// This is just the perpendicular (ie. rotate 2D vector by PI/2) of the swing axis.
		// (vSwingAxis is the cone rotation (in z,y); change vars and rotate to (x,y) coords.)
		btScalar xEllipse = vSwingAxis.y();
		btScalar yEllipse = -vSwingAxis.z();

		// Now, we use the slope of the vector (using x/yEllipse) and find the length
		// of the line that intersects the ellipse:
		//  x^2   y^2
		//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
		//  a^2   b^2
		// Do the math and it should be clear.

		swingLimit = m_swingSpan1;  // if xEllipse == 0, we have a pure vSwingAxis.z rotation: just use swingspan1
		if (fabs(xEllipse) > SIMD_EPSILON)
		{
			btScalar surfaceSlope2 = (yEllipse * yEllipse) / (xEllipse * xEllipse);
			btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
			norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
			btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
			swingLimit = std::sqrt(swingLimit2);
		}

		// test!
		/*swingLimit = m_swingSpan2;
		if (fabs(vSwingAxis.z()) > SIMD_EPSILON)
		{
		btScalar mag_2 = m_swingSpan1*m_swingSpan1 + m_swingSpan2*m_swingSpan2;
		btScalar sinphi = m_swingSpan2 / sqrt(mag_2);
		btScalar phi = asin(sinphi);
		btScalar theta = atan2(fabs(vSwingAxis.y()),fabs(vSwingAxis.z()));
		btScalar alpha = 3.14159f - theta - phi;
		btScalar sinalpha = sin(alpha);
		swingLimit = m_swingSpan1 * sinphi/sinalpha;
		}*/
	}
	else if (swingAngle < 0)
	{
		// this should never happen!
#if 0
        btAssert(0);
#endif
	}
}

btVector3 btConeTwistConstraint::GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const
{
	// compute x/y in ellipse using cone angle (0 -> 2*PI along surface of cone)
	btScalar xEllipse = btCos(fAngleInRadians);
	btScalar yEllipse = btSin(fAngleInRadians);

	// Use the slope of the vector (using x/yEllipse) and find the length
	// of the line that intersects the ellipse:
	//  x^2   y^2
	//  --- + --- = 1, where a and b are semi-major axes 2 and 1 respectively (ie. the limits)
	//  a^2   b^2
	// Do the math and it should be clear.

	btScalar swingLimit = m_swingSpan1;  // if xEllipse == 0, just use axis b (1)
	if (fabs(xEllipse) > SIMD_EPSILON)
	{
		btScalar surfaceSlope2 = (yEllipse * yEllipse) / (xEllipse * xEllipse);
		btScalar norm = 1 / (m_swingSpan2 * m_swingSpan2);
		norm += surfaceSlope2 / (m_swingSpan1 * m_swingSpan1);
		btScalar swingLimit2 = (1 + surfaceSlope2) / norm;
		swingLimit = std::sqrt(swingLimit2);
	}

	// convert into point in constraint space:
	// note: twist is x-axis, swing 1 and 2 are along the z and y axes respectively
	btVector3 vSwingAxis(0, xEllipse, -yEllipse);
	btQuaternion qSwing(vSwingAxis, swingLimit);
	btVector3 vPointInConstraintSpace(fLength, 0, 0);
	return quatRotate(qSwing, vPointInConstraintSpace);
}

// given a twist rotation in constraint space, (pre: cone must already be removed)
// this method computes its corresponding angle and axis.
void btConeTwistConstraint::computeTwistLimitInfo(const btQuaternion& qTwist,
												  btScalar& twistAngle,   // out
												  btVector3& vTwistAxis)  // out
{
	btQuaternion qMinTwist = qTwist;
	twistAngle = qTwist.getAngle();

	if (twistAngle > SIMD_PI)  // long way around. flip quat and recalculate.
	{
		qMinTwist = -(qTwist);
		twistAngle = qMinTwist.getAngle();
	}
	if (twistAngle < 0)
	{
		// this should never happen
#if 0
        btAssert(0);
#endif
	}

	vTwistAxis = btVector3(qMinTwist.x(), qMinTwist.y(), qMinTwist.z());
	if (twistAngle > SIMD_EPSILON)
		vTwistAxis.normalize();
}

void btConeTwistConstraint::adjustSwingAxisToUseEllipseNormal(btVector3& vSwingAxis) const
{
	// the swing axis is computed as the "twist-free" cone rotation,
	// but the cone limit is not circular, but elliptical (if swingspan1 != swingspan2).
	// so, if we're outside the limits, the closest way back inside the cone isn't
	// along the vector back to the center. better (and more stable) to use the ellipse normal.

	// convert swing axis to direction from center to surface of ellipse
	// (ie. rotate 2D vector by PI/2)
	btScalar y = -vSwingAxis.z();
	btScalar z = vSwingAxis.y();

	// do the math...
	if (fabs(z) > SIMD_EPSILON)  // avoid division by 0. and we don't need an update if z == 0.
	{
		// compute gradient/normal of ellipse surface at current "point"
		btScalar grad = y / z;
		grad *= m_swingSpan2 / m_swingSpan1;

		// adjust y/z to represent normal at point (instead of vector to point)
		if (y > 0)
			y = fabs(grad * z);
		else
			y = -fabs(grad * z);

		// convert ellipse direction back to swing axis
		vSwingAxis.setZ(-y);
		vSwingAxis.setY(z);
		vSwingAxis.normalize();
	}
}

void btConeTwistConstraint::setMotorTarget(const btQuaternion& q)
{
	//btTransform trACur = m_rbA.getCenterOfMassTransform();
	//btTransform trBCur = m_rbB.getCenterOfMassTransform();
	//	btTransform trABCur = trBCur.inverse() * trACur;
	//	btQuaternion qABCur = trABCur.getRotation();
	//	btTransform trConstraintCur = (trBCur * m_rbBFrame).inverse() * (trACur * m_rbAFrame);
	//btQuaternion qConstraintCur = trConstraintCur.getRotation();

	btQuaternion qConstraint = m_rbBFrame.getRotation().inverse() * q * m_rbAFrame.getRotation();
	setMotorTargetInConstraintSpace(qConstraint);
}

void btConeTwistConstraint::setMotorTargetInConstraintSpace(const btQuaternion& q)
{
	m_qTarget = q;

	// clamp motor target to within limits
	{
		btScalar softness = 1.f;  //m_limitSoftness;

		// split into twist and cone
		btVector3 vTwisted = quatRotate(m_qTarget, vTwist);
		btQuaternion qTargetCone = shortestArcQuat(vTwist, vTwisted);
		qTargetCone.normalize();
		btQuaternion qTargetTwist = qTargetCone.inverse() * m_qTarget;
		qTargetTwist.normalize();

		// clamp cone
		if (m_swingSpan1 >= btScalar(0.05f) && m_swingSpan2 >= btScalar(0.05f))
		{
			btScalar swingAngle, swingLimit;
			btVector3 swingAxis;
			computeConeLimitInfo(qTargetCone, swingAngle, swingAxis, swingLimit);

			if (fabs(swingAngle) > SIMD_EPSILON)
			{
				if (swingAngle > swingLimit * softness)
					swingAngle = swingLimit * softness;
				else if (swingAngle < -swingLimit * softness)
					swingAngle = -swingLimit * softness;
				qTargetCone = btQuaternion(swingAxis, swingAngle);
			}
		}

		// clamp twist
		if (m_twistSpan >= btScalar(0.05f))
		{
			btScalar twistAngle;
			btVector3 twistAxis;
			computeTwistLimitInfo(qTargetTwist, twistAngle, twistAxis);

			if (fabs(twistAngle) > SIMD_EPSILON)
			{
				// eddy todo: limitSoftness used here???
				if (twistAngle > m_twistSpan * softness)
					twistAngle = m_twistSpan * softness;
				else if (twistAngle < -m_twistSpan * softness)
					twistAngle = -m_twistSpan * softness;
				qTargetTwist = btQuaternion(twistAxis, twistAngle);
			}
		}

		m_qTarget = qTargetCone * qTargetTwist;
	}
}

///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
///If no axis is provided, it uses the default axis for this constraint.
void btConeTwistConstraint::setParam(int num, btScalar value, int axis)
{
	switch (num)
	{
		case BT_CONSTRAINT_ERP:
		case BT_CONSTRAINT_STOP_ERP:
			if ((axis >= 0) && (axis < 3))
			{
				m_linERP = value;
				m_flags |= BT_CONETWIST_FLAGS_LIN_ERP;
			}
			else
			{
				m_biasFactor = value;
			}
			break;
		case BT_CONSTRAINT_CFM:
		case BT_CONSTRAINT_STOP_CFM:
			if ((axis >= 0) && (axis < 3))
			{
				m_linCFM = value;
				m_flags |= BT_CONETWIST_FLAGS_LIN_CFM;
			}
			else
			{
				m_angCFM = value;
				m_flags |= BT_CONETWIST_FLAGS_ANG_CFM;
			}
			break;
		default:
			btAssertConstrParams(0);
			break;
	}
}

///return the local value of parameter
btScalar btConeTwistConstraint::getParam(int num, int axis) const
{
	btScalar retVal = 0;
	switch (num)
	{
		case BT_CONSTRAINT_ERP:
		case BT_CONSTRAINT_STOP_ERP:
			if ((axis >= 0) && (axis < 3))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_ERP);
				retVal = m_linERP;
			}
			else if ((axis >= 3) && (axis < 6))
			{
				retVal = m_biasFactor;
			}
			else
			{
				btAssertConstrParams(0);
			}
			break;
		case BT_CONSTRAINT_CFM:
		case BT_CONSTRAINT_STOP_CFM:
			if ((axis >= 0) && (axis < 3))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_LIN_CFM);
				retVal = m_linCFM;
			}
			else if ((axis >= 3) && (axis < 6))
			{
				btAssertConstrParams(m_flags & BT_CONETWIST_FLAGS_ANG_CFM);
				retVal = m_angCFM;
			}
			else
			{
				btAssertConstrParams(0);
			}
			break;
		default:
			btAssertConstrParams(0);
	}
	return retVal;
}

void btConeTwistConstraint::setFrames(const btTransform& frameA, const btTransform& frameB)
{
	m_rbAFrame = frameA;
	m_rbBFrame = frameB;
	buildJacobian();
	//calculateTransforms();
}





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#ifndef BT_DISCRETE_DYNAMICS_WORLD_H
#define BT_DISCRETE_DYNAMICS_WORLD_H

#include "BulletDynamics/Dynamics/btDynamicsWorld.h"
class btDispatcher;
class btOverlappingPairCache;
class btConstraintSolver;
class btSimulationIslandManager;
class btTypedConstraint;
class btActionInterface;
class btPersistentManifold;
class btIDebugDraw;

struct InplaceSolverIslandCallback;

#include "LinearMath/btAlignedObjectArray.h"
#include "LinearMath/btThreads.h"

///btDiscreteDynamicsWorld provides discrete rigid body simulation
///those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
ATTRIBUTE_ALIGNED16(class)
btDiscreteDynamicsWorld : public btDynamicsWorld
{
protected:
	btAlignedObjectArray<btTypedConstraint*> m_sortedConstraints;
	InplaceSolverIslandCallback* m_solverIslandCallback;

	btConstraintSolver* m_constraintSolver;

	btSimulationIslandManager* m_islandManager;

	btAlignedObjectArray<btTypedConstraint*> m_constraints;

	btAlignedObjectArray<btRigidBody*> m_nonStaticRigidBodies;

	btVector3 m_gravity;

	//for variable timesteps
	btScalar m_localTime;
	btScalar m_fixedTimeStep;
	//for variable timesteps

	bool m_ownsIslandManager;
	bool m_ownsConstraintSolver;
	bool m_synchronizeAllMotionStates;
	bool m_applySpeculativeContactRestitution;

	btAlignedObjectArray<btActionInterface*> m_actions;

	int m_profileTimings;

	bool m_latencyMotionStateInterpolation;

	btAlignedObjectArray<btPersistentManifold*> m_predictiveManifolds;
	btSpinMutex m_predictiveManifoldsMutex;  // used to synchronize threads creating predictive contacts

	virtual void predictUnconstraintMotion(btScalar timeStep);

	void integrateTransformsInternal(btRigidBody * *bodies, int numBodies, btScalar timeStep);  // can be called in parallel
	virtual void integrateTransforms(btScalar timeStep);

	virtual void calculateSimulationIslands();

	

	virtual void updateActivationState(btScalar timeStep);

	void updateActions(btScalar timeStep);

	void startProfiling(btScalar timeStep);

	virtual void internalSingleStepSimulation(btScalar timeStep);

	void releasePredictiveContacts();
	void createPredictiveContactsInternal(btRigidBody * *bodies, int numBodies, btScalar timeStep);  // can be called in parallel
	virtual void createPredictiveContacts(btScalar timeStep);

	virtual void saveKinematicState(btScalar timeStep);

	void serializeRigidBodies(btSerializer * serializer);

	void serializeDynamicsWorldInfo(btSerializer * serializer);
    
public:
	BT_DECLARE_ALIGNED_ALLOCATOR();

	///this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
	btDiscreteDynamicsWorld(btDispatcher * dispatcher, btBroadphaseInterface * pairCache, btConstraintSolver * constraintSolver, btCollisionConfiguration * collisionConfiguration);

	virtual ~btDiscreteDynamicsWorld();

	///if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's
	virtual int stepSimulation(btScalar timeStep, int maxSubSteps = 1, btScalar fixedTimeStep = btScalar(1.) / btScalar(60.));

    virtual void solveConstraints(btContactSolverInfo & solverInfo);
    
	virtual void synchronizeMotionStates();

	///this can be useful to synchronize a single rigid body -> graphics object
	void synchronizeSingleMotionState(btRigidBody * body);

	virtual void addConstraint(btTypedConstraint * constraint, bool disableCollisionsBetweenLinkedBodies = false);

	virtual void removeConstraint(btTypedConstraint * constraint);

	virtual void addAction(btActionInterface*);

	virtual void removeAction(btActionInterface*);

	btSimulationIslandManager* getSimulationIslandManager()
	{
		return m_islandManager;
	}

	const btSimulationIslandManager* getSimulationIslandManager() const
	{
		return m_islandManager;
	}

	btCollisionWorld* getCollisionWorld()
	{
		return this;
	}

	virtual void setGravity(const btVector3& gravity);

	virtual btVector3 getGravity() const;

	virtual void addCollisionObject(btCollisionObject * collisionObject, int collisionFilterGroup = btBroadphaseProxy::StaticFilter, int collisionFilterMask = btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

	virtual void addRigidBody(btRigidBody * body);

	virtual void addRigidBody(btRigidBody * body, int group, int mask);

	virtual void removeRigidBody(btRigidBody * body);

	///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
	virtual void removeCollisionObject(btCollisionObject * collisionObject);

	virtual void debugDrawConstraint(btTypedConstraint * constraint);

	virtual void debugDrawWorld();

	virtual void setConstraintSolver(btConstraintSolver * solver);

	virtual btConstraintSolver* getConstraintSolver();

	virtual int getNumConstraints() const;

	virtual btTypedConstraint* getConstraint(int index);

	virtual const btTypedConstraint* getConstraint(int index) const;

	virtual btDynamicsWorldType getWorldType() const
	{
		return BT_DISCRETE_DYNAMICS_WORLD;
	}

	///the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
	virtual void clearForces();

	///apply gravity, call this once per timestep
	virtual void applyGravity();

	virtual void setNumTasks(int numTasks)
	{
		(void)numTasks;
	}

	///obsolete, use updateActions instead
	virtual void updateVehicles(btScalar timeStep)
	{
		updateActions(timeStep);
	}

	///obsolete, use addAction instead
	virtual void addVehicle(btActionInterface * vehicle);
	///obsolete, use removeAction instead
	virtual void removeVehicle(btActionInterface * vehicle);
	///obsolete, use addAction instead
	virtual void addCharacter(btActionInterface * character);
	///obsolete, use removeAction instead
	virtual void removeCharacter(btActionInterface * character);

	void setSynchronizeAllMotionStates(bool synchronizeAll)
	{
		m_synchronizeAllMotionStates = synchronizeAll;
	}
	bool getSynchronizeAllMotionStates() const
	{
		return m_synchronizeAllMotionStates;
	}

	void setApplySpeculativeContactRestitution(bool enable)
	{
		m_applySpeculativeContactRestitution = enable;
	}

	bool getApplySpeculativeContactRestitution() const
	{
		return m_applySpeculativeContactRestitution;
	}

	///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
	virtual void serialize(btSerializer * serializer);

	///Interpolate motion state between previous and current transform, instead of current and next transform.
	///This can relieve discontinuities in the rendering, due to penetrations
	void setLatencyMotionStateInterpolation(bool latencyInterpolation)
	{
		m_latencyMotionStateInterpolation = latencyInterpolation;
	}
	bool getLatencyMotionStateInterpolation() const
	{
		return m_latencyMotionStateInterpolation;
	}
    
    btAlignedObjectArray<btRigidBody*>& getNonStaticRigidBodies()
    {
        return m_nonStaticRigidBodies;
    }
    
    const btAlignedObjectArray<btRigidBody*>& getNonStaticRigidBodies() const
    {
        return m_nonStaticRigidBodies;
    }
};

#endif  //BT_DISCRETE_DYNAMICS_WORLD_H





/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

#include "BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h"

//collision detection
#include "BulletCollision/CollisionDispatch/btCollisionDispatcher.h"
#include "BulletCollision/BroadphaseCollision/btSimpleBroadphase.h"
#include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"
#include "BulletCollision/CollisionShapes/btCollisionShape.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"
#include "LinearMath/btTransformUtil.h"
#include "LinearMath/btQuickprof.h"

//rigidbody & constraints
#include "BulletDynamics/Dynamics/btRigidBody.h"
#include "BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h"
#include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
#include "BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h"
#include "BulletDynamics/ConstraintSolver/btHingeConstraint.h"
#include "BulletDynamics/ConstraintSolver/btConeTwistConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h"
#include "BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h"
#include "BulletDynamics/ConstraintSolver/btSliderConstraint.h"
#include "BulletDynamics/ConstraintSolver/btContactConstraint.h"

#include "LinearMath/btIDebugDraw.h"
#include "BulletCollision/CollisionShapes/btSphereShape.h"

#include "BulletDynamics/Dynamics/btActionInterface.h"
#include "LinearMath/btQuickprof.h"
#include "LinearMath/btMotionState.h"

#include "LinearMath/btSerializer.h"

#if 0
btAlignedObjectArray<btVector3> debugContacts;
btAlignedObjectArray<btVector3> debugNormals;
int startHit=2;
int firstHit=startHit;
#endif

SIMD_FORCE_INLINE int btGetConstraintIslandId(const btTypedConstraint* lhs)
{
	int islandId;

	const btCollisionObject& rcolObj0 = lhs->getRigidBodyA();
	const btCollisionObject& rcolObj1 = lhs->getRigidBodyB();
	islandId = rcolObj0.getIslandTag() >= 0 ? rcolObj0.getIslandTag() : rcolObj1.getIslandTag();
	return islandId;
}

class btSortConstraintOnIslandPredicate
{
public:
	bool operator()(const btTypedConstraint* lhs, const btTypedConstraint* rhs) const
	{
		int rIslandId0, lIslandId0;
		rIslandId0 = btGetConstraintIslandId(rhs);
		lIslandId0 = btGetConstraintIslandId(lhs);
		return lIslandId0 < rIslandId0;
	}
};

struct InplaceSolverIslandCallback : public btSimulationIslandManager::IslandCallback
{
	btContactSolverInfo* m_solverInfo;
	btConstraintSolver* m_solver;
	btTypedConstraint** m_sortedConstraints;
	int m_numConstraints;
	btIDebugDraw* m_debugDrawer;
	btDispatcher* m_dispatcher;

	btAlignedObjectArray<btCollisionObject*> m_bodies;
	btAlignedObjectArray<btPersistentManifold*> m_manifolds;
	btAlignedObjectArray<btTypedConstraint*> m_constraints;

	InplaceSolverIslandCallback(
		btConstraintSolver* solver,
		btStackAlloc* stackAlloc,
		btDispatcher* dispatcher)
		: m_solverInfo(NULL),
		  m_solver(solver),
		  m_sortedConstraints(NULL),
		  m_numConstraints(0),
		  m_debugDrawer(NULL),
		  m_dispatcher(dispatcher)
	{
	}

	InplaceSolverIslandCallback& operator=(InplaceSolverIslandCallback& other)
	{
		btAssert(0);
		(void)other;
		return *this;
	}

	SIMD_FORCE_INLINE void setup(btContactSolverInfo* solverInfo, btTypedConstraint** sortedConstraints, int numConstraints, btIDebugDraw* debugDrawer)
	{
		btAssert(solverInfo);
		m_solverInfo = solverInfo;
		m_sortedConstraints = sortedConstraints;
		m_numConstraints = numConstraints;
		m_debugDrawer = debugDrawer;
		m_bodies.resize(0);
		m_manifolds.resize(0);
		m_constraints.resize(0);
	}

	virtual void processIsland(btCollisionObject** bodies, int numBodies, btPersistentManifold** manifolds, int numManifolds, int islandId)
	{
		if (islandId < 0)
		{
			///we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id
			m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, &m_sortedConstraints[0], m_numConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
		}
		else
		{
			//also add all non-contact constraints/joints for this island
			btTypedConstraint** startConstraint = 0;
			int numCurConstraints = 0;
			int i;

			//find the first constraint for this island
			for (i = 0; i < m_numConstraints; i++)
			{
				if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
				{
					startConstraint = &m_sortedConstraints[i];
					break;
				}
			}
			//count the number of constraints in this island
			for (; i < m_numConstraints; i++)
			{
				if (btGetConstraintIslandId(m_sortedConstraints[i]) == islandId)
				{
					numCurConstraints++;
				}
			}

			if (m_solverInfo->m_minimumSolverBatchSize <= 1)
			{
				m_solver->solveGroup(bodies, numBodies, manifolds, numManifolds, startConstraint, numCurConstraints, *m_solverInfo, m_debugDrawer, m_dispatcher);
			}
			else
			{
				for (i = 0; i < numBodies; i++)
					m_bodies.push_back(bodies[i]);
				for (i = 0; i < numManifolds; i++)
					m_manifolds.push_back(manifolds[i]);
				for (i = 0; i < numCurConstraints; i++)
					m_constraints.push_back(startConstraint[i]);
				if ((m_constraints.size() + m_manifolds.size()) > m_solverInfo->m_minimumSolverBatchSize)
				{
					processConstraints();
				}
				else
				{
					//printf("deferred\n");
				}
			}
		}
	}
	void processConstraints()
	{
		btCollisionObject** bodies = m_bodies.size() ? &m_bodies[0] : 0;
		btPersistentManifold** manifold = m_manifolds.size() ? &m_manifolds[0] : 0;
		btTypedConstraint** constraints = m_constraints.size() ? &m_constraints[0] : 0;

		m_solver->solveGroup(bodies, m_bodies.size(), manifold, m_manifolds.size(), constraints, m_constraints.size(), *m_solverInfo, m_debugDrawer, m_dispatcher);
		m_bodies.resize(0);
		m_manifolds.resize(0);
		m_constraints.resize(0);
	}
};

btDiscreteDynamicsWorld::btDiscreteDynamicsWorld(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration)
	: btDynamicsWorld(dispatcher, pairCache, collisionConfiguration),
	  m_sortedConstraints(),
	  m_solverIslandCallback(NULL),
	  m_constraintSolver(constraintSolver),
	  m_gravity(0, -10, 0),
	  m_localTime(0),
	  m_fixedTimeStep(0),
	  m_synchronizeAllMotionStates(false),
	  m_applySpeculativeContactRestitution(false),
	  m_profileTimings(0),
	  m_latencyMotionStateInterpolation(true)

{
	if (!m_constraintSolver)
	{
		void* mem = btAlignedAlloc(sizeof(btSequentialImpulseConstraintSolver), 16);
		m_constraintSolver = new (mem) btSequentialImpulseConstraintSolver;
		m_ownsConstraintSolver = true;
	}
	else
	{
		m_ownsConstraintSolver = false;
	}

	{
		void* mem = btAlignedAlloc(sizeof(btSimulationIslandManager), 16);
		m_islandManager = new (mem) btSimulationIslandManager();
	}

	m_ownsIslandManager = true;

	{
		void* mem = btAlignedAlloc(sizeof(InplaceSolverIslandCallback), 16);
		m_solverIslandCallback = new (mem) InplaceSolverIslandCallback(m_constraintSolver, 0, dispatcher);
	}
}

btDiscreteDynamicsWorld::~btDiscreteDynamicsWorld()
{
	//only delete it when we created it
	if (m_ownsIslandManager)
	{
		m_islandManager->~btSimulationIslandManager();
		btAlignedFree(m_islandManager);
	}
	if (m_solverIslandCallback)
	{
		m_solverIslandCallback->~InplaceSolverIslandCallback();
		btAlignedFree(m_solverIslandCallback);
	}
	if (m_ownsConstraintSolver)
	{
		m_constraintSolver->~btConstraintSolver();
		btAlignedFree(m_constraintSolver);
	}
}

void btDiscreteDynamicsWorld::saveKinematicState(btScalar timeStep)
{
	///would like to iterate over m_nonStaticRigidBodies, but unfortunately old API allows
	///to switch status _after_ adding kinematic objects to the world
	///fix it for Bullet 3.x release
	for (int i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		btRigidBody* body = btRigidBody::upcast(colObj);
		if (body && body->getActivationState() != ISLAND_SLEEPING)
		{
			if (body->isKinematicObject())
			{
				//to calculate velocities next frame
				body->saveKinematicState(timeStep);
			}
		}
	}
}

void btDiscreteDynamicsWorld::debugDrawWorld()
{
	BT_PROFILE("debugDrawWorld");

	btCollisionWorld::debugDrawWorld();

	bool drawConstraints = false;
	if (getDebugDrawer())
	{
		int mode = getDebugDrawer()->getDebugMode();
		if (mode & (btIDebugDraw::DBG_DrawConstraints | btIDebugDraw::DBG_DrawConstraintLimits))
		{
			drawConstraints = true;
		}
	}
	if (drawConstraints)
	{
		for (int i = getNumConstraints() - 1; i >= 0; i--)
		{
			btTypedConstraint* constraint = getConstraint(i);
			debugDrawConstraint(constraint);
		}
	}

	if (getDebugDrawer() && (getDebugDrawer()->getDebugMode() & (btIDebugDraw::DBG_DrawWireframe | btIDebugDraw::DBG_DrawAabb | btIDebugDraw::DBG_DrawNormals)))
	{
		int i;

		if (getDebugDrawer() && getDebugDrawer()->getDebugMode())
		{
			for (i = 0; i < m_actions.size(); i++)
			{
				m_actions[i]->debugDraw(m_debugDrawer);
			}
		}
	}
	if (getDebugDrawer())
		getDebugDrawer()->flushLines();
}

void btDiscreteDynamicsWorld::clearForces()
{
	///@todo: iterate over awake simulation islands!
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		//need to check if next line is ok
		//it might break backward compatibility (people applying forces on sleeping objects get never cleared and accumulate on wake-up
		body->clearForces();
	}
}

///apply gravity, call this once per timestep
void btDiscreteDynamicsWorld::applyGravity()
{
	///@todo: iterate over awake simulation islands!
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body->isActive())
		{
			body->applyGravity();
		}
	}
}

void btDiscreteDynamicsWorld::synchronizeSingleMotionState(btRigidBody* body)
{
	btAssert(body);

	if (body->getMotionState() && !body->isStaticOrKinematicObject())
	{
		//we need to call the update at least once, even for sleeping objects
		//otherwise the 'graphics' transform never updates properly
		///@todo: add 'dirty' flag
		//if (body->getActivationState() != ISLAND_SLEEPING)
		{
			btTransform interpolatedTransform;
			btTransformUtil::integrateTransform(body->getInterpolationWorldTransform(),
												body->getInterpolationLinearVelocity(), body->getInterpolationAngularVelocity(),
												(m_latencyMotionStateInterpolation && m_fixedTimeStep) ? m_localTime - m_fixedTimeStep : m_localTime * body->getHitFraction(),
												interpolatedTransform);
			body->getMotionState()->setWorldTransform(interpolatedTransform);
		}
	}
}

void btDiscreteDynamicsWorld::synchronizeMotionStates()
{
	//	BT_PROFILE("synchronizeMotionStates");
	if (m_synchronizeAllMotionStates)
	{
		//iterate  over all collision objects
		for (int i = 0; i < m_collisionObjects.size(); i++)
		{
			btCollisionObject* colObj = m_collisionObjects[i];
			btRigidBody* body = btRigidBody::upcast(colObj);
			if (body)
				synchronizeSingleMotionState(body);
		}
	}
	else
	{
		//iterate over all active rigid bodies
		for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
		{
			btRigidBody* body = m_nonStaticRigidBodies[i];
			if (body->isActive())
				synchronizeSingleMotionState(body);
		}
	}
}

int btDiscreteDynamicsWorld::stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep)
{
	startProfiling(timeStep);

	int numSimulationSubSteps = 0;

	if (maxSubSteps)
	{
		//fixed timestep with interpolation
		m_fixedTimeStep = fixedTimeStep;
		m_localTime += timeStep;
		if (m_localTime >= fixedTimeStep)
		{
			numSimulationSubSteps = int(m_localTime / fixedTimeStep);
			m_localTime -= numSimulationSubSteps * fixedTimeStep;
		}
	}
	else
	{
		//variable timestep
		fixedTimeStep = timeStep;
		m_localTime = m_latencyMotionStateInterpolation ? 0 : timeStep;
		m_fixedTimeStep = 0;
		if (btFuzzyZero(timeStep))
		{
			numSimulationSubSteps = 0;
			maxSubSteps = 0;
		}
		else
		{
			numSimulationSubSteps = 1;
			maxSubSteps = 1;
		}
	}

	//process some debugging flags
	if (getDebugDrawer())
	{
		btIDebugDraw* debugDrawer = getDebugDrawer();
		gDisableDeactivation = (debugDrawer->getDebugMode() & btIDebugDraw::DBG_NoDeactivation) != 0;
	}
	if (numSimulationSubSteps)
	{
		//clamp the number of substeps, to prevent simulation grinding spiralling down to a halt
		int clampedSimulationSteps = (numSimulationSubSteps > maxSubSteps) ? maxSubSteps : numSimulationSubSteps;

		saveKinematicState(fixedTimeStep * clampedSimulationSteps);

		applyGravity();

		for (int i = 0; i < clampedSimulationSteps; i++)
		{
			internalSingleStepSimulation(fixedTimeStep);
			synchronizeMotionStates();
		}
	}
	else
	{
		synchronizeMotionStates();
	}

	clearForces();

#ifndef BT_NO_PROFILE
	CProfileManager::Increment_Frame_Counter();
#endif  //BT_NO_PROFILE

	return numSimulationSubSteps;
}

void btDiscreteDynamicsWorld::internalSingleStepSimulation(btScalar timeStep)
{
	BT_PROFILE("internalSingleStepSimulation");

	if (0 != m_internalPreTickCallback)
	{
		(*m_internalPreTickCallback)(this, timeStep);
	}

	///apply gravity, predict motion
	predictUnconstraintMotion(timeStep);

	btDispatcherInfo& dispatchInfo = getDispatchInfo();

	dispatchInfo.m_timeStep = timeStep;
	dispatchInfo.m_stepCount = 0;
	dispatchInfo.m_debugDraw = getDebugDrawer();

	createPredictiveContacts(timeStep);

	///perform collision detection
	performDiscreteCollisionDetection();

	calculateSimulationIslands();

	getSolverInfo().m_timeStep = timeStep;

	///solve contact and other joint constraints
	solveConstraints(getSolverInfo());

	///CallbackTriggers();

	///integrate transforms

	integrateTransforms(timeStep);

	///update vehicle simulation
	updateActions(timeStep);

	updateActivationState(timeStep);

	if (0 != m_internalTickCallback)
	{
		(*m_internalTickCallback)(this, timeStep);
	}
}

void btDiscreteDynamicsWorld::setGravity(const btVector3& gravity)
{
	m_gravity = gravity;
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body->isActive() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
		{
			body->setGravity(gravity);
		}
	}
}

btVector3 btDiscreteDynamicsWorld::getGravity() const
{
	return m_gravity;
}

void btDiscreteDynamicsWorld::addCollisionObject(btCollisionObject* collisionObject, int collisionFilterGroup, int collisionFilterMask)
{
	btCollisionWorld::addCollisionObject(collisionObject, collisionFilterGroup, collisionFilterMask);
}

void btDiscreteDynamicsWorld::removeCollisionObject(btCollisionObject* collisionObject)
{
	btRigidBody* body = btRigidBody::upcast(collisionObject);
	if (body)
		removeRigidBody(body);
	else
		btCollisionWorld::removeCollisionObject(collisionObject);
}

void btDiscreteDynamicsWorld::removeRigidBody(btRigidBody* body)
{
	m_nonStaticRigidBodies.remove(body);
	btCollisionWorld::removeCollisionObject(body);
}

void btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body)
{
	if (!body->isStaticOrKinematicObject() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
	{
		body->setGravity(m_gravity);
	}

	if (body->getCollisionShape())
	{
		if (!body->isStaticObject())
		{
			m_nonStaticRigidBodies.push_back(body);
		}
		else
		{
			body->setActivationState(ISLAND_SLEEPING);
		}

		bool isDynamic = !(body->isStaticObject() || body->isKinematicObject());
		int collisionFilterGroup = isDynamic ? int(btBroadphaseProxy::DefaultFilter) : int(btBroadphaseProxy::StaticFilter);
		int collisionFilterMask = isDynamic ? int(btBroadphaseProxy::AllFilter) : int(btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter);

		addCollisionObject(body, collisionFilterGroup, collisionFilterMask);
	}
}

void btDiscreteDynamicsWorld::addRigidBody(btRigidBody* body, int group, int mask)
{
	if (!body->isStaticOrKinematicObject() && !(body->getFlags() & BT_DISABLE_WORLD_GRAVITY))
	{
		body->setGravity(m_gravity);
	}

	if (body->getCollisionShape())
	{
		if (!body->isStaticObject())
		{
			m_nonStaticRigidBodies.push_back(body);
		}
		else
		{
			body->setActivationState(ISLAND_SLEEPING);
		}
		addCollisionObject(body, group, mask);
	}
}

void btDiscreteDynamicsWorld::updateActions(btScalar timeStep)
{
	BT_PROFILE("updateActions");

	for (int i = 0; i < m_actions.size(); i++)
	{
		m_actions[i]->updateAction(this, timeStep);
	}
}

void btDiscreteDynamicsWorld::updateActivationState(btScalar timeStep)
{
	BT_PROFILE("updateActivationState");

	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (body)
		{
			body->updateDeactivation(timeStep);

			if (body->wantsSleeping())
			{
				if (body->isStaticOrKinematicObject())
				{
					body->setActivationState(ISLAND_SLEEPING);
				}
				else
				{
					if (body->getActivationState() == ACTIVE_TAG)
						body->setActivationState(WANTS_DEACTIVATION);
					if (body->getActivationState() == ISLAND_SLEEPING)
					{
						body->setAngularVelocity(btVector3(0, 0, 0));
						body->setLinearVelocity(btVector3(0, 0, 0));
					}
				}
			}
			else
			{
				if (body->getActivationState() != DISABLE_DEACTIVATION)
					body->setActivationState(ACTIVE_TAG);
			}
		}
	}
}

void btDiscreteDynamicsWorld::addConstraint(btTypedConstraint* constraint, bool disableCollisionsBetweenLinkedBodies)
{
	m_constraints.push_back(constraint);
	//Make sure the two bodies of a type constraint are different (possibly add this to the btTypedConstraint constructor?)
	btAssert(&constraint->getRigidBodyA() != &constraint->getRigidBodyB());

	if (disableCollisionsBetweenLinkedBodies)
	{
		constraint->getRigidBodyA().addConstraintRef(constraint);
		constraint->getRigidBodyB().addConstraintRef(constraint);
	}
}

void btDiscreteDynamicsWorld::removeConstraint(btTypedConstraint* constraint)
{
	m_constraints.remove(constraint);
	constraint->getRigidBodyA().removeConstraintRef(constraint);
	constraint->getRigidBodyB().removeConstraintRef(constraint);
}

void btDiscreteDynamicsWorld::addAction(btActionInterface* action)
{
	m_actions.push_back(action);
}

void btDiscreteDynamicsWorld::removeAction(btActionInterface* action)
{
	m_actions.remove(action);
}

void btDiscreteDynamicsWorld::addVehicle(btActionInterface* vehicle)
{
	addAction(vehicle);
}

void btDiscreteDynamicsWorld::removeVehicle(btActionInterface* vehicle)
{
	removeAction(vehicle);
}

void btDiscreteDynamicsWorld::addCharacter(btActionInterface* character)
{
	addAction(character);
}

void btDiscreteDynamicsWorld::removeCharacter(btActionInterface* character)
{
	removeAction(character);
}

void btDiscreteDynamicsWorld::solveConstraints(btContactSolverInfo& solverInfo)
{
	BT_PROFILE("solveConstraints");

	m_sortedConstraints.resize(m_constraints.size());
	int i;
	for (i = 0; i < getNumConstraints(); i++)
	{
		m_sortedConstraints[i] = m_constraints[i];
	}

	//	btAssert(0);

	m_sortedConstraints.quickSort(btSortConstraintOnIslandPredicate());

	btTypedConstraint** constraintsPtr = getNumConstraints() ? &m_sortedConstraints[0] : 0;

	m_solverIslandCallback->setup(&solverInfo, constraintsPtr, m_sortedConstraints.size(), getDebugDrawer());
	m_constraintSolver->prepareSolve(getCollisionWorld()->getNumCollisionObjects(), getCollisionWorld()->getDispatcher()->getNumManifolds());

	/// solve all the constraints for this island
	m_islandManager->buildAndProcessIslands(getCollisionWorld()->getDispatcher(), getCollisionWorld(), m_solverIslandCallback);

	m_solverIslandCallback->processConstraints();

	m_constraintSolver->allSolved(solverInfo, m_debugDrawer);
}

void btDiscreteDynamicsWorld::calculateSimulationIslands()
{
	BT_PROFILE("calculateSimulationIslands");

	getSimulationIslandManager()->updateActivationState(getCollisionWorld(), getCollisionWorld()->getDispatcher());

	{
		//merge islands based on speculative contact manifolds too
		for (int i = 0; i < this->m_predictiveManifolds.size(); i++)
		{
			btPersistentManifold* manifold = m_predictiveManifolds[i];

			const btCollisionObject* colObj0 = manifold->getBody0();
			const btCollisionObject* colObj1 = manifold->getBody1();

			if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
				((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
			{
				getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
			}
		}
	}

	{
		int i;
		int numConstraints = int(m_constraints.size());
		for (i = 0; i < numConstraints; i++)
		{
			btTypedConstraint* constraint = m_constraints[i];
			if (constraint->isEnabled())
			{
				const btRigidBody* colObj0 = &constraint->getRigidBodyA();
				const btRigidBody* colObj1 = &constraint->getRigidBodyB();

				if (((colObj0) && (!(colObj0)->isStaticOrKinematicObject())) &&
					((colObj1) && (!(colObj1)->isStaticOrKinematicObject())))
				{
					getSimulationIslandManager()->getUnionFind().unite((colObj0)->getIslandTag(), (colObj1)->getIslandTag());
				}
			}
		}
	}

	//Store the island id in each body
	getSimulationIslandManager()->storeIslandActivationState(getCollisionWorld());
}

class btClosestNotMeConvexResultCallback : public btCollisionWorld::ClosestConvexResultCallback
{
public:
	btCollisionObject* m_me;
	btScalar m_allowedPenetration;
	btOverlappingPairCache* m_pairCache;
	btDispatcher* m_dispatcher;

public:
	btClosestNotMeConvexResultCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btCollisionWorld::ClosestConvexResultCallback(fromA, toA),
																																										   m_me(me),
																																										   m_allowedPenetration(0.0f),
																																										   m_pairCache(pairCache),
																																										   m_dispatcher(dispatcher)
	{
	}

	virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult, bool normalInWorldSpace)
	{
		if (convexResult.m_hitCollisionObject == m_me)
			return 1.0f;

		//ignore result if there is no contact response
		if (!convexResult.m_hitCollisionObject->hasContactResponse())
			return 1.0f;

		btVector3 linVelA, linVelB;
		linVelA = m_convexToWorld - m_convexFromWorld;
		linVelB = btVector3(0, 0, 0);  //toB.getOrigin()-fromB.getOrigin();

		btVector3 relativeVelocity = (linVelA - linVelB);
		//don't report time of impact for motion away from the contact normal (or causes minor penetration)
		if (convexResult.m_hitNormalLocal.dot(relativeVelocity) >= -m_allowedPenetration)
			return 1.f;

		return ClosestConvexResultCallback::addSingleResult(convexResult, normalInWorldSpace);
	}

	virtual bool needsCollision(btBroadphaseProxy* proxy0) const
	{
		//don't collide with itself
		if (proxy0->m_clientObject == m_me)
			return false;

		///don't do CCD when the collision filters are not matching
		if (!ClosestConvexResultCallback::needsCollision(proxy0))
			return false;
		if (m_pairCache->getOverlapFilterCallback()) {
			btBroadphaseProxy* proxy1 = m_me->getBroadphaseHandle();
			bool collides = m_pairCache->needsBroadphaseCollision(proxy0, proxy1);
			if (!collides)
			{
				return false;
			}
		}

		btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;

		if (!m_dispatcher->needsCollision(m_me, otherObj))
			return false;

		//call needsResponse, see http://code.google.com/p/bullet/issues/detail?id=179
		if (m_dispatcher->needsResponse(m_me, otherObj))
		{
#if 0
			///don't do CCD when there are already contact points (touching contact/penetration)
			btAlignedObjectArray<btPersistentManifold*> manifoldArray;
			btBroadphasePair* collisionPair = m_pairCache->findPair(m_me->getBroadphaseHandle(),proxy0);
			if (collisionPair)
			{
				if (collisionPair->m_algorithm)
				{
					manifoldArray.resize(0);
					collisionPair->m_algorithm->getAllContactManifolds(manifoldArray);
					for (int j=0;j<manifoldArray.size();j++)
					{
						btPersistentManifold* manifold = manifoldArray[j];
						if (manifold->getNumContacts()>0)
							return false;
					}
				}
			}
#endif
			return true;
		}

		return false;
	}
};

///internal debugging variable. this value shouldn't be too high
int gNumClampedCcdMotions = 0;

void btDiscreteDynamicsWorld::createPredictiveContactsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
	btTransform predictedTrans;
	for (int i = 0; i < numBodies; i++)
	{
		btRigidBody* body = bodies[i];
		body->setHitFraction(1.f);

		if (body->isActive() && (!body->isStaticOrKinematicObject()))
		{
			body->predictIntegratedTransform(timeStep, predictedTrans);

			btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();

			if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
			{
				BT_PROFILE("predictive convexSweepTest");
				if (body->getCollisionShape()->isConvex())
				{
					gNumClampedCcdMotions++;
#ifdef PREDICTIVE_CONTACT_USE_STATIC_ONLY
					class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
					{
					public:
						StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
						{
						}

						virtual bool needsCollision(btBroadphaseProxy* proxy0) const
						{
							btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
							if (!otherObj->isStaticOrKinematicObject())
								return false;
							return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
						}
					};

					StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
					btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
					//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					btSphereShape tmpSphere(body->getCcdSweptSphereRadius());  //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

					sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
					sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
					btTransform modifiedPredictedTrans = predictedTrans;
					modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

					convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
					if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
					{
						btVector3 distVec = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()) * sweepResults.m_closestHitFraction;
						btScalar distance = distVec.dot(-sweepResults.m_hitNormalWorld);

						btMutexLock(&m_predictiveManifoldsMutex);
						btPersistentManifold* manifold = m_dispatcher1->getNewManifold(body, sweepResults.m_hitCollisionObject);
						m_predictiveManifolds.push_back(manifold);
						btMutexUnlock(&m_predictiveManifoldsMutex);

						btVector3 worldPointB = body->getWorldTransform().getOrigin() + distVec;
						btVector3 localPointB = sweepResults.m_hitCollisionObject->getWorldTransform().inverse() * worldPointB;

						btManifoldPoint newPoint(btVector3(0, 0, 0), localPointB, sweepResults.m_hitNormalWorld, distance);

						bool isPredictive = true;
						int index = manifold->addManifoldPoint(newPoint, isPredictive);
						btManifoldPoint& pt = manifold->getContactPoint(index);
						pt.m_combinedRestitution = 0;
						pt.m_combinedFriction = gCalculateCombinedFrictionCallback(body, sweepResults.m_hitCollisionObject);
						pt.m_positionWorldOnA = body->getWorldTransform().getOrigin();
						pt.m_positionWorldOnB = worldPointB;
					}
				}
			}
		}
	}
}

void btDiscreteDynamicsWorld::releasePredictiveContacts()
{
	BT_PROFILE("release predictive contact manifolds");

	for (int i = 0; i < m_predictiveManifolds.size(); i++)
	{
		btPersistentManifold* manifold = m_predictiveManifolds[i];
		this->m_dispatcher1->releaseManifold(manifold);
	}
	m_predictiveManifolds.clear();
}

void btDiscreteDynamicsWorld::createPredictiveContacts(btScalar timeStep)
{
	BT_PROFILE("createPredictiveContacts");
	releasePredictiveContacts();
	if (m_nonStaticRigidBodies.size() > 0)
	{
		createPredictiveContactsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
	}
}

void btDiscreteDynamicsWorld::integrateTransformsInternal(btRigidBody** bodies, int numBodies, btScalar timeStep)
{
	btTransform predictedTrans;
	for (int i = 0; i < numBodies; i++)
	{
		btRigidBody* body = bodies[i];
		body->setHitFraction(1.f);

		if (body->isActive() && (!body->isStaticOrKinematicObject()))
		{
			body->predictIntegratedTransform(timeStep, predictedTrans);

			btScalar squareMotion = (predictedTrans.getOrigin() - body->getWorldTransform().getOrigin()).length2();

			if (getDispatchInfo().m_useContinuous && body->getCcdSquareMotionThreshold() && body->getCcdSquareMotionThreshold() < squareMotion)
			{
				BT_PROFILE("CCD motion clamping");
				if (body->getCollisionShape()->isConvex())
				{
					gNumClampedCcdMotions++;
#ifdef USE_STATIC_ONLY
					class StaticOnlyCallback : public btClosestNotMeConvexResultCallback
					{
					public:
						StaticOnlyCallback(btCollisionObject* me, const btVector3& fromA, const btVector3& toA, btOverlappingPairCache* pairCache, btDispatcher* dispatcher) : btClosestNotMeConvexResultCallback(me, fromA, toA, pairCache, dispatcher)
						{
						}

						virtual bool needsCollision(btBroadphaseProxy* proxy0) const
						{
							btCollisionObject* otherObj = (btCollisionObject*)proxy0->m_clientObject;
							if (!otherObj->isStaticOrKinematicObject())
								return false;
							return btClosestNotMeConvexResultCallback::needsCollision(proxy0);
						}
					};

					StaticOnlyCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#else
					btClosestNotMeConvexResultCallback sweepResults(body, body->getWorldTransform().getOrigin(), predictedTrans.getOrigin(), getBroadphase()->getOverlappingPairCache(), getDispatcher());
#endif
					//btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					btSphereShape tmpSphere(body->getCcdSweptSphereRadius());  //btConvexShape* convexShape = static_cast<btConvexShape*>(body->getCollisionShape());
					sweepResults.m_allowedPenetration = getDispatchInfo().m_allowedCcdPenetration;

					sweepResults.m_collisionFilterGroup = body->getBroadphaseProxy()->m_collisionFilterGroup;
					sweepResults.m_collisionFilterMask = body->getBroadphaseProxy()->m_collisionFilterMask;
					btTransform modifiedPredictedTrans = predictedTrans;
					modifiedPredictedTrans.setBasis(body->getWorldTransform().getBasis());

					convexSweepTest(&tmpSphere, body->getWorldTransform(), modifiedPredictedTrans, sweepResults);
					if (sweepResults.hasHit() && (sweepResults.m_closestHitFraction < 1.f))
					{
						//printf("clamped integration to hit fraction = %f\n",fraction);
						body->setHitFraction(sweepResults.m_closestHitFraction);
						body->predictIntegratedTransform(timeStep * body->getHitFraction(), predictedTrans);
						body->setHitFraction(0.f);
						body->proceedToTransform(predictedTrans);

#if 0
						btVector3 linVel = body->getLinearVelocity();

						btScalar maxSpeed = body->getCcdMotionThreshold()/getSolverInfo().m_timeStep;
						btScalar maxSpeedSqr = maxSpeed*maxSpeed;
						if (linVel.length2()>maxSpeedSqr)
						{
							linVel.normalize();
							linVel*= maxSpeed;
							body->setLinearVelocity(linVel);
							btScalar ms2 = body->getLinearVelocity().length2();
							body->predictIntegratedTransform(timeStep, predictedTrans);

							btScalar sm2 = (predictedTrans.getOrigin()-body->getWorldTransform().getOrigin()).length2();
							btScalar smt = body->getCcdSquareMotionThreshold();
							printf("sm2=%f\n",sm2);
						}
#else

						//don't apply the collision response right now, it will happen next frame
						//if you really need to, you can uncomment next 3 lines. Note that is uses zero restitution.
						//btScalar appliedImpulse = 0.f;
						//btScalar depth = 0.f;
						//appliedImpulse = resolveSingleCollision(body,(btCollisionObject*)sweepResults.m_hitCollisionObject,sweepResults.m_hitPointWorld,sweepResults.m_hitNormalWorld,getSolverInfo(), depth);

#endif

						continue;
					}
				}
			}

			body->proceedToTransform(predictedTrans);
		}
	}
}

void btDiscreteDynamicsWorld::integrateTransforms(btScalar timeStep)
{
	BT_PROFILE("integrateTransforms");
	if (m_nonStaticRigidBodies.size() > 0)
	{
		integrateTransformsInternal(&m_nonStaticRigidBodies[0], m_nonStaticRigidBodies.size(), timeStep);
	}

	///this should probably be switched on by default, but it is not well tested yet
	if (m_applySpeculativeContactRestitution)
	{
		BT_PROFILE("apply speculative contact restitution");
		for (int i = 0; i < m_predictiveManifolds.size(); i++)
		{
			btPersistentManifold* manifold = m_predictiveManifolds[i];
			btRigidBody* body0 = btRigidBody::upcast((btCollisionObject*)manifold->getBody0());
			btRigidBody* body1 = btRigidBody::upcast((btCollisionObject*)manifold->getBody1());

			for (int p = 0; p < manifold->getNumContacts(); p++)
			{
				const btManifoldPoint& pt = manifold->getContactPoint(p);
				btScalar combinedRestitution = gCalculateCombinedRestitutionCallback(body0, body1);

				if (combinedRestitution > 0 && pt.m_appliedImpulse != 0.f)
				//if (pt.getDistance()>0 && combinedRestitution>0 && pt.m_appliedImpulse != 0.f)
				{
					btVector3 imp = -pt.m_normalWorldOnB * pt.m_appliedImpulse * combinedRestitution;

					const btVector3& pos1 = pt.getPositionWorldOnA();
					const btVector3& pos2 = pt.getPositionWorldOnB();

					btVector3 rel_pos0 = pos1 - body0->getWorldTransform().getOrigin();
					btVector3 rel_pos1 = pos2 - body1->getWorldTransform().getOrigin();

					if (body0)
						body0->applyImpulse(imp, rel_pos0);
					if (body1)
						body1->applyImpulse(-imp, rel_pos1);
				}
			}
		}
	}
}

void btDiscreteDynamicsWorld::predictUnconstraintMotion(btScalar timeStep)
{
	BT_PROFILE("predictUnconstraintMotion");
	for (int i = 0; i < m_nonStaticRigidBodies.size(); i++)
	{
		btRigidBody* body = m_nonStaticRigidBodies[i];
		if (!body->isStaticOrKinematicObject())
		{
			//don't integrate/update velocities here, it happens in the constraint solver

			body->applyDamping(timeStep);

			body->predictIntegratedTransform(timeStep, body->getInterpolationWorldTransform());
		}
	}
}

void btDiscreteDynamicsWorld::startProfiling(btScalar timeStep)
{
	(void)timeStep;

#ifndef BT_NO_PROFILE
	CProfileManager::Reset();
#endif  //BT_NO_PROFILE
}

void btDiscreteDynamicsWorld::debugDrawConstraint(btTypedConstraint* constraint)
{
	bool drawFrames = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraints) != 0;
	bool drawLimits = (getDebugDrawer()->getDebugMode() & btIDebugDraw::DBG_DrawConstraintLimits) != 0;
	btScalar dbgDrawSize = constraint->getDbgDrawSize();
	if (dbgDrawSize <= btScalar(0.f))
	{
		return;
	}

	switch (constraint->getConstraintType())
	{
		case POINT2POINT_CONSTRAINT_TYPE:
		{
			btPoint2PointConstraint* p2pC = (btPoint2PointConstraint*)constraint;
			btTransform tr;
			tr.setIdentity();
			btVector3 pivot = p2pC->getPivotInA();
			pivot = p2pC->getRigidBodyA().getCenterOfMassTransform() * pivot;
			tr.setOrigin(pivot);
			getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			// that ideally should draw the same frame
			pivot = p2pC->getPivotInB();
			pivot = p2pC->getRigidBodyB().getCenterOfMassTransform() * pivot;
			tr.setOrigin(pivot);
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
		}
		break;
		case HINGE_CONSTRAINT_TYPE:
		{
			btHingeConstraint* pHinge = (btHingeConstraint*)constraint;
			btTransform tr = pHinge->getRigidBodyA().getCenterOfMassTransform() * pHinge->getAFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pHinge->getRigidBodyB().getCenterOfMassTransform() * pHinge->getBFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			btScalar minAng = pHinge->getLowerLimit();
			btScalar maxAng = pHinge->getUpperLimit();
			if (minAng == maxAng)
			{
				break;
			}
			bool drawSect = true;
			if (!pHinge->hasLimit())
			{
				minAng = btScalar(0.f);
				maxAng = SIMD_2_PI;
				drawSect = false;
			}
			if (drawLimits)
			{
				btVector3& center = tr.getOrigin();
				btVector3 normal = tr.getBasis().getColumn(2);
				btVector3 axis = tr.getBasis().getColumn(0);
				getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, minAng, maxAng, btVector3(0, 0, 0), drawSect);
			}
		}
		break;
		case CONETWIST_CONSTRAINT_TYPE:
		{
			btConeTwistConstraint* pCT = (btConeTwistConstraint*)constraint;
			btTransform tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				//const btScalar length = btScalar(5);
				const btScalar length = dbgDrawSize;
				static int nSegments = 8 * 4;
				btScalar fAngleInRadians = btScalar(2. * 3.1415926) * (btScalar)(nSegments - 1) / btScalar(nSegments);
				btVector3 pPrev = pCT->GetPointForAngle(fAngleInRadians, length);
				pPrev = tr * pPrev;
				for (int i = 0; i < nSegments; i++)
				{
					fAngleInRadians = btScalar(2. * 3.1415926) * (btScalar)i / btScalar(nSegments);
					btVector3 pCur = pCT->GetPointForAngle(fAngleInRadians, length);
					pCur = tr * pCur;
					getDebugDrawer()->drawLine(pPrev, pCur, btVector3(0, 0, 0));

					if (i % (nSegments / 8) == 0)
						getDebugDrawer()->drawLine(tr.getOrigin(), pCur, btVector3(0, 0, 0));

					pPrev = pCur;
				}
				btScalar tws = pCT->getTwistSpan();
				btScalar twa = pCT->getTwistAngle();
				bool useFrameB = (pCT->getRigidBodyB().getInvMass() > btScalar(0.f));
				if (useFrameB)
				{
					tr = pCT->getRigidBodyB().getCenterOfMassTransform() * pCT->getBFrame();
				}
				else
				{
					tr = pCT->getRigidBodyA().getCenterOfMassTransform() * pCT->getAFrame();
				}
				btVector3 pivot = tr.getOrigin();
				btVector3 normal = tr.getBasis().getColumn(0);
				btVector3 axis1 = tr.getBasis().getColumn(1);
				getDebugDrawer()->drawArc(pivot, normal, axis1, dbgDrawSize, dbgDrawSize, -twa - tws, -twa + tws, btVector3(0, 0, 0), true);
			}
		}
		break;
		case D6_SPRING_CONSTRAINT_TYPE:
		case D6_CONSTRAINT_TYPE:
		{
			btGeneric6DofConstraint* p6DOF = (btGeneric6DofConstraint*)constraint;
			btTransform tr = p6DOF->getCalculatedTransformA();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = p6DOF->getCalculatedTransformB();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				tr = p6DOF->getCalculatedTransformA();
				const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
				btVector3 up = tr.getBasis().getColumn(2);
				btVector3 axis = tr.getBasis().getColumn(0);
				btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
				btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
				btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
				btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
				getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
				axis = tr.getBasis().getColumn(1);
				btScalar ay = p6DOF->getAngle(1);
				btScalar az = p6DOF->getAngle(2);
				btScalar cy = btCos(ay);
				btScalar sy = btSin(ay);
				btScalar cz = btCos(az);
				btScalar sz = btSin(az);
				btVector3 ref;
				ref[0] = cy * cz * axis[0] + cy * sz * axis[1] - sy * axis[2];
				ref[1] = -sz * axis[0] + cz * axis[1];
				ref[2] = cz * sy * axis[0] + sz * sy * axis[1] + cy * axis[2];
				tr = p6DOF->getCalculatedTransformB();
				btVector3 normal = -tr.getBasis().getColumn(0);
				btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
				btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
				if (minFi > maxFi)
				{
					getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
				}
				else if (minFi < maxFi)
				{
					getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
				}
				tr = p6DOF->getCalculatedTransformA();
				btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
				btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
				getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
			}
		}
		break;
		///note: the code for D6_SPRING_2_CONSTRAINT_TYPE is identical to D6_CONSTRAINT_TYPE, the D6_CONSTRAINT_TYPE+D6_SPRING_CONSTRAINT_TYPE will likely become obsolete/deprecated at some stage
		case D6_SPRING_2_CONSTRAINT_TYPE:
		{
			{
				btGeneric6DofSpring2Constraint* p6DOF = (btGeneric6DofSpring2Constraint*)constraint;
				btTransform tr = p6DOF->getCalculatedTransformA();
				if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
				tr = p6DOF->getCalculatedTransformB();
				if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
				if (drawLimits)
				{
					tr = p6DOF->getCalculatedTransformA();
					const btVector3& center = p6DOF->getCalculatedTransformB().getOrigin();
					btVector3 up = tr.getBasis().getColumn(2);
					btVector3 axis = tr.getBasis().getColumn(0);
					btScalar minTh = p6DOF->getRotationalLimitMotor(1)->m_loLimit;
					btScalar maxTh = p6DOF->getRotationalLimitMotor(1)->m_hiLimit;
					if (minTh <= maxTh)
					{
						btScalar minPs = p6DOF->getRotationalLimitMotor(2)->m_loLimit;
						btScalar maxPs = p6DOF->getRotationalLimitMotor(2)->m_hiLimit;
						getDebugDrawer()->drawSpherePatch(center, up, axis, dbgDrawSize * btScalar(.9f), minTh, maxTh, minPs, maxPs, btVector3(0, 0, 0));
					}
					axis = tr.getBasis().getColumn(1);
					btScalar ay = p6DOF->getAngle(1);
					btScalar az = p6DOF->getAngle(2);
					btScalar cy = btCos(ay);
					btScalar sy = btSin(ay);
					btScalar cz = btCos(az);
					btScalar sz = btSin(az);
					btVector3 ref;
					ref[0] = cy * cz * axis[0] + cy * sz * axis[1] - sy * axis[2];
					ref[1] = -sz * axis[0] + cz * axis[1];
					ref[2] = cz * sy * axis[0] + sz * sy * axis[1] + cy * axis[2];
					tr = p6DOF->getCalculatedTransformB();
					btVector3 normal = -tr.getBasis().getColumn(0);
					btScalar minFi = p6DOF->getRotationalLimitMotor(0)->m_loLimit;
					btScalar maxFi = p6DOF->getRotationalLimitMotor(0)->m_hiLimit;
					if (minFi > maxFi)
					{
						getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, -SIMD_PI, SIMD_PI, btVector3(0, 0, 0), false);
					}
					else if (minFi < maxFi)
					{
						getDebugDrawer()->drawArc(center, normal, ref, dbgDrawSize, dbgDrawSize, minFi, maxFi, btVector3(0, 0, 0), true);
					}
					tr = p6DOF->getCalculatedTransformA();
					btVector3 bbMin = p6DOF->getTranslationalLimitMotor()->m_lowerLimit;
					btVector3 bbMax = p6DOF->getTranslationalLimitMotor()->m_upperLimit;
					getDebugDrawer()->drawBox(bbMin, bbMax, tr, btVector3(0, 0, 0));
				}
			}
			break;
		}
		case SLIDER_CONSTRAINT_TYPE:
		{
			btSliderConstraint* pSlider = (btSliderConstraint*)constraint;
			btTransform tr = pSlider->getCalculatedTransformA();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			tr = pSlider->getCalculatedTransformB();
			if (drawFrames) getDebugDrawer()->drawTransform(tr, dbgDrawSize);
			if (drawLimits)
			{
				btTransform tr = pSlider->getUseLinearReferenceFrameA() ? pSlider->getCalculatedTransformA() : pSlider->getCalculatedTransformB();
				btVector3 li_min = tr * btVector3(pSlider->getLowerLinLimit(), 0.f, 0.f);
				btVector3 li_max = tr * btVector3(pSlider->getUpperLinLimit(), 0.f, 0.f);
				getDebugDrawer()->drawLine(li_min, li_max, btVector3(0, 0, 0));
				btVector3 normal = tr.getBasis().getColumn(0);
				btVector3 axis = tr.getBasis().getColumn(1);
				btScalar a_min = pSlider->getLowerAngLimit();
				btScalar a_max = pSlider->getUpperAngLimit();
				const btVector3& center = pSlider->getCalculatedTransformB().getOrigin();
				getDebugDrawer()->drawArc(center, normal, axis, dbgDrawSize, dbgDrawSize, a_min, a_max, btVector3(0, 0, 0), true);
			}
		}
		break;
		default:
			break;
	}
	return;
}

void btDiscreteDynamicsWorld::setConstraintSolver(btConstraintSolver* solver)
{
	if (m_ownsConstraintSolver)
	{
		btAlignedFree(m_constraintSolver);
	}
	m_ownsConstraintSolver = false;
	m_constraintSolver = solver;
	m_solverIslandCallback->m_solver = solver;
}

btConstraintSolver* btDiscreteDynamicsWorld::getConstraintSolver()
{
	return m_constraintSolver;
}

int btDiscreteDynamicsWorld::getNumConstraints() const
{
	return int(m_constraints.size());
}
btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index)
{
	return m_constraints[index];
}
const btTypedConstraint* btDiscreteDynamicsWorld::getConstraint(int index) const
{
	return m_constraints[index];
}

void btDiscreteDynamicsWorld::serializeRigidBodies(btSerializer* serializer)
{
	int i;
	//serialize all collision objects
	for (i = 0; i < m_collisionObjects.size(); i++)
	{
		btCollisionObject* colObj = m_collisionObjects[i];
		if (colObj->getInternalType() & btCollisionObject::CO_RIGID_BODY)
		{
			int len = colObj->calculateSerializeBufferSize();
			btChunk* chunk = serializer->allocate(len, 1);
			const char* structType = colObj->serialize(chunk->m_oldPtr, serializer);
			serializer->finalizeChunk(chunk, structType, BT_RIGIDBODY_CODE, colObj);
		}
	}

	for (i = 0; i < m_constraints.size(); i++)
	{
		btTypedConstraint* constraint = m_constraints[i];
		int size = constraint->calculateSerializeBufferSize();
		btChunk* chunk = serializer->allocate(size, 1);
		const char* structType = constraint->serialize(chunk->m_oldPtr, serializer);
		serializer->finalizeChunk(chunk, structType, BT_CONSTRAINT_CODE, constraint);
	}
}

void btDiscreteDynamicsWorld::serializeDynamicsWorldInfo(btSerializer* serializer)
{
#ifdef BT_USE_DOUBLE_PRECISION
	int len = sizeof(btDynamicsWorldDoubleData);
	btChunk* chunk = serializer->allocate(len, 1);
	btDynamicsWorldDoubleData* worldInfo = (btDynamicsWorldDoubleData*)chunk->m_oldPtr;
#else   //BT_USE_DOUBLE_PRECISION
	int len = sizeof(btDynamicsWorldFloatData);
	btChunk* chunk = serializer->allocate(len, 1);
	btDynamicsWorldFloatData* worldInfo = (btDynamicsWorldFloatData*)chunk->m_oldPtr;
#endif  //BT_USE_DOUBLE_PRECISION

	memset(worldInfo, 0x00, len);

	m_gravity.serialize(worldInfo->m_gravity);
	worldInfo->m_solverInfo.m_tau = getSolverInfo().m_tau;
	worldInfo->m_solverInfo.m_damping = getSolverInfo().m_damping;
	worldInfo->m_solverInfo.m_friction = getSolverInfo().m_friction;
	worldInfo->m_solverInfo.m_timeStep = getSolverInfo().m_timeStep;

	worldInfo->m_solverInfo.m_restitution = getSolverInfo().m_restitution;
	worldInfo->m_solverInfo.m_maxErrorReduction = getSolverInfo().m_maxErrorReduction;
	worldInfo->m_solverInfo.m_sor = getSolverInfo().m_sor;
	worldInfo->m_solverInfo.m_erp = getSolverInfo().m_erp;

	worldInfo->m_solverInfo.m_erp2 = getSolverInfo().m_erp2;
	worldInfo->m_solverInfo.m_globalCfm = getSolverInfo().m_globalCfm;
	worldInfo->m_solverInfo.m_splitImpulsePenetrationThreshold = getSolverInfo().m_splitImpulsePenetrationThreshold;
	worldInfo->m_solverInfo.m_splitImpulseTurnErp = getSolverInfo().m_splitImpulseTurnErp;

	worldInfo->m_solverInfo.m_linearSlop = getSolverInfo().m_linearSlop;
	worldInfo->m_solverInfo.m_warmstartingFactor = getSolverInfo().m_warmstartingFactor;
	worldInfo->m_solverInfo.m_maxGyroscopicForce = getSolverInfo().m_maxGyroscopicForce;
	worldInfo->m_solverInfo.m_singleAxisRollingFrictionThreshold = getSolverInfo().m_singleAxisRollingFrictionThreshold;

	worldInfo->m_solverInfo.m_numIterations = getSolverInfo().m_numIterations;
	worldInfo->m_solverInfo.m_solverMode = getSolverInfo().m_solverMode;
	worldInfo->m_solverInfo.m_restingContactRestitutionThreshold = getSolverInfo().m_restingContactRestitutionThreshold;
	worldInfo->m_solverInfo.m_minimumSolverBatchSize = getSolverInfo().m_minimumSolverBatchSize;

	worldInfo->m_solverInfo.m_splitImpulse = getSolverInfo().m_splitImpulse;

	
#ifdef BT_USE_DOUBLE_PRECISION
	const char* structType = "btDynamicsWorldDoubleData";
#else   //BT_USE_DOUBLE_PRECISION
	const char* structType = "btDynamicsWorldFloatData";
#endif  //BT_USE_DOUBLE_PRECISION
	serializer->finalizeChunk(chunk, structType, BT_DYNAMICSWORLD_CODE, worldInfo);
}

void btDiscreteDynamicsWorld::serialize(btSerializer* serializer)
{
	serializer->startSerialization();

	serializeDynamicsWorldInfo(serializer);

	serializeCollisionObjects(serializer);

	serializeRigidBodies(serializer);

	serializeContactManifolds(serializer);

	serializer->finishSerialization();
}



#ifdef __cplusplus
extern "C" {
#endif

void _wrap_Swig_free_mbt_e1d552452a96202d(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  Swig_free(arg1);
  
}


void *_wrap_Swig_malloc_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (void *)Swig_malloc(arg1);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetVersion_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetVersion();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsDoublePrecision_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btIsDoublePrecision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_0_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btInfMaskConverter *)new btInfMaskConverter(arg1);
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


btInfMaskConverter *_wrap_new_btInfMaskConverter__SWIG_1_mbt_e1d552452a96202d() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)new btInfMaskConverter();
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


void _wrap_delete_btInfMaskConverter_mbt_e1d552452a96202d(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btInfinityMask_set_mbt_e1d552452a96202d(btInfMaskConverter *_swig_go_0) {
  btInfMaskConverter *arg1 = (btInfMaskConverter *) 0 ;
  
  arg1 = *(btInfMaskConverter **)&_swig_go_0; 
  
  btInfinityMask = *arg1;
  
}


btInfMaskConverter *_wrap_btInfinityMask_get_mbt_e1d552452a96202d() {
  btInfMaskConverter *result = 0 ;
  btInfMaskConverter *_swig_go_result;
  
  
  result = (btInfMaskConverter *)&btInfinityMask;
  *(btInfMaskConverter **)&_swig_go_result = (btInfMaskConverter *)result; 
  return _swig_go_result;
}


intgo _wrap_btGetInfinityMask_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btGetInfinityMask();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSqrt_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSqrt(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFabs_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btFabs(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCos_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btCos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSin_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btSin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTan_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btTan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAcos_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAcos(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAsin_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAsin(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btAtan(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btExp_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btExp(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLog_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btLog(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPow_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btPow(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFmod_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btFmod(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAtan2Fast_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)btAtan2Fast(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btFuzzyZero_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (bool)btFuzzyZero(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btEqual_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGreaterEqual_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (bool)btGreaterEqual(arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btIsNegative_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (int)btIsNegative(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRadians_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btRadians(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDegrees_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btDegrees(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btFsel_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btFsel(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btMachineIsLittleEndian_mbt_e1d552452a96202d() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)btMachineIsLittleEndian();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_0_mbt_e1d552452a96202d(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  arg3 = (unsigned int)_swig_go_2; 
  
  result = (unsigned int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSelect__SWIG_1_mbt_e1d552452a96202d(intgo _swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSelect__SWIG_2_mbt_e1d552452a96202d(intgo _swig_go_0, float _swig_go_1, float _swig_go_2) {
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  arg3 = (float)_swig_go_2; 
  
  result = (float)btSelect(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_0_mbt_e1d552452a96202d(intgo _swig_go_0) {
  unsigned int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_1_mbt_e1d552452a96202d(short _swig_go_0) {
  unsigned short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (unsigned short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndian__SWIG_2_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (unsigned int)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


short _wrap_btSwapEndian__SWIG_3_mbt_e1d552452a96202d(short _swig_go_0) {
  short arg1 ;
  unsigned short result;
  short _swig_go_result;
  
  arg1 = (short)_swig_go_0; 
  
  result = (unsigned short)btSwapEndian(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSwapEndianFloat_mbt_e1d552452a96202d(float _swig_go_0) {
  float arg1 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = (float)_swig_go_0; 
  
  result = (unsigned int)btSwapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btUnswapEndianFloat_mbt_e1d552452a96202d(intgo _swig_go_0) {
  unsigned int arg1 ;
  float result;
  float _swig_go_result;
  
  arg1 = (unsigned int)_swig_go_0; 
  
  result = (float)btUnswapEndianFloat(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSwapEndianDouble_mbt_e1d552452a96202d(double _swig_go_0, char *_swig_go_1) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (double)_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  btSwapEndianDouble(arg1,arg2);
  
}


double _wrap_btUnswapEndianDouble_mbt_e1d552452a96202d(char *_swig_go_0) {
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(unsigned char **)&_swig_go_0; 
  
  result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btLargeDot_mbt_e1d552452a96202d(float *_swig_go_0, float *_swig_go_1, intgo _swig_go_2) {
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btScalar **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btNormalizeAngle_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btScalar)btNormalizeAngle(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedObject *_wrap_new_btTypedObject_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  btTypedObject *result = 0 ;
  btTypedObject *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btTypedObject *)new btTypedObject(arg1);
  *(btTypedObject **)&_swig_go_result = (btTypedObject *)result; 
  return _swig_go_result;
}


void _wrap_btTypedObject_m_objectType_set_mbt_e1d552452a96202d(btTypedObject *_swig_go_0, intgo _swig_go_1) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedObject_m_objectType_get_mbt_e1d552452a96202d(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedObject_getObjectType_mbt_e1d552452a96202d(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  result = (int)((btTypedObject const *)arg1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedObject_mbt_e1d552452a96202d(btTypedObject *_swig_go_0) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  
  arg1 = *(btTypedObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void *_wrap_btAlignedAllocInternal_mbt_e1d552452a96202d(long long _swig_go_0, intgo _swig_go_1) {
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)btAlignedAllocInternal(SWIG_STD_MOVE(arg1),arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btAlignedFreeInternal_mbt_e1d552452a96202d(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btAlignedFreeInternal(arg1);
  
}


void _wrap_btAlignedAllocSetCustom_mbt_e1d552452a96202d(void* _swig_go_0, void* _swig_go_1) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  btFreeFunc *arg2 = (btFreeFunc *) 0 ;
  
  arg1 = *(btAllocFunc **)&_swig_go_0; 
  arg2 = *(btFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustom(arg1,arg2);
  
}


void _wrap_btAlignedAllocSetCustomAligned_mbt_e1d552452a96202d(void* _swig_go_0, void* _swig_go_1) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  btAlignedFreeFunc *arg2 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = *(btAlignedAllocFunc **)&_swig_go_0; 
  arg2 = *(btAlignedFreeFunc **)&_swig_go_1; 
  
  btAlignedAllocSetCustomAligned(arg1,arg2);
  
}


void *_wrap_btAllocDefault_mbt_e1d552452a96202d(long long _swig_go_0) {
  size_t arg1 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  
  result = (void *)btAllocDefault(SWIG_STD_MOVE(arg1));
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btFreeDefault_mbt_e1d552452a96202d(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btFreeDefault(arg1);
  
}


void _wrap_sAllocFunc_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  btAllocFunc *arg1 = (btAllocFunc *) 0 ;
  
  arg1 = *(btAllocFunc **)&_swig_go_0; 
  
  sAllocFunc = arg1;
  
}


void* _wrap_sAllocFunc_get_mbt_e1d552452a96202d() {
  btAllocFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAllocFunc *)sAllocFunc;
  *(btAllocFunc **)&_swig_go_result = (btAllocFunc *)result; 
  return _swig_go_result;
}


void _wrap_sFreeFunc_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  btFreeFunc *arg1 = (btFreeFunc *) 0 ;
  
  arg1 = *(btFreeFunc **)&_swig_go_0; 
  
  sFreeFunc = arg1;
  
}


void* _wrap_sFreeFunc_get_mbt_e1d552452a96202d() {
  btFreeFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btFreeFunc *)sFreeFunc;
  *(btFreeFunc **)&_swig_go_result = (btFreeFunc *)result; 
  return _swig_go_result;
}


void *_wrap_btAlignedAllocDefault_mbt_e1d552452a96202d(long long _swig_go_0, intgo _swig_go_1) {
  size_t arg1 ;
  int arg2 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = (size_t)_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (void *)btAlignedAllocDefault(SWIG_STD_MOVE(arg1),arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btAlignedFreeDefault_mbt_e1d552452a96202d(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  
  arg1 = *(void **)&_swig_go_0; 
  
  btAlignedFreeDefault(arg1);
  
}


void _wrap_sAlignedAllocFunc_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  btAlignedAllocFunc *arg1 = (btAlignedAllocFunc *) 0 ;
  
  arg1 = *(btAlignedAllocFunc **)&_swig_go_0; 
  
  sAlignedAllocFunc = arg1;
  
}


void* _wrap_sAlignedAllocFunc_get_mbt_e1d552452a96202d() {
  btAlignedAllocFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAlignedAllocFunc *)sAlignedAllocFunc;
  *(btAlignedAllocFunc **)&_swig_go_result = (btAlignedAllocFunc *)result; 
  return _swig_go_result;
}


void _wrap_sAlignedFreeFunc_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  btAlignedFreeFunc *arg1 = (btAlignedFreeFunc *) 0 ;
  
  arg1 = *(btAlignedFreeFunc **)&_swig_go_0; 
  
  sAlignedFreeFunc = arg1;
  
}


void* _wrap_sAlignedFreeFunc_get_mbt_e1d552452a96202d() {
  btAlignedFreeFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btAlignedFreeFunc *)sAlignedFreeFunc;
  *(btAlignedFreeFunc **)&_swig_go_result = (btAlignedFreeFunc *)result; 
  return _swig_go_result;
}


void _wrap_btVector3_m_floats_set_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btVector3_m_floats_get_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_0_mbt_e1d552452a96202d() {
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  
  result = (btVector3 *)new btVector3();
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_new_btVector3__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


float _wrap_btVector3_dot_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length2_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_length_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_norm_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_safeNorm_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar)((btVector3 const *)arg1)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector3_distance_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_safeNormalize_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalize_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_normalized_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_rotate_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_angle_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_absolute_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = ((btVector3 const *)arg1)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_cross_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_triple_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_minAxis_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_maxAxis_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_furthestAxis_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector3_closestAxis_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (int)((btVector3 const *)arg1)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_setInterpolate3_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector3_lerp_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector3_getX_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getY_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_getZ_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setX_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btVector3_setY_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btVector3_setZ_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btVector3_setW_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btVector3_x_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_y_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_z_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector3_w_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btScalar *) &((btVector3 const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector3_setMax_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setMin_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector3_setValue_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btVector3_getSkewSymmetricMatrix_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector3_setZero_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


bool _wrap_btVector3_isZero_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector3_fuzzyZero_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)((btVector3 const *)arg1)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector3_serialize_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_0_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector3_deSerialize__SWIG_1_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeFloat_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btVector3_deSerializeFloat_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector3_serializeDouble_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  ((btVector3 const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btVector3_deSerializeDouble_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector3_maxDot_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector3_minDot_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector3_dot3_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_delete_btVector3_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btDot_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btDistance_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_0_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCross_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btTriple_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_lerp_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_0_mbt_e1d552452a96202d() {
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  
  result = (btVector4 *)new btVector4();
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_new_btVector4__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  btVector4 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btVector4 **)&_swig_go_result = (btVector4 *)result; 
  return _swig_go_result;
}


btVector4 *_wrap_btVector4_absolute4_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  btVector4 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = ((btVector4 const *)arg1)->absolute4();
  *(btVector4 **)&_swig_go_result = new btVector4(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getW_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (btScalar)((btVector4 const *)arg1)->getW();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis4_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->maxAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis4_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->minAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis4_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  result = (int)((btVector4 const *)arg1)->closestAxis4();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setValue_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_delete_btVector4_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtVector4_M_floats_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ;
  
}


float *_wrap_GetbtVector4_M_floats_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *)(btScalar *) ((swig_b0)->m_floats);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_dot_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->dot((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length2_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_length_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_norm_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->norm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_safeNorm_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->safeNorm();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance2_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance2((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btVector4_distance_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->distance((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_safeNormalize_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->safeNormalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalize_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btVector3 *) &(swig_b0)->normalize();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_normalized_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->normalized();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_rotate_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->rotate((btVector3 const &)*arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_angle_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->angle((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_absolute_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->absolute();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_cross_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->cross((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_triple_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar)((btVector3 const *)swig_b0)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_minAxis_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->minAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_maxAxis_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->maxAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_furthestAxis_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->furthestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btVector4_closestAxis_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (int)((btVector3 const *)swig_b0)->closestAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_setInterpolate3_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


btVector3 *_wrap_btVector4_lerp_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btVector4_getX_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getY_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_getZ_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setX_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btVector4_setY_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btVector4_setZ_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btVector4_setW_mbt_e1d552452a96202d(btVector4 *_swig_go_0, float _swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btVector4_x_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_y_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_z_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btVector4_w_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (btScalar *) &((btVector3 const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btVector4_setMax_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMax((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_setMin_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setMin((btVector3 const &)*arg2);
  
}


void _wrap_btVector4_getSkewSymmetricMatrix_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->getSkewSymmetricMatrix(arg2,arg3,arg4);
  
}


void _wrap_btVector4_setZero_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->setZero();
  
}


bool _wrap_btVector4_isZero_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->isZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btVector4_fuzzyZero_mbt_e1d552452a96202d(btVector4 *_swig_go_0) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (bool)((btVector3 const *)swig_b0)->fuzzyZero();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btVector4_serialize_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serialize(*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_0_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3DoubleData const &)*arg2);
  
}


void _wrap_btVector4_deSerialize__SWIG_1_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerialize((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeFloat_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeFloat(*arg2);
  
}


void _wrap_btVector4_deSerializeFloat_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeFloat((btVector3FloatData const &)*arg2);
  
}


void _wrap_btVector4_serializeDouble_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  ((btVector3 const *)swig_b0)->serializeDouble(*arg2);
  
}


void _wrap_btVector4_deSerializeDouble_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  (swig_b0)->deSerializeDouble((btVector3DoubleData const &)*arg2);
  
}


long long _wrap_btVector4_maxDot_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->maxDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btVector4_minDot_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, long long _swig_go_2, float *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  long long _swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (long)_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = (long)((btVector3 const *)swig_b0)->minDot((btVector3 const *)arg2,arg3,*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btVector4_dot3_mbt_e1d552452a96202d(btVector4 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector4 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btVector3 *swig_b0 = (btVector3 *)arg1;
  result = ((btVector3 const *)swig_b0)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSwapScalarEndian_mbt_e1d552452a96202d(float _swig_go_0, float *_swig_go_1) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  btSwapScalarEndian((float const &)*arg1,*arg2);
  
}


void _wrap_btSwapVector3Endian_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
  
}


void _wrap_btUnSwapVector3Endian_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  btUnSwapVector3Endian(*arg1);
  
}


void _wrap_btVector3FloatData_m_floats_set_mbt_e1d552452a96202d(btVector3FloatData *_swig_go_0, float *_swig_go_1) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btVector3FloatData_m_floats_get_mbt_e1d552452a96202d(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3FloatData *_wrap_new_btVector3FloatData_mbt_e1d552452a96202d() {
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  
  result = (btVector3FloatData *)new btVector3FloatData();
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3FloatData_mbt_e1d552452a96202d(btVector3FloatData *_swig_go_0) {
  btVector3FloatData *arg1 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btVector3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btVector3DoubleData_m_floats_set_mbt_e1d552452a96202d(btVector3DoubleData *_swig_go_0, double *_swig_go_1) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btVector3DoubleData_m_floats_get_mbt_e1d552452a96202d(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3DoubleData *_wrap_new_btVector3DoubleData_mbt_e1d552452a96202d() {
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  
  result = (btVector3DoubleData *)new btVector3DoubleData();
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btVector3DoubleData_mbt_e1d552452a96202d(btVector3DoubleData *_swig_go_0) {
  btVector3DoubleData *arg1 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btVector3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuadWord_getX_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getY_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_getZ_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setX_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setX(arg2);
  
}


void _wrap_btQuadWord_setY_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setY(arg2);
  
}


void _wrap_btQuadWord_setZ_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setZ(arg2);
  
}


void _wrap_btQuadWord_setW_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setW(arg2);
  
}


float _wrap_btQuadWord_x_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_y_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_z_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuadWord_w_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuadWord const *)arg1)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setValue__SWIG_0_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuadWord_setValue__SWIG_1_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


btQuadWord *_wrap_new_btQuadWord__SWIG_0_mbt_e1d552452a96202d() {
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  
  result = (btQuadWord *)new btQuadWord();
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


btQuadWord *_wrap_new_btQuadWord__SWIG_2_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  btQuadWord *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuadWord **)&_swig_go_result = (btQuadWord *)result; 
  return _swig_go_result;
}


void _wrap_btQuadWord_setMax_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuadWord_setMin_mbt_e1d552452a96202d(btQuadWord *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  (arg1)->setMin((btQuadWord const &)*arg2);
  
}


void _wrap_delete_btQuadWord_mbt_e1d552452a96202d(btQuadWord *_swig_go_0) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = *(btQuadWord **)&_swig_go_0; 
  
  delete arg1;
  
}


btQuaternion *_wrap_new_btQuaternion__SWIG_0_mbt_e1d552452a96202d() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *)new btQuaternion();
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1) {
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  
  result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


btQuaternion *_wrap_new_btQuaternion__SWIG_3_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = (btQuaternion *)result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setRotation_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
  
}


void _wrap_btQuaternion_setEuler_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setEulerZYX_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_getEulerZYX_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btQuaternion const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


float _wrap_btQuaternion_dot_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length2_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_length_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->length();
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_safeNormalize_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->safeNormalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalize_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btQuaternion *) &(arg1)->normalize();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_normalized_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->normalized();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


float _wrap_btQuaternion_angle_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_angleShortestPath_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngle_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngle();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getAngleShortestPath_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btQuaternion_getAxis_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->getAxis();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_inverse_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = ((btQuaternion const *)arg1)->inverse();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_farthest_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_nearest_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_slerp_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_btQuaternion_getIdentity_mbt_e1d552452a96202d() {
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  
  result = (btQuaternion *) &btQuaternion::getIdentity();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getW_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar *) &((btQuaternion const *)arg1)->getW();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_serialize_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serialize(*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_0_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_deSerialize__SWIG_1_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeFloat_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btQuaternion_deSerializeFloat_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionFloatData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btQuaternionFloatData const &)*arg2);
  
}


void _wrap_btQuaternion_serializeDouble_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  ((btQuaternion const *)arg1)->serializeDouble(*arg2);
  
}


void _wrap_btQuaternion_deSerializeDouble_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternionDoubleData *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternionDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btQuaternionDoubleData const &)*arg2);
  
}


void _wrap_delete_btQuaternion_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btQuaternion_getX_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getX();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getY_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getY();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_getZ_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->getZ();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setX_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setX(arg2);
  
}


void _wrap_btQuaternion_setY_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setY(arg2);
  
}


void _wrap_btQuaternion_setZ_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setZ(arg2);
  
}


void _wrap_btQuaternion_setW_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setW(arg2);
  
}


float _wrap_btQuaternion_x_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->x();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_y_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->y();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_z_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->z();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


float _wrap_btQuaternion_w_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  result = (btScalar *) &((btQuadWord const *)swig_b0)->w();
  _swig_go_result = (btScalar)*result; 
  return _swig_go_result;
}


void _wrap_btQuaternion_setValue__SWIG_0_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btQuaternion_setValue__SWIG_1_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
  
}


void _wrap_btQuaternion_setMax_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMax((btQuadWord const &)*arg2);
  
}


void _wrap_btQuaternion_setMin_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuadWord *_swig_go_1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuadWord **)&_swig_go_1; 
  
  btQuadWord *swig_b0 = (btQuadWord *)arg1;
  (swig_b0)->setMin((btQuadWord const &)*arg2);
  
}


float _wrap_dot_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_length_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btScalar)length((btQuaternion const &)*arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngle__SWIG_1_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_inverse_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = inverse((btQuaternion const &)*arg1);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_slerp_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  
  result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btVector3 *_wrap_quatRotate_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuat_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btQuaternion *_wrap_shortestArcQuatNormalize2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = shortestArcQuatNormalize2(*arg1,*arg2);
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btQuaternionFloatData_m_floats_set_mbt_e1d552452a96202d(btQuaternionFloatData *_swig_go_0, float *_swig_go_1) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btQuaternionFloatData_m_floats_get_mbt_e1d552452a96202d(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_floats);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionFloatData *_wrap_new_btQuaternionFloatData_mbt_e1d552452a96202d() {
  btQuaternionFloatData *result = 0 ;
  btQuaternionFloatData *_swig_go_result;
  
  
  result = (btQuaternionFloatData *)new btQuaternionFloatData();
  *(btQuaternionFloatData **)&_swig_go_result = (btQuaternionFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionFloatData_mbt_e1d552452a96202d(btQuaternionFloatData *_swig_go_0) {
  btQuaternionFloatData *arg1 = (btQuaternionFloatData *) 0 ;
  
  arg1 = *(btQuaternionFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btQuaternionDoubleData_m_floats_set_mbt_e1d552452a96202d(btQuaternionDoubleData *_swig_go_0, double *_swig_go_1) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_floats;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btQuaternionDoubleData_m_floats_get_mbt_e1d552452a96202d(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_floats);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternionDoubleData *_wrap_new_btQuaternionDoubleData_mbt_e1d552452a96202d() {
  btQuaternionDoubleData *result = 0 ;
  btQuaternionDoubleData *_swig_go_result;
  
  
  result = (btQuaternionDoubleData *)new btQuaternionDoubleData();
  *(btQuaternionDoubleData **)&_swig_go_result = (btQuaternionDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btQuaternionDoubleData_mbt_e1d552452a96202d(btQuaternionDoubleData *_swig_go_0) {
  btQuaternionDoubleData *arg1 = (btQuaternionDoubleData *) 0 ;
  
  arg1 = *(btQuaternionDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_0_mbt_e1d552452a96202d() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *)new btMatrix3x3();
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_1_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_2_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = (btScalar *)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_3_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_4_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btMatrix3x3 *)new btMatrix3x3((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  *(btMatrix3x3 **)&_swig_go_result = (btMatrix3x3 *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getColumn_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_getRow_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_setFromOpenGLSubMatrix_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
  
}


void _wrap_btMatrix3x3_setValue_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6, float _swig_go_7, float _swig_go_8, float _swig_go_9) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  arg5 = (btScalar *)&_swig_go_4; 
  arg6 = (btScalar *)&_swig_go_5; 
  arg7 = (btScalar *)&_swig_go_6; 
  arg8 = (btScalar *)&_swig_go_7; 
  arg9 = (btScalar *)&_swig_go_8; 
  arg10 = (btScalar *)&_swig_go_9; 
  
  (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
  
}


void _wrap_btMatrix3x3_setRotation_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btMatrix3x3_setEulerYPR_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar *)&_swig_go_1; 
  arg3 = (btScalar *)&_swig_go_2; 
  arg4 = (btScalar *)&_swig_go_3; 
  
  (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
  
}


void _wrap_btMatrix3x3_setEulerZYX_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setEulerZYX(arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_setIdentity_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


void _wrap_btMatrix3x3_setZero_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  (arg1)->setZero();
  
}


btMatrix3x3 *_wrap_btMatrix3x3_getIdentity_mbt_e1d552452a96202d() {
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  
  result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_getOpenGLSubMatrix_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
  
}


void _wrap_btMatrix3x3_getRotation_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
  
}


void _wrap_btMatrix3x3_getEulerYPR_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_0_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = (unsigned int)_swig_go_4; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btMatrix3x3_getEulerZYX__SWIG_1_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, float *_swig_go_1, float *_swig_go_2, float *_swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  
  ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
  
}


btMatrix3x3 *_wrap_btMatrix3x3_scaled_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_determinant_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_adjoint_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->adjoint();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_absolute_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->absolute();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transpose_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->transpose();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_inverse_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = ((btMatrix3x3 const *)arg1)->inverse();
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btMatrix3x3_solve33_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->solve33((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotx_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdoty_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btMatrix3x3_tdotz_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_extractRotation__SWIG_0_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->extractRotation(*arg2,arg3,arg4);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_1_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1, float _swig_go_2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->extractRotation(*arg2,arg3);
  
}


void _wrap_btMatrix3x3_extractRotation__SWIG_2_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btQuaternion *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->extractRotation(*arg2);
  
}


void _wrap_btMatrix3x3_diagonalize_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3 *_swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->diagonalize(*arg2,arg3,arg4);
  
}


float _wrap_btMatrix3x3_cofac_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btMatrix3x3_serialize_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serialize(*arg2);
  
}


void _wrap_btMatrix3x3_serializeFloat_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btMatrix3x3_deSerialize_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeFloat_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
  
}


void _wrap_btMatrix3x3_deSerializeDouble_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
  
}


void _wrap_delete_btMatrix3x3_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3FloatData_m_el_set_mbt_e1d552452a96202d(btMatrix3x3FloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[3]) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btMatrix3x3FloatData_m_el_get_mbt_e1d552452a96202d(btMatrix3x3FloatData *_swig_go_0))[3] {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_el);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3FloatData *_wrap_new_btMatrix3x3FloatData_mbt_e1d552452a96202d() {
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  
  result = (btMatrix3x3FloatData *)new btMatrix3x3FloatData();
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3FloatData_mbt_e1d552452a96202d(btMatrix3x3FloatData *_swig_go_0) {
  btMatrix3x3FloatData *arg1 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btMatrix3x3FloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMatrix3x3DoubleData_m_el_set_mbt_e1d552452a96202d(btMatrix3x3DoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[3]) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_el;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btMatrix3x3DoubleData_m_el_get_mbt_e1d552452a96202d(btMatrix3x3DoubleData *_swig_go_0))[3] {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[3];
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_el);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3DoubleData *_wrap_new_btMatrix3x3DoubleData_mbt_e1d552452a96202d() {
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  
  result = (btMatrix3x3DoubleData *)new btMatrix3x3DoubleData();
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btMatrix3x3DoubleData_mbt_e1d552452a96202d(btMatrix3x3DoubleData *_swig_go_0) {
  btMatrix3x3DoubleData *arg1 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btMatrix3x3DoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btTransform *_wrap_new_btTransform__SWIG_0_mbt_e1d552452a96202d() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *)new btTransform();
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_1_mbt_e1d552452a96202d(btQuaternion *_swig_go_0, btVector3 *_swig_go_1) {
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_2_mbt_e1d552452a96202d(btQuaternion *_swig_go_0) {
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btQuaternion **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_3_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_4_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0) {
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


btTransform *_wrap_new_btTransform__SWIG_5_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btTransform *)new btTransform((btTransform const &)*arg1);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btTransform_mult_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_0_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &(arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_1_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_0_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &(arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btTransform_getOrigin__SWIG_1_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btTransform_getRotation_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->getRotation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setFromOpenGLMatrix_mbt_e1d552452a96202d(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
  
}


void _wrap_btTransform_getOpenGLMatrix_mbt_e1d552452a96202d(btTransform *_swig_go_0, float *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
  
}


void _wrap_btTransform_setOrigin_mbt_e1d552452a96202d(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setOrigin((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btTransform_invXform_mbt_e1d552452a96202d(btTransform *_swig_go_0, btVector3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btTransform_setBasis_mbt_e1d552452a96202d(btTransform *_swig_go_0, btMatrix3x3 *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btMatrix3x3 **)&_swig_go_1; 
  
  (arg1)->setBasis((btMatrix3x3 const &)*arg2);
  
}


void _wrap_btTransform_setRotation_mbt_e1d552452a96202d(btTransform *_swig_go_0, btQuaternion *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setRotation((btQuaternion const &)*arg2);
  
}


void _wrap_btTransform_setIdentity_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  (arg1)->setIdentity();
  
}


btTransform *_wrap_btTransform_inverse_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = ((btTransform const *)arg1)->inverse();
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_inverseTimes_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  btTransform *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
  *(btTransform **)&_swig_go_result = new btTransform(result); 
  return _swig_go_result;
}


btTransform *_wrap_btTransform_getIdentity_mbt_e1d552452a96202d() {
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  
  result = (btTransform *) &btTransform::getIdentity();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransform_serialize_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serialize(*arg2);
  
}


void _wrap_btTransform_serializeFloat_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  ((btTransform const *)arg1)->serializeFloat(*arg2);
  
}


void _wrap_btTransform_deSerialize_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btTransformFloatData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeDouble_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
  
}


void _wrap_btTransform_deSerializeFloat_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
  
}


void _wrap_delete_btTransform_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformFloatData_m_basis_set_mbt_e1d552452a96202d(btTransformFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btTransformFloatData_m_basis_get_mbt_e1d552452a96202d(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_basis);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformFloatData_m_origin_set_mbt_e1d552452a96202d(btTransformFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3FloatData *_wrap_btTransformFloatData_m_origin_get_mbt_e1d552452a96202d(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_origin);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


btTransformFloatData *_wrap_new_btTransformFloatData_mbt_e1d552452a96202d() {
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  
  result = (btTransformFloatData *)new btTransformFloatData();
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformFloatData_mbt_e1d552452a96202d(btTransformFloatData *_swig_go_0) {
  btTransformFloatData *arg1 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btTransformFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTransformDoubleData_m_basis_set_mbt_e1d552452a96202d(btTransformDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_basis = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btTransformDoubleData_m_basis_get_mbt_e1d552452a96202d(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_basis);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTransformDoubleData_m_origin_set_mbt_e1d552452a96202d(btTransformDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_origin = *arg2;
  
}


btVector3DoubleData *_wrap_btTransformDoubleData_m_origin_get_mbt_e1d552452a96202d(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_origin);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


btTransformDoubleData *_wrap_new_btTransformDoubleData_mbt_e1d552452a96202d() {
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  
  result = (btTransformDoubleData *)new btTransformDoubleData();
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTransformDoubleData_mbt_e1d552452a96202d(btTransformDoubleData *_swig_go_0) {
  btTransformDoubleData *arg1 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btTransformDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btMotionState_mbt_e1d552452a96202d(btMotionState *_swig_go_0) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btMotionState_getWorldTransform_mbt_e1d552452a96202d(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btMotionState_setWorldTransform_mbt_e1d552452a96202d(btMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btDefaultMotionState_m_graphicsWorldTrans_set_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_graphicsWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_graphicsWorldTrans_get_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_graphicsWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_centerOfMassOffset_set_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_centerOfMassOffset = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_centerOfMassOffset_get_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_centerOfMassOffset);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_startWorldTrans_set_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_startWorldTrans = *arg2;
  
}


btTransform *_wrap_btDefaultMotionState_m_startWorldTrans_get_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_startWorldTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_m_userPointer_set_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, void *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_userPointer = arg2;
  
}


void *_wrap_btDefaultMotionState_m_userPointer_get_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_userPointer);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_0_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransform *_swig_go_1) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1,(btTransform const &)*arg2);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_1_mbt_e1d552452a96202d(btTransform *_swig_go_0) {
  btTransform *arg1 = 0 ;
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  
  result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1);
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


btDefaultMotionState *_wrap_new_btDefaultMotionState__SWIG_2_mbt_e1d552452a96202d() {
  btDefaultMotionState *result = 0 ;
  btDefaultMotionState *_swig_go_result;
  
  
  result = (btDefaultMotionState *)new btDefaultMotionState();
  *(btDefaultMotionState **)&_swig_go_result = (btDefaultMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btDefaultMotionState_getWorldTransform_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  ((btDefaultMotionState const *)arg1)->getWorldTransform(*arg2);
  
}


void _wrap_btDefaultMotionState_setWorldTransform_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0, btTransform *_swig_go_1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_delete_btDefaultMotionState_mbt_e1d552452a96202d(btDefaultMotionState *_swig_go_0) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  
  arg1 = *(btDefaultMotionState **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btElement_m_id_set_mbt_e1d552452a96202d(btElement *_swig_go_0, intgo _swig_go_1) {
  btElement *arg1 = (btElement *) 0 ;
  int arg2 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_id = arg2;
  
}


intgo _wrap_btElement_m_id_get_mbt_e1d552452a96202d(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_id);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btElement_m_sz_set_mbt_e1d552452a96202d(btElement *_swig_go_0, intgo _swig_go_1) {
  btElement *arg1 = (btElement *) 0 ;
  int arg2 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_sz = arg2;
  
}


intgo _wrap_btElement_m_sz_get_mbt_e1d552452a96202d(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_sz);
  _swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_new_btElement_mbt_e1d552452a96202d() {
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  
  result = (btElement *)new btElement();
  *(btElement **)&_swig_go_result = (btElement *)result; 
  return _swig_go_result;
}


void _wrap_delete_btElement_mbt_e1d552452a96202d(btElement *_swig_go_0) {
  btElement *arg1 = (btElement *) 0 ;
  
  arg1 = *(btElement **)&_swig_go_0; 
  
  delete arg1;
  
}


btUnionFind *_wrap_new_btUnionFind_mbt_e1d552452a96202d() {
  btUnionFind *result = 0 ;
  btUnionFind *_swig_go_result;
  
  
  result = (btUnionFind *)new btUnionFind();
  *(btUnionFind **)&_swig_go_result = (btUnionFind *)result; 
  return _swig_go_result;
}


void _wrap_delete_btUnionFind_mbt_e1d552452a96202d(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btUnionFind_sortIslands_mbt_e1d552452a96202d(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  (arg1)->sortIslands();
  
}


void _wrap_btUnionFind_reset_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->reset(arg2);
  
}


intgo _wrap_btUnionFind_getNumElements_mbt_e1d552452a96202d(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  result = (int)((btUnionFind const *)arg1)->getNumElements();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btUnionFind_isRoot_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btUnionFind const *)arg1)->isRoot(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_btUnionFind_getElement__SWIG_0_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btElement *) &(arg1)->getElement(arg2);
  *(btElement **)&_swig_go_result = result; 
  return _swig_go_result;
}


btElement *_wrap_btUnionFind_getElement__SWIG_1_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  btElement *result = 0 ;
  btElement *_swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btElement *) &((btUnionFind const *)arg1)->getElement(arg2);
  *(btElement **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUnionFind_allocate_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->allocate(arg2);
  
}


void _wrap_btUnionFind_Free_mbt_e1d552452a96202d(btUnionFind *_swig_go_0) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  
  (arg1)->Free();
  
}


intgo _wrap_btUnionFind_find__SWIG_0_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)(arg1)->find(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btUnionFind_unite_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->unite(arg2,arg3);
  
}


intgo _wrap_btUnionFind_find__SWIG_1_mbt_e1d552452a96202d(btUnionFind *_swig_go_0, intgo _swig_go_1) {
  btUnionFind *arg1 = (btUnionFind *) 0 ;
  int arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btUnionFind **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (int)(arg1)->find(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btUnionFindElementSortPredicate *_wrap_new_btUnionFindElementSortPredicate_mbt_e1d552452a96202d() {
  btUnionFindElementSortPredicate *result = 0 ;
  btUnionFindElementSortPredicate *_swig_go_result;
  
  
  result = (btUnionFindElementSortPredicate *)new btUnionFindElementSortPredicate();
  *(btUnionFindElementSortPredicate **)&_swig_go_result = (btUnionFindElementSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btUnionFindElementSortPredicate_mbt_e1d552452a96202d(btUnionFindElementSortPredicate *_swig_go_0) {
  btUnionFindElementSortPredicate *arg1 = (btUnionFindElementSortPredicate *) 0 ;
  
  arg1 = *(btUnionFindElementSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btHashString_m_string1_set_mbt_e1d552452a96202d(btHashString *_swig_go_0, std::string *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string arg2 ;
  std::string *argp2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  argp2 = (std::string *)_swig_go_1;
  if (argp2 == NULL) {
    _swig_gopanic("Attempt to dereference null std::string");
  }
  arg2 = (std::string)*argp2;
  
  
  if (arg1) (arg1)->m_string1 = arg2;
  
}


std::string *_wrap_btHashString_m_string1_get_mbt_e1d552452a96202d(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  std::string result;
  std::string *_swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result =  ((arg1)->m_string1);
  *(std::string **)&_swig_go_result = new std::string(result); 
  return _swig_go_result;
}


void _wrap_btHashString_m_hash_set_mbt_e1d552452a96202d(btHashString *_swig_go_0, intgo _swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int arg2 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = (unsigned int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hash = arg2;
  
}


intgo _wrap_btHashString_m_hash_get_mbt_e1d552452a96202d(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int) ((arg1)->m_hash);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashString_getHash_mbt_e1d552452a96202d(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  result = (unsigned int)((btHashString const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_0_mbt_e1d552452a96202d() {
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  result = (btHashString *)new btHashString();
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  return _swig_go_result;
}


btHashString *_wrap_new_btHashString__SWIG_1_mbt_e1d552452a96202d(_gostring_ _swig_go_0) {
  char *arg1 = (char *) 0 ;
  btHashString *result = 0 ;
  btHashString *_swig_go_result;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  result = (btHashString *)new btHashString((char const *)arg1);
  *(btHashString **)&_swig_go_result = (btHashString *)result; 
  free(arg1); 
  return _swig_go_result;
}


bool _wrap_btHashString_equals_mbt_e1d552452a96202d(btHashString *_swig_go_0, btHashString *_swig_go_1) {
  btHashString *arg1 = (btHashString *) 0 ;
  btHashString *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  arg2 = *(btHashString **)&_swig_go_1; 
  
  result = (bool)((btHashString const *)arg1)->equals((btHashString const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashString_mbt_e1d552452a96202d(btHashString *_swig_go_0) {
  btHashString *arg1 = (btHashString *) 0 ;
  
  arg1 = *(btHashString **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_HASH_NULL_get_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)(int)BT_HASH_NULL;
  _swig_go_result = result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_0_mbt_e1d552452a96202d() {
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  
  result = (btHashInt *)new btHashInt();
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


btHashInt *_wrap_new_btHashInt__SWIG_1_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  btHashInt *result = 0 ;
  btHashInt *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btHashInt *)new btHashInt(arg1);
  *(btHashInt **)&_swig_go_result = (btHashInt *)result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getUid1_mbt_e1d552452a96202d(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (int)((btHashInt const *)arg1)->getUid1();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btHashInt_setUid1_mbt_e1d552452a96202d(btHashInt *_swig_go_0, intgo _swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  int arg2 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUid1(arg2);
  
}


bool _wrap_btHashInt_equals_mbt_e1d552452a96202d(btHashInt *_swig_go_0, btHashInt *_swig_go_1) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  btHashInt *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  arg2 = *(btHashInt **)&_swig_go_1; 
  
  result = (bool)((btHashInt const *)arg1)->equals((btHashInt const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashInt_getHash_mbt_e1d552452a96202d(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  result = (unsigned int)((btHashInt const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashInt_mbt_e1d552452a96202d(btHashInt *_swig_go_0) {
  btHashInt *arg1 = (btHashInt *) 0 ;
  
  arg1 = *(btHashInt **)&_swig_go_0; 
  
  delete arg1;
  
}


btHashPtr *_wrap_new_btHashPtr__SWIG_0_mbt_e1d552452a96202d() {
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  
  result = (btHashPtr *)new btHashPtr();
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


btHashPtr *_wrap_new_btHashPtr__SWIG_1_mbt_e1d552452a96202d(void *_swig_go_0) {
  void *arg1 = (void *) 0 ;
  btHashPtr *result = 0 ;
  btHashPtr *_swig_go_result;
  
  arg1 = *(void **)&_swig_go_0; 
  
  result = (btHashPtr *)new btHashPtr((void const *)arg1);
  *(btHashPtr **)&_swig_go_result = (btHashPtr *)result; 
  return _swig_go_result;
}


void *_wrap_btHashPtr_getPointer_mbt_e1d552452a96202d(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (void *)((btHashPtr const *)arg1)->getPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


bool _wrap_btHashPtr_equals_mbt_e1d552452a96202d(btHashPtr *_swig_go_0, btHashPtr *_swig_go_1) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  btHashPtr *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  arg2 = *(btHashPtr **)&_swig_go_1; 
  
  result = (bool)((btHashPtr const *)arg1)->equals((btHashPtr const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btHashPtr_getHash_mbt_e1d552452a96202d(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  result = (unsigned int)((btHashPtr const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btHashPtr_mbt_e1d552452a96202d(btHashPtr *_swig_go_0) {
  btHashPtr *arg1 = (btHashPtr *) 0 ;
  
  arg1 = *(btHashPtr **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_sBulletDNAstr_set_mbt_e1d552452a96202d(_gostring_ _swig_go_0) {
  char *arg1 = (char *) (char *)0 ;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  {
    if (arg1) strcpy((char *)sBulletDNAstr, (const char *)arg1);
    else sBulletDNAstr[0] = 0;
  }
  
  free(arg1); 
}


_gostring_ _wrap_sBulletDNAstr_get_mbt_e1d552452a96202d() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)(char *)sBulletDNAstr;
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_sBulletDNAlen_set_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  sBulletDNAlen = arg1;
  
}


intgo _wrap_sBulletDNAlen_get_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)sBulletDNAlen;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_sBulletDNAstr64_set_mbt_e1d552452a96202d(_gostring_ _swig_go_0) {
  char *arg1 = (char *) (char *)0 ;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  {
    if (arg1) strcpy((char *)sBulletDNAstr64, (const char *)arg1);
    else sBulletDNAstr64[0] = 0;
  }
  
  free(arg1); 
}


_gostring_ _wrap_sBulletDNAstr64_get_mbt_e1d552452a96202d() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)(char *)sBulletDNAstr64;
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_sBulletDNAlen64_set_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  sBulletDNAlen64 = arg1;
  
}


intgo _wrap_sBulletDNAlen64_get_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)sBulletDNAlen64;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btStrLen_mbt_e1d552452a96202d(_gostring_ _swig_go_0) {
  char *arg1 = (char *) 0 ;
  int result;
  intgo _swig_go_result;
  
  
  arg1 = (char *)malloc(_swig_go_0.n + 1);
  memcpy(arg1, _swig_go_0.p, _swig_go_0.n);
  arg1[_swig_go_0.n] = '\0';
  
  
  result = (int)btStrLen((char const *)arg1);
  _swig_go_result = result; 
  free(arg1); 
  return _swig_go_result;
}


void _wrap_btChunk_m_chunkCode_set_mbt_e1d552452a96202d(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_chunkCode = arg2;
  
}


intgo _wrap_btChunk_m_chunkCode_get_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_chunkCode);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_length_set_mbt_e1d552452a96202d(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_length = arg2;
  
}


intgo _wrap_btChunk_m_length_get_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_length);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_oldPtr_set_mbt_e1d552452a96202d(btChunk *_swig_go_0, void *_swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_oldPtr = arg2;
  
}


void *_wrap_btChunk_m_oldPtr_get_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_oldPtr);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_dna_nr_set_mbt_e1d552452a96202d(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_dna_nr = arg2;
  
}


intgo _wrap_btChunk_m_dna_nr_get_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_dna_nr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btChunk_m_number_set_mbt_e1d552452a96202d(btChunk *_swig_go_0, intgo _swig_go_1) {
  btChunk *arg1 = (btChunk *) 0 ;
  int arg2 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_number = arg2;
  
}


intgo _wrap_btChunk_m_number_get_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_number);
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_new_btChunk_mbt_e1d552452a96202d() {
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  
  result = (btChunk *)new btChunk();
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void _wrap_delete_btChunk_mbt_e1d552452a96202d(btChunk *_swig_go_0) {
  btChunk *arg1 = (btChunk *) 0 ;
  
  arg1 = *(btChunk **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_SERIALIZE_NO_BVH_mbt_e1d552452a96202d() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_BVH;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_NO_TRIANGLEINFOMAP_mbt_e1d552452a96202d() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_TRIANGLEINFOMAP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_NO_DUPLICATE_ASSERT_mbt_e1d552452a96202d() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_NO_DUPLICATE_ASSERT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_SERIALIZE_CONTACT_MANIFOLDS_mbt_e1d552452a96202d() {
  btSerializationFlags result;
  intgo _swig_go_result;
  
  
  result = BT_SERIALIZE_CONTACT_MANIFOLDS;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_delete_btSerializer_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  delete arg1;
  
}


char *_wrap_btSerializer_getBufferPointer_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (unsigned char *)((btSerializer const *)arg1)->getBufferPointer();
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


intgo _wrap_btSerializer_getCurrentBufferSize_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getCurrentBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btSerializer_allocate_mbt_e1d552452a96202d(btSerializer *_swig_go_0, long long _swig_go_1, intgo _swig_go_2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btChunk *)(arg1)->allocate(arg2,arg3);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void _wrap_btSerializer_finalizeChunk_mbt_e1d552452a96202d(btSerializer *_swig_go_0, btChunk *_swig_go_1, _gostring_ _swig_go_2, intgo _swig_go_3, void *_swig_go_4) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(btChunk **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  arg4 = (int)_swig_go_3; 
  arg5 = *(void **)&_swig_go_4; 
  
  (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
  
  free(arg3); 
}


void *_wrap_btSerializer_findPointer_mbt_e1d552452a96202d(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->findPointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void *_wrap_btSerializer_getUniquePointer_mbt_e1d552452a96202d(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->getUniquePointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSerializer_startSerialization_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  (arg1)->startSerialization();
  
}


void _wrap_btSerializer_finishSerialization_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  (arg1)->finishSerialization();
  
}


_gostring_ _wrap_btSerializer_findNameForPointer_mbt_e1d552452a96202d(btSerializer *_swig_go_0, void *_swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (char *)((btSerializer const *)arg1)->findNameForPointer((void const *)arg2);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btSerializer_registerNameForPointer_mbt_e1d552452a96202d(btSerializer *_swig_go_0, void *_swig_go_1, _gostring_ _swig_go_2) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  
  (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
  
  free(arg3); 
}


void _wrap_btSerializer_serializeName_mbt_e1d552452a96202d(btSerializer *_swig_go_0, _gostring_ _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  (arg1)->serializeName((char const *)arg2);
  
  free(arg2); 
}


intgo _wrap_btSerializer_getSerializationFlags_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getSerializationFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSerializer_setSerializationFlags_mbt_e1d552452a96202d(btSerializer *_swig_go_0, intgo _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int arg2 ;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setSerializationFlags(arg2);
  
}


intgo _wrap_btSerializer_getNumChunks_mbt_e1d552452a96202d(btSerializer *_swig_go_0) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  
  result = (int)((btSerializer const *)arg1)->getNumChunks();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btSerializer_getChunk_mbt_e1d552452a96202d(btSerializer *_swig_go_0, intgo _swig_go_1) {
  btSerializer *arg1 = (btSerializer *) 0 ;
  int arg2 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btChunk *)((btSerializer const *)arg1)->getChunk(arg2);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


btPointerUid *_wrap_new_btPointerUid_mbt_e1d552452a96202d() {
  btPointerUid *result = 0 ;
  btPointerUid *_swig_go_result;
  
  
  result = (btPointerUid *)new btPointerUid();
  *(btPointerUid **)&_swig_go_result = (btPointerUid *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPointerUid_mbt_e1d552452a96202d(btPointerUid *_swig_go_0) {
  btPointerUid *arg1 = (btPointerUid *) 0 ;
  
  arg1 = *(btPointerUid **)&_swig_go_0; 
  
  delete arg1;
  
}


btBulletSerializedArrays *_wrap_new_btBulletSerializedArrays_mbt_e1d552452a96202d() {
  btBulletSerializedArrays *result = 0 ;
  btBulletSerializedArrays *_swig_go_result;
  
  
  result = (btBulletSerializedArrays *)new btBulletSerializedArrays();
  *(btBulletSerializedArrays **)&_swig_go_result = (btBulletSerializedArrays *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_bvhsDouble_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btQuantizedBvhDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *arg2 = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btQuantizedBvhDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhsDouble = *arg2;
  
}


btAlignedObjectArray< btQuantizedBvhDoubleData * > *_wrap_btBulletSerializedArrays_m_bvhsDouble_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *)& ((arg1)->m_bvhsDouble);
  *(btAlignedObjectArray< btQuantizedBvhDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btQuantizedBvhDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_bvhsFloat_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btQuantizedBvhFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *arg2 = (btAlignedObjectArray< btQuantizedBvhFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btQuantizedBvhFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bvhsFloat = *arg2;
  
}


btAlignedObjectArray< btQuantizedBvhFloatData * > *_wrap_btBulletSerializedArrays_m_bvhsFloat_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *result = 0 ;
  btAlignedObjectArray< btQuantizedBvhFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btQuantizedBvhFloatData * > *)& ((arg1)->m_bvhsFloat);
  *(btAlignedObjectArray< btQuantizedBvhFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btQuantizedBvhFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_colShapeData_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionShapeData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *arg2 = (btAlignedObjectArray< btCollisionShapeData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionShapeData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_colShapeData = *arg2;
  
}


btAlignedObjectArray< btCollisionShapeData * > *_wrap_btBulletSerializedArrays_m_colShapeData_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *result = 0 ;
  btAlignedObjectArray< btCollisionShapeData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionShapeData * > *)& ((arg1)->m_colShapeData);
  *(btAlignedObjectArray< btCollisionShapeData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionShapeData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataDouble_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btDynamicsWorldDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *arg2 = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btDynamicsWorldDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dynamicWorldInfoDataDouble = *arg2;
  
}


btAlignedObjectArray< btDynamicsWorldDoubleData * > *_wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataDouble_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *result = 0 ;
  btAlignedObjectArray< btDynamicsWorldDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *)& ((arg1)->m_dynamicWorldInfoDataDouble);
  *(btAlignedObjectArray< btDynamicsWorldDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btDynamicsWorldDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataFloat_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btDynamicsWorldFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *arg2 = (btAlignedObjectArray< btDynamicsWorldFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btDynamicsWorldFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dynamicWorldInfoDataFloat = *arg2;
  
}


btAlignedObjectArray< btDynamicsWorldFloatData * > *_wrap_btBulletSerializedArrays_m_dynamicWorldInfoDataFloat_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *result = 0 ;
  btAlignedObjectArray< btDynamicsWorldFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btDynamicsWorldFloatData * > *)& ((arg1)->m_dynamicWorldInfoDataFloat);
  *(btAlignedObjectArray< btDynamicsWorldFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btDynamicsWorldFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_rigidBodyDataDouble_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btRigidBodyDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *arg2 = (btAlignedObjectArray< btRigidBodyDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btRigidBodyDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rigidBodyDataDouble = *arg2;
  
}


btAlignedObjectArray< btRigidBodyDoubleData * > *_wrap_btBulletSerializedArrays_m_rigidBodyDataDouble_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *result = 0 ;
  btAlignedObjectArray< btRigidBodyDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBodyDoubleData * > *)& ((arg1)->m_rigidBodyDataDouble);
  *(btAlignedObjectArray< btRigidBodyDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btRigidBodyDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_rigidBodyDataFloat_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btRigidBodyFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *arg2 = (btAlignedObjectArray< btRigidBodyFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btRigidBodyFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rigidBodyDataFloat = *arg2;
  
}


btAlignedObjectArray< btRigidBodyFloatData * > *_wrap_btBulletSerializedArrays_m_rigidBodyDataFloat_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *result = 0 ;
  btAlignedObjectArray< btRigidBodyFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBodyFloatData * > *)& ((arg1)->m_rigidBodyDataFloat);
  *(btAlignedObjectArray< btRigidBodyFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btRigidBodyFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_collisionObjectDataDouble_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionObjectDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *arg2 = (btAlignedObjectArray< btCollisionObjectDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObjectDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectDataDouble = *arg2;
  
}


btAlignedObjectArray< btCollisionObjectDoubleData * > *_wrap_btBulletSerializedArrays_m_collisionObjectDataDouble_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *result = 0 ;
  btAlignedObjectArray< btCollisionObjectDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObjectDoubleData * > *)& ((arg1)->m_collisionObjectDataDouble);
  *(btAlignedObjectArray< btCollisionObjectDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObjectDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_collisionObjectDataFloat_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btCollisionObjectFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *arg2 = (btAlignedObjectArray< btCollisionObjectFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObjectFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectDataFloat = *arg2;
  
}


btAlignedObjectArray< btCollisionObjectFloatData * > *_wrap_btBulletSerializedArrays_m_collisionObjectDataFloat_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *result = 0 ;
  btAlignedObjectArray< btCollisionObjectFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObjectFloatData * > *)& ((arg1)->m_collisionObjectDataFloat);
  *(btAlignedObjectArray< btCollisionObjectFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObjectFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintDataFloat_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *arg2 = (btAlignedObjectArray< btTypedConstraintFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintDataFloat = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintFloatData * > *_wrap_btBulletSerializedArrays_m_constraintDataFloat_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintFloatData * > *)& ((arg1)->m_constraintDataFloat);
  *(btAlignedObjectArray< btTypedConstraintFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintDataDouble_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *arg2 = (btAlignedObjectArray< btTypedConstraintDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintDataDouble = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintDoubleData * > *_wrap_btBulletSerializedArrays_m_constraintDataDouble_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintDoubleData * > *)& ((arg1)->m_constraintDataDouble);
  *(btAlignedObjectArray< btTypedConstraintDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_constraintData_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btTypedConstraintData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *arg2 = (btAlignedObjectArray< btTypedConstraintData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraintData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraintData = *arg2;
  
}


btAlignedObjectArray< btTypedConstraintData * > *_wrap_btBulletSerializedArrays_m_constraintData_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraintData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraintData * > *)& ((arg1)->m_constraintData);
  *(btAlignedObjectArray< btTypedConstraintData * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraintData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_softBodyFloatData_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btSoftBodyFloatData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *arg2 = (btAlignedObjectArray< btSoftBodyFloatData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btSoftBodyFloatData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_softBodyFloatData = *arg2;
  
}


btAlignedObjectArray< btSoftBodyFloatData * > *_wrap_btBulletSerializedArrays_m_softBodyFloatData_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *result = 0 ;
  btAlignedObjectArray< btSoftBodyFloatData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btSoftBodyFloatData * > *)& ((arg1)->m_softBodyFloatData);
  *(btAlignedObjectArray< btSoftBodyFloatData * > **)&_swig_go_result = (btAlignedObjectArray< btSoftBodyFloatData * > *)result; 
  return _swig_go_result;
}


void _wrap_btBulletSerializedArrays_m_softBodyDoubleData_set_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0, btAlignedObjectArray< btSoftBodyDoubleData * > *_swig_go_1) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *arg2 = (btAlignedObjectArray< btSoftBodyDoubleData * > *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btSoftBodyDoubleData * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_softBodyDoubleData = *arg2;
  
}


btAlignedObjectArray< btSoftBodyDoubleData * > *_wrap_btBulletSerializedArrays_m_softBodyDoubleData_get_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *result = 0 ;
  btAlignedObjectArray< btSoftBodyDoubleData * > *_swig_go_result;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btSoftBodyDoubleData * > *)& ((arg1)->m_softBodyDoubleData);
  *(btAlignedObjectArray< btSoftBodyDoubleData * > **)&_swig_go_result = (btAlignedObjectArray< btSoftBodyDoubleData * > *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBulletSerializedArrays_mbt_e1d552452a96202d(btBulletSerializedArrays *_swig_go_0) {
  btBulletSerializedArrays *arg1 = (btBulletSerializedArrays *) 0 ;
  
  arg1 = *(btBulletSerializedArrays **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btDefaultSerializer_m_skipPointers_set_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, btHashMap< btHashPtr,void * > *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btHashMap< btHashPtr,void * > *arg2 = (btHashMap< btHashPtr,void * > *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(btHashMap< btHashPtr,void * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_skipPointers = *arg2;
  
}


btHashMap< btHashPtr,void * > *_wrap_btDefaultSerializer_m_skipPointers_get_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btHashMap< btHashPtr,void * > *result = 0 ;
  btHashMap< btHashPtr,void * > *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (btHashMap< btHashPtr,void * > *)& ((arg1)->m_skipPointers);
  *(btHashMap< btHashPtr,void * > **)&_swig_go_result = (btHashMap< btHashPtr,void * > *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_0_mbt_e1d552452a96202d(intgo _swig_go_0, char *_swig_go_1) {
  int arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  result = (btDefaultSerializer *)new btDefaultSerializer(arg1,arg2);
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_1_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (btDefaultSerializer *)new btDefaultSerializer(arg1);
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


btDefaultSerializer *_wrap_new_btDefaultSerializer__SWIG_2_mbt_e1d552452a96202d() {
  btDefaultSerializer *result = 0 ;
  btDefaultSerializer *_swig_go_result;
  
  
  result = (btDefaultSerializer *)new btDefaultSerializer();
  *(btDefaultSerializer **)&_swig_go_result = (btDefaultSerializer *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDefaultSerializer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btDefaultSerializer_getMemoryDnaSizeInBytes_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)btDefaultSerializer::getMemoryDnaSizeInBytes();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btDefaultSerializer_getMemoryDna_mbt_e1d552452a96202d() {
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  
  result = (char *)btDefaultSerializer::getMemoryDna();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_insertHeader_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->insertHeader();
  
}


void _wrap_btDefaultSerializer_writeHeader_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, char *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(unsigned char **)&_swig_go_1; 
  
  ((btDefaultSerializer const *)arg1)->writeHeader(arg2);
  
}


void _wrap_btDefaultSerializer_startSerialization_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->startSerialization();
  
}


void _wrap_btDefaultSerializer_finishSerialization_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  (arg1)->finishSerialization();
  
}


void *_wrap_btDefaultSerializer_getUniquePointer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (void *)(arg1)->getUniquePointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


char *_wrap_btDefaultSerializer_getBufferPointer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (unsigned char *)((btDefaultSerializer const *)arg1)->getBufferPointer();
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


intgo _wrap_btDefaultSerializer_getCurrentBufferSize_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getCurrentBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_finalizeChunk_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, btChunk *_swig_go_1, _gostring_ _swig_go_2, intgo _swig_go_3, void *_swig_go_4) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  btChunk *arg2 = (btChunk *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(btChunk **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  arg4 = (int)_swig_go_3; 
  arg5 = *(void **)&_swig_go_4; 
  
  (arg1)->finalizeChunk(arg2,(char const *)arg3,arg4,arg5);
  
  free(arg3); 
}


char *_wrap_btDefaultSerializer_internalAlloc_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, long long _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  unsigned char *result = 0 ;
  char *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  
  result = (unsigned char *)(arg1)->internalAlloc(arg2);
  *(unsigned char **)&_swig_go_result = (unsigned char *)result; 
  return _swig_go_result;
}


btChunk *_wrap_btDefaultSerializer_allocate_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, long long _swig_go_1, intgo _swig_go_2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  size_t arg2 ;
  int arg3 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (size_t)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btChunk *)(arg1)->allocate(arg2,arg3);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btDefaultSerializer_findNameForPointer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  result = (char *)((btDefaultSerializer const *)arg1)->findNameForPointer((void const *)arg2);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_registerNameForPointer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, void *_swig_go_1, _gostring_ _swig_go_2) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  arg3 = (char *)malloc(_swig_go_2.n + 1);
  memcpy(arg3, _swig_go_2.p, _swig_go_2.n);
  arg3[_swig_go_2.n] = '\0';
  
  
  (arg1)->registerNameForPointer((void const *)arg2,(char const *)arg3);
  
  free(arg3); 
}


void _wrap_btDefaultSerializer_serializeName_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, _gostring_ _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  (arg1)->serializeName((char const *)arg2);
  
  free(arg2); 
}


intgo _wrap_btDefaultSerializer_getSerializationFlags_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getSerializationFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDefaultSerializer_setSerializationFlags_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, intgo _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int arg2 ;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setSerializationFlags(arg2);
  
}


intgo _wrap_btDefaultSerializer_getNumChunks_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  
  result = (int)((btDefaultSerializer const *)arg1)->getNumChunks();
  _swig_go_result = result; 
  return _swig_go_result;
}


btChunk *_wrap_btDefaultSerializer_getChunk_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, intgo _swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  int arg2 ;
  btChunk *result = 0 ;
  btChunk *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btChunk *)((btDefaultSerializer const *)arg1)->getChunk(arg2);
  *(btChunk **)&_swig_go_result = (btChunk *)result; 
  return _swig_go_result;
}


void *_wrap_btDefaultSerializer_findPointer_mbt_e1d552452a96202d(btDefaultSerializer *_swig_go_0, void *_swig_go_1) {
  btDefaultSerializer *arg1 = (btDefaultSerializer *) 0 ;
  void *arg2 = (void *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btDefaultSerializer **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btSerializer *swig_b0 = (btSerializer *)arg1;
  result = (void *)(swig_b0)->findPointer(arg2);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_AabbExpand_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  AabbExpand(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  
}


bool _wrap_TestPointAgainstAabb2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestPointAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestAabbAgainstAabb2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (bool)TestAabbAgainstAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_TestTriangleAgainstAabb2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (bool)TestTriangleAgainstAabb2((btVector3 const *)arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btOutcode_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (int)btOutcode((btVector3 const &)*arg1,(btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb2_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo *_swig_go_2, btVector3 (*_swig_go_3)[2], float *_swig_go_4, float _swig_go_5, float _swig_go_6) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  unsigned int *arg3 = (unsigned int *) (unsigned int *)0 ;
  btVector3 *arg4 = (btVector3 *) (btVector3 *)0 ;
  btScalar *arg5 = 0 ;
  btScalar arg6 ;
  btScalar arg7 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(unsigned int **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  
  result = (bool)btRayAabb2((btVector3 const &)*arg1,(btVector3 const &)*arg2,(unsigned int const (*))arg3,(btVector3 const (*))arg4,*arg5,arg6,arg7);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRayAabb_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  result = (bool)btRayAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,*arg5,*arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTransformAabb__SWIG_0_mbt_e1d552452a96202d(btVector3 *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2, btVector3 *_swig_go_3, btVector3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  
  btTransformAabb((btVector3 const &)*arg1,arg2,(btTransform const &)*arg3,*arg4,*arg5);
  
}


void _wrap_btTransformAabb__SWIG_1_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  
  btTransformAabb((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btTransform const &)*arg4,*arg5,*arg6);
  
}


intgo _wrap_testQuantizedAabbAgainstQuantizedAabb_mbt_e1d552452a96202d(short *_swig_go_0, short *_swig_go_1, short *_swig_go_2, short *_swig_go_3) {
  unsigned short *arg1 = (unsigned short *) 0 ;
  unsigned short *arg2 = (unsigned short *) 0 ;
  unsigned short *arg3 = (unsigned short *) 0 ;
  unsigned short *arg4 = (unsigned short *) 0 ;
  unsigned int result;
  intgo _swig_go_result;
  
  arg1 = *(unsigned short **)&_swig_go_0; 
  arg2 = *(unsigned short **)&_swig_go_1; 
  arg3 = *(unsigned short **)&_swig_go_2; 
  arg4 = *(unsigned short **)&_swig_go_3; 
  
  result = (unsigned int)testQuantizedAabbAgainstQuantizedAabb((unsigned short const *)arg1,(unsigned short const *)arg2,(unsigned short const *)arg3,(unsigned short const *)arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_vertices_set_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexHullComputer_vertices_get_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_original_vertex_index_set_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->original_vertex_index = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_original_vertex_index_get_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->original_vertex_index);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_edges_set_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *arg2 = (btAlignedObjectArray< btConvexHullComputer::Edge > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_1; 
  
  if (arg1) (arg1)->edges = *arg2;
  
}


btAlignedObjectArray< btConvexHullComputer::Edge > *_wrap_btConvexHullComputer_edges_get_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *result = 0 ;
  btAlignedObjectArray< btConvexHullComputer::Edge > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)& ((arg1)->edges);
  *(btAlignedObjectArray< btConvexHullComputer::Edge > **)&_swig_go_result = (btAlignedObjectArray< btConvexHullComputer::Edge > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullComputer_faces_set_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->faces = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btConvexHullComputer_faces_get_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->faces);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_0_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, float *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((float const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexHullComputer_compute__SWIG_1_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0, double *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btScalar)(arg1)->compute((double const *)arg2,arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullComputer *_wrap_new_btConvexHullComputer_mbt_e1d552452a96202d() {
  btConvexHullComputer *result = 0 ;
  btConvexHullComputer *_swig_go_result;
  
  
  result = (btConvexHullComputer *)new btConvexHullComputer();
  *(btConvexHullComputer **)&_swig_go_result = (btConvexHullComputer *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullComputer_mbt_e1d552452a96202d(btConvexHullComputer *_swig_go_0) {
  btConvexHullComputer *arg1 = (btConvexHullComputer *) 0 ;
  
  arg1 = *(btConvexHullComputer **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexHullInternal_vertexList_set_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  if (arg1) (arg1)->vertexList = arg2;
  
}


btConvexHullInternal::Vertex *_wrap_btConvexHullInternal_vertexList_get_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *result = 0 ;
  btConvexHullInternal::Vertex *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  result = (btConvexHullInternal::Vertex *) ((arg1)->vertexList);
  *(btConvexHullInternal::Vertex **)&_swig_go_result = (btConvexHullInternal::Vertex *)result; 
  return _swig_go_result;
}


void _wrap_btConvexHullInternal_compute_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0, void *_swig_go_1, bool _swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  void *arg2 = (void *) 0 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  (arg1)->compute((void const *)arg2,arg3,arg4,arg5);
  
}


btVector3 *_wrap_btConvexHullInternal_getCoordinates_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0, btConvexHullInternal::Vertex *_swig_go_1) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btConvexHullInternal::Vertex *arg2 = (btConvexHullInternal::Vertex *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = *(btConvexHullInternal::Vertex **)&_swig_go_1; 
  
  result = (arg1)->getCoordinates((btConvexHullInternal::Vertex const *)arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexHullInternal_shrink_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)(arg1)->shrink(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexHullInternal *_wrap_new_btConvexHullInternal_mbt_e1d552452a96202d() {
  btConvexHullInternal *result = 0 ;
  btConvexHullInternal *_swig_go_result;
  
  
  result = (btConvexHullInternal *)new btConvexHullInternal();
  *(btConvexHullInternal **)&_swig_go_result = (btConvexHullInternal *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexHullInternal_mbt_e1d552452a96202d(btConvexHullInternal *_swig_go_0) {
  btConvexHullInternal *arg1 = (btConvexHullInternal *) 0 ;
  
  arg1 = *(btConvexHullInternal **)&_swig_go_0; 
  
  delete arg1;
  
}


pointCmp *_wrap_new_pointCmp_mbt_e1d552452a96202d() {
  pointCmp *result = 0 ;
  pointCmp *_swig_go_result;
  
  
  result = (pointCmp *)new pointCmp();
  *(pointCmp **)&_swig_go_result = (pointCmp *)result; 
  return _swig_go_result;
}


void _wrap_delete_pointCmp_mbt_e1d552452a96202d(pointCmp *_swig_go_0) {
  pointCmp *arg1 = (pointCmp *) 0 ;
  
  arg1 = *(pointCmp **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_getVertexCopy_mbt_e1d552452a96202d(btConvexHullInternal::Vertex *_swig_go_0, btAlignedObjectArray< btConvexHullInternal::Vertex * > *_swig_go_1) {
  btConvexHullInternal::Vertex *arg1 = (btConvexHullInternal::Vertex *) 0 ;
  btAlignedObjectArray< btConvexHullInternal::Vertex * > *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexHullInternal::Vertex **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btConvexHullInternal::Vertex * > **)&_swig_go_1; 
  
  result = (int)getVertexCopy(arg1,*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeometryUtil_getPlaneEquationsFromVertices_mbt_e1d552452a96202d(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getPlaneEquationsFromVertices(*arg1,*arg2);
  
}


void _wrap_btGeometryUtil_getVerticesFromPlaneEquations_mbt_e1d552452a96202d(btAlignedObjectArray< btVector3 > *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  btGeometryUtil::getVerticesFromPlaneEquations((btAlignedObjectArray< btVector3 > const &)*arg1,*arg2);
  
}


bool _wrap_btGeometryUtil_isPointInsidePlanes_mbt_e1d552452a96202d(btAlignedObjectArray< btVector3 > *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btAlignedObjectArray< btVector3 > *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::isPointInsidePlanes((btAlignedObjectArray< btVector3 > const &)*arg1,(btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeometryUtil_areVerticesBehindPlane_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1, float _swig_go_2) {
  btVector3 *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)btGeometryUtil::areVerticesBehindPlane((btVector3 const &)*arg1,(btAlignedObjectArray< btVector3 > const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeometryUtil *_wrap_new_btGeometryUtil_mbt_e1d552452a96202d() {
  btGeometryUtil *result = 0 ;
  btGeometryUtil *_swig_go_result;
  
  
  result = (btGeometryUtil *)new btGeometryUtil();
  *(btGeometryUtil **)&_swig_go_result = (btGeometryUtil *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeometryUtil_mbt_e1d552452a96202d(btGeometryUtil *_swig_go_0) {
  btGeometryUtil *arg1 = (btGeometryUtil *) 0 ;
  
  arg1 = *(btGeometryUtil **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBulletMathProbe_mbt_e1d552452a96202d() {
  btBulletMathProbe();
  
}


bool _wrap_notExist_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btVector3 *arg1 = 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  result = (bool)notExist((btVector3 const &)*arg1,(btAlignedObjectArray< btVector3 > const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


btClock *_wrap_new_btClock__SWIG_0_mbt_e1d552452a96202d() {
  btClock *result = 0 ;
  btClock *_swig_go_result;
  
  
  result = (btClock *)new btClock();
  *(btClock **)&_swig_go_result = (btClock *)result; 
  return _swig_go_result;
}


btClock *_wrap_new_btClock__SWIG_1_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = 0 ;
  btClock *result = 0 ;
  btClock *_swig_go_result;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  result = (btClock *)new btClock((btClock const &)*arg1);
  *(btClock **)&_swig_go_result = (btClock *)result; 
  return _swig_go_result;
}


void _wrap_delete_btClock_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btClock_reset_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  (arg1)->reset();
  
}


long long _wrap_btClock_getTimeMilliseconds_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  unsigned long long result;
  long long _swig_go_result;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  result = (unsigned long long)(arg1)->getTimeMilliseconds();
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btClock_getTimeMicroseconds_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  unsigned long long result;
  long long _swig_go_result;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  result = (unsigned long long)(arg1)->getTimeMicroseconds();
  _swig_go_result = result; 
  return _swig_go_result;
}


long long _wrap_btClock_getTimeNanoseconds_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  unsigned long long result;
  long long _swig_go_result;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  result = (unsigned long long)(arg1)->getTimeNanoseconds();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btClock_getTimeSeconds_mbt_e1d552452a96202d(btClock *_swig_go_0) {
  btClock *arg1 = (btClock *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btClock **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getTimeSeconds();
  _swig_go_result = result; 
  return _swig_go_result;
}


void* _wrap_btGetCurrentEnterProfileZoneFunc_mbt_e1d552452a96202d() {
  btEnterProfileZoneFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btEnterProfileZoneFunc *)btGetCurrentEnterProfileZoneFunc();
  *(btEnterProfileZoneFunc **)&_swig_go_result = (btEnterProfileZoneFunc *)result; 
  return _swig_go_result;
}


void* _wrap_btGetCurrentLeaveProfileZoneFunc_mbt_e1d552452a96202d() {
  btLeaveProfileZoneFunc *result = 0 ;
  void* _swig_go_result;
  
  
  result = (btLeaveProfileZoneFunc *)btGetCurrentLeaveProfileZoneFunc();
  *(btLeaveProfileZoneFunc **)&_swig_go_result = (btLeaveProfileZoneFunc *)result; 
  return _swig_go_result;
}


void _wrap_btSetCustomEnterProfileZoneFunc_mbt_e1d552452a96202d(void* _swig_go_0) {
  btEnterProfileZoneFunc *arg1 = (btEnterProfileZoneFunc *) 0 ;
  
  arg1 = *(btEnterProfileZoneFunc **)&_swig_go_0; 
  
  btSetCustomEnterProfileZoneFunc(arg1);
  
}


void _wrap_btSetCustomLeaveProfileZoneFunc_mbt_e1d552452a96202d(void* _swig_go_0) {
  btLeaveProfileZoneFunc *arg1 = (btLeaveProfileZoneFunc *) 0 ;
  
  arg1 = *(btLeaveProfileZoneFunc **)&_swig_go_0; 
  
  btSetCustomLeaveProfileZoneFunc(arg1);
  
}


intgo _wrap_BT_QUICKPROF_MAX_THREAD_COUNT_get_mbt_e1d552452a96202d() {
  unsigned int result;
  intgo _swig_go_result;
  
  
  result = (unsigned int)(unsigned int)BT_QUICKPROF_MAX_THREAD_COUNT;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btQuickprofGetCurrentThreadIndex2_mbt_e1d552452a96202d() {
  unsigned int result;
  intgo _swig_go_result;
  
  
  result = (unsigned int)btQuickprofGetCurrentThreadIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BOX_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TETRAHEDRAL_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TETRAHEDRAL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_HULL_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_HULL_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_POLYHEDRAL_SHAPE_TYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_POLYHEDRAL_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_IMPLICIT_CONVEX_SHAPES_START_HERE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = IMPLICIT_CONVEX_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SPHERE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTI_SPHERE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTI_SPHERE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CAPSULE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CAPSULE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CYLINDER_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CYLINDER_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_UNIFORM_SCALING_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = UNIFORM_SCALING_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_SUM_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_SUM_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BOX_2D_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = BOX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONVEX_2D_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONVEX_2D_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONVEX_SHAPE_TYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONVEX_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_START_HERE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_START_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FAST_CONCAVE_MESH_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = FAST_CONCAVE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_TERRAIN_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = TERRAIN_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GIMPACT_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = GIMPACT_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_EMPTY_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = EMPTY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_STATIC_PLANE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = STATIC_PLANE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CUSTOM_CONCAVE_SHAPE_TYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CUSTOM_CONCAVE_SHAPE_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SDF_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SDF_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONCAVE_SHAPES_END_HERE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = CONCAVE_SHAPES_END_HERE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_COMPOUND_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = COMPOUND_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SOFTBODY_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = SOFTBODY_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_INVALID_SHAPE_PROXYTYPE_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = INVALID_SHAPE_PROXYTYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_BROADPHASE_COLLISION_TYPES_mbt_e1d552452a96202d() {
  BroadphaseNativeTypes result;
  intgo _swig_go_result;
  
  
  result = MAX_BROADPHASE_COLLISION_TYPES;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DefaultFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DefaultFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_StaticFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::StaticFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_KinematicFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::KinematicFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_DebrisFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::DebrisFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SensorTrigger_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::SensorTrigger;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CharacterFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::CharacterFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_AllFilter_btBroadphaseProxy_mbt_e1d552452a96202d() {
  btBroadphaseProxy::CollisionFilterGroups result;
  intgo _swig_go_result;
  
  
  result = btBroadphaseProxy::AllFilter;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_clientObject_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, void *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_clientObject = arg2;
  
}


void *_wrap_btBroadphaseProxy_m_clientObject_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_clientObject);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterGroup_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterGroup_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_collisionFilterMask_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_collisionFilterMask_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_uniqueId_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, intgo _swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int arg2 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btBroadphaseProxy_m_uniqueId_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMin_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMin = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMin_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMin);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphaseProxy_m_aabbMax_set_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, btVector3 *_swig_go_1) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_aabbMax = *arg2;
  
}


btVector3 *_wrap_btBroadphaseProxy_m_aabbMax_get_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_aabbMax);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


intgo _wrap_btBroadphaseProxy_getUid_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  result = (int)((btBroadphaseProxy const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_0_mbt_e1d552452a96202d() {
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_new_btBroadphaseProxy__SWIG_1_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, void *_swig_go_2, intgo _swig_go_3, intgo _swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  void *arg3 = (void *) 0 ;
  int arg4 ;
  int arg5 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  
  result = (btBroadphaseProxy *)new btBroadphaseProxy((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isPolyhedral_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isPolyhedral(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isNonMoving_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isNonMoving(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConcave_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConcave(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isCompound_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isCompound(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isSoftBody_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isSoftBody(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isInfinite_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isInfinite(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBroadphaseProxy_isConvex2d_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = (int)_swig_go_0; 
  
  result = (bool)btBroadphaseProxy::isConvex2d(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphaseProxy_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0) {
  btBroadphaseProxy *arg1 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_0_mbt_e1d552452a96202d() {
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  
  result = (btBroadphasePair *)new btBroadphasePair();
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


btBroadphasePair *_wrap_new_btBroadphasePair__SWIG_1_mbt_e1d552452a96202d(btBroadphaseProxy *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphaseProxy *arg1 = 0 ;
  btBroadphaseProxy *arg2 = 0 ;
  btBroadphasePair *result = 0 ;
  btBroadphasePair *_swig_go_result;
  
  arg1 = *(btBroadphaseProxy **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (btBroadphasePair *)new btBroadphasePair(*arg1,*arg2);
  *(btBroadphasePair **)&_swig_go_result = (btBroadphasePair *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy0_set_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy0 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy0_get_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy0);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_pProxy1_set_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pProxy1 = arg2;
  
}


btBroadphaseProxy *_wrap_btBroadphasePair_m_pProxy1_get_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *) ((arg1)->m_pProxy1);
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btBroadphasePair_m_algorithm_set_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0, btCollisionAlgorithm *_swig_go_1) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *arg2 = (btCollisionAlgorithm *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  arg2 = *(btCollisionAlgorithm **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_algorithm = arg2;
  
}


btCollisionAlgorithm *_wrap_btBroadphasePair_m_algorithm_get_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  btCollisionAlgorithm *_swig_go_result;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  result = (btCollisionAlgorithm *) ((arg1)->m_algorithm);
  *(btCollisionAlgorithm **)&_swig_go_result = (btCollisionAlgorithm *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePair_mbt_e1d552452a96202d(btBroadphasePair *_swig_go_0) {
  btBroadphasePair *arg1 = (btBroadphasePair *) 0 ;
  
  arg1 = *(btBroadphasePair **)&_swig_go_0; 
  
  delete arg1;
  
}


btBroadphasePairSortPredicate *_wrap_new_btBroadphasePairSortPredicate_mbt_e1d552452a96202d() {
  btBroadphasePairSortPredicate *result = 0 ;
  btBroadphasePairSortPredicate *_swig_go_result;
  
  
  result = (btBroadphasePairSortPredicate *)new btBroadphasePairSortPredicate();
  *(btBroadphasePairSortPredicate **)&_swig_go_result = (btBroadphasePairSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btBroadphasePairSortPredicate_mbt_e1d552452a96202d(btBroadphasePairSortPredicate *_swig_go_0) {
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  
  arg1 = *(btBroadphasePairSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btCollisionShape_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionShape_getAabb_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCollisionShape_getBoundingSphere_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCollisionShape_getAngularMotionDisc_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateTemporalAabb_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCollisionShape_isPolyhedral_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex2d_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConvex_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isNonMoving_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isConcave_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isCompound_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isSoftBody_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionShape_isInfinite_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (bool)((btCollisionShape const *)arg1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setLocalScaling_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionShape_getLocalScaling_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_calculateLocalInertia_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btCollisionShape_getName_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (char *)((btCollisionShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_getShapeType_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setMargin_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, float _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btCollisionShape_getMargin_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserPointer_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, void *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void *_wrap_btCollisionShape_getUserPointer_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShape_setUserIndex2_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, intgo _swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


intgo _wrap_btCollisionShape_getUserIndex2_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  
  result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionShape_serialize_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShape_serializeSingleShape_mbt_e1d552452a96202d(btCollisionShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
  
}


void _wrap_btCollisionShapeData_m_name_set_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_name_get_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_shapeType_set_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0, intgo _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_shapeType = arg2;
  
}


intgo _wrap_btCollisionShapeData_m_shapeType_get_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_shapeType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionShapeData_m_padding_set_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionShapeData_m_padding_get_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCollisionShapeData *_wrap_new_btCollisionShapeData_mbt_e1d552452a96202d() {
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  
  result = (btCollisionShapeData *)new btCollisionShapeData();
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionShapeData_mbt_e1d552452a96202d(btCollisionShapeData *_swig_go_0) {
  btCollisionShapeData *arg1 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBulletCollisionProbe_mbt_e1d552452a96202d() {
  btBulletCollisionProbe();
  
}


void _wrap_delete_btConvexShape_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertex_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexShape_getMarginNonVirtual_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getAabbNonVirtual_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_project_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexShape_getAabb_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_getAabbSlow_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexShape_setLocalScaling_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexShape_getLocalScaling_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setMargin_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexShape_getMargin_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_btConvexShape_getBoundingSphere_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexShape_getAngularMotionDisc_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, float _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (btScalar)((btCollisionShape const *)swig_b0)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateTemporalAabb_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexShape_isPolyhedral_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex2d_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConvex_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isNonMoving_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isConcave_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isCompound_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isSoftBody_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexShape_isInfinite_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (bool)((btCollisionShape const *)swig_b0)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_calculateLocalInertia_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexShape_getName_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_getShapeType_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = ((btCollisionShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserPointer_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, void *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void *_wrap_btConvexShape_getUserPointer_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (void *)((btCollisionShape const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexShape_setUserIndex2_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, intgo _swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexShape_getUserIndex2_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btConvexShape *_swig_go_0) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (int)((btCollisionShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexShape_serialize_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  result = (char *)((btCollisionShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btConvexShape_serializeSingleShape_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCollisionShape *swig_b0 = (btCollisionShape *)arg1;
  ((btCollisionShape const *)swig_b0)->serializeSingleShape(arg2);
  
}


btVector3 *_wrap_convexHullSupport_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = convexHullSupport((btVector3 const &)*arg1,(btVector3 const *)arg2,arg3,(btVector3 const &)*arg4);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShape_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalShape_getAabb_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_getAabbSlow_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_setLocalScaling_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btConvexInternalShape_getLocalScaling_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setMargin_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btConvexInternalShape_getMargin_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNV_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalShape_serialize_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = ((btConvexShape const *)swig_b0)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getMarginNonVirtual_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  result = (btScalar)((btConvexShape const *)swig_b0)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_getAabbNonVirtual_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalShape_project_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  ((btConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalShape_getBoundingSphere_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalShape_getAngularMotionDisc_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (btScalar)((btCollisionShape const *)swig_b1)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateTemporalAabb_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalShape_isPolyhedral_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex2d_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConvex_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isNonMoving_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isConcave_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isCompound_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isSoftBody_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalShape_isInfinite_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (bool)((btCollisionShape const *)swig_b1)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_calculateLocalInertia_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalShape_getName_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (char *)((btCollisionShape const *)swig_b1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalShape_getShapeType_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = ((btCollisionShape const *)swig_b1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserPointer_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalShape_getUserPointer_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (void *)((btCollisionShape const *)swig_b1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_setUserIndex2_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  (swig_b1)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalShape_getUserIndex2_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  result = (int)((btCollisionShape const *)swig_b1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShape_serializeSingleShape_mbt_e1d552452a96202d(btConvexInternalShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexShape *swig_b0 = (btConvexShape *)arg1;
  btCollisionShape *swig_b1 = (btCollisionShape *)swig_b0;
  ((btCollisionShape const *)swig_b1)->serializeSingleShape(arg2);
  
}


void _wrap_btConvexInternalShapeData_m_collisionShapeData_set_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShapeData = *arg2;
  
}


btCollisionShapeData *_wrap_btConvexInternalShapeData_m_collisionShapeData_get_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *)& ((arg1)->m_collisionShapeData);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_localScaling_set_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localScaling = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_localScaling_get_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_localScaling);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_implicitShapeDimensions_set_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_implicitShapeDimensions = *arg2;
  
}


btVector3FloatData *_wrap_btConvexInternalShapeData_m_implicitShapeDimensions_get_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_implicitShapeDimensions);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_collisionMargin_set_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0, float _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionMargin = arg2;
  
}


float _wrap_btConvexInternalShapeData_m_collisionMargin_get_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_collisionMargin);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalShapeData_m_padding_set_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btConvexInternalShapeData_m_padding_get_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConvexInternalShapeData *_wrap_new_btConvexInternalShapeData_mbt_e1d552452a96202d() {
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  
  result = (btConvexInternalShapeData *)new btConvexInternalShapeData();
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexInternalShapeData_mbt_e1d552452a96202d(btConvexInternalShapeData *_swig_go_0) {
  btConvexInternalShapeData *arg1 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btConvexInternalShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexInternalAabbCachingShape_setLocalScaling_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabb_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btConvexInternalAabbCachingShape_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertex_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btConvexInternalAabbCachingShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btConvexInternalAabbCachingShape_getAabbSlow_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScaling_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getLocalScalingNV_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setMargin_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btConvexInternalAabbCachingShape_getMargin_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNV_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_serialize_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getMarginNonVirtual_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_getAabbNonVirtual_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_project_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btConvexInternalAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btConvexInternalAabbCachingShape_getBoundingSphere_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btConvexInternalAabbCachingShape_getAngularMotionDisc_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConvexInternalAabbCachingShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateTemporalAabb_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btConvexInternalAabbCachingShape_isPolyhedral_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex2d_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConvex_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isNonMoving_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isConcave_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isCompound_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isSoftBody_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConvexInternalAabbCachingShape_isInfinite_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_calculateLocalInertia_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateLocalInertia(arg2,*arg3);
  
}


_gostring_ _wrap_btConvexInternalAabbCachingShape_getName_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btConvexInternalAabbCachingShape_getShapeType_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btConvexInternalAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserPointer_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btConvexInternalAabbCachingShape_getUserPointer_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_setUserIndex2_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btConvexInternalAabbCachingShape_getUserIndex2_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexInternalAabbCachingShape_serializeSingleShape_mbt_e1d552452a96202d(btConvexInternalAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btConvexInternalAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_delete_btPolyhedralConvexShape_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (bool)(arg1)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setPolyhedralFeatures_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  (arg1)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexShape_calculateLocalInertia_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumVertices_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumEdges_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getEdge_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getVertex_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_getNumPlanes_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPlane_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexShape_isInside_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertex_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexShape_getAabb_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_getAabbSlow_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_setLocalScaling_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScaling_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getLocalScalingNV_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setMargin_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexShape_getMargin_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNV_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_serialize_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getMarginNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_getAabbNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexShape_project_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexShape_getBoundingSphere_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexShape_getAngularMotionDisc_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_calculateTemporalAabb_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexShape_isPolyhedral_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex2d_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConvex_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isNonMoving_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isConcave_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isCompound_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isSoftBody_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexShape_isInfinite_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexShape_getName_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (char *)((btCollisionShape const *)swig_b2)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexShape_getShapeType_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserPointer_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexShape_getUserPointer_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_setUserIndex2_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexShape_getUserIndex2_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexShape_serializeSingleShape_mbt_e1d552452a96202d(btPolyhedralConvexShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabb_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  (arg1)->recalcLocalAabb();
  
}


void _wrap_delete_btPolyhedralConvexAabbCachingShape_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_0_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_initializePolyhedralFeatures__SWIG_1_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setPolyhedralFeatures_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btPolyhedralConvexAabbCachingShape_getConvexPolyhedron_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = ((btPolyhedralConvexShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateLocalInertia_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumVertices_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumEdges_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getEdge_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getEdge(arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getVertex_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getVertex(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPlanes_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (int)((btPolyhedralConvexShape const *)swig_b0)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPlane_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  ((btPolyhedralConvexShape const *)swig_b0)->getPlane(*arg2,*arg3,arg4);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInside_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)((btPolyhedralConvexShape const *)swig_b0)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportingVertex_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbSlow_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScaling_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getLocalScalingNV_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setMargin_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setMargin(arg2);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMargin_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNV_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_serialize_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getMarginNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_getAabbNonVirtual_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_project_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btPolyhedralConvexAabbCachingShape_getBoundingSphere_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btPolyhedralConvexAabbCachingShape_getAngularMotionDisc_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPolyhedralConvexAabbCachingShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, float _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_calculateTemporalAabb_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isPolyhedral_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex2d_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConvex_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isNonMoving_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isConcave_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isCompound_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isSoftBody_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btPolyhedralConvexAabbCachingShape_isInfinite_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPolyhedralConvexAabbCachingShape_getName_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (char *)((btCollisionShape const *)swig_b3)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getShapeType_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btPolyhedralConvexAabbCachingShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserPointer_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, void *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btPolyhedralConvexAabbCachingShape_getUserPointer_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_setUserIndex2_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, intgo _swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btPolyhedralConvexAabbCachingShape_getUserIndex2_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPolyhedralConvexAabbCachingShape_serializeSingleShape_mbt_e1d552452a96202d(btPolyhedralConvexAabbCachingShape *_swig_go_0, btSerializer *_swig_go_1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btPolyhedralConvexAabbCachingShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


void _wrap_btFace_m_indices_set_mbt_e1d552452a96202d(btFace *_swig_go_0, btAlignedObjectArray< int > *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< int > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_indices = *arg2;
  
}


btAlignedObjectArray< int > *_wrap_btFace_m_indices_get_mbt_e1d552452a96202d(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  btAlignedObjectArray< int > *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< int > *)& ((arg1)->m_indices);
  *(btAlignedObjectArray< int > **)&_swig_go_result = (btAlignedObjectArray< int > *)result; 
  return _swig_go_result;
}


void _wrap_btFace_m_plane_set_mbt_e1d552452a96202d(btFace *_swig_go_0, float *_swig_go_1) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *arg2 = (btScalar *) (btScalar *)0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  {
    size_t ii;
    btScalar *b = (btScalar *) arg1->m_plane;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
  }
  
}


float *_wrap_btFace_m_plane_get_mbt_e1d552452a96202d(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  btScalar *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  result = (btScalar *)(btScalar *) ((arg1)->m_plane);
  *(btScalar **)&_swig_go_result = result; 
  return _swig_go_result;
}


btFace *_wrap_new_btFace_mbt_e1d552452a96202d() {
  btFace *result = 0 ;
  btFace *_swig_go_result;
  
  
  result = (btFace *)new btFace();
  *(btFace **)&_swig_go_result = (btFace *)result; 
  return _swig_go_result;
}


void _wrap_delete_btFace_mbt_e1d552452a96202d(btFace *_swig_go_0) {
  btFace *arg1 = (btFace *) 0 ;
  
  arg1 = *(btFace **)&_swig_go_0; 
  
  delete arg1;
  
}


btConvexPolyhedron *_wrap_new_btConvexPolyhedron_mbt_e1d552452a96202d() {
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  
  result = (btConvexPolyhedron *)new btConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConvexPolyhedron_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConvexPolyhedron_m_vertices_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_vertices = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_vertices_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_vertices);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_faces_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btFace > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *arg2 = (btAlignedObjectArray< btFace > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btFace > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_faces = *arg2;
  
}


btAlignedObjectArray< btFace > *_wrap_btConvexPolyhedron_m_faces_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btFace > *result = 0 ;
  btAlignedObjectArray< btFace > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btFace > *)& ((arg1)->m_faces);
  *(btAlignedObjectArray< btFace > **)&_swig_go_result = (btAlignedObjectArray< btFace > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_uniqueEdges_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btAlignedObjectArray< btVector3 > *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *arg2 = (btAlignedObjectArray< btVector3 > *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btVector3 > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueEdges = *arg2;
  
}


btAlignedObjectArray< btVector3 > *_wrap_btConvexPolyhedron_m_uniqueEdges_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btAlignedObjectArray< btVector3 > *result = 0 ;
  btAlignedObjectArray< btVector3 > *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btVector3 > *)& ((arg1)->m_uniqueEdges);
  *(btAlignedObjectArray< btVector3 > **)&_swig_go_result = (btAlignedObjectArray< btVector3 > *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_localCenter_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_localCenter = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_localCenter_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_localCenter);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_extents_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_extents = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_m_extents_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_extents);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_m_radius_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, float _swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_radius = arg2;
  
}


float _wrap_btConvexPolyhedron_m_radius_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_radius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mC_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mC = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mC_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mC);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_mE_set_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btVector3 *_swig_go_1) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->mE = *arg2;
  
}


btVector3 *_wrap_btConvexPolyhedron_mE_get_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->mE);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_initialize_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize();
  
}


void _wrap_btConvexPolyhedron_initialize2_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  (arg1)->initialize2();
  
}


bool _wrap_btConvexPolyhedron_testContainment_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  
  result = (bool)((btConvexPolyhedron const *)arg1)->testContainment();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConvexPolyhedron_project_mbt_e1d552452a96202d(btConvexPolyhedron *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btConvexPolyhedron *arg1 = (btConvexPolyhedron *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btConvexPolyhedron **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  ((btConvexPolyhedron const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


bool _wrap_IsAlmostZero1_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (bool)IsAlmostZero1((btVector3 const &)*arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btInternalVertexPair *_wrap_new_btInternalVertexPair_mbt_e1d552452a96202d(short _swig_go_0, short _swig_go_1) {
  short arg1 ;
  short arg2 ;
  btInternalVertexPair *result = 0 ;
  btInternalVertexPair *_swig_go_result;
  
  arg1 = (short)_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  result = (btInternalVertexPair *)new btInternalVertexPair(arg1,arg2);
  *(btInternalVertexPair **)&_swig_go_result = (btInternalVertexPair *)result; 
  return _swig_go_result;
}


void _wrap_btInternalVertexPair_m_v0_set_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0, short _swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_v0 = arg2;
  
}


short _wrap_btInternalVertexPair_m_v0_get_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_v0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btInternalVertexPair_m_v1_set_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0, short _swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_v1 = arg2;
  
}


short _wrap_btInternalVertexPair_m_v1_get_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_v1);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btInternalVertexPair_getHash_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  result = (int)((btInternalVertexPair const *)arg1)->getHash();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btInternalVertexPair_equals_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0, btInternalVertexPair *_swig_go_1) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  btInternalVertexPair *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  arg2 = *(btInternalVertexPair **)&_swig_go_1; 
  
  result = (bool)((btInternalVertexPair const *)arg1)->equals((btInternalVertexPair const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btInternalVertexPair_mbt_e1d552452a96202d(btInternalVertexPair *_swig_go_0) {
  btInternalVertexPair *arg1 = (btInternalVertexPair *) 0 ;
  
  arg1 = *(btInternalVertexPair **)&_swig_go_0; 
  
  delete arg1;
  
}


btInternalEdge *_wrap_new_btInternalEdge_mbt_e1d552452a96202d() {
  btInternalEdge *result = 0 ;
  btInternalEdge *_swig_go_result;
  
  
  result = (btInternalEdge *)new btInternalEdge();
  *(btInternalEdge **)&_swig_go_result = (btInternalEdge *)result; 
  return _swig_go_result;
}


void _wrap_btInternalEdge_m_face0_set_mbt_e1d552452a96202d(btInternalEdge *_swig_go_0, short _swig_go_1) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_face0 = arg2;
  
}


short _wrap_btInternalEdge_m_face0_get_mbt_e1d552452a96202d(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_face0);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btInternalEdge_m_face1_set_mbt_e1d552452a96202d(btInternalEdge *_swig_go_0, short _swig_go_1) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short arg2 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  arg2 = (short)_swig_go_1; 
  
  if (arg1) (arg1)->m_face1 = arg2;
  
}


short _wrap_btInternalEdge_m_face1_get_mbt_e1d552452a96202d(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  short result;
  short _swig_go_result;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  result = (short) ((arg1)->m_face1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btInternalEdge_mbt_e1d552452a96202d(btInternalEdge *_swig_go_0) {
  btInternalEdge *arg1 = (btInternalEdge *) 0 ;
  
  arg1 = *(btInternalEdge **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertex_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


btBoxShape *_wrap_new_btBoxShape_mbt_e1d552452a96202d(btVector3 *_swig_go_0) {
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  btBoxShape *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  
  result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
  *(btBoxShape **)&_swig_go_result = (btBoxShape *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btBoxShape_setLocalScaling_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabb_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_calculateLocalInertia_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlane_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
  
}


intgo _wrap_btBoxShape_getNumPlanes_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPlanes();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumVertices_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumVertices();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumEdges_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumEdges();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getVertex_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
  
}


void _wrap_btBoxShape_getPlaneEquation_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector4 *_swig_go_1, intgo _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector4 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
  
}


void _wrap_btBoxShape_getEdge_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
  
}


bool _wrap_btBoxShape_isInside_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_getName_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (char *)((btBoxShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


void _wrap_delete_btBoxShape_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  delete arg1;
  
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_0_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_initializePolyhedralFeatures__SWIG_1_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (bool)(swig_b0)->initializePolyhedralFeatures();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setPolyhedralFeatures_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btConvexPolyhedron *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btConvexPolyhedron **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  (swig_b0)->setPolyhedralFeatures(*arg2);
  
}


btConvexPolyhedron *_wrap_btBoxShape_getConvexPolyhedron_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  btConvexPolyhedron *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)swig_b0)->getConvexPolyhedron();
  *(btConvexPolyhedron **)&_swig_go_result = (btConvexPolyhedron *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btBoxShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btBoxShape_getAabbSlow_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btBoxShape_getLocalScaling_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getLocalScalingNV_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMargin_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNV_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btBoxShape_serialize_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (char *)((btConvexInternalShape const *)swig_b1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btBoxShape_getMarginNonVirtual_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_getAabbNonVirtual_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btBoxShape_project_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btBoxShape_getBoundingSphere_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btBoxShape_getAngularMotionDisc_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBoxShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, float _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_calculateTemporalAabb_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btBoxShape_isPolyhedral_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex2d_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConvex_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isNonMoving_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isConcave_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isCompound_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isSoftBody_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btBoxShape_isInfinite_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btBoxShape_getShapeType_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btBoxShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = ((btCollisionShape const *)swig_b3)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserPointer_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, void *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btBoxShape_getUserPointer_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_setUserIndex2_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, intgo _swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btBoxShape_getUserIndex2_mbt_e1d552452a96202d(btBoxShape *_swig_go_0) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btBoxShape_serializeSingleShape_mbt_e1d552452a96202d(btBoxShape *_swig_go_0, btSerializer *_swig_go_1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btBoxShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btPolyhedralConvexShape *swig_b0 = (btPolyhedralConvexShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btCapsuleShape *_wrap_new_btCapsuleShape__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShape *result = 0 ;
  btCapsuleShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShape *)new btCapsuleShape(arg1,arg2);
  *(btCapsuleShape **)&_swig_go_result = (btCapsuleShape *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateLocalInertia_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btCapsuleShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btCapsuleShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShape_setMargin_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


void _wrap_btCapsuleShape_getAabb_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btCapsuleShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


_gostring_ _wrap_btCapsuleShape_getName_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getUpAxis_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getRadius_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getHalfHeight_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (btScalar)((btCapsuleShape const *)arg1)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setLocalScaling_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = ((btCapsuleShape const *)arg1)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  result = (int)((btCapsuleShape const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShape_serialize_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCapsuleShape const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_deSerializeFloat_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  (arg1)->deSerializeFloat(arg2);
  
}


void _wrap_delete_btCapsuleShape_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportingVertex_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = ((btConvexInternalShape const *)swig_b0)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShape_getAabbSlow_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShape_getLocalScaling_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_getLocalScalingNV_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMargin_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNV_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_getAabbNonVirtual_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShape_project_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShape_getBoundingSphere_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShape_getAngularMotionDisc_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, float _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_calculateTemporalAabb_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShape_isPolyhedral_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex2d_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConvex_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isNonMoving_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isConcave_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isCompound_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isSoftBody_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShape_isInfinite_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShape_getShapeType_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserPointer_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, void *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShape_getUserPointer_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_setUserIndex2_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShape_getUserIndex2_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShape_serializeSingleShape_mbt_e1d552452a96202d(btCapsuleShape *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


btCapsuleShapeX *_wrap_new_btCapsuleShapeX_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeX *result = 0 ;
  btCapsuleShapeX *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeX *)new btCapsuleShapeX(arg1,arg2);
  *(btCapsuleShapeX **)&_swig_go_result = (btCapsuleShapeX *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_getName_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeX const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeX_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeX_calculateLocalInertia_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeX_setMargin_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_getAabb_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeX_getUpAxis_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getRadius_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getHalfHeight_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setLocalScaling_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_calculateSerializeBufferSize_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeX_serialize_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_deSerializeFloat_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportingVertex_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeX_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeX_getAabbSlow_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScaling_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_getLocalScalingNV_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMargin_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNV_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeX_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_getAabbNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeX_project_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeX_getBoundingSphere_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeX_getAngularMotionDisc_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeX_getContactBreakingThreshold_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_calculateTemporalAabb_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeX_isPolyhedral_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex2d_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConvex_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isNonMoving_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isConcave_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isCompound_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isSoftBody_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeX_isInfinite_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeX_getShapeType_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserPointer_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeX_getUserPointer_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_setUserIndex2_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeX_getUserIndex2_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeX_serializeSingleShape_mbt_e1d552452a96202d(btCapsuleShapeX *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeX **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


btCapsuleShapeZ *_wrap_new_btCapsuleShapeZ_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1) {
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeZ *result = 0 ;
  btCapsuleShapeZ *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (btCapsuleShapeZ *)new btCapsuleShapeZ(arg1,arg2);
  *(btCapsuleShapeZ **)&_swig_go_result = (btCapsuleShapeZ *)result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_getName_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  result = (char *)((btCapsuleShapeZ const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeZ_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCapsuleShapeZ_calculateLocalInertia_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->calculateLocalInertia(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btCapsuleShapeZ_setMargin_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabb_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  ((btCapsuleShape const *)swig_b0)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


intgo _wrap_btCapsuleShapeZ_getUpAxis_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->getUpAxis();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getRadius_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getHalfHeight_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (btScalar)((btCapsuleShape const *)swig_b0)->getHalfHeight();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setLocalScaling_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = ((btCapsuleShape const *)swig_b0)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_calculateSerializeBufferSize_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (int)((btCapsuleShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCapsuleShapeZ_serialize_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  result = (char *)((btCapsuleShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_deSerializeFloat_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btCapsuleShapeData *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btCapsuleShapeData *arg2 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btCapsuleShapeData **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  (swig_b0)->deSerializeFloat(arg2);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportingVertex_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = ((btConvexInternalShape const *)swig_b1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setImplicitShapeDimensions_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin(arg2);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCapsuleShapeZ_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  (swig_b1)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btCapsuleShapeZ_getAabbSlow_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScaling_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_getLocalScalingNV_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b1)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMargin_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNV_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (btScalar)((btConvexInternalShape const *)swig_b1)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  result = (int)((btConvexInternalShape const *)swig_b1)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  ((btConvexInternalShape const *)swig_b1)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btCapsuleShapeZ_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = ((btConvexShape const *)swig_b2)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getMarginNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  result = (btScalar)((btConvexShape const *)swig_b2)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_getAabbNonVirtual_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btCapsuleShapeZ_project_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  ((btConvexShape const *)swig_b2)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btCapsuleShapeZ_getBoundingSphere_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btCapsuleShapeZ_getAngularMotionDisc_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCapsuleShapeZ_getContactBreakingThreshold_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, float _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (btScalar)((btCollisionShape const *)swig_b3)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_calculateTemporalAabb_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btCapsuleShapeZ_isPolyhedral_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex2d_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConvex_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isNonMoving_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isConcave_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isCompound_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isSoftBody_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCapsuleShapeZ_isInfinite_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (bool)((btCollisionShape const *)swig_b3)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCapsuleShapeZ_getShapeType_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserPointer_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, void *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserPointer(arg2);
  
}


void *_wrap_btCapsuleShapeZ_getUserPointer_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (void *)((btCollisionShape const *)swig_b3)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_setUserIndex2_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  (swig_b3)->setUserIndex2(arg2);
  
}


intgo _wrap_btCapsuleShapeZ_getUserIndex2_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  result = (int)((btCollisionShape const *)swig_b3)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeZ_serializeSingleShape_mbt_e1d552452a96202d(btCapsuleShapeZ *_swig_go_0, btSerializer *_swig_go_1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCapsuleShapeZ **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btCapsuleShape *swig_b0 = (btCapsuleShape *)arg1;
  btConvexInternalShape *swig_b1 = (btConvexInternalShape *)swig_b0;
  btConvexShape *swig_b2 = (btConvexShape *)swig_b1;
  btCollisionShape *swig_b3 = (btCollisionShape *)swig_b2;
  ((btCollisionShape const *)swig_b3)->serializeSingleShape(arg2);
  
}


void _wrap_btCapsuleShapeData_m_convexInternalShapeData_set_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0, btConvexInternalShapeData *_swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *arg2 = (btConvexInternalShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = *(btConvexInternalShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexInternalShapeData = *arg2;
  
}


btConvexInternalShapeData *_wrap_btCapsuleShapeData_m_convexInternalShapeData_get_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  btConvexInternalShapeData *result = 0 ;
  btConvexInternalShapeData *_swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (btConvexInternalShapeData *)& ((arg1)->m_convexInternalShapeData);
  *(btConvexInternalShapeData **)&_swig_go_result = (btConvexInternalShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_upAxis_set_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0, intgo _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_upAxis = arg2;
  
}


intgo _wrap_btCapsuleShapeData_m_upAxis_get_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_upAxis);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCapsuleShapeData_m_padding_set_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0, _gostring_ _swig_go_1) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCapsuleShapeData_m_padding_get_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btCapsuleShapeData *_wrap_new_btCapsuleShapeData_mbt_e1d552452a96202d() {
  btCapsuleShapeData *result = 0 ;
  btCapsuleShapeData *_swig_go_result;
  
  
  result = (btCapsuleShapeData *)new btCapsuleShapeData();
  *(btCapsuleShapeData **)&_swig_go_result = (btCapsuleShapeData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCapsuleShapeData_mbt_e1d552452a96202d(btCapsuleShapeData *_swig_go_0) {
  btCapsuleShapeData *arg1 = (btCapsuleShapeData *) 0 ;
  
  arg1 = *(btCapsuleShapeData **)&_swig_go_0; 
  
  delete arg1;
  
}


btSphereShape *_wrap_new_btSphereShape_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  btSphereShape *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  
  result = (btSphereShape *)new btSphereShape(arg1);
  *(btSphereShape **)&_swig_go_result = (btSphereShape *)result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertex_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, intgo _swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
  
}


void _wrap_btSphereShape_calculateLocalInertia_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
  
}


void _wrap_btSphereShape_getAabb_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
  
}


float _wrap_btSphereShape_getRadius_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUnscaledRadius_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setUnscaledRadius(arg2);
  
}


_gostring_ _wrap_btSphereShape_getName_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (char *)((btSphereShape const *)arg1)->getName();
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setMargin_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMargin(arg2);
  
}


float _wrap_btSphereShape_getMargin_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  result = (btScalar)((btSphereShape const *)arg1)->getMargin();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSphereShape_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  delete arg1;
  
}


btVector3 *_wrap_btSphereShape_getImplicitShapeDimensions_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getImplicitShapeDimensions();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setImplicitShapeDimensions_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setImplicitShapeDimensions((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_0_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_1_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin(arg2);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_2_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btSphereShape_setSafeMargin__SWIG_3_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setSafeMargin((btVector3 const &)*arg2);
  
}


void _wrap_btSphereShape_getAabbSlow_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_setLocalScaling_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  (swig_b0)->setLocalScaling((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btSphereShape_getLocalScaling_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScaling();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getLocalScalingNV_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btVector3 *) &((btConvexInternalShape const *)swig_b0)->getLocalScalingNV();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNV_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (btScalar)((btConvexInternalShape const *)swig_b0)->getMarginNV();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getNumPreferredPenetrationDirections_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->getNumPreferredPenetrationDirections();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getPreferredPenetrationDirection_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, intgo _swig_go_1, btVector3 *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  ((btConvexInternalShape const *)swig_b0)->getPreferredPenetrationDirection(arg2,*arg3);
  
}


intgo _wrap_btSphereShape_calculateSerializeBufferSize_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (int)((btConvexInternalShape const *)swig_b0)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btSphereShape_serialize_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  result = (char *)((btConvexInternalShape const *)swig_b0)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexWithoutMarginNonVirtual_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_localGetSupportVertexNonVirtual_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = ((btConvexShape const *)swig_b1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btSphereShape_getMarginNonVirtual_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  result = (btScalar)((btConvexShape const *)swig_b1)->getMarginNonVirtual();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_getAabbNonVirtual_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
  
}


void _wrap_btSphereShape_project_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, float *_swig_go_3, float *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btScalar **)&_swig_go_3; 
  arg5 = *(btScalar **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  ((btConvexShape const *)swig_b1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
  
}


void _wrap_btSphereShape_getBoundingSphere_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btVector3 *_swig_go_1, float *_swig_go_2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btScalar **)&_swig_go_2; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->getBoundingSphere(*arg2,*arg3);
  
}


float _wrap_btSphereShape_getAngularMotionDisc_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getAngularMotionDisc();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btSphereShape_getContactBreakingThreshold_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, float _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (btScalar)((btCollisionShape const *)swig_b2)->getContactBreakingThreshold(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_calculateTemporalAabb_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3, float _swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
  
}


bool _wrap_btSphereShape_isPolyhedral_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isPolyhedral();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex2d_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex2d();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConvex_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConvex();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isNonMoving_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isNonMoving();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isConcave_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isConcave();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isCompound_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isCompound();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isSoftBody_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isSoftBody();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btSphereShape_isInfinite_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (bool)((btCollisionShape const *)swig_b2)->isInfinite();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btSphereShape_getShapeType_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getShapeType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btSphereShape_getAnisotropicRollingFrictionDirection_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = ((btCollisionShape const *)swig_b2)->getAnisotropicRollingFrictionDirection();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserPointer_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, void *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserPointer(arg2);
  
}


void *_wrap_btSphereShape_getUserPointer_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (void *)((btCollisionShape const *)swig_b2)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_setUserIndex2_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, intgo _swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int arg2 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  (swig_b2)->setUserIndex2(arg2);
  
}


intgo _wrap_btSphereShape_getUserIndex2_mbt_e1d552452a96202d(btSphereShape *_swig_go_0) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  result = (int)((btCollisionShape const *)swig_b2)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSphereShape_serializeSingleShape_mbt_e1d552452a96202d(btSphereShape *_swig_go_0, btSerializer *_swig_go_1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btSphereShape **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  btConvexInternalShape *swig_b0 = (btConvexInternalShape *)arg1;
  btConvexShape *swig_b1 = (btConvexShape *)swig_b0;
  btCollisionShape *swig_b2 = (btCollisionShape *)swig_b1;
  ((btCollisionShape const *)swig_b2)->serializeSingleShape(arg2);
  
}


void _wrap_gContactAddedCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  ContactAddedCallback arg1 = (ContactAddedCallback) 0 ;
  
  arg1 = *(ContactAddedCallback *)&_swig_go_0; 
  
  gContactAddedCallback = arg1;
  
}


void* _wrap_gContactAddedCallback_get_mbt_e1d552452a96202d() {
  ContactAddedCallback result;
  void* _swig_go_result;
  
  
  result = (ContactAddedCallback)gContactAddedCallback;
  *(ContactAddedCallback *)&_swig_go_result = (ContactAddedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedRestitutionCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedRestitutionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedRestitutionCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedRestitutionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedFrictionCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedFrictionCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedRollingFrictionCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedRollingFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedRollingFrictionCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedRollingFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedSpinningFrictionCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedSpinningFrictionCallback = arg1;
  
}


void* _wrap_gCalculateCombinedSpinningFrictionCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedSpinningFrictionCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedContactDampingCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedContactDampingCallback = arg1;
  
}


void* _wrap_gCalculateCombinedContactDampingCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedContactDampingCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


void _wrap_gCalculateCombinedContactStiffnessCallback_set_mbt_e1d552452a96202d(void* _swig_go_0) {
  CalculateCombinedCallback arg1 = (CalculateCombinedCallback) 0 ;
  
  arg1 = *(CalculateCombinedCallback *)&_swig_go_0; 
  
  gCalculateCombinedContactStiffnessCallback = arg1;
  
}


void* _wrap_gCalculateCombinedContactStiffnessCallback_get_mbt_e1d552452a96202d() {
  CalculateCombinedCallback result;
  void* _swig_go_result;
  
  
  result = (CalculateCombinedCallback)gCalculateCombinedContactStiffnessCallback;
  *(CalculateCombinedCallback *)&_swig_go_result = (CalculateCombinedCallback)result; 
  return _swig_go_result;
}


btManifoldResult *_wrap_new_btManifoldResult__SWIG_0_mbt_e1d552452a96202d() {
  btManifoldResult *result = 0 ;
  btManifoldResult *_swig_go_result;
  
  
  result = (btManifoldResult *)new btManifoldResult();
  *(btManifoldResult **)&_swig_go_result = (btManifoldResult *)result; 
  return _swig_go_result;
}


btManifoldResult *_wrap_new_btManifoldResult__SWIG_1_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btManifoldResult *result = 0 ;
  btManifoldResult *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  result = (btManifoldResult *)new btManifoldResult((btCollisionObjectWrapper const *)arg1,(btCollisionObjectWrapper const *)arg2);
  *(btManifoldResult **)&_swig_go_result = (btManifoldResult *)result; 
  return _swig_go_result;
}


void _wrap_delete_btManifoldResult_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btManifoldResult_setPersistentManifold_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  (arg1)->setPersistentManifold(arg2);
  
}


btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_0_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btPersistentManifold *)((btManifoldResult const *)arg1)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btManifoldResult_getPersistentManifold__SWIG_1_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btPersistentManifold *)(arg1)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_setShapeIdentifiersA_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setShapeIdentifiersA(arg2,arg3);
  
}


void _wrap_btManifoldResult_setShapeIdentifiersB_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setShapeIdentifiersB(arg2,arg3);
  
}


void _wrap_btManifoldResult_addContactPoint_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_btManifoldResult_refreshContactPoints_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  (arg1)->refreshContactPoints();
  
}


btCollisionObjectWrapper *_wrap_btManifoldResult_getBody0Wrap_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody0Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


btCollisionObjectWrapper *_wrap_btManifoldResult_getBody1Wrap_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)arg1)->getBody1Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_setBody0Wrap_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  (arg1)->setBody0Wrap((btCollisionObjectWrapper const *)arg2);
  
}


void _wrap_btManifoldResult_setBody1Wrap_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  (arg1)->setBody1Wrap((btCollisionObjectWrapper const *)arg2);
  
}


btCollisionObject *_wrap_btManifoldResult_getBody0Internal_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody0Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btManifoldResult_getBody1Internal_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btManifoldResult const *)arg1)->getBody1Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btManifoldResult_m_closestPointDistanceThreshold_set_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0, float _swig_go_1) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_closestPointDistanceThreshold = arg2;
  
}


float _wrap_btManifoldResult_m_closestPointDistanceThreshold_get_mbt_e1d552452a96202d(btManifoldResult *_swig_go_0) {
  btManifoldResult *arg1 = (btManifoldResult *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btManifoldResult **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_closestPointDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedRestitution_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRestitution((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedRollingFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRollingFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedSpinningFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedSpinningFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedContactDamping_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactDamping((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btManifoldResult_calculateCombinedContactStiffness_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactStiffness((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_CF_DYNAMIC_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DYNAMIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_STATIC_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_STATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_KINEMATIC_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_KINEMATIC_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_NO_CONTACT_RESPONSE_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_NO_CONTACT_RESPONSE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CUSTOM_MATERIAL_CALLBACK_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_CHARACTER_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_CHARACTER_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_VISUALIZE_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_DISABLE_SPU_COLLISION_PROCESSING_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_DISABLE_SPU_COLLISION_PROCESSING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CONTACT_STIFFNESS_DAMPING_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CONTACT_STIFFNESS_DAMPING;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_FRICTION_ANCHOR_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_FRICTION_ANCHOR;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_HAS_COLLISION_SOUND_TRIGGER_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_HAS_COLLISION_SOUND_TRIGGER;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_COLLISION_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_COLLISION_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_RIGID_BODY_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_RIGID_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_GHOST_OBJECT_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_GHOST_OBJECT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_SOFT_BODY_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_SOFT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_HF_FLUID_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_HF_FLUID;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_USER_TYPE_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_USER_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CO_FEATHERSTONE_LINK_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::CollisionObjectTypes result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CO_FEATHERSTONE_LINK;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_DISABLED_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION_DISABLED;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_FRICTION_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CF_ANISOTROPIC_ROLLING_FRICTION_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject::AnisotropicFrictionFlags result;
  intgo _swig_go_result;
  
  
  result = btCollisionObject::CF_ANISOTROPIC_ROLLING_FRICTION;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_mergesSimulationIslands_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getAnisotropicFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactProcessingThreshold_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btCollisionObject_getContactProcessingThreshold_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticObject_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isKinematicObject_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_isStaticOrKinematicObject_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_hasContactResponse_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_new_btCollisionObject_mbt_e1d552452a96202d() {
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  
  result = (btCollisionObject *)new btCollisionObject();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObject_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObject_setCollisionShape_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionShape *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  (arg1)->setCollisionShape(arg2);
  
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIgnoreCollisionCheck_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btCollisionObject_getNumObjectsWithoutCollision_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btCollisionObject_getObjectWithoutCollision_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btCollisionObject *)(arg1)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWithOverride_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btCollisionObject_internalGetExtensionPointer_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_internalSetExtensionPointer_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btCollisionObject_getActivationState_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setActivationState_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->setActivationState(arg2);
  
}


void _wrap_btCollisionObject_setDeactivationTime_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDeactivationTime(arg2);
  
}


float _wrap_btCollisionObject_getDeactivationTime_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_forceActivationState_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->forceActivationState(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, bool _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->activate(arg2);
  
}


void _wrap_btCollisionObject_activate__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  ((btCollisionObject const *)arg1)->activate();
  
}


bool _wrap_btCollisionObject_isActive_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (bool)((btCollisionObject const *)arg1)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRestitution_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRestitution(arg2);
  
}


float _wrap_btCollisionObject_getRestitution_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setFriction(arg2);
  
}


float _wrap_btCollisionObject_getFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setRollingFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setRollingFriction(arg2);
  
}


float _wrap_btCollisionObject_getRollingFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setSpinningFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setSpinningFriction(arg2);
  
}


float _wrap_btCollisionObject_getSpinningFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setContactStiffnessAndDamping_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btCollisionObject_getContactStiffness_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getContactDamping_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getInternalType_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldTransform_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setBroadphaseHandle_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setInterpolationWorldTransform_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationLinearVelocity_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_setInterpolationAngularVelocity_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getIslandTag_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setIslandTag_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setIslandTag(arg2);
  
}


intgo _wrap_btCollisionObject_getCompanionId_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCompanionId_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCompanionId(arg2);
  
}


intgo _wrap_btCollisionObject_getWorldArrayIndex_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setWorldArrayIndex_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setWorldArrayIndex(arg2);
  
}


float _wrap_btCollisionObject_getHitFraction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setHitFraction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setHitFraction(arg2);
  
}


intgo _wrap_btCollisionObject_getCollisionFlags_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCollisionFlags_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setCollisionFlags(arg2);
  
}


float _wrap_btCollisionObject_getCcdSweptSphereRadius_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdSweptSphereRadius_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btCollisionObject_getCcdMotionThreshold_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btCollisionObject_getCcdSquareMotionThreshold_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCcdMotionThreshold_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, float _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btCollisionObject_getUserPointer_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex2_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_getUserIndex3_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setUserPointer_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, void *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserPointer(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex2_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex2(arg2);
  
}


void _wrap_btCollisionObject_setUserIndex3_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, intgo _swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserIndex3(arg2);
  
}


intgo _wrap_btCollisionObject_getUpdateRevisionInternal_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObject_setCustomDebugColor_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btCollisionObject_removeCustomDebugColor_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  (arg1)->removeCustomDebugColor();
  
}


bool _wrap_btCollisionObject_getCustomDebugColor_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionObject_checkCollideWith_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btCollisionObject_calculateSerializeBufferSize_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btCollisionObject_serialize_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObject_serializeSingleObject_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
  
}


void _wrap_btCollisionObjectDoubleData_m_broadphaseHandle_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_broadphaseHandle_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionShape_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectDoubleData_m_collisionShape_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rootCollisionShape_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectDoubleData_m_rootCollisionShape_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_name_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectDoubleData_m_name_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_worldTransform_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_worldTransform_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_worldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformDoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationWorldTransform_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationLinearVelocity_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_interpolationAngularVelocity_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_anisotropicFriction_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3DoubleData *_wrap_btCollisionObjectDoubleData_m_anisotropicFriction_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactProcessingThreshold_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_deactivationTime_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_deactivationTime_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_friction_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_friction_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_rollingFriction_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_rollingFriction_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactDamping_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactDamping_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_contactStiffness_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_contactStiffness_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_restitution_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_restitution_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hitFraction_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_hitFraction_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdSweptSphereRadius_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, double _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


double _wrap_btCollisionObjectDoubleData_m_ccdMotionThreshold_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_hasAnisotropicFriction_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFlags_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFlags_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_islandTag1_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_islandTag1_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_companionId_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_companionId_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_activationState1_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_activationState1_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_internalType_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_internalType_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_checkCollideWith_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_checkCollideWith_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterGroup_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_collisionFilterMask_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectDoubleData_m_uniqueId_set_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectDoubleData_m_uniqueId_get_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectDoubleData *_wrap_new_btCollisionObjectDoubleData_mbt_e1d552452a96202d() {
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  
  result = (btCollisionObjectDoubleData *)new btCollisionObjectDoubleData();
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectDoubleData_mbt_e1d552452a96202d(btCollisionObjectDoubleData *_swig_go_0) {
  btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btCollisionObjectDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObjectFloatData_m_broadphaseHandle_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_broadphaseHandle = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_broadphaseHandle_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_broadphaseHandle);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionShape_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, void *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionShape = arg2;
  
}


void *_wrap_btCollisionObjectFloatData_m_collisionShape_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (void *) ((arg1)->m_collisionShape);
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rootCollisionShape_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btCollisionShapeData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionShapeData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rootCollisionShape = arg2;
  
}


btCollisionShapeData *_wrap_btCollisionObjectFloatData_m_rootCollisionShape_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btCollisionShapeData *result = 0 ;
  btCollisionShapeData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btCollisionShapeData *) ((arg1)->m_rootCollisionShape);
  *(btCollisionShapeData **)&_swig_go_result = (btCollisionShapeData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_name_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btCollisionObjectFloatData_m_name_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_worldTransform_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_worldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_worldTransform_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_worldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationWorldTransform = *arg2;
  
}


btTransformFloatData *_wrap_btCollisionObjectFloatData_m_interpolationWorldTransform_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_interpolationWorldTransform);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationLinearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationLinearVelocity_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationLinearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_interpolationAngularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_interpolationAngularVelocity_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_interpolationAngularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_anisotropicFriction_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_anisotropicFriction = *arg2;
  
}


btVector3FloatData *_wrap_btCollisionObjectFloatData_m_anisotropicFriction_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_anisotropicFriction);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactProcessingThreshold_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_deactivationTime_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_deactivationTime = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_deactivationTime_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_deactivationTime);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_friction_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_friction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_friction_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_friction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_rollingFriction_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_rollingFriction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_rollingFriction_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_rollingFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactDamping_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactDamping = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactDamping_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_contactStiffness_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactStiffness = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_contactStiffness_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactStiffness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_restitution_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_restitution_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hitFraction_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_hitFraction = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_hitFraction_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_hitFraction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdSweptSphereRadius = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdSweptSphereRadius_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdSweptSphereRadius);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, float _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_ccdMotionThreshold = arg2;
  
}


float _wrap_btCollisionObjectFloatData_m_ccdMotionThreshold_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_ccdMotionThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_hasAnisotropicFriction = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_hasAnisotropicFriction_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_hasAnisotropicFriction);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFlags_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFlags = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFlags_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFlags);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_islandTag1_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_islandTag1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_islandTag1_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_islandTag1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_companionId_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_companionId_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_activationState1_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_activationState1 = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_activationState1_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_activationState1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_internalType_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_internalType = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_internalType_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_internalType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_checkCollideWith_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_checkCollideWith = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_checkCollideWith_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_checkCollideWith);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterGroup = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterGroup_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterGroup);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_collisionFilterMask_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionFilterMask = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_collisionFilterMask_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_collisionFilterMask);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectFloatData_m_uniqueId_set_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_uniqueId = arg2;
  
}


intgo _wrap_btCollisionObjectFloatData_m_uniqueId_get_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_uniqueId);
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObjectFloatData *_wrap_new_btCollisionObjectFloatData_mbt_e1d552452a96202d() {
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  
  result = (btCollisionObjectFloatData *)new btCollisionObjectFloatData();
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectFloatData_mbt_e1d552452a96202d(btCollisionObjectFloatData *_swig_go_0) {
  btCollisionObjectFloatData *arg1 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btCollisionObjectFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionObjectWrapper_m_parent_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_parent = (btCollisionObjectWrapper const *)arg2;
  
}


btCollisionObjectWrapper *_wrap_btCollisionObjectWrapper_m_parent_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btCollisionObjectWrapper *) ((arg1)->m_parent);
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectWrapper_m_shape_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btCollisionShape *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_shape = (btCollisionShape const *)arg2;
  
}


btCollisionShape *_wrap_btCollisionObjectWrapper_m_shape_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btCollisionShape *) ((arg1)->m_shape);
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectWrapper_m_collisionObject_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObject = (btCollisionObject const *)arg2;
  
}


btCollisionObject *_wrap_btCollisionObjectWrapper_m_collisionObject_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btCollisionObject *) ((arg1)->m_collisionObject);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObjectWrapper_m_worldTransform_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btTransform *) &(btTransform const &) ((arg1)->m_worldTransform);
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectWrapper_m_preTransform_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btTransform *_swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_preTransform = (btTransform const *)arg2;
  
}


btTransform *_wrap_btCollisionObjectWrapper_m_preTransform_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btTransform *) ((arg1)->m_preTransform);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectWrapper_m_partId_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_partId = arg2;
  
}


intgo _wrap_btCollisionObjectWrapper_m_partId_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_partId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionObjectWrapper_m_index_set_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, intgo _swig_go_1) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  int arg2 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index = arg2;
  
}


intgo _wrap_btCollisionObjectWrapper_m_index_get_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btCollisionObjectWrapper_getWorldTransform_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btTransform *) &((btCollisionObjectWrapper const *)arg1)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btCollisionObjectWrapper_getCollisionObject_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btCollisionObjectWrapper const *)arg1)->getCollisionObject();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btCollisionObjectWrapper_getCollisionShape_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btCollisionObjectWrapper const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionObjectWrapper_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  
  delete arg1;
  
}


btSimulationIslandManager *_wrap_new_btSimulationIslandManager_mbt_e1d552452a96202d() {
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  
  result = (btSimulationIslandManager *)new btSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSimulationIslandManager_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSimulationIslandManager_initUnionFind_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, intgo _swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  int arg2 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->initUnionFind(arg2);
  
}


btUnionFind *_wrap_btSimulationIslandManager_getUnionFind_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btUnionFind *result = 0 ;
  btUnionFind *_swig_go_result;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  result = (btUnionFind *) &(arg1)->getUnionFind();
  *(btUnionFind **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSimulationIslandManager_updateActivationState_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btCollisionWorld *_swig_go_1, btDispatcher *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  (arg1)->updateActivationState(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_storeIslandActivationState_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  (arg1)->storeIslandActivationState(arg2);
  
}


void _wrap_btSimulationIslandManager_findUnions_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  
  (arg1)->findUnions(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_buildAndProcessIslands_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2, btSimulationIslandManager::IslandCallback *_swig_go_3) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btSimulationIslandManager::IslandCallback *arg4 = (btSimulationIslandManager::IslandCallback *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btSimulationIslandManager::IslandCallback **)&_swig_go_3; 
  
  (arg1)->buildAndProcessIslands(arg2,arg3,arg4);
  
}


void _wrap_btSimulationIslandManager_buildIslands_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  
  (arg1)->buildIslands(arg2,arg3);
  
}


void _wrap_btSimulationIslandManager_processIslands_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, btDispatcher *_swig_go_1, btCollisionWorld *_swig_go_2, btSimulationIslandManager::IslandCallback *_swig_go_3) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btSimulationIslandManager::IslandCallback *arg4 = (btSimulationIslandManager::IslandCallback *) 0 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btSimulationIslandManager::IslandCallback **)&_swig_go_3; 
  
  (arg1)->processIslands(arg2,arg3,arg4);
  
}


bool _wrap_btSimulationIslandManager_getSplitIslands_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  
  result = (bool)(arg1)->getSplitIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSimulationIslandManager_setSplitIslands_mbt_e1d552452a96202d(btSimulationIslandManager *_swig_go_0, bool _swig_go_1) {
  btSimulationIslandManager *arg1 = (btSimulationIslandManager *) 0 ;
  bool arg2 ;
  
  arg1 = *(btSimulationIslandManager **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setSplitIslands(arg2);
  
}


intgo _wrap_getIslandId_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int)getIslandId((btPersistentManifold const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btPersistentManifoldSortPredicate *_wrap_new_btPersistentManifoldSortPredicate_mbt_e1d552452a96202d() {
  btPersistentManifoldSortPredicate *result = 0 ;
  btPersistentManifoldSortPredicate *_swig_go_result;
  
  
  result = (btPersistentManifoldSortPredicate *)new btPersistentManifoldSortPredicate();
  *(btPersistentManifoldSortPredicate **)&_swig_go_result = (btPersistentManifoldSortPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldSortPredicate_mbt_e1d552452a96202d(btPersistentManifoldSortPredicate *_swig_go_0) {
  btPersistentManifoldSortPredicate *arg1 = (btPersistentManifoldSortPredicate *) 0 ;
  
  arg1 = *(btPersistentManifoldSortPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


btPersistentManifoldSortPredicateDeterministic *_wrap_new_btPersistentManifoldSortPredicateDeterministic_mbt_e1d552452a96202d() {
  btPersistentManifoldSortPredicateDeterministic *result = 0 ;
  btPersistentManifoldSortPredicateDeterministic *_swig_go_result;
  
  
  result = (btPersistentManifoldSortPredicateDeterministic *)new btPersistentManifoldSortPredicateDeterministic();
  *(btPersistentManifoldSortPredicateDeterministic **)&_swig_go_result = (btPersistentManifoldSortPredicateDeterministic *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldSortPredicateDeterministic_mbt_e1d552452a96202d(btPersistentManifoldSortPredicateDeterministic *_swig_go_0) {
  btPersistentManifoldSortPredicateDeterministic *arg1 = (btPersistentManifoldSortPredicateDeterministic *) 0 ;
  
  arg1 = *(btPersistentManifoldSortPredicateDeterministic **)&_swig_go_0; 
  
  delete arg1;
  
}


btCollisionWorld *_wrap_new_btCollisionWorld_mbt_e1d552452a96202d(btDispatcher *_swig_go_0, btBroadphaseInterface *_swig_go_1, btCollisionConfiguration *_swig_go_2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btCollisionConfiguration *arg3 = (btCollisionConfiguration *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  arg3 = *(btCollisionConfiguration **)&_swig_go_2; 
  
  result = (btCollisionWorld *)new btCollisionWorld(arg1,arg2,arg3);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_delete_btCollisionWorld_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btCollisionWorld_setBroadphase_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btBroadphaseInterface *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  
  (arg1)->setBroadphase(arg2);
  
}


btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btBroadphaseInterface *)((btCollisionWorld const *)arg1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  btBroadphaseInterface *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btBroadphaseInterface *)(arg1)->getBroadphase();
  *(btBroadphaseInterface **)&_swig_go_result = (btBroadphaseInterface *)result; 
  return _swig_go_result;
}


btOverlappingPairCache *_wrap_btCollisionWorld_getPairCache_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *)(arg1)->getPairCache();
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcher *)(arg1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcher *)((btCollisionWorld const *)arg1)->getDispatcher();
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_updateSingleAabb_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->updateSingleAabb(arg2);
  
}


void _wrap_btCollisionWorld_updateAabbs_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->updateAabbs();
  
}


void _wrap_btCollisionWorld_computeOverlappingPairs_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->computeOverlappingPairs();
  
}


void _wrap_btCollisionWorld_setDebugDrawer_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btIDebugDraw *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  (arg1)->setDebugDrawer(arg2);
  
}


btIDebugDraw *_wrap_btCollisionWorld_getDebugDrawer_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btIDebugDraw *)(arg1)->getDebugDrawer();
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_debugDrawWorld_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->debugDrawWorld();
  
}


void _wrap_btCollisionWorld_debugDrawObject_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btTransform *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  (arg1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
  
}


intgo _wrap_btCollisionWorld_getNumCollisionObjects_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (int)((btCollisionWorld const *)arg1)->getNumCollisionObjects();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_rayTest_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  ((btCollisionWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
  
}


void _wrap_btCollisionWorld_convexSweepTest__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
  
}


void _wrap_btCollisionWorld_convexSweepTest__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btConvexShape *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  
  ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
  
}


void _wrap_btCollisionWorld_contactTest_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  (arg1)->contactTest(arg2,*arg3);
  
}


void _wrap_btCollisionWorld_contactPairTest_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionWorld::ContactResultCallback *_swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_3; 
  
  (arg1)->contactPairTest(arg2,arg3,*arg4);
  
}


void _wrap_btCollisionWorld_rayTestSingle_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObject *_swig_go_2, btCollisionShape *_swig_go_3, btTransform *_swig_go_4, btCollisionWorld::RayResultCallback *_swig_go_5) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  arg4 = *(btCollisionShape **)&_swig_go_3; 
  arg5 = *(btTransform **)&_swig_go_4; 
  arg6 = *(btCollisionWorld::RayResultCallback **)&_swig_go_5; 
  
  btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
  
}


void _wrap_btCollisionWorld_rayTestSingleInternal_mbt_e1d552452a96202d(btTransform *_swig_go_0, btTransform *_swig_go_1, btCollisionObjectWrapper *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = *(btTransform **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btCollisionObjectWrapper **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
  
}


void _wrap_btCollisionWorld_objectQuerySingle_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObject *_swig_go_3, btCollisionShape *_swig_go_4, btTransform *_swig_go_5, btCollisionWorld::ConvexResultCallback *_swig_go_6, float _swig_go_7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObject **)&_swig_go_3; 
  arg5 = *(btCollisionShape **)&_swig_go_4; 
  arg6 = *(btTransform **)&_swig_go_5; 
  arg7 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_6; 
  arg8 = (btScalar)_swig_go_7; 
  
  btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
  
}


void _wrap_btCollisionWorld_objectQuerySingleInternal_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionObjectWrapper *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionObjectWrapper **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addCollisionObject(arg2,arg3,arg4);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->addCollisionObject(arg2,arg3);
  
}


void _wrap_btCollisionWorld_addCollisionObject__SWIG_2_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->addCollisionObject(arg2);
  
}


void _wrap_btCollisionWorld_refreshBroadphaseProxy_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->refreshBroadphaseProxy(arg2);
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btCollisionObjectArray *) &(arg1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btCollisionObject * > *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btCollisionObjectArray *) &((btCollisionWorld const *)arg1)->getCollisionObjectArray();
  *(btCollisionObjectArray **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_removeCollisionObject_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->removeCollisionObject(arg2);
  
}


void _wrap_btCollisionWorld_performDiscreteCollisionDetection_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  (arg1)->performDiscreteCollisionDetection();
  
}


btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_0_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcherInfo *) &(arg1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_1_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  btDispatcherInfo *_swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (btDispatcherInfo *) &((btCollisionWorld const *)arg1)->getDispatchInfo();
  *(btDispatcherInfo **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btCollisionWorld_getForceUpdateAllAabbs_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  
  result = (bool)((btCollisionWorld const *)arg1)->getForceUpdateAllAabbs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btCollisionWorld_setForceUpdateAllAabbs_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, bool _swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setForceUpdateAllAabbs(arg2);
  
}


void _wrap_btCollisionWorld_serialize_mbt_e1d552452a96202d(btCollisionWorld *_swig_go_0, btSerializer *_swig_go_1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btCollisionWorld **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  (arg1)->serialize(arg2);
  
}


void _wrap_btSingleRayCallback_m_rayFromWorld_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayFromWorld = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_rayFromWorld_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_rayFromWorld);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayToWorld_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayToWorld = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_rayToWorld_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_rayToWorld);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayFromTrans_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayFromTrans = *arg2;
  
}


btTransform *_wrap_btSingleRayCallback_m_rayFromTrans_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_rayFromTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_rayToTrans_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rayToTrans = *arg2;
  
}


btTransform *_wrap_btSingleRayCallback_m_rayToTrans_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_rayToTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_hitNormal_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_hitNormal = *arg2;
  
}


btVector3 *_wrap_btSingleRayCallback_m_hitNormal_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_hitNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_world_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = (btCollisionWorld const *)arg2;
  
}


btCollisionWorld *_wrap_btSingleRayCallback_m_world_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleRayCallback_m_resultCallback_set_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btCollisionWorld::RayResultCallback *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld::RayResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::RayResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::RayResultCallback *_wrap_btSingleRayCallback_m_resultCallback_get_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btCollisionWorld::RayResultCallback *result = 0 ;
  btCollisionWorld::RayResultCallback *_swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::RayResultCallback *) &(btCollisionWorld::RayResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::RayResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btSingleRayCallback *_wrap_new_btSingleRayCallback_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btCollisionWorld *_swig_go_2, btCollisionWorld::RayResultCallback *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btCollisionWorld *arg3 = (btCollisionWorld *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  btSingleRayCallback *result = 0 ;
  btSingleRayCallback *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btCollisionWorld **)&_swig_go_2; 
  arg4 = *(btCollisionWorld::RayResultCallback **)&_swig_go_3; 
  
  result = (btSingleRayCallback *)new btSingleRayCallback((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btCollisionWorld const *)arg3,*arg4);
  *(btSingleRayCallback **)&_swig_go_result = (btSingleRayCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleRayCallback_process_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleRayCallback_mbt_e1d552452a96202d(btSingleRayCallback *_swig_go_0) {
  btSingleRayCallback *arg1 = (btSingleRayCallback *) 0 ;
  
  arg1 = *(btSingleRayCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btSingleSweepCallback_m_convexFromTrans_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexFromTrans = *arg2;
  
}


btTransform *_wrap_btSingleSweepCallback_m_convexFromTrans_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexFromTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_convexToTrans_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btTransform *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_convexToTrans = *arg2;
  
}


btTransform *_wrap_btSingleSweepCallback_m_convexToTrans_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btTransform *)& ((arg1)->m_convexToTrans);
  *(btTransform **)&_swig_go_result = (btTransform *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_hitNormal_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btVector3 *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_hitNormal = *arg2;
  
}


btVector3 *_wrap_btSingleSweepCallback_m_hitNormal_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_hitNormal);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_world_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = (btCollisionWorld const *)arg2;
  
}


btCollisionWorld *_wrap_btSingleSweepCallback_m_world_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_resultCallback_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btCollisionWorld::ConvexResultCallback *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ConvexResultCallback *_wrap_btSingleSweepCallback_m_resultCallback_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btCollisionWorld::ConvexResultCallback *result = 0 ;
  btCollisionWorld::ConvexResultCallback *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::ConvexResultCallback *) &(btCollisionWorld::ConvexResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ConvexResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_allowedCcdPenetration_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, float _swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedCcdPenetration = arg2;
  
}


float _wrap_btSingleSweepCallback_m_allowedCcdPenetration_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedCcdPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleSweepCallback_m_castShape_set_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btConvexShape *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btConvexShape **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_castShape = (btConvexShape const *)arg2;
  
}


btConvexShape *_wrap_btSingleSweepCallback_m_castShape_get_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btConvexShape *result = 0 ;
  btConvexShape *_swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  result = (btConvexShape *) ((arg1)->m_castShape);
  *(btConvexShape **)&_swig_go_result = (btConvexShape *)result; 
  return _swig_go_result;
}


btSingleSweepCallback *_wrap_new_btSingleSweepCallback_mbt_e1d552452a96202d(btConvexShape *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btCollisionWorld *_swig_go_3, btCollisionWorld::ConvexResultCallback *_swig_go_4, float _swig_go_5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionWorld *arg4 = (btCollisionWorld *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  btSingleSweepCallback *result = 0 ;
  btSingleSweepCallback *_swig_go_result;
  
  arg1 = *(btConvexShape **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btCollisionWorld **)&_swig_go_3; 
  arg5 = *(btCollisionWorld::ConvexResultCallback **)&_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  result = (btSingleSweepCallback *)new btSingleSweepCallback((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionWorld const *)arg4,*arg5,arg6);
  *(btSingleSweepCallback **)&_swig_go_result = (btSingleSweepCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleSweepCallback_process_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleSweepCallback_mbt_e1d552452a96202d(btSingleSweepCallback *_swig_go_0) {
  btSingleSweepCallback *arg1 = (btSingleSweepCallback *) 0 ;
  
  arg1 = *(btSingleSweepCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBridgedManifoldResult_m_resultCallback_set_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, btCollisionWorld::ContactResultCallback *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionWorld::ContactResultCallback *arg2 = 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ContactResultCallback *_wrap_btBridgedManifoldResult_m_resultCallback_get_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionWorld::ContactResultCallback *result = 0 ;
  btCollisionWorld::ContactResultCallback *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  result = (btCollisionWorld::ContactResultCallback *) &(btCollisionWorld::ContactResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ContactResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btBridgedManifoldResult *_wrap_new_btBridgedManifoldResult_mbt_e1d552452a96202d(btCollisionObjectWrapper *_swig_go_0, btCollisionObjectWrapper *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionObjectWrapper *arg1 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  btBridgedManifoldResult *result = 0 ;
  btBridgedManifoldResult *_swig_go_result;
  
  arg1 = *(btCollisionObjectWrapper **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  result = (btBridgedManifoldResult *)new btBridgedManifoldResult((btCollisionObjectWrapper const *)arg1,(btCollisionObjectWrapper const *)arg2,*arg3);
  *(btBridgedManifoldResult **)&_swig_go_result = (btBridgedManifoldResult *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_addContactPoint_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->addContactPoint((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
  
}


void _wrap_delete_btBridgedManifoldResult_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btBridgedManifoldResult_setPersistentManifold_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, btPersistentManifold *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setPersistentManifold(arg2);
  
}


btPersistentManifold *_wrap_btBridgedManifoldResult_getPersistentManifold__SWIG_0_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btPersistentManifold *)((btManifoldResult const *)swig_b0)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_btBridgedManifoldResult_getPersistentManifold__SWIG_1_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btPersistentManifold *)(swig_b0)->getPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_setShapeIdentifiersA_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setShapeIdentifiersA(arg2,arg3);
  
}


void _wrap_btBridgedManifoldResult_setShapeIdentifiersB_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setShapeIdentifiersB(arg2,arg3);
  
}


void _wrap_btBridgedManifoldResult_refreshContactPoints_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->refreshContactPoints();
  
}


btCollisionObjectWrapper *_wrap_btBridgedManifoldResult_getBody0Wrap_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)swig_b0)->getBody0Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


btCollisionObjectWrapper *_wrap_btBridgedManifoldResult_getBody1Wrap_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *result = 0 ;
  btCollisionObjectWrapper *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObjectWrapper *)((btManifoldResult const *)swig_b0)->getBody1Wrap();
  *(btCollisionObjectWrapper **)&_swig_go_result = (btCollisionObjectWrapper *)result; 
  return _swig_go_result;
}


void _wrap_btBridgedManifoldResult_setBody0Wrap_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setBody0Wrap((btCollisionObjectWrapper const *)arg2);
  
}


void _wrap_btBridgedManifoldResult_setBody1Wrap_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, btCollisionObjectWrapper *_swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = *(btCollisionObjectWrapper **)&_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  (swig_b0)->setBody1Wrap((btCollisionObjectWrapper const *)arg2);
  
}


btCollisionObject *_wrap_btBridgedManifoldResult_getBody0Internal_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObject *)((btManifoldResult const *)swig_b0)->getBody0Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btBridgedManifoldResult_getBody1Internal_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btCollisionObject *)((btManifoldResult const *)swig_b0)->getBody1Internal();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_SetbtBridgedManifoldResult_M_closestPointDistanceThreshold_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0, float _swig_go_1) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  if (swig_b0) (swig_b0)->m_closestPointDistanceThreshold = arg2;
  
}


float _wrap_GetbtBridgedManifoldResult_M_closestPointDistanceThreshold_mbt_e1d552452a96202d(btBridgedManifoldResult *_swig_go_0) {
  btBridgedManifoldResult *arg1 = (btBridgedManifoldResult *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btBridgedManifoldResult **)&_swig_go_0; 
  
  btManifoldResult *swig_b0 = (btManifoldResult *)arg1;
  result = (btScalar) ((swig_b0)->m_closestPointDistanceThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedRestitution_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRestitution((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedRollingFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedRollingFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedSpinningFriction_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedSpinningFriction((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedContactDamping_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactDamping((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btBridgedManifoldResult_calculateCombinedContactStiffness_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  result = (btScalar)btManifoldResult::calculateCombinedContactStiffness((btCollisionObject const *)arg1,(btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_collisionObject_set_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0, btCollisionObject *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObject = arg2;
  
}


btCollisionObject *_wrap_btSingleContactCallback_m_collisionObject_get_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionObject *) ((arg1)->m_collisionObject);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_world_set_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0, btCollisionWorld *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_world = arg2;
  
}


btCollisionWorld *_wrap_btSingleContactCallback_m_world_get_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld *) ((arg1)->m_world);
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btSingleContactCallback_m_resultCallback_set_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0, btCollisionWorld::ContactResultCallback *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld::ContactResultCallback *arg2 = 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_resultCallback = *arg2;
  
}


btCollisionWorld::ContactResultCallback *_wrap_btSingleContactCallback_m_resultCallback_get_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btCollisionWorld::ContactResultCallback *result = 0 ;
  btCollisionWorld::ContactResultCallback *_swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  result = (btCollisionWorld::ContactResultCallback *) &(btCollisionWorld::ContactResultCallback &) ((arg1)->m_resultCallback);
  *(btCollisionWorld::ContactResultCallback **)&_swig_go_result = result; 
  return _swig_go_result;
}


btSingleContactCallback *_wrap_new_btSingleContactCallback_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionWorld *_swig_go_1, btCollisionWorld::ContactResultCallback *_swig_go_2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionWorld *arg2 = (btCollisionWorld *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  btSingleContactCallback *result = 0 ;
  btSingleContactCallback *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionWorld **)&_swig_go_1; 
  arg3 = *(btCollisionWorld::ContactResultCallback **)&_swig_go_2; 
  
  result = (btSingleContactCallback *)new btSingleContactCallback(arg1,arg2,*arg3);
  *(btSingleContactCallback **)&_swig_go_result = (btSingleContactCallback *)result; 
  return _swig_go_result;
}


bool _wrap_btSingleContactCallback_process_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)(arg1)->process((btBroadphaseProxy const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btSingleContactCallback_mbt_e1d552452a96202d(btSingleContactCallback *_swig_go_0) {
  btSingleContactCallback *arg1 = (btSingleContactCallback *) 0 ;
  
  arg1 = *(btSingleContactCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


DebugDrawcallback *_wrap_new_DebugDrawcallback_mbt_e1d552452a96202d(btIDebugDraw *_swig_go_0, btTransform *_swig_go_1, btVector3 *_swig_go_2) {
  btIDebugDraw *arg1 = (btIDebugDraw *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  DebugDrawcallback *result = 0 ;
  DebugDrawcallback *_swig_go_result;
  
  arg1 = *(btIDebugDraw **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (DebugDrawcallback *)new DebugDrawcallback(arg1,(btTransform const &)*arg2,(btVector3 const &)*arg3);
  *(DebugDrawcallback **)&_swig_go_result = (DebugDrawcallback *)result; 
  return _swig_go_result;
}


void _wrap_DebugDrawcallback_internalProcessTriangleIndex_mbt_e1d552452a96202d(DebugDrawcallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->internalProcessTriangleIndex(arg2,arg3,arg4);
  
}


void _wrap_DebugDrawcallback_processTriangle_mbt_e1d552452a96202d(DebugDrawcallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


void _wrap_delete_DebugDrawcallback_mbt_e1d552452a96202d(DebugDrawcallback *_swig_go_0) {
  DebugDrawcallback *arg1 = (DebugDrawcallback *) 0 ;
  
  arg1 = *(DebugDrawcallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btTriangleCallback_mbt_e1d552452a96202d(btTriangleCallback *_swig_go_0) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  
  arg1 = *(btTriangleCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTriangleCallback_processTriangle_mbt_e1d552452a96202d(btTriangleCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btTriangleCallback *arg1 = (btTriangleCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btTriangleCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->processTriangle(arg2,arg3,arg4);
  
}


void _wrap_delete_btInternalTriangleIndexCallback_mbt_e1d552452a96202d(btInternalTriangleIndexCallback *_swig_go_0) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  
  arg1 = *(btInternalTriangleIndexCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btInternalTriangleIndexCallback_internalProcessTriangleIndex_mbt_e1d552452a96202d(btInternalTriangleIndexCallback *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btInternalTriangleIndexCallback *arg1 = (btInternalTriangleIndexCallback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btInternalTriangleIndexCallback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->internalProcessTriangleIndex(arg2,arg3,arg4);
  
}


intgo _wrap_POINT2POINT_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = POINT2POINT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_HINGE_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = HINGE_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONETWIST_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONETWIST_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_SLIDER_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = SLIDER_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_CONTACT_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = CONTACT_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_GEAR_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = GEAR_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_FIXED_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = FIXED_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_D6_SPRING_2_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = D6_SPRING_2_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_MAX_CONSTRAINT_TYPE_mbt_e1d552452a96202d() {
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  
  result = MAX_CONSTRAINT_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_ERP_mbt_e1d552452a96202d() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_ERP_mbt_e1d552452a96202d() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_CFM_mbt_e1d552452a96202d() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONSTRAINT_STOP_CFM_mbt_e1d552452a96202d() {
  btConstraintParams result;
  intgo _swig_go_result;
  
  
  result = BT_CONSTRAINT_STOP_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyA_set_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyA_get_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyA_set_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyA = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyA_get_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyA);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedForceBodyB_set_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedForceBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedForceBodyB_get_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedForceBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btJointFeedback_m_appliedTorqueBodyB_set_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0, btVector3 *_swig_go_1) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedTorqueBodyB = *arg2;
  
}


btVector3 *_wrap_btJointFeedback_m_appliedTorqueBodyB_get_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_appliedTorqueBodyB);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_new_btJointFeedback_mbt_e1d552452a96202d() {
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  
  result = (btJointFeedback *)new btJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


void _wrap_delete_btJointFeedback_mbt_e1d552452a96202d(btJointFeedback *_swig_go_0) {
  btJointFeedback *arg1 = (btJointFeedback *) 0 ;
  
  arg1 = *(btJointFeedback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_delete_btTypedConstraint_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btTypedConstraint_getFixedBody_mbt_e1d552452a96202d() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getOverrideNumSolverIterations_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setOverrideNumSolverIterations_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btTypedConstraint_buildJacobian_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btTypedConstraint_setupSolverConstraint_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, btConstraintArray *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btTypedConstraint_getInfo1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btTypedConstraint_getInfo2_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btTypedConstraint_internalSetAppliedImpulse_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btTypedConstraint_internalGetAppliedImpulse_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getBreakingImpulseThreshold_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setBreakingImpulseThreshold_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btTypedConstraint_isEnabled_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setEnabled_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setEnabled(arg2);
  
}


void _wrap_btTypedConstraint_solveConstraintObsolete_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &(arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUserConstraintType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintType(arg2);
  
}


void _wrap_btTypedConstraint_setUserConstraintId_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setUserConstraintId(arg2);
  
}


intgo _wrap_btTypedConstraint_getUserConstraintId_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setUserConstraintPtr_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, void *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  (arg1)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btTypedConstraint_getUserConstraintPtr_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (void *)(arg1)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setJointFeedback_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  (arg1)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btJointFeedback *)(arg1)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getUid_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTypedConstraint_needsFeedback_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_enableFeedback_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, bool _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->enableFeedback(arg2);
  
}


float _wrap_btTypedConstraint_getAppliedImpulse_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getConstraintType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setDbgDrawSize_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, float _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDbgDrawSize(arg2);
  
}


float _wrap_btTypedConstraint_getDbgDrawSize_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraint_setParam__SWIG_0_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btTypedConstraint_setParam__SWIG_1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


float _wrap_btTypedConstraint_getParam__SWIG_0_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTypedConstraint_getParam__SWIG_1_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_calculateSerializeBufferSize_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btTypedConstraint_serialize_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_SetbtTypedConstraint_M_objectType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  if (swig_b0) (swig_b0)->m_objectType = arg2;
  
}


intgo _wrap_GetbtTypedConstraint_M_objectType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int) ((swig_b0)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTypedConstraint_getObjectType_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int)((btTypedObject const *)swig_b0)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAdjustAngleToLimits_mbt_e1d552452a96202d(float _swig_go_0, float _swig_go_1, float _swig_go_2) {
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbA_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbA_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbA);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_rbB_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, btRigidBodyFloatData *_swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *arg2 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = *(btRigidBodyFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyFloatData *_wrap_btTypedConstraintFloatData_m_rbB_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (btRigidBodyFloatData *) ((arg1)->m_rbB);
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_name_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintFloatData_m_name_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_objectType_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_objectType_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintType_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintType_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_userConstraintId_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_userConstraintId_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_needsFeedback_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_needsFeedback_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_appliedImpulse_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_appliedImpulse_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_dbgDrawSize_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_dbgDrawSize_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_disableCollisionsBetweenLinkedBodies_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_overrideNumSolverIterations_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintFloatData_m_breakingImpulseThreshold_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintFloatData_m_isEnabled_set_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintFloatData_m_isEnabled_get_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintFloatData *_wrap_new_btTypedConstraintFloatData_mbt_e1d552452a96202d() {
  btTypedConstraintFloatData *result = 0 ;
  btTypedConstraintFloatData *_swig_go_result;
  
  
  result = (btTypedConstraintFloatData *)new btTypedConstraintFloatData();
  *(btTypedConstraintFloatData **)&_swig_go_result = (btTypedConstraintFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintFloatData_mbt_e1d552452a96202d(btTypedConstraintFloatData *_swig_go_0) {
  btTypedConstraintFloatData *arg1 = (btTypedConstraintFloatData *) 0 ;
  
  arg1 = *(btTypedConstraintFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintData_m_rbA_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, btRigidBodyData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyData *arg2 = (btRigidBodyData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyData *_wrap_btTypedConstraintData_m_rbA_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyData *result = 0 ;
  btRigidBodyData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyData *) ((arg1)->m_rbA);
  *(btRigidBodyData **)&_swig_go_result = (btRigidBodyData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_rbB_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, btRigidBodyData *_swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyData *arg2 = (btRigidBodyData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = *(btRigidBodyData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyData *_wrap_btTypedConstraintData_m_rbB_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  btRigidBodyData *result = 0 ;
  btRigidBodyData *_swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (btRigidBodyData *) ((arg1)->m_rbB);
  *(btRigidBodyData **)&_swig_go_result = (btRigidBodyData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_name_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintData_m_name_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_objectType_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_objectType_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintType_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintType_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_userConstraintId_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_userConstraintId_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_needsFeedback_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_needsFeedback_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_appliedImpulse_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


float _wrap_btTypedConstraintData_m_appliedImpulse_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_dbgDrawSize_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


float _wrap_btTypedConstraintData_m_dbgDrawSize_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_disableCollisionsBetweenLinkedBodies_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_overrideNumSolverIterations_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_overrideNumSolverIterations_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_breakingImpulseThreshold_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, float _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


float _wrap_btTypedConstraintData_m_breakingImpulseThreshold_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintData_m_isEnabled_set_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintData_m_isEnabled_get_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraintData *_wrap_new_btTypedConstraintData_mbt_e1d552452a96202d() {
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  
  result = (btTypedConstraintData *)new btTypedConstraintData();
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintData_mbt_e1d552452a96202d(btTypedConstraintData *_swig_go_0) {
  btTypedConstraintData *arg1 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btTypedConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTypedConstraintDoubleData_m_rbA_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbA = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbA_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbA);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_rbB_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, btRigidBodyDoubleData *_swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *arg2 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btRigidBodyDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbB = arg2;
  
}


btRigidBodyDoubleData *_wrap_btTypedConstraintDoubleData_m_rbB_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (btRigidBodyDoubleData *) ((arg1)->m_rbB);
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_name_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    delete [] arg1->m_name;
    if (arg2) {
      arg1->m_name = (char *) (new char[strlen((const char *)arg2)+1]);
      strcpy((char *)arg1->m_name, (const char *)arg2);
    } else {
      arg1->m_name = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_m_name_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *) ((arg1)->m_name);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_objectType_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_objectType_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintType_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintType = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintType_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_userConstraintId_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_userConstraintId = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_userConstraintId_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_userConstraintId);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_needsFeedback_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_needsFeedback = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_needsFeedback_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_needsFeedback);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_appliedImpulse_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_appliedImpulse = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_appliedImpulse_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_appliedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_dbgDrawSize = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_dbgDrawSize_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_dbgDrawSize);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_disableCollisionsBetweenLinkedBodies = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_disableCollisionsBetweenLinkedBodies_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_disableCollisionsBetweenLinkedBodies);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_overrideNumSolverIterations = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_overrideNumSolverIterations_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_overrideNumSolverIterations);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_breakingImpulseThreshold = arg2;
  
}


double _wrap_btTypedConstraintDoubleData_m_breakingImpulseThreshold_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_breakingImpulseThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_m_isEnabled_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, intgo _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_isEnabled = arg2;
  
}


intgo _wrap_btTypedConstraintDoubleData_m_isEnabled_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_isEnabled);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTypedConstraintDoubleData_padding_set_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->padding, (const char *)arg2, 4-1);
      arg1->padding[4-1] = 0;
    } else {
      arg1->padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btTypedConstraintDoubleData_padding_get_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btTypedConstraintDoubleData *_wrap_new_btTypedConstraintDoubleData_mbt_e1d552452a96202d() {
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  
  result = (btTypedConstraintDoubleData *)new btTypedConstraintDoubleData();
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btTypedConstraintDoubleData_mbt_e1d552452a96202d(btTypedConstraintDoubleData *_swig_go_0) {
  btTypedConstraintDoubleData *arg1 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btTypedConstraintDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


btAngularLimit *_wrap_new_btAngularLimit_mbt_e1d552452a96202d() {
  btAngularLimit *result = 0 ;
  btAngularLimit *_swig_go_result;
  
  
  result = (btAngularLimit *)new btAngularLimit();
  *(btAngularLimit **)&_swig_go_result = (btAngularLimit *)result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_set__SWIG_0_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->set(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_btAngularLimit_set__SWIG_1_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->set(arg2,arg3,arg4,arg5);
  
}


void _wrap_btAngularLimit_set__SWIG_2_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->set(arg2,arg3,arg4);
  
}


void _wrap_btAngularLimit_set__SWIG_3_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->set(arg2,arg3);
  
}


void _wrap_btAngularLimit_test_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float _swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->test(arg2);
  
}


float _wrap_btAngularLimit_getSoftness_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getBiasFactor_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getRelaxationFactor_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getCorrection_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getSign_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getSign();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHalfRange_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btAngularLimit_isLimit_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (bool)((btAngularLimit const *)arg1)->isLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btAngularLimit_fit_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0, float *_swig_go_1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  arg2 = *(btScalar **)&_swig_go_1; 
  
  ((btAngularLimit const *)arg1)->fit(*arg2);
  
}


float _wrap_btAngularLimit_getError_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getError();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getLow_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getLow();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btAngularLimit_getHigh_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btAngularLimit_mbt_e1d552452a96202d(btAngularLimit *_swig_go_0) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = *(btAngularLimit **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRotationalLimitMotor_m_loLimit_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_loLimit = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_loLimit_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_loLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_hiLimit_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_hiLimit = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_hiLimit_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_hiLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_targetVelocity_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_targetVelocity = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_targetVelocity_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_targetVelocity);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_maxMotorForce_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxMotorForce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_maxMotorForce_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxMotorForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_maxLimitForce_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_maxLimitForce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_maxLimitForce_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_maxLimitForce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_damping_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_damping_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_limitSoftness_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_limitSoftness_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_normalCFM_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_normalCFM = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_normalCFM_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_normalCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_stopERP_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_stopERP = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_stopERP_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_stopERP);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_stopCFM_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_stopCFM = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_stopCFM_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_stopCFM);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_bounce_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_bounce = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_bounce_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_bounce);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_enableMotor_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, bool _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_enableMotor = arg2;
  
}


bool _wrap_btRotationalLimitMotor_m_enableMotor_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_enableMotor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentLimitError_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimitError = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_currentLimitError_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_currentLimitError);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentPosition_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentPosition = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_currentPosition_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_currentPosition);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_currentLimit_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimit = arg2;
  
}


intgo _wrap_btRotationalLimitMotor_m_currentLimit_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_currentLimit);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRotationalLimitMotor_m_accumulatedImpulse_set_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_accumulatedImpulse = arg2;
  
}


float _wrap_btRotationalLimitMotor_m_accumulatedImpulse_get_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_accumulatedImpulse);
  _swig_go_result = result; 
  return _swig_go_result;
}


btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_0_mbt_e1d552452a96202d() {
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  
  result = (btRotationalLimitMotor *)new btRotationalLimitMotor();
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_1_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = 0 ;
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (btRotationalLimitMotor *)new btRotationalLimitMotor((btRotationalLimitMotor const &)*arg1);
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


bool _wrap_btRotationalLimitMotor_isLimited_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool)((btRotationalLimitMotor const *)arg1)->isLimited();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRotationalLimitMotor_needApplyTorques_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  result = (bool)((btRotationalLimitMotor const *)arg1)->needApplyTorques();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRotationalLimitMotor_testLimitValue_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (int)(arg1)->testLimitValue(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRotationalLimitMotor_solveAngularLimits_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btRigidBody *_swig_go_4, btRigidBody *_swig_go_5) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btRigidBody *arg5 = (btRigidBody *) 0 ;
  btRigidBody *arg6 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btRigidBody **)&_swig_go_4; 
  arg6 = *(btRigidBody **)&_swig_go_5; 
  
  result = (btScalar)(arg1)->solveAngularLimits(arg2,*arg3,arg4,arg5,arg6);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btRotationalLimitMotor_mbt_e1d552452a96202d(btRotationalLimitMotor *_swig_go_0) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  
  arg1 = *(btRotationalLimitMotor **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btTranslationalLimitMotor_m_lowerLimit_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_lowerLimit = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_lowerLimit_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_lowerLimit);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_upperLimit_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_upperLimit = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_upperLimit_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_upperLimit);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_accumulatedImpulse_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_accumulatedImpulse = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_accumulatedImpulse_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_accumulatedImpulse);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_limitSoftness_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_limitSoftness_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_damping_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_damping_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_restitution_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_restitution = arg2;
  
}


float _wrap_btTranslationalLimitMotor_m_restitution_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_restitution);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_normalCFM_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_normalCFM = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_normalCFM_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_normalCFM);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_stopERP_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_stopERP = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_stopERP_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_stopERP);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_stopCFM_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_stopCFM = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_stopCFM_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_stopCFM);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_enableMotor_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, bool *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *arg2 = (bool *) (bool *)0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(bool **)&_swig_go_1; 
  
  {
    size_t ii;
    bool *b = (bool *) arg1->m_enableMotor;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((bool *) arg2 + ii);
  }
  
}


bool *_wrap_btTranslationalLimitMotor_m_enableMotor_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *result = 0 ;
  bool *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (bool *)(bool *) ((arg1)->m_enableMotor);
  *(bool **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_targetVelocity_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_targetVelocity = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_targetVelocity_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_targetVelocity);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_maxMotorForce_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_maxMotorForce = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_maxMotorForce_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_maxMotorForce);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLimitError_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLimitError = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_currentLimitError_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_currentLimitError);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLinearDiff_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, btVector3 *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_currentLinearDiff = *arg2;
  
}


btVector3 *_wrap_btTranslationalLimitMotor_m_currentLinearDiff_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btVector3 *)& ((arg1)->m_currentLinearDiff);
  *(btVector3 **)&_swig_go_result = (btVector3 *)result; 
  return _swig_go_result;
}


void _wrap_btTranslationalLimitMotor_m_currentLimit_set_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, intgo *_swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_currentLimit;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btTranslationalLimitMotor_m_currentLimit_get_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_currentLimit);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_0_mbt_e1d552452a96202d() {
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  
  result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor();
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_1_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = 0 ;
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor((btTranslationalLimitMotor const &)*arg1);
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


bool _wrap_btTranslationalLimitMotor_isLimited_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btTranslationalLimitMotor const *)arg1)->isLimited(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btTranslationalLimitMotor_needApplyForce_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btTranslationalLimitMotor const *)arg1)->needApplyForce(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btTranslationalLimitMotor_testLimitValue_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = (int)(arg1)->testLimitValue(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btTranslationalLimitMotor_solveLinearAxis_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0, float _swig_go_1, float _swig_go_2, btRigidBody *_swig_go_3, btVector3 *_swig_go_4, btRigidBody *_swig_go_5, btVector3 *_swig_go_6, intgo _swig_go_7, btVector3 *_swig_go_8, btVector3 *_swig_go_9) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btRigidBody *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btRigidBody *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  int arg8 ;
  btVector3 *arg9 = 0 ;
  btVector3 *arg10 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btRigidBody **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btRigidBody **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = (int)_swig_go_7; 
  arg9 = *(btVector3 **)&_swig_go_8; 
  arg10 = *(btVector3 **)&_swig_go_9; 
  
  result = (btScalar)(arg1)->solveLinearAxis(arg2,arg3,*arg4,(btVector3 const &)*arg5,*arg6,(btVector3 const &)*arg7,arg8,(btVector3 const &)*arg9,(btVector3 const &)*arg10);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btTranslationalLimitMotor_mbt_e1d552452a96202d(btTranslationalLimitMotor *_swig_go_0) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  
  arg1 = *(btTranslationalLimitMotor **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_BT_6DOF_FLAGS_CFM_NORM_mbt_e1d552452a96202d() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_CFM_NORM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_6DOF_FLAGS_CFM_STOP_mbt_e1d552452a96202d() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_CFM_STOP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_6DOF_FLAGS_ERP_STOP_mbt_e1d552452a96202d() {
  bt6DofFlags result;
  intgo _swig_go_result;
  
  
  result = BT_6DOF_FLAGS_ERP_STOP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_set_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
  
}


bool _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_get_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool) ((arg1)->m_useSolveConstraintObsolete);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btRigidBody *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, bool _swig_go_4) {
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofConstraint *result = 0 ;
  btGeneric6DofConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = (bool)_swig_go_4; 
  
  result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
  *(btGeneric6DofConstraint **)&_swig_go_result = (btGeneric6DofConstraint *)result; 
  return _swig_go_result;
}


btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1, bool _swig_go_2) {
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofConstraint *result = 0 ;
  btGeneric6DofConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,(btTransform const &)*arg2,arg3);
  *(btGeneric6DofConstraint **)&_swig_go_result = (btGeneric6DofConstraint *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->calculateTransforms();
  
}


btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformA_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformB_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &(arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_buildJacobian_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btGeneric6DofConstraint_getInfo1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo1NonVirtual_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1NonVirtual(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo2_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btGeneric6DofConstraint_getInfo2NonVirtual_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  
  (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8);
  
}


void _wrap_btGeneric6DofConstraint_updateRHS_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateRHS(arg2);
  
}


btVector3 *_wrap_btGeneric6DofConstraint_getAxis_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = ((btGeneric6DofConstraint const *)arg1)->getAxis(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getAngle_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getAngle(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getRelativePivotPosition_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getRelativePivotPosition(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setFrames_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


bool _wrap_btGeneric6DofConstraint_testAngularLimitMotor_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)(arg1)->testAngularLimitMotor(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setLinearLowerLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearLowerLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getLinearLowerLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getLinearLowerLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setLinearUpperLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearUpperLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getLinearUpperLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getLinearUpperLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setAngularLowerLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularLowerLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getAngularLowerLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getAngularLowerLimit(*arg2);
  
}


void _wrap_btGeneric6DofConstraint_setAngularUpperLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularUpperLimit((btVector3 const &)*arg2);
  
}


void _wrap_btGeneric6DofConstraint_getAngularUpperLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  ((btGeneric6DofConstraint const *)arg1)->getAngularUpperLimit(*arg2);
  
}


btRotationalLimitMotor *_wrap_btGeneric6DofConstraint_getRotationalLimitMotor_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btRotationalLimitMotor *result = 0 ;
  btRotationalLimitMotor *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btRotationalLimitMotor *)(arg1)->getRotationalLimitMotor(arg2);
  *(btRotationalLimitMotor **)&_swig_go_result = (btRotationalLimitMotor *)result; 
  return _swig_go_result;
}


btTranslationalLimitMotor *_wrap_btGeneric6DofConstraint_getTranslationalLimitMotor_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTranslationalLimitMotor *result = 0 ;
  btTranslationalLimitMotor *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (btTranslationalLimitMotor *)(arg1)->getTranslationalLimitMotor();
  *(btTranslationalLimitMotor **)&_swig_go_result = (btTranslationalLimitMotor *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setLimit_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setLimit(arg2,arg3,arg4);
  
}


bool _wrap_btGeneric6DofConstraint_isLimited_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->isLimited(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_calcAnchorPos_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  (arg1)->calcAnchorPos();
  
}


intgo _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btRotationalLimitMotor *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, btTypedConstraint::btConstraintInfo2 *_swig_go_8, intgo _swig_go_9, btVector3 *_swig_go_10, intgo _swig_go_11, intgo _swig_go_12) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int arg13 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btRotationalLimitMotor **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  arg11 = *(btVector3 **)&_swig_go_10; 
  arg12 = (int)_swig_go_11; 
  arg13 = (int)_swig_go_12; 
  
  result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12,arg13);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btRotationalLimitMotor *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btVector3 *_swig_go_4, btVector3 *_swig_go_5, btVector3 *_swig_go_6, btVector3 *_swig_go_7, btTypedConstraint::btConstraintInfo2 *_swig_go_8, intgo _swig_go_9, btVector3 *_swig_go_10, intgo _swig_go_11) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btRotationalLimitMotor **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btVector3 **)&_swig_go_4; 
  arg6 = *(btVector3 **)&_swig_go_5; 
  arg7 = *(btVector3 **)&_swig_go_6; 
  arg8 = *(btVector3 **)&_swig_go_7; 
  arg9 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_8; 
  arg10 = (int)_swig_go_9; 
  arg11 = *(btVector3 **)&_swig_go_10; 
  arg12 = (int)_swig_go_11; 
  
  result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeneric6DofConstraint_getUseFrameOffset_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->getUseFrameOffset();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUseFrameOffset_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseFrameOffset(arg2);
  
}


bool _wrap_btGeneric6DofConstraint_getUseLinearReferenceFrameA_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (bool)((btGeneric6DofConstraint const *)arg1)->getUseLinearReferenceFrameA();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUseLinearReferenceFrameA_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setUseLinearReferenceFrameA(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setParam__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btGeneric6DofConstraint_setParam__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


float _wrap_btGeneric6DofConstraint_getParam__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getParam__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setAxis_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


intgo _wrap_btGeneric6DofConstraint_getFlags_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (int)((btGeneric6DofConstraint const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_calculateSerializeBufferSize_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  result = (int)((btGeneric6DofConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btGeneric6DofConstraint_serialize_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btGeneric6DofConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraint_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btGeneric6DofConstraint_getFixedBody_mbt_e1d552452a96202d() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getOverrideNumSolverIterations_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setOverrideNumSolverIterations_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setupSolverConstraint_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btConstraintArray *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btGeneric6DofConstraint_internalSetAppliedImpulse_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btGeneric6DofConstraint_internalGetAppliedImpulse_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btGeneric6DofConstraint_getBreakingImpulseThreshold_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setBreakingImpulseThreshold_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btGeneric6DofConstraint_isEnabled_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setEnabled_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setEnabled(arg2);
  
}


void _wrap_btGeneric6DofConstraint_solveConstraintObsolete_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyA__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &((btTypedConstraint const *)swig_b0)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyA__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &(swig_b0)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyB__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &((btTypedConstraint const *)swig_b0)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btGeneric6DofConstraint_getRigidBodyB__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btRigidBody *) &(swig_b0)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getUserConstraintType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUserConstraintType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintType(arg2);
  
}


void _wrap_btGeneric6DofConstraint_setUserConstraintId_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintId(arg2);
  
}


intgo _wrap_btGeneric6DofConstraint_getUserConstraintId_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setUserConstraintPtr_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, void *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btGeneric6DofConstraint_getUserConstraintPtr_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (void *)(swig_b0)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setJointFeedback_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btGeneric6DofConstraint_getJointFeedback__SWIG_0_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)((btTypedConstraint const *)swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btGeneric6DofConstraint_getJointFeedback__SWIG_1_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)(swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getUid_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btGeneric6DofConstraint_needsFeedback_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_enableFeedback_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, bool _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->enableFeedback(arg2);
  
}


float _wrap_btGeneric6DofConstraint_getAppliedImpulse_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getConstraintType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btTypedConstraintType)((btTypedConstraint const *)swig_b0)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraint_setDbgDrawSize_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, float _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setDbgDrawSize(arg2);
  
}


float _wrap_btGeneric6DofConstraint_getDbgDrawSize_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtGeneric6DofConstraint_M_objectType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  if (swig_b1) (swig_b1)->m_objectType = arg2;
  
}


intgo _wrap_GetbtGeneric6DofConstraint_M_objectType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int) ((swig_b1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGeneric6DofConstraint_getObjectType_mbt_e1d552452a96202d(btGeneric6DofConstraint *_swig_go_0) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int)((btTypedObject const *)swig_b1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_typeConstraintData_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btTypedConstraintData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTypedConstraintData *arg2 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintData *_wrap_btGeneric6DofConstraintData_m_typeConstraintData_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTypedConstraintData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_rbAFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformFloatData *_wrap_btGeneric6DofConstraintData_m_rbAFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbAFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_rbBFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformFloatData *_wrap_btGeneric6DofConstraintData_m_rbBFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbBFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_linearUpperLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearUpperLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_linearUpperLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearUpperLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_linearLowerLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearLowerLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_linearLowerLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearLowerLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_angularUpperLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularUpperLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_angularUpperLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularUpperLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_angularLowerLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularLowerLimit = *arg2;
  
}


btVector3FloatData *_wrap_btGeneric6DofConstraintData_m_angularLowerLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularLowerLimit);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_useLinearReferenceFrameA_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useLinearReferenceFrameA = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintData_m_useLinearReferenceFrameA_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useLinearReferenceFrameA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useOffsetForConstraintFrame = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintData_m_useOffsetForConstraintFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useOffsetForConstraintFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraintData *_wrap_new_btGeneric6DofConstraintData_mbt_e1d552452a96202d() {
  btGeneric6DofConstraintData *result = 0 ;
  btGeneric6DofConstraintData *_swig_go_result;
  
  
  result = (btGeneric6DofConstraintData *)new btGeneric6DofConstraintData();
  *(btGeneric6DofConstraintData **)&_swig_go_result = (btGeneric6DofConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraintData_mbt_e1d552452a96202d(btGeneric6DofConstraintData *_swig_go_0) {
  btGeneric6DofConstraintData *arg1 = (btGeneric6DofConstraintData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_typeConstraintData_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTypedConstraintDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTypedConstraintDoubleData *arg2 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTypedConstraintDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_typeConstraintData_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTypedConstraintDoubleData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_rbAFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_rbAFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbAFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_rbBFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_rbBFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbBFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_linearUpperLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearUpperLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_linearUpperLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearUpperLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_linearLowerLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearLowerLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_linearLowerLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearLowerLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_angularUpperLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularUpperLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_angularUpperLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularUpperLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_angularLowerLimit_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularLowerLimit = *arg2;
  
}


btVector3DoubleData *_wrap_btGeneric6DofConstraintDoubleData2_m_angularLowerLimit_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularLowerLimit);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_useLinearReferenceFrameA_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useLinearReferenceFrameA = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintDoubleData2_m_useLinearReferenceFrameA_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useLinearReferenceFrameA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btGeneric6DofConstraintDoubleData2_m_useOffsetForConstraintFrame_set_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0, intgo _swig_go_1) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int arg2 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_useOffsetForConstraintFrame = arg2;
  
}


intgo _wrap_btGeneric6DofConstraintDoubleData2_m_useOffsetForConstraintFrame_get_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_useOffsetForConstraintFrame);
  _swig_go_result = result; 
  return _swig_go_result;
}


btGeneric6DofConstraintDoubleData2 *_wrap_new_btGeneric6DofConstraintDoubleData2_mbt_e1d552452a96202d() {
  btGeneric6DofConstraintDoubleData2 *result = 0 ;
  btGeneric6DofConstraintDoubleData2 *_swig_go_result;
  
  
  result = (btGeneric6DofConstraintDoubleData2 *)new btGeneric6DofConstraintDoubleData2();
  *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_result = (btGeneric6DofConstraintDoubleData2 *)result; 
  return _swig_go_result;
}


void _wrap_delete_btGeneric6DofConstraintDoubleData2_mbt_e1d552452a96202d(btGeneric6DofConstraintDoubleData2 *_swig_go_0) {
  btGeneric6DofConstraintDoubleData2 *arg1 = (btGeneric6DofConstraintDoubleData2 *) 0 ;
  
  arg1 = *(btGeneric6DofConstraintDoubleData2 **)&_swig_go_0; 
  
  delete arg1;
  
}


float _wrap_btGetMatrixElem_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, intgo _swig_go_1) {
  btMatrix3x3 *arg1 = 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)btGetMatrixElem((btMatrix3x3 const &)*arg1,arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_matrixToEulerXYZ_mbt_e1d552452a96202d(btMatrix3x3 *_swig_go_0, btVector3 *_swig_go_1) {
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btMatrix3x3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (bool)matrixToEulerXYZ((btMatrix3x3 const &)*arg1,*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gContactBreakingThreshold_set_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  
  arg1 = (btScalar)_swig_go_0; 
  
  gContactBreakingThreshold = arg1;
  
}


float _wrap_gContactBreakingThreshold_get_mbt_e1d552452a96202d() {
  btScalar result;
  float _swig_go_result;
  
  
  result = (btScalar)gContactBreakingThreshold;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_MIN_CONTACT_MANIFOLD_TYPE_mbt_e1d552452a96202d() {
  btContactManifoldTypes result;
  intgo _swig_go_result;
  
  
  result = MIN_CONTACT_MANIFOLD_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_PERSISTENT_MANIFOLD_TYPE_mbt_e1d552452a96202d() {
  btContactManifoldTypes result;
  intgo _swig_go_result;
  
  
  result = BT_PERSISTENT_MANIFOLD_TYPE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_companionIdA_set_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifold_m_companionIdA_get_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_companionIdB_set_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifold_m_companionIdB_get_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_m_index1a_set_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifold_m_index1a_get_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_0_mbt_e1d552452a96202d() {
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  
  result = (btPersistentManifold *)new btPersistentManifold();
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btPersistentManifold *_wrap_new_btPersistentManifold__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btPersistentManifold *result = 0 ;
  btPersistentManifold *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  result = (btPersistentManifold *)new btPersistentManifold((btCollisionObject const *)arg1,(btCollisionObject const *)arg2,arg3,arg4,arg5);
  *(btPersistentManifold **)&_swig_go_result = (btPersistentManifold *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btPersistentManifold_getBody0_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody0();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btPersistentManifold_getBody1_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btCollisionObject *)((btPersistentManifold const *)arg1)->getBody1();
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setBodies_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btCollisionObject *_swig_go_1, btCollisionObject *_swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = *(btCollisionObject **)&_swig_go_2; 
  
  (arg1)->setBodies((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
  
}


void _wrap_btPersistentManifold_clearUserCache_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  (arg1)->clearUserCache(*arg2);
  
}


intgo _wrap_btPersistentManifold_getNumContacts_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int)((btPersistentManifold const *)arg1)->getNumContacts();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setNumContacts_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setNumContacts(arg2);
  
}


btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_0_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btManifoldPoint *) &((btPersistentManifold const *)arg1)->getContactPoint(arg2);
  *(btManifoldPoint **)&_swig_go_result = result; 
  return _swig_go_result;
}


btManifoldPoint *_wrap_btPersistentManifold_getContactPoint__SWIG_1_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  btManifoldPoint *result = 0 ;
  btManifoldPoint *_swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btManifoldPoint *) &(arg1)->getContactPoint(arg2);
  *(btManifoldPoint **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPersistentManifold_getContactBreakingThreshold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btScalar)((btPersistentManifold const *)arg1)->getContactBreakingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btPersistentManifold_getContactProcessingThreshold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (btScalar)((btPersistentManifold const *)arg1)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_setContactBreakingThreshold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, float _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactBreakingThreshold(arg2);
  
}


void _wrap_btPersistentManifold_setContactProcessingThreshold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, float _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setContactProcessingThreshold(arg2);
  
}


intgo _wrap_btPersistentManifold_getCacheEntry_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (int)((btPersistentManifold const *)arg1)->getCacheEntry((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_addManifoldPoint__SWIG_0_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1, bool _swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_addManifoldPoint__SWIG_1_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (int)(arg1)->addManifoldPoint((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_removeContactPoint_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->removeContactPoint(arg2);
  
}


void _wrap_btPersistentManifold_replaceContactPoint_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1, intgo _swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->replaceContactPoint((btManifoldPoint const &)*arg2,arg3);
  
}


bool _wrap_btPersistentManifold_validContactDistance_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btManifoldPoint *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btManifoldPoint *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btManifoldPoint **)&_swig_go_1; 
  
  result = (bool)((btPersistentManifold const *)arg1)->validContactDistance((btManifoldPoint const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_refreshContactPoints_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->refreshContactPoints((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


void _wrap_btPersistentManifold_clearManifold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  (arg1)->clearManifold();
  
}


intgo _wrap_btPersistentManifold_calculateSerializeBufferSize_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  result = (int)((btPersistentManifold const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btPersistentManifold_serialize_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btPersistentManifold *_swig_go_1, void *_swig_go_2, btSerializer *_swig_go_3) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  void *arg3 = (void *) 0 ;
  btSerializer *arg4 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifold **)&_swig_go_1; 
  arg3 = *(void **)&_swig_go_2; 
  arg4 = *(btSerializer **)&_swig_go_3; 
  
  result = (char *)((btPersistentManifold const *)arg1)->serialize((btPersistentManifold const *)arg2,arg3,arg4);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btPersistentManifold_deSerialize__SWIG_0_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btPersistentManifoldDoubleData *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifoldDoubleData *arg2 = (btPersistentManifoldDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifoldDoubleData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btPersistentManifoldDoubleData const *)arg2);
  
}


void _wrap_btPersistentManifold_deSerialize__SWIG_1_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, btPersistentManifoldFloatData *_swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  btPersistentManifoldFloatData *arg2 = (btPersistentManifoldFloatData *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = *(btPersistentManifoldFloatData **)&_swig_go_1; 
  
  (arg1)->deSerialize((btPersistentManifoldFloatData const *)arg2);
  
}


void _wrap_delete_btPersistentManifold_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_SetbtPersistentManifold_M_objectType_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  if (swig_b0) (swig_b0)->m_objectType = arg2;
  
}


intgo _wrap_GetbtPersistentManifold_M_objectType_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int) ((swig_b0)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btPersistentManifold_getObjectType_mbt_e1d552452a96202d(btPersistentManifold *_swig_go_0) {
  btPersistentManifold *arg1 = (btPersistentManifold *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifold **)&_swig_go_0; 
  
  btTypedObject *swig_b0 = (btTypedObject *)arg1;
  result = (int)((btTypedObject const *)swig_b0)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointA_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLocalPointA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointA_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLocalPointA);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointB_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLocalPointB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLocalPointB_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLocalPointB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnA_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCachePositionWorldOnA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnA_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCachePositionWorldOnA);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnB_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCachePositionWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCachePositionWorldOnB_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCachePositionWorldOnB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheNormalWorldOnB_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheNormalWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheNormalWorldOnB_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheNormalWorldOnB);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLateralFrictionDir1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLateralFrictionDir1);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir2_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btVector3DoubleData (*_swig_go_1)[4]) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) (btVector3DoubleData *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3DoubleData *b = (btVector3DoubleData *) arg1->m_pointCacheLateralFrictionDir2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3DoubleData *) arg2 + ii);
  }
  
}


btVector3DoubleData (*_wrap_btPersistentManifoldDoubleData_m_pointCacheLateralFrictionDir2_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0))[4] {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)(btVector3DoubleData *) ((arg1)->m_pointCacheLateralFrictionDir2);
  *(btVector3DoubleData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheDistance_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheDistance;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheDistance_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheDistance);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulse_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulse;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulse_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulse);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePrevRHS_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCachePrevRHS;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCachePrevRHS_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCachePrevRHS);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedFriction_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedFriction_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRollingFriction_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedRollingFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRollingFriction_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedRollingFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedSpinningFriction_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedSpinningFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedSpinningFriction_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedSpinningFriction);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRestitution_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedRestitution;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedRestitution_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedRestitution);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePartId0_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCachePartId0_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCachePartId1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCachePartId1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheIndex0_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheIndex0_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheIndex1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheIndex1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactPointFlags_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheContactPointFlags;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactPointFlags_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheContactPointFlags);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulseLateral1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulseLateral1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral2_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheAppliedImpulseLateral2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheAppliedImpulseLateral2_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheAppliedImpulseLateral2);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactMotion1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactMotion1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion2_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactMotion2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactMotion2_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactMotion2);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactCFM_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactCFM_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactCFM);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactStiffness1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedContactStiffness1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactStiffness1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedContactStiffness1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheContactERP_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheContactERP;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheContactERP_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheContactERP);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactDamping1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheCombinedContactDamping1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheCombinedContactDamping1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheCombinedContactDamping1);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheFrictionCFM_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *arg2 = (double *) (double *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(double **)&_swig_go_1; 
  
  {
    size_t ii;
    double *b = (double *) arg1->m_pointCacheFrictionCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((double *) arg2 + ii);
  }
  
}


double *_wrap_btPersistentManifoldDoubleData_m_pointCacheFrictionCFM_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double *result = 0 ;
  double *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double *)(double *) ((arg1)->m_pointCacheFrictionCFM);
  *(double **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_pointCacheLifeTime_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheLifeTime;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldDoubleData_m_pointCacheLifeTime_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheLifeTime);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_numCachedPoints_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numCachedPoints = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_numCachedPoints_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numCachedPoints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_companionIdA_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_companionIdA_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_companionIdB_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_companionIdB_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_index1a_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_index1a_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_objectType_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_objectType_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_contactBreakingThreshold_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactBreakingThreshold = arg2;
  
}


double _wrap_btPersistentManifoldDoubleData_m_contactBreakingThreshold_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactBreakingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_contactProcessingThreshold_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, double _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


double _wrap_btPersistentManifoldDoubleData_m_contactProcessingThreshold_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_padding_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btPersistentManifoldDoubleData_m_padding_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_body0_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body0 = arg2;
  
}


btCollisionObjectDoubleData *_wrap_btPersistentManifoldDoubleData_m_body0_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *) ((arg1)->m_body0);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldDoubleData_m_body1_set_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body1 = arg2;
  
}


btCollisionObjectDoubleData *_wrap_btPersistentManifoldDoubleData_m_body1_get_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *) ((arg1)->m_body1);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


btPersistentManifoldDoubleData *_wrap_new_btPersistentManifoldDoubleData_mbt_e1d552452a96202d() {
  btPersistentManifoldDoubleData *result = 0 ;
  btPersistentManifoldDoubleData *_swig_go_result;
  
  
  result = (btPersistentManifoldDoubleData *)new btPersistentManifoldDoubleData();
  *(btPersistentManifoldDoubleData **)&_swig_go_result = (btPersistentManifoldDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldDoubleData_mbt_e1d552452a96202d(btPersistentManifoldDoubleData *_swig_go_0) {
  btPersistentManifoldDoubleData *arg1 = (btPersistentManifoldDoubleData *) 0 ;
  
  arg1 = *(btPersistentManifoldDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointA_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLocalPointA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointA_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLocalPointA);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointB_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLocalPointB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLocalPointB_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLocalPointB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnA_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCachePositionWorldOnA;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnA_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCachePositionWorldOnA);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnB_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCachePositionWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCachePositionWorldOnB_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCachePositionWorldOnB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheNormalWorldOnB_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheNormalWorldOnB;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheNormalWorldOnB_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheNormalWorldOnB);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLateralFrictionDir1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLateralFrictionDir1);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir2_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btVector3FloatData (*_swig_go_1)[4]) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) (btVector3FloatData *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  {
    size_t ii;
    btVector3FloatData *b = (btVector3FloatData *) arg1->m_pointCacheLateralFrictionDir2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btVector3FloatData *) arg2 + ii);
  }
  
}


btVector3FloatData (*_wrap_btPersistentManifoldFloatData_m_pointCacheLateralFrictionDir2_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0))[4] {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData (*_swig_go_result)[4];
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)(btVector3FloatData *) ((arg1)->m_pointCacheLateralFrictionDir2);
  *(btVector3FloatData **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheDistance_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheDistance;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheDistance_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheDistance);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulse_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulse;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulse_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulse);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePrevRHS_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCachePrevRHS;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCachePrevRHS_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCachePrevRHS);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedFriction_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedFriction_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRollingFriction_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedRollingFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRollingFriction_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedRollingFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedSpinningFriction_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedSpinningFriction;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedSpinningFriction_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedSpinningFriction);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRestitution_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedRestitution;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedRestitution_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedRestitution);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePartId0_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCachePartId0_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCachePartId1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCachePartId1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCachePartId1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCachePartId1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheIndex0_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex0;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheIndex0_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex0);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheIndex1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheIndex1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheIndex1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheIndex1);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactPointFlags_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheContactPointFlags;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheContactPointFlags_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheContactPointFlags);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulseLateral1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulseLateral1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral2_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheAppliedImpulseLateral2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheAppliedImpulseLateral2_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheAppliedImpulseLateral2);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactMotion1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactMotion1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion2_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactMotion2;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactMotion2_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactMotion2);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactCFM_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactCFM_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactCFM);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactStiffness1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedContactStiffness1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactStiffness1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedContactStiffness1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheContactERP_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheContactERP;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheContactERP_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheContactERP);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactDamping1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheCombinedContactDamping1;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheCombinedContactDamping1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheCombinedContactDamping1);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheFrictionCFM_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *arg2 = (float *) (float *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(float **)&_swig_go_1; 
  
  {
    size_t ii;
    float *b = (float *) arg1->m_pointCacheFrictionCFM;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
}


float *_wrap_btPersistentManifoldFloatData_m_pointCacheFrictionCFM_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float *result = 0 ;
  float *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float *)(float *) ((arg1)->m_pointCacheFrictionCFM);
  *(float **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_pointCacheLifeTime_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *arg2 = (int *) (int *)0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(int **)&_swig_go_1; 
  
  {
    size_t ii;
    int *b = (int *) arg1->m_pointCacheLifeTime;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
}


intgo *_wrap_btPersistentManifoldFloatData_m_pointCacheLifeTime_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int *result = 0 ;
  intgo *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int *)(int *) ((arg1)->m_pointCacheLifeTime);
  *(int **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_numCachedPoints_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numCachedPoints = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_numCachedPoints_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numCachedPoints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_companionIdA_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdA = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_companionIdA_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdA);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_companionIdB_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_companionIdB = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_companionIdB_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_companionIdB);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_index1a_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_index1a = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_index1a_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_index1a);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_objectType_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_objectType = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_objectType_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_contactBreakingThreshold_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactBreakingThreshold = arg2;
  
}


float _wrap_btPersistentManifoldFloatData_m_contactBreakingThreshold_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactBreakingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_contactProcessingThreshold_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, float _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactProcessingThreshold = arg2;
  
}


float _wrap_btPersistentManifoldFloatData_m_contactProcessingThreshold_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_contactProcessingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_padding_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, intgo _swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_padding = arg2;
  
}


intgo _wrap_btPersistentManifoldFloatData_m_padding_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_padding);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_body0_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body0 = arg2;
  
}


btCollisionObjectFloatData *_wrap_btPersistentManifoldFloatData_m_body0_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *) ((arg1)->m_body0);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btPersistentManifoldFloatData_m_body1_set_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_body1 = arg2;
  
}


btCollisionObjectFloatData *_wrap_btPersistentManifoldFloatData_m_body1_get_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *) ((arg1)->m_body1);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


btPersistentManifoldFloatData *_wrap_new_btPersistentManifoldFloatData_mbt_e1d552452a96202d() {
  btPersistentManifoldFloatData *result = 0 ;
  btPersistentManifoldFloatData *_swig_go_result;
  
  
  result = (btPersistentManifoldFloatData *)new btPersistentManifoldFloatData();
  *(btPersistentManifoldFloatData **)&_swig_go_result = (btPersistentManifoldFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btPersistentManifoldFloatData_mbt_e1d552452a96202d(btPersistentManifoldFloatData *_swig_go_0) {
  btPersistentManifoldFloatData *arg1 = (btPersistentManifoldFloatData *) 0 ;
  
  arg1 = *(btPersistentManifoldFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gContactDestroyedCallback_set_mbt_e1d552452a96202d(ContactDestroyedCallback *_swig_go_0) {
  ContactDestroyedCallback arg1 ;
  ContactDestroyedCallback *argp1 ;
  
  
  argp1 = (ContactDestroyedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactDestroyedCallback");
  }
  arg1 = (ContactDestroyedCallback)*argp1;
  
  
  gContactDestroyedCallback = arg1;
  
}


ContactDestroyedCallback *_wrap_gContactDestroyedCallback_get_mbt_e1d552452a96202d() {
  ContactDestroyedCallback result;
  ContactDestroyedCallback *_swig_go_result;
  
  
  result = gContactDestroyedCallback;
  *(ContactDestroyedCallback **)&_swig_go_result = new ContactDestroyedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactProcessedCallback_set_mbt_e1d552452a96202d(ContactProcessedCallback *_swig_go_0) {
  ContactProcessedCallback arg1 ;
  ContactProcessedCallback *argp1 ;
  
  
  argp1 = (ContactProcessedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactProcessedCallback");
  }
  arg1 = (ContactProcessedCallback)*argp1;
  
  
  gContactProcessedCallback = arg1;
  
}


ContactProcessedCallback *_wrap_gContactProcessedCallback_get_mbt_e1d552452a96202d() {
  ContactProcessedCallback result;
  ContactProcessedCallback *_swig_go_result;
  
  
  result = gContactProcessedCallback;
  *(ContactProcessedCallback **)&_swig_go_result = new ContactProcessedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactStartedCallback_set_mbt_e1d552452a96202d(ContactStartedCallback *_swig_go_0) {
  ContactStartedCallback arg1 ;
  ContactStartedCallback *argp1 ;
  
  
  argp1 = (ContactStartedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactStartedCallback");
  }
  arg1 = (ContactStartedCallback)*argp1;
  
  
  gContactStartedCallback = arg1;
  
}


ContactStartedCallback *_wrap_gContactStartedCallback_get_mbt_e1d552452a96202d() {
  ContactStartedCallback result;
  ContactStartedCallback *_swig_go_result;
  
  
  result = gContactStartedCallback;
  *(ContactStartedCallback **)&_swig_go_result = new ContactStartedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactEndedCallback_set_mbt_e1d552452a96202d(ContactEndedCallback *_swig_go_0) {
  ContactEndedCallback arg1 ;
  ContactEndedCallback *argp1 ;
  
  
  argp1 = (ContactEndedCallback *)_swig_go_0;
  if (argp1 == NULL) {
    _swig_gopanic("Attempt to dereference null ContactEndedCallback");
  }
  arg1 = (ContactEndedCallback)*argp1;
  
  
  gContactEndedCallback = arg1;
  
}


ContactEndedCallback *_wrap_gContactEndedCallback_get_mbt_e1d552452a96202d() {
  ContactEndedCallback result;
  ContactEndedCallback *_swig_go_result;
  
  
  result = gContactEndedCallback;
  *(ContactEndedCallback **)&_swig_go_result = new ContactEndedCallback(result); 
  return _swig_go_result;
}


void _wrap_gContactCalcArea3Points_set_mbt_e1d552452a96202d(bool _swig_go_0) {
  bool arg1 ;
  
  arg1 = (bool)_swig_go_0; 
  
  gContactCalcArea3Points = arg1;
  
}


bool _wrap_gContactCalcArea3Points_get_mbt_e1d552452a96202d() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)gContactCalcArea3Points;
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_calcArea4Points_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btVector3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btScalar)calcArea4Points((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gDeactivationTime_set_mbt_e1d552452a96202d(float _swig_go_0) {
  btScalar arg1 ;
  
  arg1 = (btScalar)_swig_go_0; 
  
  gDeactivationTime = arg1;
  
}


float _wrap_gDeactivationTime_get_mbt_e1d552452a96202d() {
  btScalar result;
  float _swig_go_result;
  
  
  result = (btScalar)gDeactivationTime;
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_gDisableDeactivation_set_mbt_e1d552452a96202d(bool _swig_go_0) {
  bool arg1 ;
  
  arg1 = (bool)_swig_go_0; 
  
  gDisableDeactivation = arg1;
  
}


bool _wrap_gDisableDeactivation_get_mbt_e1d552452a96202d() {
  bool result;
  bool _swig_go_result;
  
  
  result = (bool)gDisableDeactivation;
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_BT_DISABLE_WORLD_GRAVITY_mbt_e1d552452a96202d() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_DISABLE_WORLD_GRAVITY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT_mbt_e1d552452a96202d() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD_mbt_e1d552452a96202d() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY_mbt_e1d552452a96202d() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_ENABLE_GYROPSCOPIC_FORCE_mbt_e1d552452a96202d() {
  btRigidBodyFlags result;
  intgo _swig_go_result;
  
  
  result = BT_ENABLE_GYROPSCOPIC_FORCE;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_0_mbt_e1d552452a96202d(btRigidBody::btRigidBodyConstructionInfo *_swig_go_0) {
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btRigidBody::btRigidBodyConstructionInfo **)&_swig_go_0; 
  
  result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_1_mbt_e1d552452a96202d(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2, btVector3 *_swig_go_3) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  arg4 = *(btVector3 **)&_swig_go_3; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_new_btRigidBody__SWIG_2_mbt_e1d552452a96202d(float _swig_go_0, btMotionState *_swig_go_1, btCollisionShape *_swig_go_2) {
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = (btScalar)_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  arg3 = *(btCollisionShape **)&_swig_go_2; 
  
  result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBody_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBody_proceedToTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->proceedToTransform((btTransform const &)*arg2);
  
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_0_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btRigidBody_upcast__SWIG_1_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  
  result = (btRigidBody *)btRigidBody::upcast(arg1);
  *(btRigidBody **)&_swig_go_result = (btRigidBody *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_predictIntegratedTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1, btTransform *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->predictIntegratedTransform(arg2,*arg3);
  
}


void _wrap_btRigidBody_saveKinematicState_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->saveKinematicState(arg2);
  
}


void _wrap_btRigidBody_applyGravity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->applyGravity();
  
}


void _wrap_btRigidBody_clearGravity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearGravity();
  
}


void _wrap_btRigidBody_setGravity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getGravity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getLinearDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getLinearSleepingThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getAngularSleepingThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_applyDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->applyDamping(arg2);
  
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  btCollisionShape *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btCollisionShape *)(arg1)->getCollisionShape();
  *(btCollisionShape **)&_swig_go_result = (btCollisionShape *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMassProps_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getLinearFactor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearFactor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearFactor((btVector3 const &)*arg2);
  
}


float _wrap_btRigidBody_getInvMass_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getMass_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btScalar)((btRigidBody const *)arg1)->getMass();
  _swig_go_result = result; 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
  *(btMatrix3x3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_integrateVelocities_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->integrateVelocities(arg2);
  
}


void _wrap_btRigidBody_setCenterOfMassTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralForce_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralForce((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getTotalForce_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTotalTorque_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInvInertiaDiagLocal_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setSleepingThresholds_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setSleepingThresholds(arg2,arg3);
  
}


void _wrap_btRigidBody_applyTorque_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorque((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyForce_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyCentralImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


void _wrap_btRigidBody_applyPushImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  (arg1)->applyPushImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  
}


btVector3 *_wrap_btRigidBody_getPushVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getTurnVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getTurnVelocity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_setPushVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setPushVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setTurnVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setTurnVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyCentralPushImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyCentralPushImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_applyTorqueTurnImpulse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->applyTorqueTurnImpulse((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_clearForces_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btRigidBody_updateInertiaTensor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  (arg1)->updateInertiaTensor();
  
}


btVector3 *_wrap_btRigidBody_getCenterOfMassPosition_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btQuaternion *_wrap_btRigidBody_getOrientation_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getOrientation();
  *(btQuaternion **)&_swig_go_result = new btQuaternion(result); 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getCenterOfMassTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLinearVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAngularVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setLinearVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getPushVelocityInLocalPoint_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->getPushVelocityInLocalPoint((btVector3 const &)*arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btRigidBody_translate_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->translate((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_getAabb_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
  
}


float _wrap_btRigidBody_computeImpulseDenominator_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_computeAngularImpulseDenominator_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_updateDeactivation_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateDeactivation(arg2);
  
}


bool _wrap_btRigidBody_wantsSleeping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)(arg1)->wantsSleeping();
  _swig_go_result = result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setNewBroadphaseProxy_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  (arg1)->setNewBroadphaseProxy(arg2);
  
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)(arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  btMotionState *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
  *(btMotionState **)&_swig_go_result = (btMotionState *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setMotionState_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btMotionState *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btMotionState **)&_swig_go_1; 
  
  (arg1)->setMotionState(arg2);
  
}


void _wrap_btRigidBody_m_contactSolverType_set_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_contactSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_contactSolverType_get_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_contactSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_m_frictionSolverType_set_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_frictionSolverType = arg2;
  
}


intgo _wrap_btRigidBody_m_frictionSolverType_get_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_frictionSolverType);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAngularFactor__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setAngularFactor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setAngularFactor__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setAngularFactor(arg2);
  
}


btVector3 *_wrap_btRigidBody_getAngularFactor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isInWorld_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (bool)((btRigidBody const *)arg1)->isInWorld();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_addConstraintRef_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraintRef(arg2);
  
}


void _wrap_btRigidBody_removeConstraintRef_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraintRef(arg2);
  
}


btTypedConstraint *_wrap_btRigidBody_getConstraintRef_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getNumConstraintRefs_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFlags_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setFlags(arg2);
  
}


intgo _wrap_btRigidBody_getFlags_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_World_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_World(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_Body_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_Body(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_computeGyroscopicForceExplicit_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = ((btRigidBody const *)arg1)->computeGyroscopicForceExplicit(arg2);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getLocalInertia_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = ((btRigidBody const *)arg1)->getLocalInertia();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_calculateSerializeBufferSize_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btRigidBody_serialize_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_btRigidBody_serializeSingleObject_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btSerializer *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
  
}


bool _wrap_btRigidBody_mergesSimulationIslands_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->mergesSimulationIslands();
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getAnisotropicFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getAnisotropicFriction();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1, intgo _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
  
}


void _wrap_btRigidBody_setAnisotropicFriction__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setAnisotropicFriction((btVector3 const &)*arg2);
  
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasAnisotropicFriction__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasAnisotropicFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactProcessingThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactProcessingThreshold(arg2);
  
}


float _wrap_btRigidBody_getContactProcessingThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactProcessingThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticObject_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isKinematicObject_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_isStaticOrKinematicObject_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isStaticOrKinematicObject();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_hasContactResponse_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->hasContactResponse();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionShape_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btCollisionShape *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionShape **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionShape(arg2);
  
}


void _wrap_btRigidBody_setIgnoreCollisionCheck_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1, bool _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
  
}


intgo _wrap_btRigidBody_getNumObjectsWithoutCollision_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getNumObjectsWithoutCollision();
  _swig_go_result = result; 
  return _swig_go_result;
}


btCollisionObject *_wrap_btRigidBody_getObjectWithoutCollision_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btCollisionObject *)(swig_b0)->getObjectWithoutCollision(arg2);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWithOverride_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWithOverride((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void *_wrap_btRigidBody_internalGetExtensionPointer_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->internalGetExtensionPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_internalSetExtensionPointer_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->internalSetExtensionPointer(arg2);
  
}


intgo _wrap_btRigidBody_getActivationState_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getActivationState();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setActivationState_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->setActivationState(arg2);
  
}


void _wrap_btRigidBody_setDeactivationTime_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setDeactivationTime(arg2);
  
}


float _wrap_btRigidBody_getDeactivationTime_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getDeactivationTime();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_forceActivationState_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->forceActivationState(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, bool _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate(arg2);
  
}


void _wrap_btRigidBody_activate__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  ((btCollisionObject const *)swig_b0)->activate();
  
}


bool _wrap_btRigidBody_isActive_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->isActive();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRestitution_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRestitution(arg2);
  
}


float _wrap_btRigidBody_getRestitution_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setFriction(arg2);
  
}


float _wrap_btRigidBody_getFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setRollingFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setRollingFriction(arg2);
  
}


float _wrap_btRigidBody_getRollingFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getRollingFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setSpinningFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setSpinningFriction(arg2);
  
}


float _wrap_btRigidBody_getSpinningFriction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getSpinningFriction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setContactStiffnessAndDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setContactStiffnessAndDamping(arg2,arg3);
  
}


float _wrap_btRigidBody_getContactStiffness_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactStiffness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getContactDamping_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getContactDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getInternalType_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getInternalType();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getWorldTransform__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldTransform((btTransform const &)*arg2);
  
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)(swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseHandle__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  btBroadphaseProxy *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btBroadphaseProxy *)((btCollisionObject const *)swig_b0)->getBroadphaseHandle();
  *(btBroadphaseProxy **)&_swig_go_result = (btBroadphaseProxy *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setBroadphaseHandle_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setBroadphaseHandle(arg2);
  
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &((btCollisionObject const *)swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btRigidBody_getInterpolationWorldTransform__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btTransform *) &(swig_b0)->getInterpolationWorldTransform();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setInterpolationWorldTransform_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationWorldTransform((btTransform const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationLinearVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_setInterpolationAngularVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btRigidBody_getInterpolationLinearVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationLinearVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_btRigidBody_getInterpolationAngularVelocity_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  btVector3 *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btVector3 *) &((btCollisionObject const *)swig_b0)->getInterpolationAngularVelocity();
  *(btVector3 **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getIslandTag_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getIslandTag();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setIslandTag_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setIslandTag(arg2);
  
}


intgo _wrap_btRigidBody_getCompanionId_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCompanionId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCompanionId_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCompanionId(arg2);
  
}


intgo _wrap_btRigidBody_getWorldArrayIndex_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getWorldArrayIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setWorldArrayIndex_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setWorldArrayIndex(arg2);
  
}


float _wrap_btRigidBody_getHitFraction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getHitFraction();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setHitFraction_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setHitFraction(arg2);
  
}


intgo _wrap_btRigidBody_getCollisionFlags_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getCollisionFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCollisionFlags_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCollisionFlags(arg2);
  
}


float _wrap_btRigidBody_getCcdSweptSphereRadius_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSweptSphereRadius();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdSweptSphereRadius_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdSweptSphereRadius(arg2);
  
}


float _wrap_btRigidBody_getCcdMotionThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btRigidBody_getCcdSquareMotionThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (btScalar)((btCollisionObject const *)swig_b0)->getCcdSquareMotionThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCcdMotionThreshold_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, float _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCcdMotionThreshold(arg2);
  
}


void *_wrap_btRigidBody_getUserPointer_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (void *)((btCollisionObject const *)swig_b0)->getUserPointer();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex2_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex2();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btRigidBody_getUserIndex3_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUserIndex3();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setUserPointer_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, void *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserPointer(arg2);
  
}


void _wrap_btRigidBody_setUserIndex_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex(arg2);
  
}


void _wrap_btRigidBody_setUserIndex2_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex2(arg2);
  
}


void _wrap_btRigidBody_setUserIndex3_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, intgo _swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setUserIndex3(arg2);
  
}


intgo _wrap_btRigidBody_getUpdateRevisionInternal_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (int)((btCollisionObject const *)swig_b0)->getUpdateRevisionInternal();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBody_setCustomDebugColor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->setCustomDebugColor((btVector3 const &)*arg2);
  
}


void _wrap_btRigidBody_removeCustomDebugColor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  (swig_b0)->removeCustomDebugColor();
  
}


bool _wrap_btRigidBody_getCustomDebugColor_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btVector3 *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->getCustomDebugColor(*arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btRigidBody_checkCollideWith_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btCollisionObject *_swig_go_1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  btCollisionObject *swig_b0 = (btCollisionObject *)arg1;
  result = (bool)((btCollisionObject const *)swig_b0)->checkCollideWith((btCollisionObject const *)arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_collisionObjectData_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btCollisionObjectFloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *arg2 = (btCollisionObjectFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectFloatData *_wrap_btRigidBodyFloatData_m_collisionObjectData_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btCollisionObjectFloatData *result = 0 ;
  btCollisionObjectFloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btCollisionObjectFloatData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectFloatData **)&_swig_go_result = (btCollisionObjectFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btMatrix3x3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *arg2 = (btMatrix3x3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaTensorWorld_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btMatrix3x3FloatData *result = 0 ;
  btMatrix3x3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btMatrix3x3FloatData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3FloatData **)&_swig_go_result = (btMatrix3x3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearVelocity_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearVelocity_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularVelocity_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularVelocity_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularVelocity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularFactor_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_angularFactor_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_angularFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearFactor_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_linearFactor_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_linearFactor);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_gravity_acceleration_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_gravity_acceleration_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_invInertiaLocal_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_invInertiaLocal_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalForce_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalForce_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalForce);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_totalTorque_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, btVector3FloatData *_swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = *(btVector3FloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3FloatData *_wrap_btRigidBodyFloatData_m_totalTorque_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  btVector3FloatData *result = 0 ;
  btVector3FloatData *_swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (btVector3FloatData *)& ((arg1)->m_totalTorque);
  *(btVector3FloatData **)&_swig_go_result = (btVector3FloatData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_inverseMass_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_inverseMass_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearDamping_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearDamping_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularDamping_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularDamping_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDampingFactor_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalDampingFactor_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalLinearDampingThresholdSqr_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingThresholdSqr_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_additionalAngularDampingFactor_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_linearSleepingThreshold_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, float _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


float _wrap_btRigidBodyFloatData_m_angularSleepingThreshold_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyFloatData_m_additionalDamping_set_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyFloatData_m_additionalDamping_get_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


btRigidBodyFloatData *_wrap_new_btRigidBodyFloatData_mbt_e1d552452a96202d() {
  btRigidBodyFloatData *result = 0 ;
  btRigidBodyFloatData *_swig_go_result;
  
  
  result = (btRigidBodyFloatData *)new btRigidBodyFloatData();
  *(btRigidBodyFloatData **)&_swig_go_result = (btRigidBodyFloatData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyFloatData_mbt_e1d552452a96202d(btRigidBodyFloatData *_swig_go_0) {
  btRigidBodyFloatData *arg1 = (btRigidBodyFloatData *) 0 ;
  
  arg1 = *(btRigidBodyFloatData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btRigidBodyDoubleData_m_collisionObjectData_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btCollisionObjectDoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *arg2 = (btCollisionObjectDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btCollisionObjectDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_collisionObjectData = *arg2;
  
}


btCollisionObjectDoubleData *_wrap_btRigidBodyDoubleData_m_collisionObjectData_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btCollisionObjectDoubleData *result = 0 ;
  btCollisionObjectDoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btCollisionObjectDoubleData *)& ((arg1)->m_collisionObjectData);
  *(btCollisionObjectDoubleData **)&_swig_go_result = (btCollisionObjectDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btMatrix3x3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *arg2 = (btMatrix3x3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btMatrix3x3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaTensorWorld = *arg2;
  
}


btMatrix3x3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaTensorWorld_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btMatrix3x3DoubleData *result = 0 ;
  btMatrix3x3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btMatrix3x3DoubleData *)& ((arg1)->m_invInertiaTensorWorld);
  *(btMatrix3x3DoubleData **)&_swig_go_result = (btMatrix3x3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearVelocity_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearVelocity_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularVelocity_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularVelocity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularVelocity_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularVelocity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularFactor_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_angularFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_angularFactor_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_angularFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearFactor_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_linearFactor = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_linearFactor_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_linearFactor);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_gravity_acceleration_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_gravity_acceleration = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_gravity_acceleration_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_gravity_acceleration);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_invInertiaLocal_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_invInertiaLocal = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_invInertiaLocal_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_invInertiaLocal);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalForce_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalForce = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalForce_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalForce);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_totalTorque_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, btVector3DoubleData *_swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *arg2 = (btVector3DoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = *(btVector3DoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_totalTorque = *arg2;
  
}


btVector3DoubleData *_wrap_btRigidBodyDoubleData_m_totalTorque_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  btVector3DoubleData *result = 0 ;
  btVector3DoubleData *_swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (btVector3DoubleData *)& ((arg1)->m_totalTorque);
  *(btVector3DoubleData **)&_swig_go_result = (btVector3DoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_inverseMass_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_inverseMass = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_inverseMass_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_inverseMass);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearDamping_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearDamping_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularDamping_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularDamping = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularDamping_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalDampingFactor_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalLinearDampingThresholdSqr_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalLinearDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingThresholdSqr_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingThresholdSqr);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_additionalAngularDampingFactor_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_additionalAngularDampingFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_linearSleepingThreshold_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_linearSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, double _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
  
}


double _wrap_btRigidBodyDoubleData_m_angularSleepingThreshold_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_angularSleepingThreshold);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_additionalDamping_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, intgo _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int arg2 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_additionalDamping = arg2;
  
}


intgo _wrap_btRigidBodyDoubleData_m_additionalDamping_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_additionalDamping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btRigidBodyDoubleData_m_padding_set_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0, _gostring_ _swig_go_1) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_padding, (const char *)arg2, 4-1);
      arg1->m_padding[4-1] = 0;
    } else {
      arg1->m_padding[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btRigidBodyDoubleData_m_padding_get_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_padding);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btRigidBodyDoubleData *_wrap_new_btRigidBodyDoubleData_mbt_e1d552452a96202d() {
  btRigidBodyDoubleData *result = 0 ;
  btRigidBodyDoubleData *_swig_go_result;
  
  
  result = (btRigidBodyDoubleData *)new btRigidBodyDoubleData();
  *(btRigidBodyDoubleData **)&_swig_go_result = (btRigidBodyDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btRigidBodyDoubleData_mbt_e1d552452a96202d(btRigidBodyDoubleData *_swig_go_0) {
  btRigidBodyDoubleData *arg1 = (btRigidBodyDoubleData *) 0 ;
  
  arg1 = *(btRigidBodyDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_uniqueId_set_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  uniqueId = arg1;
  
}


intgo _wrap_uniqueId_get_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)uniqueId;
  _swig_go_result = result; 
  return _swig_go_result;
}


btVector3 *_wrap_evalEulerEqn_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, float _swig_go_3, btMatrix3x3 *_swig_go_4) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btMatrix3x3 *arg5 = 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  
  result = evalEulerEqn((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,(btMatrix3x3 const &)*arg5);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


btMatrix3x3 *_wrap_evalEulerEqnDeriv_mbt_e1d552452a96202d(btVector3 *_swig_go_0, btVector3 *_swig_go_1, float _swig_go_2, btMatrix3x3 *_swig_go_3) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 result;
  btMatrix3x3 *_swig_go_result;
  
  arg1 = *(btVector3 **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = *(btMatrix3x3 **)&_swig_go_3; 
  
  result = evalEulerEqnDeriv((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,(btMatrix3x3 const &)*arg4);
  *(btMatrix3x3 **)&_swig_go_result = new btMatrix3x3(result); 
  return _swig_go_result;
}


intgo _wrap_BT_CONETWIST_FLAGS_LIN_CFM_mbt_e1d552452a96202d() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_LIN_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONETWIST_FLAGS_LIN_ERP_mbt_e1d552452a96202d() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_LIN_ERP;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


intgo _wrap_BT_CONETWIST_FLAGS_ANG_CFM_mbt_e1d552452a96202d() {
  btConeTwistFlags result;
  intgo _swig_go_result;
  
  
  result = BT_CONETWIST_FLAGS_ANG_CFM;
  
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_0_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btRigidBody *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3) {
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btConeTwistConstraint *result = 0 ;
  btConeTwistConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  
  result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
  *(btConeTwistConstraint **)&_swig_go_result = (btConeTwistConstraint *)result; 
  return _swig_go_result;
}


btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_1_mbt_e1d552452a96202d(btRigidBody *_swig_go_0, btTransform *_swig_go_1) {
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btConeTwistConstraint *result = 0 ;
  btConeTwistConstraint *_swig_go_result;
  
  arg1 = *(btRigidBody **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  
  result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,(btTransform const &)*arg2);
  *(btConeTwistConstraint **)&_swig_go_result = (btConeTwistConstraint *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_buildJacobian_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  (arg1)->buildJacobian();
  
}


void _wrap_btConeTwistConstraint_getInfo1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo1NonVirtual_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo1 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo1 **)&_swig_go_1; 
  
  (arg1)->getInfo1NonVirtual(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo2_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  
  (arg1)->getInfo2(arg2);
  
}


void _wrap_btConeTwistConstraint_getInfo2NonVirtual_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTypedConstraint::btConstraintInfo2 *_swig_go_1, btTransform *_swig_go_2, btTransform *_swig_go_3, btMatrix3x3 *_swig_go_4, btMatrix3x3 *_swig_go_5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  btMatrix3x3 *arg6 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTypedConstraint::btConstraintInfo2 **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btTransform **)&_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  arg6 = *(btMatrix3x3 **)&_swig_go_5; 
  
  (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btMatrix3x3 const &)*arg5,(btMatrix3x3 const &)*arg6);
  
}


void _wrap_btConeTwistConstraint_solveConstraintObsolete_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btSolverBody *_swig_go_1, btSolverBody *_swig_go_2, float _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btSolverBody **)&_swig_go_1; 
  arg3 = *(btSolverBody **)&_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
  
}


void _wrap_btConeTwistConstraint_updateRHS_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateRHS(arg2);
  
}


btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyA_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyA();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyB_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyB();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setAngularOnly_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setAngularOnly(arg2);
  
}


bool _wrap_btConeTwistConstraint_getAngularOnly_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->getAngularOnly();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_0_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setLimit(arg2,arg3);
  
}


float _wrap_btConeTwistConstraint_getLimit_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getLimit(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5, float _swig_go_6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  arg7 = (btScalar)_swig_go_6; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6,arg7);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_2_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4, float _swig_go_5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  arg6 = (btScalar)_swig_go_5; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_3_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3, float _swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  (arg1)->setLimit(arg2,arg3,arg4,arg5);
  
}


void _wrap_btConeTwistConstraint_setLimit__SWIG_4_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2, float _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  (arg1)->setLimit(arg2,arg3,arg4);
  
}


btTransform *_wrap_btConeTwistConstraint_getAFrame_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getAFrame();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btConeTwistConstraint_getBFrame_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getBFrame();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getSolveTwistLimit_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)(arg1)->getSolveTwistLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getSolveSwingLimit_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)(arg1)->getSolveSwingLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistLimitSign_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getTwistLimitSign();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_calcAngleInfo_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  (arg1)->calcAngleInfo();
  
}


void _wrap_btConeTwistConstraint_calcAngleInfo2_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2, btMatrix3x3 *_swig_go_3, btMatrix3x3 *_swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  arg4 = *(btMatrix3x3 **)&_swig_go_3; 
  arg5 = *(btMatrix3x3 **)&_swig_go_4; 
  
  (arg1)->calcAngleInfo2((btTransform const &)*arg2,(btTransform const &)*arg3,(btMatrix3x3 const &)*arg4,(btMatrix3x3 const &)*arg5);
  
}


float _wrap_btConeTwistConstraint_getSwingSpan1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getSwingSpan1();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getSwingSpan2_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getSwingSpan2();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistSpan_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getTwistSpan();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getLimitSoftness_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getLimitSoftness();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getBiasFactor_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getBiasFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getRelaxationFactor_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getRelaxationFactor();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getTwistAngle_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getTwistAngle();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_isPastSwingLimit_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)(arg1)->isPastSwingLimit();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getDamping_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getDamping();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setDamping_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setDamping(arg2);
  
}


void _wrap_btConeTwistConstraint_enableMotor_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->enableMotor(arg2);
  
}


bool _wrap_btConeTwistConstraint_isMotorEnabled_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->isMotorEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getMaxMotorImpulse_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getMaxMotorImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_isMaxMotorImpulseNormalized_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (bool)((btConeTwistConstraint const *)arg1)->isMaxMotorImpulseNormalized();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setMaxMotorImpulse_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMaxMotorImpulse(arg2);
  
}


void _wrap_btConeTwistConstraint_setMaxMotorImpulseNormalized_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setMaxMotorImpulseNormalized(arg2);
  
}


float _wrap_btConeTwistConstraint_getFixThresh_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btScalar)(arg1)->getFixThresh();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setFixThresh_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->setFixThresh(arg2);
  
}


void _wrap_btConeTwistConstraint_setMotorTarget_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btQuaternion *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setMotorTarget((btQuaternion const &)*arg2);
  
}


btQuaternion *_wrap_btConeTwistConstraint_getMotorTarget_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *result = 0 ;
  btQuaternion *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btQuaternion *) &((btConeTwistConstraint const *)arg1)->getMotorTarget();
  *(btQuaternion **)&_swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setMotorTargetInConstraintSpace_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btQuaternion *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btQuaternion **)&_swig_go_1; 
  
  (arg1)->setMotorTargetInConstraintSpace((btQuaternion const &)*arg2);
  
}


btVector3 *_wrap_btConeTwistConstraint_GetPointForAngle_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  result = ((btConeTwistConstraint const *)arg1)->GetPointForAngle(arg2,arg3);
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setParam__SWIG_0_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2, intgo _swig_go_3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->setParam(arg2,arg3,arg4);
  
}


void _wrap_btConeTwistConstraint_setParam__SWIG_1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, float _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (btScalar)_swig_go_2; 
  
  (arg1)->setParam(arg2,arg3);
  
}


void _wrap_btConeTwistConstraint_setFrames_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btTransform *_swig_go_1, btTransform *_swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btTransform **)&_swig_go_1; 
  arg3 = *(btTransform **)&_swig_go_2; 
  
  (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
  
}


btTransform *_wrap_btConeTwistConstraint_getFrameOffsetA_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetA();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


btTransform *_wrap_btConeTwistConstraint_getFrameOffsetB_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  btTransform *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetB();
  *(btTransform **)&_swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getParam__SWIG_0_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1, intgo _swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getParam__SWIG_1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getFlags_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)((btConeTwistConstraint const *)arg1)->getFlags();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_calculateSerializeBufferSize_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  result = (int)((btConeTwistConstraint const *)arg1)->calculateSerializeBufferSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


_gostring_ _wrap_btConeTwistConstraint_serialize_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, void *_swig_go_1, btSerializer *_swig_go_2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  arg3 = *(btSerializer **)&_swig_go_2; 
  
  result = (char *)((btConeTwistConstraint const *)arg1)->serialize(arg2,arg3);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraint_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  delete arg1;
  
}


btRigidBody *_wrap_btConeTwistConstraint_getFixedBody_mbt_e1d552452a96202d() {
  btRigidBody *result = 0 ;
  btRigidBody *_swig_go_result;
  
  
  result = (btRigidBody *) &btTypedConstraint::getFixedBody();
  *(btRigidBody **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getOverrideNumSolverIterations_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getOverrideNumSolverIterations();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setOverrideNumSolverIterations_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setOverrideNumSolverIterations(arg2);
  
}


void _wrap_btConeTwistConstraint_setupSolverConstraint_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btConstraintArray *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3, float _swig_go_4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btConstraintArray **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = (btScalar)_swig_go_4; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
  
}


void _wrap_btConeTwistConstraint_internalSetAppliedImpulse_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->internalSetAppliedImpulse(arg2);
  
}


float _wrap_btConeTwistConstraint_internalGetAppliedImpulse_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->internalGetAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


float _wrap_btConeTwistConstraint_getBreakingImpulseThreshold_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getBreakingImpulseThreshold();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setBreakingImpulseThreshold_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setBreakingImpulseThreshold(arg2);
  
}


bool _wrap_btConeTwistConstraint_isEnabled_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->isEnabled();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setEnabled_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setEnabled(arg2);
  
}


intgo _wrap_btConeTwistConstraint_getUserConstraintType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setUserConstraintType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintType(arg2);
  
}


void _wrap_btConeTwistConstraint_setUserConstraintId_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintId(arg2);
  
}


intgo _wrap_btConeTwistConstraint_getUserConstraintId_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUserConstraintId();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setUserConstraintPtr_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, void *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(void **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setUserConstraintPtr(arg2);
  
}


void *_wrap_btConeTwistConstraint_getUserConstraintPtr_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *result = 0 ;
  void *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (void *)(swig_b0)->getUserConstraintPtr();
  *(void **)&_swig_go_result = (void *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setJointFeedback_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, btJointFeedback *_swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = *(btJointFeedback **)&_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setJointFeedback(arg2);
  
}


btJointFeedback *_wrap_btConeTwistConstraint_getJointFeedback__SWIG_0_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)((btTypedConstraint const *)swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


btJointFeedback *_wrap_btConeTwistConstraint_getJointFeedback__SWIG_1_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  btJointFeedback *_swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btJointFeedback *)(swig_b0)->getJointFeedback();
  *(btJointFeedback **)&_swig_go_result = (btJointFeedback *)result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getUid_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (int)((btTypedConstraint const *)swig_b0)->getUid();
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btConeTwistConstraint_needsFeedback_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (bool)((btTypedConstraint const *)swig_b0)->needsFeedback();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_enableFeedback_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, bool _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->enableFeedback(arg2);
  
}


float _wrap_btConeTwistConstraint_getAppliedImpulse_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)((btTypedConstraint const *)swig_b0)->getAppliedImpulse();
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getConstraintType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraintType result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btTypedConstraintType)((btTypedConstraint const *)swig_b0)->getConstraintType();
  _swig_go_result = (intgo)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraint_setDbgDrawSize_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  (swig_b0)->setDbgDrawSize(arg2);
  
}


float _wrap_btConeTwistConstraint_getDbgDrawSize_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  result = (btScalar)(swig_b0)->getDbgDrawSize();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_SetbtConeTwistConstraint_M_objectType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0, intgo _swig_go_1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  if (swig_b1) (swig_b1)->m_objectType = arg2;
  
}


intgo _wrap_GetbtConeTwistConstraint_M_objectType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int) ((swig_b1)->m_objectType);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btConeTwistConstraint_getObjectType_mbt_e1d552452a96202d(btConeTwistConstraint *_swig_go_0) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btConeTwistConstraint **)&_swig_go_0; 
  
  btTypedConstraint *swig_b0 = (btTypedConstraint *)arg1;
  btTypedObject *swig_b1 = (btTypedObject *)swig_b0;
  result = (int)((btTypedObject const *)swig_b1)->getObjectType();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_typeConstraintData_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, btTypedConstraintDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTypedConstraintDoubleData *arg2 = (btTypedConstraintDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintDoubleData *_wrap_btConeTwistConstraintDoubleData_m_typeConstraintData_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTypedConstraintDoubleData *result = 0 ;
  btTypedConstraintDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTypedConstraintDoubleData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintDoubleData **)&_swig_go_result = (btTypedConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_rbAFrame_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btConeTwistConstraintDoubleData_m_rbAFrame_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbAFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_rbBFrame_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, btTransformDoubleData *_swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *arg2 = (btTransformDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = *(btTransformDoubleData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformDoubleData *_wrap_btConeTwistConstraintDoubleData_m_rbBFrame_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  btTransformDoubleData *result = 0 ;
  btTransformDoubleData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (btTransformDoubleData *)& ((arg1)->m_rbBFrame);
  *(btTransformDoubleData **)&_swig_go_result = (btTransformDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_swingSpan1_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan1 = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_swingSpan1_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_swingSpan1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_swingSpan2_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan2 = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_swingSpan2_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_swingSpan2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_twistSpan_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_twistSpan = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_twistSpan_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_twistSpan);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_limitSoftness_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_limitSoftness_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_biasFactor_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_biasFactor = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_biasFactor_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_biasFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_relaxationFactor_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_relaxationFactor = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_relaxationFactor_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_relaxationFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintDoubleData_m_damping_set_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0, double _swig_go_1) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double arg2 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  arg2 = (double)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


double _wrap_btConeTwistConstraintDoubleData_m_damping_get_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  double result;
  double _swig_go_result;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  result = (double) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


btConeTwistConstraintDoubleData *_wrap_new_btConeTwistConstraintDoubleData_mbt_e1d552452a96202d() {
  btConeTwistConstraintDoubleData *result = 0 ;
  btConeTwistConstraintDoubleData *_swig_go_result;
  
  
  result = (btConeTwistConstraintDoubleData *)new btConeTwistConstraintDoubleData();
  *(btConeTwistConstraintDoubleData **)&_swig_go_result = (btConeTwistConstraintDoubleData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraintDoubleData_mbt_e1d552452a96202d(btConeTwistConstraintDoubleData *_swig_go_0) {
  btConeTwistConstraintDoubleData *arg1 = (btConeTwistConstraintDoubleData *) 0 ;
  
  arg1 = *(btConeTwistConstraintDoubleData **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btConeTwistConstraintData_m_typeConstraintData_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, btTypedConstraintData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTypedConstraintData *arg2 = (btTypedConstraintData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTypedConstraintData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_typeConstraintData = *arg2;
  
}


btTypedConstraintData *_wrap_btConeTwistConstraintData_m_typeConstraintData_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTypedConstraintData *result = 0 ;
  btTypedConstraintData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTypedConstraintData *)& ((arg1)->m_typeConstraintData);
  *(btTypedConstraintData **)&_swig_go_result = (btTypedConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_rbAFrame_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbAFrame = *arg2;
  
}


btTransformFloatData *_wrap_btConeTwistConstraintData_m_rbAFrame_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbAFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_rbBFrame_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, btTransformFloatData *_swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *arg2 = (btTransformFloatData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = *(btTransformFloatData **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_rbBFrame = *arg2;
  
}


btTransformFloatData *_wrap_btConeTwistConstraintData_m_rbBFrame_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  btTransformFloatData *result = 0 ;
  btTransformFloatData *_swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (btTransformFloatData *)& ((arg1)->m_rbBFrame);
  *(btTransformFloatData **)&_swig_go_result = (btTransformFloatData *)result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_swingSpan1_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan1 = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_swingSpan1_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_swingSpan1);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_swingSpan2_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_swingSpan2 = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_swingSpan2_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_swingSpan2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_twistSpan_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_twistSpan = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_twistSpan_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_twistSpan);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_limitSoftness_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_limitSoftness = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_limitSoftness_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_limitSoftness);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_biasFactor_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_biasFactor = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_biasFactor_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_biasFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_relaxationFactor_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_relaxationFactor = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_relaxationFactor_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_relaxationFactor);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_damping_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, float _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float arg2 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  arg2 = (float)_swig_go_1; 
  
  if (arg1) (arg1)->m_damping = arg2;
  
}


float _wrap_btConeTwistConstraintData_m_damping_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  float result;
  float _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (float) ((arg1)->m_damping);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btConeTwistConstraintData_m_pad_set_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0, _gostring_ _swig_go_1) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  arg2 = (char *)malloc(_swig_go_1.n + 1);
  memcpy(arg2, _swig_go_1.p, _swig_go_1.n);
  arg2[_swig_go_1.n] = '\0';
  
  
  {
    if(arg2) {
      strncpy((char*)arg1->m_pad, (const char *)arg2, 4-1);
      arg1->m_pad[4-1] = 0;
    } else {
      arg1->m_pad[0] = 0;
    }
  }
  
  free(arg2); 
}


_gostring_ _wrap_btConeTwistConstraintData_m_pad_get_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  char *result = 0 ;
  _gostring_ _swig_go_result;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  result = (char *)(char *) ((arg1)->m_pad);
  _swig_go_result = Swig_AllocateString((char*)result, result ? strlen((char*)result) : 0); 
  return _swig_go_result;
}


btConeTwistConstraintData *_wrap_new_btConeTwistConstraintData_mbt_e1d552452a96202d() {
  btConeTwistConstraintData *result = 0 ;
  btConeTwistConstraintData *_swig_go_result;
  
  
  result = (btConeTwistConstraintData *)new btConeTwistConstraintData();
  *(btConeTwistConstraintData **)&_swig_go_result = (btConeTwistConstraintData *)result; 
  return _swig_go_result;
}


void _wrap_delete_btConeTwistConstraintData_mbt_e1d552452a96202d(btConeTwistConstraintData *_swig_go_0) {
  btConeTwistConstraintData *arg1 = (btConeTwistConstraintData *) 0 ;
  
  arg1 = *(btConeTwistConstraintData **)&_swig_go_0; 
  
  delete arg1;
  
}


btDiscreteDynamicsWorld *_wrap_new_btDiscreteDynamicsWorld_mbt_e1d552452a96202d(btDispatcher *_swig_go_0, btBroadphaseInterface *_swig_go_1, btConstraintSolver *_swig_go_2, btCollisionConfiguration *_swig_go_3) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btDiscreteDynamicsWorld *result = 0 ;
  btDiscreteDynamicsWorld *_swig_go_result;
  
  arg1 = *(btDispatcher **)&_swig_go_0; 
  arg2 = *(btBroadphaseInterface **)&_swig_go_1; 
  arg3 = *(btConstraintSolver **)&_swig_go_2; 
  arg4 = *(btCollisionConfiguration **)&_swig_go_3; 
  
  result = (btDiscreteDynamicsWorld *)new btDiscreteDynamicsWorld(arg1,arg2,arg3,arg4);
  *(btDiscreteDynamicsWorld **)&_swig_go_result = (btDiscreteDynamicsWorld *)result; 
  return _swig_go_result;
}


void _wrap_delete_btDiscreteDynamicsWorld_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  delete arg1;
  
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2, float _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (btScalar)_swig_go_3; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1, intgo _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  result = (int)(arg1)->stepSimulation(arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_2_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  result = (int)(arg1)->stepSimulation(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_solveConstraints_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btContactSolverInfo *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  
  (arg1)->solveConstraints(*arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_synchronizeMotionStates_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->synchronizeMotionStates();
  
}


void _wrap_btDiscreteDynamicsWorld_synchronizeSingleMotionState_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->synchronizeSingleMotionState(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1, bool _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  (arg1)->addConstraint(arg2,arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->addConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeConstraint_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->removeConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addAction_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addAction(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeAction_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeAction(arg2);
  
}


btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btSimulationIslandManager *)(arg1)->getSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  btSimulationIslandManager *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btSimulationIslandManager *)((btDiscreteDynamicsWorld const *)arg1)->getSimulationIslandManager();
  *(btSimulationIslandManager **)&_swig_go_result = (btSimulationIslandManager *)result; 
  return _swig_go_result;
}


btCollisionWorld *_wrap_btDiscreteDynamicsWorld_getCollisionWorld_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionWorld *result = 0 ;
  btCollisionWorld *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btCollisionWorld *)(arg1)->getCollisionWorld();
  *(btCollisionWorld **)&_swig_go_result = (btCollisionWorld *)result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setGravity_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btVector3 *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  
  (arg1)->setGravity((btVector3 const &)*arg2);
  
}


btVector3 *_wrap_btDiscreteDynamicsWorld_getGravity_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 result;
  btVector3 *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = ((btDiscreteDynamicsWorld const *)arg1)->getGravity();
  *(btVector3 **)&_swig_go_result = new btVector3(result); 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addCollisionObject(arg2,arg3,arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1, intgo _swig_go_2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  int arg3 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  
  (arg1)->addCollisionObject(arg2,arg3);
  
}


void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_2_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->addCollisionObject(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->addRigidBody(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1, intgo _swig_go_2, intgo _swig_go_3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  
  (arg1)->addRigidBody(arg2,arg3,arg4);
  
}


void _wrap_btDiscreteDynamicsWorld_removeRigidBody_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btRigidBody *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btRigidBody **)&_swig_go_1; 
  
  (arg1)->removeRigidBody(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeCollisionObject_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btCollisionObject *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  (arg1)->removeCollisionObject(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_debugDrawConstraint_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btTypedConstraint *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btTypedConstraint **)&_swig_go_1; 
  
  (arg1)->debugDrawConstraint(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_debugDrawWorld_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->debugDrawWorld();
  
}


void _wrap_btDiscreteDynamicsWorld_setConstraintSolver_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btConstraintSolver *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btConstraintSolver **)&_swig_go_1; 
  
  (arg1)->setConstraintSolver(arg2);
  
}


btConstraintSolver *_wrap_btDiscreteDynamicsWorld_getConstraintSolver_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  btConstraintSolver *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btConstraintSolver *)(arg1)->getConstraintSolver();
  *(btConstraintSolver **)&_swig_go_result = (btConstraintSolver *)result; 
  return _swig_go_result;
}


intgo _wrap_btDiscreteDynamicsWorld_getNumConstraints_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (int)((btDiscreteDynamicsWorld const *)arg1)->getNumConstraints();
  _swig_go_result = result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  btTypedConstraint *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  result = (btTypedConstraint *)((btDiscreteDynamicsWorld const *)arg1)->getConstraint(arg2);
  *(btTypedConstraint **)&_swig_go_result = (btTypedConstraint *)result; 
  return _swig_go_result;
}


btDynamicsWorldType *_wrap_btDiscreteDynamicsWorld_getWorldType_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  btDynamicsWorldType *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = ((btDiscreteDynamicsWorld const *)arg1)->getWorldType();
  *(btDynamicsWorldType **)&_swig_go_result = new btDynamicsWorldType(result); 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_clearForces_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->clearForces();
  
}


void _wrap_btDiscreteDynamicsWorld_applyGravity_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  (arg1)->applyGravity();
  
}


void _wrap_btDiscreteDynamicsWorld_setNumTasks_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, intgo _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  (arg1)->setNumTasks(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_updateVehicles_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, float _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  (arg1)->updateVehicles(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addVehicle_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addVehicle(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeVehicle_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeVehicle(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_addCharacter_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->addCharacter(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_removeCharacter_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btActionInterface *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btActionInterface **)&_swig_go_1; 
  
  (arg1)->removeCharacter(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_setSynchronizeAllMotionStates_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setSynchronizeAllMotionStates(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getSynchronizeAllMotionStates_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getSynchronizeAllMotionStates();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setApplySpeculativeContactRestitution(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getApplySpeculativeContactRestitution();
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btDiscreteDynamicsWorld_serialize_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, btSerializer *_swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = *(btSerializer **)&_swig_go_1; 
  
  (arg1)->serialize(arg2);
  
}


void _wrap_btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0, bool _swig_go_1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  arg2 = (bool)_swig_go_1; 
  
  (arg1)->setLatencyMotionStateInterpolation(arg2);
  
}


bool _wrap_btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getLatencyMotionStateInterpolation();
  _swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btRigidBody * > *_wrap_btDiscreteDynamicsWorld_getNonStaticRigidBodies__SWIG_0_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btAlignedObjectArray< btRigidBody * > *result = 0 ;
  btAlignedObjectArray< btRigidBody * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBody * > *) &(arg1)->getNonStaticRigidBodies();
  *(btAlignedObjectArray< btRigidBody * > **)&_swig_go_result = result; 
  return _swig_go_result;
}


btAlignedObjectArray< btRigidBody * > *_wrap_btDiscreteDynamicsWorld_getNonStaticRigidBodies__SWIG_1_mbt_e1d552452a96202d(btDiscreteDynamicsWorld *_swig_go_0) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btAlignedObjectArray< btRigidBody * > *result = 0 ;
  btAlignedObjectArray< btRigidBody * > *_swig_go_result;
  
  arg1 = *(btDiscreteDynamicsWorld **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btRigidBody * > *) &((btDiscreteDynamicsWorld const *)arg1)->getNonStaticRigidBodies();
  *(btAlignedObjectArray< btRigidBody * > **)&_swig_go_result = result; 
  return _swig_go_result;
}


intgo _wrap_btGetConstraintIslandId_mbt_e1d552452a96202d(btTypedConstraint *_swig_go_0) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(btTypedConstraint **)&_swig_go_0; 
  
  result = (int)btGetConstraintIslandId((btTypedConstraint const *)arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}


btSortConstraintOnIslandPredicate *_wrap_new_btSortConstraintOnIslandPredicate_mbt_e1d552452a96202d() {
  btSortConstraintOnIslandPredicate *result = 0 ;
  btSortConstraintOnIslandPredicate *_swig_go_result;
  
  
  result = (btSortConstraintOnIslandPredicate *)new btSortConstraintOnIslandPredicate();
  *(btSortConstraintOnIslandPredicate **)&_swig_go_result = (btSortConstraintOnIslandPredicate *)result; 
  return _swig_go_result;
}


void _wrap_delete_btSortConstraintOnIslandPredicate_mbt_e1d552452a96202d(btSortConstraintOnIslandPredicate *_swig_go_0) {
  btSortConstraintOnIslandPredicate *arg1 = (btSortConstraintOnIslandPredicate *) 0 ;
  
  arg1 = *(btSortConstraintOnIslandPredicate **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_InplaceSolverIslandCallback_m_solverInfo_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btContactSolverInfo *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *arg2 = (btContactSolverInfo *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solverInfo = arg2;
  
}


btContactSolverInfo *_wrap_InplaceSolverIslandCallback_m_solverInfo_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *result = 0 ;
  btContactSolverInfo *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btContactSolverInfo *) ((arg1)->m_solverInfo);
  *(btContactSolverInfo **)&_swig_go_result = (btContactSolverInfo *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_solver_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btConstraintSolver *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btConstraintSolver **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_solver = arg2;
  
}


btConstraintSolver *_wrap_InplaceSolverIslandCallback_m_solver_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btConstraintSolver *result = 0 ;
  btConstraintSolver *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btConstraintSolver *) ((arg1)->m_solver);
  *(btConstraintSolver **)&_swig_go_result = (btConstraintSolver *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_sortedConstraints_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btTypedConstraint **_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btTypedConstraint **arg2 = (btTypedConstraint **) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btTypedConstraint ***)&_swig_go_1; 
  
  if (arg1) (arg1)->m_sortedConstraints = arg2;
  
}


btTypedConstraint **_wrap_InplaceSolverIslandCallback_m_sortedConstraints_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btTypedConstraint **result = 0 ;
  btTypedConstraint **_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btTypedConstraint **) ((arg1)->m_sortedConstraints);
  *(btTypedConstraint ***)&_swig_go_result = (btTypedConstraint **)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_numConstraints_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, intgo _swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  int arg2 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = (int)_swig_go_1; 
  
  if (arg1) (arg1)->m_numConstraints = arg2;
  
}


intgo _wrap_InplaceSolverIslandCallback_m_numConstraints_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (int) ((arg1)->m_numConstraints);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_debugDrawer_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btIDebugDraw *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btIDebugDraw **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_debugDrawer = arg2;
  
}


btIDebugDraw *_wrap_InplaceSolverIslandCallback_m_debugDrawer_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btIDebugDraw *result = 0 ;
  btIDebugDraw *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btIDebugDraw *) ((arg1)->m_debugDrawer);
  *(btIDebugDraw **)&_swig_go_result = (btIDebugDraw *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_dispatcher_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btDispatcher *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dispatcher = arg2;
  
}


btDispatcher *_wrap_InplaceSolverIslandCallback_m_dispatcher_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btDispatcher *) ((arg1)->m_dispatcher);
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_bodies_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btCollisionObject * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btCollisionObject * > *arg2 = (btAlignedObjectArray< btCollisionObject * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btCollisionObject * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_bodies = *arg2;
  
}


btAlignedObjectArray< btCollisionObject * > *_wrap_InplaceSolverIslandCallback_m_bodies_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btCollisionObject * > *result = 0 ;
  btAlignedObjectArray< btCollisionObject * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btCollisionObject * > *)& ((arg1)->m_bodies);
  *(btAlignedObjectArray< btCollisionObject * > **)&_swig_go_result = (btAlignedObjectArray< btCollisionObject * > *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_manifolds_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btPersistentManifold * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btPersistentManifold * > *arg2 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btPersistentManifold * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_manifolds = *arg2;
  
}


btAlignedObjectArray< btPersistentManifold * > *_wrap_InplaceSolverIslandCallback_m_manifolds_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btPersistentManifold * > *result = 0 ;
  btAlignedObjectArray< btPersistentManifold * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btPersistentManifold * > *)& ((arg1)->m_manifolds);
  *(btAlignedObjectArray< btPersistentManifold * > **)&_swig_go_result = (btAlignedObjectArray< btPersistentManifold * > *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_m_constraints_set_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btAlignedObjectArray< btTypedConstraint * > *_swig_go_1) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btTypedConstraint * > *arg2 = (btAlignedObjectArray< btTypedConstraint * > *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btAlignedObjectArray< btTypedConstraint * > **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_constraints = *arg2;
  
}


btAlignedObjectArray< btTypedConstraint * > *_wrap_InplaceSolverIslandCallback_m_constraints_get_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btAlignedObjectArray< btTypedConstraint * > *result = 0 ;
  btAlignedObjectArray< btTypedConstraint * > *_swig_go_result;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  result = (btAlignedObjectArray< btTypedConstraint * > *)& ((arg1)->m_constraints);
  *(btAlignedObjectArray< btTypedConstraint * > **)&_swig_go_result = (btAlignedObjectArray< btTypedConstraint * > *)result; 
  return _swig_go_result;
}


InplaceSolverIslandCallback *_wrap_new_InplaceSolverIslandCallback_mbt_e1d552452a96202d(btConstraintSolver *_swig_go_0, btStackAlloc *_swig_go_1, btDispatcher *_swig_go_2) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btStackAlloc *arg2 = (btStackAlloc *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  InplaceSolverIslandCallback *result = 0 ;
  InplaceSolverIslandCallback *_swig_go_result;
  
  arg1 = *(btConstraintSolver **)&_swig_go_0; 
  arg2 = *(btStackAlloc **)&_swig_go_1; 
  arg3 = *(btDispatcher **)&_swig_go_2; 
  
  result = (InplaceSolverIslandCallback *)new InplaceSolverIslandCallback(arg1,arg2,arg3);
  *(InplaceSolverIslandCallback **)&_swig_go_result = (InplaceSolverIslandCallback *)result; 
  return _swig_go_result;
}


void _wrap_InplaceSolverIslandCallback_setup_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btContactSolverInfo *_swig_go_1, btTypedConstraint **_swig_go_2, intgo _swig_go_3, btIDebugDraw *_swig_go_4) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btContactSolverInfo *arg2 = (btContactSolverInfo *) 0 ;
  btTypedConstraint **arg3 = (btTypedConstraint **) 0 ;
  int arg4 ;
  btIDebugDraw *arg5 = (btIDebugDraw *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btContactSolverInfo **)&_swig_go_1; 
  arg3 = *(btTypedConstraint ***)&_swig_go_2; 
  arg4 = (int)_swig_go_3; 
  arg5 = *(btIDebugDraw **)&_swig_go_4; 
  
  (arg1)->setup(arg2,arg3,arg4,arg5);
  
}


void _wrap_InplaceSolverIslandCallback_processIsland_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0, btCollisionObject **_swig_go_1, intgo _swig_go_2, btPersistentManifold **_swig_go_3, intgo _swig_go_4, intgo _swig_go_5) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  int arg6 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject ***)&_swig_go_1; 
  arg3 = (int)_swig_go_2; 
  arg4 = *(btPersistentManifold ***)&_swig_go_3; 
  arg5 = (int)_swig_go_4; 
  arg6 = (int)_swig_go_5; 
  
  (arg1)->processIsland(arg2,arg3,arg4,arg5,arg6);
  
}


void _wrap_InplaceSolverIslandCallback_processConstraints_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  (arg1)->processConstraints();
  
}


void _wrap_delete_InplaceSolverIslandCallback_mbt_e1d552452a96202d(InplaceSolverIslandCallback *_swig_go_0) {
  InplaceSolverIslandCallback *arg1 = (InplaceSolverIslandCallback *) 0 ;
  
  arg1 = *(InplaceSolverIslandCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_btClosestNotMeConvexResultCallback_m_me_set_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, btCollisionObject *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btCollisionObject **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_me = arg2;
  
}


btCollisionObject *_wrap_btClosestNotMeConvexResultCallback_m_me_get_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionObject *result = 0 ;
  btCollisionObject *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btCollisionObject *) ((arg1)->m_me);
  *(btCollisionObject **)&_swig_go_result = (btCollisionObject *)result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_allowedPenetration_set_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, float _swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btScalar arg2 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = (btScalar)_swig_go_1; 
  
  if (arg1) (arg1)->m_allowedPenetration = arg2;
  
}


float _wrap_btClosestNotMeConvexResultCallback_m_allowedPenetration_get_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btScalar) ((arg1)->m_allowedPenetration);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_pairCache_set_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, btOverlappingPairCache *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btOverlappingPairCache **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_pairCache = arg2;
  
}


btOverlappingPairCache *_wrap_btClosestNotMeConvexResultCallback_m_pairCache_get_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btOverlappingPairCache *result = 0 ;
  btOverlappingPairCache *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btOverlappingPairCache *) ((arg1)->m_pairCache);
  *(btOverlappingPairCache **)&_swig_go_result = (btOverlappingPairCache *)result; 
  return _swig_go_result;
}


void _wrap_btClosestNotMeConvexResultCallback_m_dispatcher_set_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, btDispatcher *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btDispatcher **)&_swig_go_1; 
  
  if (arg1) (arg1)->m_dispatcher = arg2;
  
}


btDispatcher *_wrap_btClosestNotMeConvexResultCallback_m_dispatcher_get_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btDispatcher *result = 0 ;
  btDispatcher *_swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  result = (btDispatcher *) ((arg1)->m_dispatcher);
  *(btDispatcher **)&_swig_go_result = (btDispatcher *)result; 
  return _swig_go_result;
}


btClosestNotMeConvexResultCallback *_wrap_new_btClosestNotMeConvexResultCallback_mbt_e1d552452a96202d(btCollisionObject *_swig_go_0, btVector3 *_swig_go_1, btVector3 *_swig_go_2, btOverlappingPairCache *_swig_go_3, btDispatcher *_swig_go_4) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btOverlappingPairCache *arg4 = (btOverlappingPairCache *) 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  btClosestNotMeConvexResultCallback *result = 0 ;
  btClosestNotMeConvexResultCallback *_swig_go_result;
  
  arg1 = *(btCollisionObject **)&_swig_go_0; 
  arg2 = *(btVector3 **)&_swig_go_1; 
  arg3 = *(btVector3 **)&_swig_go_2; 
  arg4 = *(btOverlappingPairCache **)&_swig_go_3; 
  arg5 = *(btDispatcher **)&_swig_go_4; 
  
  result = (btClosestNotMeConvexResultCallback *)new btClosestNotMeConvexResultCallback(arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5);
  *(btClosestNotMeConvexResultCallback **)&_swig_go_result = (btClosestNotMeConvexResultCallback *)result; 
  return _swig_go_result;
}


float _wrap_btClosestNotMeConvexResultCallback_addSingleResult_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, btCollisionWorld::LocalConvexResult *_swig_go_1, bool _swig_go_2) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btCollisionWorld::LocalConvexResult *arg2 = 0 ;
  bool arg3 ;
  btScalar result;
  float _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btCollisionWorld::LocalConvexResult **)&_swig_go_1; 
  arg3 = (bool)_swig_go_2; 
  
  result = (btScalar)(arg1)->addSingleResult(*arg2,arg3);
  _swig_go_result = result; 
  return _swig_go_result;
}


bool _wrap_btClosestNotMeConvexResultCallback_needsCollision_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0, btBroadphaseProxy *_swig_go_1) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  bool result;
  bool _swig_go_result;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  arg2 = *(btBroadphaseProxy **)&_swig_go_1; 
  
  result = (bool)((btClosestNotMeConvexResultCallback const *)arg1)->needsCollision(arg2);
  _swig_go_result = result; 
  return _swig_go_result;
}


void _wrap_delete_btClosestNotMeConvexResultCallback_mbt_e1d552452a96202d(btClosestNotMeConvexResultCallback *_swig_go_0) {
  btClosestNotMeConvexResultCallback *arg1 = (btClosestNotMeConvexResultCallback *) 0 ;
  
  arg1 = *(btClosestNotMeConvexResultCallback **)&_swig_go_0; 
  
  delete arg1;
  
}


void _wrap_gNumClampedCcdMotions_set_mbt_e1d552452a96202d(intgo _swig_go_0) {
  int arg1 ;
  
  arg1 = (int)_swig_go_0; 
  
  gNumClampedCcdMotions = arg1;
  
}


intgo _wrap_gNumClampedCcdMotions_get_mbt_e1d552452a96202d() {
  int result;
  intgo _swig_go_result;
  
  
  result = (int)gNumClampedCcdMotions;
  _swig_go_result = result; 
  return _swig_go_result;
}


#ifdef __cplusplus
}
#endif

